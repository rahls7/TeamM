<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MimeMessageHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-context-support</a> &gt; <a href="index.source.html" class="el_package">org.springframework.mail.javamail</a> &gt; <span class="el_source">MimeMessageHelper.java</span></div><h1>MimeMessageHelper.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.mail.javamail;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.Date;
import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.activation.FileDataSource;
import javax.activation.FileTypeMap;
import javax.mail.BodyPart;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import javax.mail.internet.MimePart;
import javax.mail.internet.MimeUtility;

import org.springframework.core.io.InputStreamSource;
import org.springframework.core.io.Resource;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Helper class for populating a {@link javax.mail.internet.MimeMessage}.
 *
 * &lt;p&gt;Mirrors the simple setters of {@link org.springframework.mail.SimpleMailMessage},
 * directly applying the values to the underlying MimeMessage. Allows for defining
 * a character encoding for the entire message, automatically applied by all methods
 * of this helper class.
 *
 * &lt;p&gt;Offers support for HTML text content, inline elements such as images, and typical
 * mail attachments. Also supports personal names that accompany mail addresses. Note that
 * advanced settings can still be applied directly to the underlying MimeMessage object!
 *
 * &lt;p&gt;Typically used in {@link MimeMessagePreparator} implementations or
 * {@link JavaMailSender} client code: simply instantiating it as a MimeMessage wrapper,
 * invoking setters on the wrapper, using the underlying MimeMessage for mail sending.
 * Also used internally by {@link JavaMailSenderImpl}.
 *
 * &lt;p&gt;Sample code for an HTML mail with an inline image and a PDF attachment:
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * mailSender.send(new MimeMessagePreparator() {
 *   public void prepare(MimeMessage mimeMessage) throws MessagingException {
 *     MimeMessageHelper message = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;);
 *     message.setFrom(&quot;me@mail.com&quot;);
 *     message.setTo(&quot;you@mail.com&quot;);
 *     message.setSubject(&quot;my subject&quot;);
 *     message.setText(&quot;my text &amp;lt;img src='cid:myLogo'&amp;gt;&quot;, true);
 *     message.addInline(&quot;myLogo&quot;, new ClassPathResource(&quot;img/mylogo.gif&quot;));
 *     message.addAttachment(&quot;myDocument.pdf&quot;, new ClassPathResource(&quot;doc/myDocument.pdf&quot;));
 *   }
 * });&lt;/pre&gt;
 *
 * Consider using {@link MimeMailMessage} (which implements the common
 * {@link org.springframework.mail.MailMessage} interface, just like
 * {@link org.springframework.mail.SimpleMailMessage}) on top of this helper,
 * in order to let message population code interact with a simple message
 * or a MIME message through a common interface.
 *
 * &lt;p&gt;&lt;b&gt;Warning regarding multipart mails:&lt;/b&gt; Simple MIME messages that
 * just contain HTML text but no inline elements or attachments will work on
 * more or less any email client that is capable of HTML rendering. However,
 * inline elements and attachments are still a major compatibility issue
 * between email clients: It's virtually impossible to get inline elements
 * and attachments working across Microsoft Outlook, Lotus Notes and Mac Mail.
 * Consider choosing a specific multipart mode for your needs: The javadoc
 * on the MULTIPART_MODE constants contains more detailed information.
 *
 * @author Juergen Hoeller
 * @since 19.01.2004
 * @see #setText(String, boolean)
 * @see #setText(String, String)
 * @see #addInline(String, org.springframework.core.io.Resource)
 * @see #addAttachment(String, org.springframework.core.io.InputStreamSource)
 * @see #MULTIPART_MODE_MIXED_RELATED
 * @see #MULTIPART_MODE_RELATED
 * @see #getMimeMessage()
 * @see JavaMailSender
 */
public class MimeMessageHelper {

	/**
	 * Constant indicating a non-multipart message.
	 */
	public static final int MULTIPART_MODE_NO = 0;

	/**
	 * Constant indicating a multipart message with a single root multipart
	 * element of type &quot;mixed&quot;. Texts, inline elements and attachements
	 * will all get added to that root element.
	 * &lt;p&gt;This was Spring 1.0's default behavior. It is known to work properly
	 * on Outlook. However, other mail clients tend to misinterpret inline
	 * elements as attachments and/or show attachments inline as well.
	 */
	public static final int MULTIPART_MODE_MIXED = 1;

	/**
	 * Constant indicating a multipart message with a single root multipart
	 * element of type &quot;related&quot;. Texts, inline elements and attachements
	 * will all get added to that root element.
	 * &lt;p&gt;This was the default behavior from Spring 1.1 up to 1.2 final.
	 * This is the &quot;Microsoft multipart mode&quot;, as natively sent by Outlook.
	 * It is known to work properly on Outlook, Outlook Express, Yahoo Mail, and
	 * to a large degree also on Mac Mail (with an additional attachment listed
	 * for an inline element, despite the inline element also shown inline).
	 * Does not work properly on Lotus Notes (attachments won't be shown there).
	 */
	public static final int MULTIPART_MODE_RELATED = 2;

	/**
	 * Constant indicating a multipart message with a root multipart element
	 * &quot;mixed&quot; plus a nested multipart element of type &quot;related&quot;. Texts and
	 * inline elements will get added to the nested &quot;related&quot; element,
	 * while attachments will get added to the &quot;mixed&quot; root element.
	 * &lt;p&gt;This is the default since Spring 1.2.1. This is arguably the most correct
	 * MIME structure, according to the MIME spec: It is known to work properly
	 * on Outlook, Outlook Express, Yahoo Mail, and Lotus Notes. Does not work
	 * properly on Mac Mail. If you target Mac Mail or experience issues with
	 * specific mails on Outlook, consider using MULTIPART_MODE_RELATED instead.
	 */
	public static final int MULTIPART_MODE_MIXED_RELATED = 3;


	private static final String MULTIPART_SUBTYPE_MIXED = &quot;mixed&quot;;

	private static final String MULTIPART_SUBTYPE_RELATED = &quot;related&quot;;

	private static final String MULTIPART_SUBTYPE_ALTERNATIVE = &quot;alternative&quot;;

	private static final String CONTENT_TYPE_ALTERNATIVE = &quot;text/alternative&quot;;

	private static final String CONTENT_TYPE_HTML = &quot;text/html&quot;;

	private static final String CONTENT_TYPE_CHARSET_SUFFIX = &quot;;charset=&quot;;

	private static final String HEADER_PRIORITY = &quot;X-Priority&quot;;

	private static final String HEADER_CONTENT_ID = &quot;Content-ID&quot;;


	private final MimeMessage mimeMessage;

	@Nullable
	private MimeMultipart rootMimeMultipart;

	@Nullable
	private MimeMultipart mimeMultipart;

	@Nullable
	private final String encoding;

	private FileTypeMap fileTypeMap;

<span class="pc" id="L177">	private boolean validateAddresses = false;</span>


	/**
	 * Create a new MimeMessageHelper for the given MimeMessage,
	 * assuming a simple text message (no multipart content,
	 * i.e. no alternative texts and no inline elements or attachments).
	 * &lt;p&gt;The character encoding for the message will be taken from
	 * the passed-in MimeMessage object, if carried there. Else,
	 * JavaMail's default encoding will be used.
	 * @param mimeMessage the mime message to work on
	 * @see #MimeMessageHelper(javax.mail.internet.MimeMessage, boolean)
	 * @see #getDefaultEncoding(javax.mail.internet.MimeMessage)
	 * @see JavaMailSenderImpl#setDefaultEncoding
	 */
	public MimeMessageHelper(MimeMessage mimeMessage) {
<span class="fc" id="L193">		this(mimeMessage, null);</span>
<span class="fc" id="L194">	}</span>

	/**
	 * Create a new MimeMessageHelper for the given MimeMessage,
	 * assuming a simple text message (no multipart content,
	 * i.e. no alternative texts and no inline elements or attachments).
	 * @param mimeMessage the mime message to work on
	 * @param encoding the character encoding to use for the message
	 * @see #MimeMessageHelper(javax.mail.internet.MimeMessage, boolean)
	 */
<span class="fc" id="L204">	public MimeMessageHelper(MimeMessage mimeMessage, @Nullable String encoding) {</span>
<span class="fc" id="L205">		this.mimeMessage = mimeMessage;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">		this.encoding = (encoding != null ? encoding : getDefaultEncoding(mimeMessage));</span>
<span class="fc" id="L207">		this.fileTypeMap = getDefaultFileTypeMap(mimeMessage);</span>
<span class="fc" id="L208">	}</span>

	/**
	 * Create a new MimeMessageHelper for the given MimeMessage,
	 * in multipart mode (supporting alternative texts, inline
	 * elements and attachments) if requested.
	 * &lt;p&gt;Consider using the MimeMessageHelper constructor that
	 * takes a multipartMode argument to choose a specific multipart
	 * mode other than MULTIPART_MODE_MIXED_RELATED.
	 * &lt;p&gt;The character encoding for the message will be taken from
	 * the passed-in MimeMessage object, if carried there. Else,
	 * JavaMail's default encoding will be used.
	 * @param mimeMessage the mime message to work on
	 * @param multipart whether to create a multipart message that
	 * supports alternative texts, inline elements and attachments
	 * (corresponds to MULTIPART_MODE_MIXED_RELATED)
	 * @throws MessagingException if multipart creation failed
	 * @see #MimeMessageHelper(javax.mail.internet.MimeMessage, int)
	 * @see #getDefaultEncoding(javax.mail.internet.MimeMessage)
	 * @see JavaMailSenderImpl#setDefaultEncoding
	 */
	public MimeMessageHelper(MimeMessage mimeMessage, boolean multipart) throws MessagingException {
<span class="nc" id="L230">		this(mimeMessage, multipart, null);</span>
<span class="nc" id="L231">	}</span>

	/**
	 * Create a new MimeMessageHelper for the given MimeMessage,
	 * in multipart mode (supporting alternative texts, inline
	 * elements and attachments) if requested.
	 * &lt;p&gt;Consider using the MimeMessageHelper constructor that
	 * takes a multipartMode argument to choose a specific multipart
	 * mode other than MULTIPART_MODE_MIXED_RELATED.
	 * @param mimeMessage the mime message to work on
	 * @param multipart whether to create a multipart message that
	 * supports alternative texts, inline elements and attachments
	 * (corresponds to MULTIPART_MODE_MIXED_RELATED)
	 * @param encoding the character encoding to use for the message
	 * @throws MessagingException if multipart creation failed
	 * @see #MimeMessageHelper(javax.mail.internet.MimeMessage, int, String)
	 */
	public MimeMessageHelper(MimeMessage mimeMessage, boolean multipart, @Nullable String encoding)
			throws MessagingException {

<span class="nc bnc" id="L251" title="All 2 branches missed.">		this(mimeMessage, (multipart ? MULTIPART_MODE_MIXED_RELATED : MULTIPART_MODE_NO), encoding);</span>
<span class="nc" id="L252">	}</span>

	/**
	 * Create a new MimeMessageHelper for the given MimeMessage,
	 * in multipart mode (supporting alternative texts, inline
	 * elements and attachments) if requested.
	 * &lt;p&gt;The character encoding for the message will be taken from
	 * the passed-in MimeMessage object, if carried there. Else,
	 * JavaMail's default encoding will be used.
	 * @param mimeMessage the mime message to work on
	 * @param multipartMode which kind of multipart message to create
	 * (MIXED, RELATED, MIXED_RELATED, or NO)
	 * @throws MessagingException if multipart creation failed
	 * @see #MULTIPART_MODE_NO
	 * @see #MULTIPART_MODE_MIXED
	 * @see #MULTIPART_MODE_RELATED
	 * @see #MULTIPART_MODE_MIXED_RELATED
	 * @see #getDefaultEncoding(javax.mail.internet.MimeMessage)
	 * @see JavaMailSenderImpl#setDefaultEncoding
	 */
	public MimeMessageHelper(MimeMessage mimeMessage, int multipartMode) throws MessagingException {
<span class="nc" id="L273">		this(mimeMessage, multipartMode, null);</span>
<span class="nc" id="L274">	}</span>

	/**
	 * Create a new MimeMessageHelper for the given MimeMessage,
	 * in multipart mode (supporting alternative texts, inline
	 * elements and attachments) if requested.
	 * @param mimeMessage the mime message to work on
	 * @param multipartMode which kind of multipart message to create
	 * (MIXED, RELATED, MIXED_RELATED, or NO)
	 * @param encoding the character encoding to use for the message
	 * @throws MessagingException if multipart creation failed
	 * @see #MULTIPART_MODE_NO
	 * @see #MULTIPART_MODE_MIXED
	 * @see #MULTIPART_MODE_RELATED
	 * @see #MULTIPART_MODE_MIXED_RELATED
	 */
	public MimeMessageHelper(MimeMessage mimeMessage, int multipartMode, @Nullable String encoding)
<span class="nc" id="L291">			throws MessagingException {</span>

<span class="nc" id="L293">		this.mimeMessage = mimeMessage;</span>
<span class="nc" id="L294">		createMimeMultiparts(mimeMessage, multipartMode);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">		this.encoding = (encoding != null ? encoding : getDefaultEncoding(mimeMessage));</span>
<span class="nc" id="L296">		this.fileTypeMap = getDefaultFileTypeMap(mimeMessage);</span>
<span class="nc" id="L297">	}</span>


	/**
	 * Return the underlying MimeMessage object.
	 */
	public final MimeMessage getMimeMessage() {
<span class="fc" id="L304">		return this.mimeMessage;</span>
	}


	/**
	 * Determine the MimeMultipart objects to use, which will be used
	 * to store attachments on the one hand and text(s) and inline elements
	 * on the other hand.
	 * &lt;p&gt;Texts and inline elements can either be stored in the root element
	 * itself (MULTIPART_MODE_MIXED, MULTIPART_MODE_RELATED) or in a nested element
	 * rather than the root element directly (MULTIPART_MODE_MIXED_RELATED).
	 * &lt;p&gt;By default, the root MimeMultipart element will be of type &quot;mixed&quot;
	 * (MULTIPART_MODE_MIXED) or &quot;related&quot; (MULTIPART_MODE_RELATED).
	 * The main multipart element will either be added as nested element of
	 * type &quot;related&quot; (MULTIPART_MODE_MIXED_RELATED) or be identical to the root
	 * element itself (MULTIPART_MODE_MIXED, MULTIPART_MODE_RELATED).
	 * @param mimeMessage the MimeMessage object to add the root MimeMultipart
	 * object to
	 * @param multipartMode the multipart mode, as passed into the constructor
	 * (MIXED, RELATED, MIXED_RELATED, or NO)
	 * @throws MessagingException if multipart creation failed
	 * @see #setMimeMultiparts
	 * @see #MULTIPART_MODE_NO
	 * @see #MULTIPART_MODE_MIXED
	 * @see #MULTIPART_MODE_RELATED
	 * @see #MULTIPART_MODE_MIXED_RELATED
	 */
	protected void createMimeMultiparts(MimeMessage mimeMessage, int multipartMode) throws MessagingException {
<span class="nc bnc" id="L332" title="All 5 branches missed.">		switch (multipartMode) {</span>
			case MULTIPART_MODE_NO:
<span class="nc" id="L334">				setMimeMultiparts(null, null);</span>
<span class="nc" id="L335">				break;</span>
			case MULTIPART_MODE_MIXED:
<span class="nc" id="L337">				MimeMultipart mixedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_MIXED);</span>
<span class="nc" id="L338">				mimeMessage.setContent(mixedMultipart);</span>
<span class="nc" id="L339">				setMimeMultiparts(mixedMultipart, mixedMultipart);</span>
<span class="nc" id="L340">				break;</span>
			case MULTIPART_MODE_RELATED:
<span class="nc" id="L342">				MimeMultipart relatedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_RELATED);</span>
<span class="nc" id="L343">				mimeMessage.setContent(relatedMultipart);</span>
<span class="nc" id="L344">				setMimeMultiparts(relatedMultipart, relatedMultipart);</span>
<span class="nc" id="L345">				break;</span>
			case MULTIPART_MODE_MIXED_RELATED:
<span class="nc" id="L347">				MimeMultipart rootMixedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_MIXED);</span>
<span class="nc" id="L348">				mimeMessage.setContent(rootMixedMultipart);</span>
<span class="nc" id="L349">				MimeMultipart nestedRelatedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_RELATED);</span>
<span class="nc" id="L350">				MimeBodyPart relatedBodyPart = new MimeBodyPart();</span>
<span class="nc" id="L351">				relatedBodyPart.setContent(nestedRelatedMultipart);</span>
<span class="nc" id="L352">				rootMixedMultipart.addBodyPart(relatedBodyPart);</span>
<span class="nc" id="L353">				setMimeMultiparts(rootMixedMultipart, nestedRelatedMultipart);</span>
<span class="nc" id="L354">				break;</span>
			default:
<span class="nc" id="L356">				throw new IllegalArgumentException(&quot;Only multipart modes MIXED_RELATED, RELATED and NO supported&quot;);</span>
		}
<span class="nc" id="L358">	}</span>

	/**
	 * Set the given MimeMultipart objects for use by this MimeMessageHelper.
	 * @param root the root MimeMultipart object, which attachments will be added to;
	 * or {@code null} to indicate no multipart at all
	 * @param main the main MimeMultipart object, which text(s) and inline elements
	 * will be added to (can be the same as the root multipart object, or an element
	 * nested underneath the root multipart element)
	 */
	protected final void setMimeMultiparts(@Nullable MimeMultipart root, @Nullable MimeMultipart main) {
<span class="nc" id="L369">		this.rootMimeMultipart = root;</span>
<span class="nc" id="L370">		this.mimeMultipart = main;</span>
<span class="nc" id="L371">	}</span>

	/**
	 * Return whether this helper is in multipart mode,
	 * i.e. whether it holds a multipart message.
	 * @see #MimeMessageHelper(MimeMessage, boolean)
	 */
	public final boolean isMultipart() {
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">		return (this.rootMimeMultipart != null);</span>
	}

	/**
	 * Return the root MIME &quot;multipart/mixed&quot; object, if any.
	 * Can be used to manually add attachments.
	 * &lt;p&gt;This will be the direct content of the MimeMessage,
	 * in case of a multipart mail.
	 * @throws IllegalStateException if this helper is not in multipart mode
	 * @see #isMultipart
	 * @see #getMimeMessage
	 * @see javax.mail.internet.MimeMultipart#addBodyPart
	 */
	public final MimeMultipart getRootMimeMultipart() throws IllegalStateException {
<span class="nc bnc" id="L393" title="All 2 branches missed.">		if (this.rootMimeMultipart == null) {</span>
<span class="nc" id="L394">			throw new IllegalStateException(&quot;Not in multipart mode - &quot; +</span>
					&quot;create an appropriate MimeMessageHelper via a constructor that takes a 'multipart' flag &quot; +
					&quot;if you need to set alternative texts or add inline elements or attachments.&quot;);
		}
<span class="nc" id="L398">		return this.rootMimeMultipart;</span>
	}

	/**
	 * Return the underlying MIME &quot;multipart/related&quot; object, if any.
	 * Can be used to manually add body parts, inline elements, etc.
	 * &lt;p&gt;This will be nested within the root MimeMultipart,
	 * in case of a multipart mail.
	 * @throws IllegalStateException if this helper is not in multipart mode
	 * @see #isMultipart
	 * @see #getRootMimeMultipart
	 * @see javax.mail.internet.MimeMultipart#addBodyPart
	 */
	public final MimeMultipart getMimeMultipart() throws IllegalStateException {
<span class="nc bnc" id="L412" title="All 2 branches missed.">		if (this.mimeMultipart == null) {</span>
<span class="nc" id="L413">			throw new IllegalStateException(&quot;Not in multipart mode - &quot; +</span>
					&quot;create an appropriate MimeMessageHelper via a constructor that takes a 'multipart' flag &quot; +
					&quot;if you need to set alternative texts or add inline elements or attachments.&quot;);
		}
<span class="nc" id="L417">		return this.mimeMultipart;</span>
	}


	/**
	 * Determine the default encoding for the given MimeMessage.
	 * @param mimeMessage the passed-in MimeMessage
	 * @return the default encoding associated with the MimeMessage,
	 * or {@code null} if none found
	 */
	@Nullable
	protected String getDefaultEncoding(MimeMessage mimeMessage) {
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">		if (mimeMessage instanceof SmartMimeMessage) {</span>
<span class="fc" id="L430">			return ((SmartMimeMessage) mimeMessage).getDefaultEncoding();</span>
		}
<span class="nc" id="L432">		return null;</span>
	}

	/**
	 * Return the specific character encoding used for this message, if any.
	 */
	@Nullable
	public String getEncoding() {
<span class="fc" id="L440">		return this.encoding;</span>
	}

	/**
	 * Determine the default Java Activation FileTypeMap for the given MimeMessage.
	 * @param mimeMessage the passed-in MimeMessage
	 * @return the default FileTypeMap associated with the MimeMessage,
	 * or a default ConfigurableMimeFileTypeMap if none found for the message
	 * @see ConfigurableMimeFileTypeMap
	 */
	protected FileTypeMap getDefaultFileTypeMap(MimeMessage mimeMessage) {
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">		if (mimeMessage instanceof SmartMimeMessage) {</span>
<span class="fc" id="L452">			FileTypeMap fileTypeMap = ((SmartMimeMessage) mimeMessage).getDefaultFileTypeMap();</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">			if (fileTypeMap != null) {</span>
<span class="fc" id="L454">				return fileTypeMap;</span>
			}
		}
<span class="nc" id="L457">		ConfigurableMimeFileTypeMap fileTypeMap = new ConfigurableMimeFileTypeMap();</span>
<span class="nc" id="L458">		fileTypeMap.afterPropertiesSet();</span>
<span class="nc" id="L459">		return fileTypeMap;</span>
	}

	/**
	 * Set the Java Activation Framework {@code FileTypeMap} to use
	 * for determining the content type of inline content and attachments
	 * that get added to the message.
	 * &lt;p&gt;Default is the {@code FileTypeMap} that the underlying
	 * MimeMessage carries, if any, or the Activation Framework's default
	 * {@code FileTypeMap} instance else.
	 * @see #addInline
	 * @see #addAttachment
	 * @see #getDefaultFileTypeMap(javax.mail.internet.MimeMessage)
	 * @see JavaMailSenderImpl#setDefaultFileTypeMap
	 * @see javax.activation.FileTypeMap#getDefaultFileTypeMap
	 * @see ConfigurableMimeFileTypeMap
	 */
	public void setFileTypeMap(@Nullable FileTypeMap fileTypeMap) {
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">		this.fileTypeMap = (fileTypeMap != null ? fileTypeMap : getDefaultFileTypeMap(getMimeMessage()));</span>
<span class="fc" id="L478">	}</span>

	/**
	 * Return the {@code FileTypeMap} used by this MimeMessageHelper.
	 */
	public FileTypeMap getFileTypeMap() {
<span class="fc" id="L484">		return this.fileTypeMap;</span>
	}


	/**
	 * Set whether to validate all addresses which get passed to this helper.
	 * Default is &quot;false&quot;.
	 * &lt;p&gt;Note that this is by default just available for JavaMail &gt;= 1.3.
	 * You can override the default {@code validateAddress method} for
	 * validation on older JavaMail versions (or for custom validation).
	 * @see #validateAddress
	 */
	public void setValidateAddresses(boolean validateAddresses) {
<span class="nc" id="L497">		this.validateAddresses = validateAddresses;</span>
<span class="nc" id="L498">	}</span>

	/**
	 * Return whether this helper will validate all addresses passed to it.
	 */
	public boolean isValidateAddresses() {
<span class="fc" id="L504">		return this.validateAddresses;</span>
	}

	/**
	 * Validate the given mail address.
	 * Called by all of MimeMessageHelper's address setters and adders.
	 * &lt;p&gt;Default implementation invokes {@code InternetAddress.validate()},
	 * provided that address validation is activated for the helper instance.
	 * &lt;p&gt;Note that this method will just work on JavaMail &gt;= 1.3. You can override
	 * it for validation on older JavaMail versions or for custom validation.
	 * @param address the address to validate
	 * @throws AddressException if validation failed
	 * @see #isValidateAddresses()
	 * @see javax.mail.internet.InternetAddress#validate()
	 */
	protected void validateAddress(InternetAddress address) throws AddressException {
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">		if (isValidateAddresses()) {</span>
<span class="nc" id="L521">			address.validate();</span>
		}
<span class="fc" id="L523">	}</span>

	/**
	 * Validate all given mail addresses.
	 * Default implementation simply delegates to validateAddress for each address.
	 * @param addresses the addresses to validate
	 * @throws AddressException if validation failed
	 * @see #validateAddress(InternetAddress)
	 */
	protected void validateAddresses(InternetAddress[] addresses) throws AddressException {
<span class="fc bfc" id="L533" title="All 2 branches covered.">		for (InternetAddress address : addresses) {</span>
<span class="fc" id="L534">			validateAddress(address);</span>
		}
<span class="fc" id="L536">	}</span>


	public void setFrom(InternetAddress from) throws MessagingException {
<span class="fc" id="L540">		Assert.notNull(from, &quot;From address must not be null&quot;);</span>
<span class="fc" id="L541">		validateAddress(from);</span>
<span class="fc" id="L542">		this.mimeMessage.setFrom(from);</span>
<span class="fc" id="L543">	}</span>

	public void setFrom(String from) throws MessagingException {
<span class="fc" id="L546">		Assert.notNull(from, &quot;From address must not be null&quot;);</span>
<span class="fc" id="L547">		setFrom(parseAddress(from));</span>
<span class="fc" id="L548">	}</span>

	public void setFrom(String from, String personal) throws MessagingException, UnsupportedEncodingException {
<span class="nc" id="L551">		Assert.notNull(from, &quot;From address must not be null&quot;);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">		setFrom(getEncoding() != null ?</span>
<span class="nc" id="L553">			new InternetAddress(from, personal, getEncoding()) : new InternetAddress(from, personal));</span>
<span class="nc" id="L554">	}</span>

	public void setReplyTo(InternetAddress replyTo) throws MessagingException {
<span class="fc" id="L557">		Assert.notNull(replyTo, &quot;Reply-to address must not be null&quot;);</span>
<span class="fc" id="L558">		validateAddress(replyTo);</span>
<span class="fc" id="L559">		this.mimeMessage.setReplyTo(new InternetAddress[] {replyTo});</span>
<span class="fc" id="L560">	}</span>

	public void setReplyTo(String replyTo) throws MessagingException {
<span class="fc" id="L563">		Assert.notNull(replyTo, &quot;Reply-to address must not be null&quot;);</span>
<span class="fc" id="L564">		setReplyTo(parseAddress(replyTo));</span>
<span class="fc" id="L565">	}</span>

	public void setReplyTo(String replyTo, String personal) throws MessagingException, UnsupportedEncodingException {
<span class="nc" id="L568">		Assert.notNull(replyTo, &quot;Reply-to address must not be null&quot;);</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">		InternetAddress replyToAddress = (getEncoding() != null) ?</span>
<span class="nc" id="L570">				new InternetAddress(replyTo, personal, getEncoding()) : new InternetAddress(replyTo, personal);</span>
<span class="nc" id="L571">		setReplyTo(replyToAddress);</span>
<span class="nc" id="L572">	}</span>


	public void setTo(InternetAddress to) throws MessagingException {
<span class="fc" id="L576">		Assert.notNull(to, &quot;To address must not be null&quot;);</span>
<span class="fc" id="L577">		validateAddress(to);</span>
<span class="fc" id="L578">		this.mimeMessage.setRecipient(Message.RecipientType.TO, to);</span>
<span class="fc" id="L579">	}</span>

	public void setTo(InternetAddress[] to) throws MessagingException {
<span class="fc" id="L582">		Assert.notNull(to, &quot;To address array must not be null&quot;);</span>
<span class="fc" id="L583">		validateAddresses(to);</span>
<span class="fc" id="L584">		this.mimeMessage.setRecipients(Message.RecipientType.TO, to);</span>
<span class="fc" id="L585">	}</span>

	public void setTo(String to) throws MessagingException {
<span class="fc" id="L588">		Assert.notNull(to, &quot;To address must not be null&quot;);</span>
<span class="fc" id="L589">		setTo(parseAddress(to));</span>
<span class="fc" id="L590">	}</span>

	public void setTo(String[] to) throws MessagingException {
<span class="fc" id="L593">		Assert.notNull(to, &quot;To address array must not be null&quot;);</span>
<span class="fc" id="L594">		InternetAddress[] addresses = new InternetAddress[to.length];</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">		for (int i = 0; i &lt; to.length; i++) {</span>
<span class="fc" id="L596">			addresses[i] = parseAddress(to[i]);</span>
		}
<span class="fc" id="L598">		setTo(addresses);</span>
<span class="fc" id="L599">	}</span>

	public void addTo(InternetAddress to) throws MessagingException {
<span class="nc" id="L602">		Assert.notNull(to, &quot;To address must not be null&quot;);</span>
<span class="nc" id="L603">		validateAddress(to);</span>
<span class="nc" id="L604">		this.mimeMessage.addRecipient(Message.RecipientType.TO, to);</span>
<span class="nc" id="L605">	}</span>

	public void addTo(String to) throws MessagingException {
<span class="nc" id="L608">		Assert.notNull(to, &quot;To address must not be null&quot;);</span>
<span class="nc" id="L609">		addTo(parseAddress(to));</span>
<span class="nc" id="L610">	}</span>

	public void addTo(String to, String personal) throws MessagingException, UnsupportedEncodingException {
<span class="nc" id="L613">		Assert.notNull(to, &quot;To address must not be null&quot;);</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">		addTo(getEncoding() != null ?</span>
<span class="nc" id="L615">			new InternetAddress(to, personal, getEncoding()) :</span>
			new InternetAddress(to, personal));
<span class="nc" id="L617">	}</span>


	public void setCc(InternetAddress cc) throws MessagingException {
<span class="nc" id="L621">		Assert.notNull(cc, &quot;Cc address must not be null&quot;);</span>
<span class="nc" id="L622">		validateAddress(cc);</span>
<span class="nc" id="L623">		this.mimeMessage.setRecipient(Message.RecipientType.CC, cc);</span>
<span class="nc" id="L624">	}</span>

	public void setCc(InternetAddress[] cc) throws MessagingException {
<span class="fc" id="L627">		Assert.notNull(cc, &quot;Cc address array must not be null&quot;);</span>
<span class="fc" id="L628">		validateAddresses(cc);</span>
<span class="fc" id="L629">		this.mimeMessage.setRecipients(Message.RecipientType.CC, cc);</span>
<span class="fc" id="L630">	}</span>

	public void setCc(String cc) throws MessagingException {
<span class="nc" id="L633">		Assert.notNull(cc, &quot;Cc address must not be null&quot;);</span>
<span class="nc" id="L634">		setCc(parseAddress(cc));</span>
<span class="nc" id="L635">	}</span>

	public void setCc(String[] cc) throws MessagingException {
<span class="fc" id="L638">		Assert.notNull(cc, &quot;Cc address array must not be null&quot;);</span>
<span class="fc" id="L639">		InternetAddress[] addresses = new InternetAddress[cc.length];</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">		for (int i = 0; i &lt; cc.length; i++) {</span>
<span class="fc" id="L641">			addresses[i] = parseAddress(cc[i]);</span>
		}
<span class="fc" id="L643">		setCc(addresses);</span>
<span class="fc" id="L644">	}</span>

	public void addCc(InternetAddress cc) throws MessagingException {
<span class="nc" id="L647">		Assert.notNull(cc, &quot;Cc address must not be null&quot;);</span>
<span class="nc" id="L648">		validateAddress(cc);</span>
<span class="nc" id="L649">		this.mimeMessage.addRecipient(Message.RecipientType.CC, cc);</span>
<span class="nc" id="L650">	}</span>

	public void addCc(String cc) throws MessagingException {
<span class="nc" id="L653">		Assert.notNull(cc, &quot;Cc address must not be null&quot;);</span>
<span class="nc" id="L654">		addCc(parseAddress(cc));</span>
<span class="nc" id="L655">	}</span>

	public void addCc(String cc, String personal) throws MessagingException, UnsupportedEncodingException {
<span class="nc" id="L658">		Assert.notNull(cc, &quot;Cc address must not be null&quot;);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">		addCc(getEncoding() != null ?</span>
<span class="nc" id="L660">			new InternetAddress(cc, personal, getEncoding()) :</span>
			new InternetAddress(cc, personal));
<span class="nc" id="L662">	}</span>


	public void setBcc(InternetAddress bcc) throws MessagingException {
<span class="nc" id="L666">		Assert.notNull(bcc, &quot;Bcc address must not be null&quot;);</span>
<span class="nc" id="L667">		validateAddress(bcc);</span>
<span class="nc" id="L668">		this.mimeMessage.setRecipient(Message.RecipientType.BCC, bcc);</span>
<span class="nc" id="L669">	}</span>

	public void setBcc(InternetAddress[] bcc) throws MessagingException {
<span class="fc" id="L672">		Assert.notNull(bcc, &quot;Bcc address array must not be null&quot;);</span>
<span class="fc" id="L673">		validateAddresses(bcc);</span>
<span class="fc" id="L674">		this.mimeMessage.setRecipients(Message.RecipientType.BCC, bcc);</span>
<span class="fc" id="L675">	}</span>

	public void setBcc(String bcc) throws MessagingException {
<span class="nc" id="L678">		Assert.notNull(bcc, &quot;Bcc address must not be null&quot;);</span>
<span class="nc" id="L679">		setBcc(parseAddress(bcc));</span>
<span class="nc" id="L680">	}</span>

	public void setBcc(String[] bcc) throws MessagingException {
<span class="fc" id="L683">		Assert.notNull(bcc, &quot;Bcc address array must not be null&quot;);</span>
<span class="fc" id="L684">		InternetAddress[] addresses = new InternetAddress[bcc.length];</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">		for (int i = 0; i &lt; bcc.length; i++) {</span>
<span class="fc" id="L686">			addresses[i] = parseAddress(bcc[i]);</span>
		}
<span class="fc" id="L688">		setBcc(addresses);</span>
<span class="fc" id="L689">	}</span>

	public void addBcc(InternetAddress bcc) throws MessagingException {
<span class="nc" id="L692">		Assert.notNull(bcc, &quot;Bcc address must not be null&quot;);</span>
<span class="nc" id="L693">		validateAddress(bcc);</span>
<span class="nc" id="L694">		this.mimeMessage.addRecipient(Message.RecipientType.BCC, bcc);</span>
<span class="nc" id="L695">	}</span>

	public void addBcc(String bcc) throws MessagingException {
<span class="nc" id="L698">		Assert.notNull(bcc, &quot;Bcc address must not be null&quot;);</span>
<span class="nc" id="L699">		addBcc(parseAddress(bcc));</span>
<span class="nc" id="L700">	}</span>

	public void addBcc(String bcc, String personal) throws MessagingException, UnsupportedEncodingException {
<span class="nc" id="L703">		Assert.notNull(bcc, &quot;Bcc address must not be null&quot;);</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">		addBcc(getEncoding() != null ?</span>
<span class="nc" id="L705">			new InternetAddress(bcc, personal, getEncoding()) :</span>
			new InternetAddress(bcc, personal));
<span class="nc" id="L707">	}</span>

	private InternetAddress parseAddress(String address) throws MessagingException {
<span class="fc" id="L710">		InternetAddress[] parsed = InternetAddress.parse(address);</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">		if (parsed.length != 1) {</span>
<span class="fc" id="L712">			throw new AddressException(&quot;Illegal address&quot;, address);</span>
		}
<span class="fc" id="L714">		InternetAddress raw = parsed[0];</span>
		try {
<span class="fc bfc" id="L716" title="All 2 branches covered.">			return (getEncoding() != null ?</span>
<span class="fc" id="L717">					new InternetAddress(raw.getAddress(), raw.getPersonal(), getEncoding()) : raw);</span>
		}
<span class="nc" id="L719">		catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L720">			throw new MessagingException(&quot;Failed to parse embedded personal name to correct encoding&quot;, ex);</span>
		}
	}


	/**
	 * Set the priority (&quot;X-Priority&quot; header) of the message.
	 * @param priority the priority value;
	 * typically between 1 (highest) and 5 (lowest)
	 * @throws MessagingException in case of errors
	 */
	public void setPriority(int priority) throws MessagingException {
<span class="nc" id="L732">		this.mimeMessage.setHeader(HEADER_PRIORITY, Integer.toString(priority));</span>
<span class="nc" id="L733">	}</span>

	/**
	 * Set the sent-date of the message.
	 * @param sentDate the date to set (never {@code null})
	 * @throws MessagingException in case of errors
	 */
	public void setSentDate(Date sentDate) throws MessagingException {
<span class="fc" id="L741">		Assert.notNull(sentDate, &quot;Sent date must not be null&quot;);</span>
<span class="fc" id="L742">		this.mimeMessage.setSentDate(sentDate);</span>
<span class="fc" id="L743">	}</span>

	/**
	 * Set the subject of the message, using the correct encoding.
	 * @param subject the subject text
	 * @throws MessagingException in case of errors
	 */
	public void setSubject(String subject) throws MessagingException {
<span class="fc" id="L751">		Assert.notNull(subject, &quot;Subject must not be null&quot;);</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">		if (getEncoding() != null) {</span>
<span class="nc" id="L753">			this.mimeMessage.setSubject(subject, getEncoding());</span>
		}
		else {
<span class="fc" id="L756">			this.mimeMessage.setSubject(subject);</span>
		}
<span class="fc" id="L758">	}</span>


	/**
	 * Set the given text directly as content in non-multipart mode
	 * or as default body part in multipart mode.
	 * Always applies the default content type &quot;text/plain&quot;.
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Invoke {@link #addInline} &lt;i&gt;after&lt;/i&gt; {@code setText};
	 * else, mail readers might not be able to resolve inline references correctly.
	 * @param text the text for the message
	 * @throws MessagingException in case of errors
	 */
	public void setText(String text) throws MessagingException {
<span class="fc" id="L771">		setText(text, false);</span>
<span class="fc" id="L772">	}</span>

	/**
	 * Set the given text directly as content in non-multipart mode
	 * or as default body part in multipart mode.
	 * The &quot;html&quot; flag determines the content type to apply.
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Invoke {@link #addInline} &lt;i&gt;after&lt;/i&gt; {@code setText};
	 * else, mail readers might not be able to resolve inline references correctly.
	 * @param text the text for the message
	 * @param html whether to apply content type &quot;text/html&quot; for an
	 * HTML mail, using default content type (&quot;text/plain&quot;) else
	 * @throws MessagingException in case of errors
	 */
	public void setText(String text, boolean html) throws MessagingException {
<span class="fc" id="L786">		Assert.notNull(text, &quot;Text must not be null&quot;);</span>
		MimePart partToUse;
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">		if (isMultipart()) {</span>
<span class="nc" id="L789">			partToUse = getMainPart();</span>
		}
		else {
<span class="fc" id="L792">			partToUse = this.mimeMessage;</span>
		}
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">		if (html) {</span>
<span class="nc" id="L795">			setHtmlTextToMimePart(partToUse, text);</span>
		}
		else {
<span class="fc" id="L798">			setPlainTextToMimePart(partToUse, text);</span>
		}
<span class="fc" id="L800">	}</span>

	/**
	 * Set the given plain text and HTML text as alternatives, offering
	 * both options to the email client. Requires multipart mode.
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Invoke {@link #addInline} &lt;i&gt;after&lt;/i&gt; {@code setText};
	 * else, mail readers might not be able to resolve inline references correctly.
	 * @param plainText the plain text for the message
	 * @param htmlText the HTML text for the message
	 * @throws MessagingException in case of errors
	 */
	public void setText(String plainText, String htmlText) throws MessagingException {
<span class="nc" id="L812">		Assert.notNull(plainText, &quot;Plain text must not be null&quot;);</span>
<span class="nc" id="L813">		Assert.notNull(htmlText, &quot;HTML text must not be null&quot;);</span>

<span class="nc" id="L815">		MimeMultipart messageBody = new MimeMultipart(MULTIPART_SUBTYPE_ALTERNATIVE);</span>
<span class="nc" id="L816">		getMainPart().setContent(messageBody, CONTENT_TYPE_ALTERNATIVE);</span>

		// Create the plain text part of the message.
<span class="nc" id="L819">		MimeBodyPart plainTextPart = new MimeBodyPart();</span>
<span class="nc" id="L820">		setPlainTextToMimePart(plainTextPart, plainText);</span>
<span class="nc" id="L821">		messageBody.addBodyPart(plainTextPart);</span>

		// Create the HTML text part of the message.
<span class="nc" id="L824">		MimeBodyPart htmlTextPart = new MimeBodyPart();</span>
<span class="nc" id="L825">		setHtmlTextToMimePart(htmlTextPart, htmlText);</span>
<span class="nc" id="L826">		messageBody.addBodyPart(htmlTextPart);</span>
<span class="nc" id="L827">	}</span>

	private MimeBodyPart getMainPart() throws MessagingException {
<span class="nc" id="L830">		MimeMultipart mimeMultipart = getMimeMultipart();</span>
<span class="nc" id="L831">		MimeBodyPart bodyPart = null;</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">		for (int i = 0; i &lt; mimeMultipart.getCount(); i++) {</span>
<span class="nc" id="L833">			BodyPart bp = mimeMultipart.getBodyPart(i);</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">			if (bp.getFileName() == null) {</span>
<span class="nc" id="L835">				bodyPart = (MimeBodyPart) bp;</span>
			}
		}
<span class="nc bnc" id="L838" title="All 2 branches missed.">		if (bodyPart == null) {</span>
<span class="nc" id="L839">			MimeBodyPart mimeBodyPart = new MimeBodyPart();</span>
<span class="nc" id="L840">			mimeMultipart.addBodyPart(mimeBodyPart);</span>
<span class="nc" id="L841">			bodyPart = mimeBodyPart;</span>
		}
<span class="nc" id="L843">		return bodyPart;</span>
	}

	private void setPlainTextToMimePart(MimePart mimePart, String text) throws MessagingException {
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">		if (getEncoding() != null) {</span>
<span class="nc" id="L848">			mimePart.setText(text, getEncoding());</span>
		}
		else {
<span class="fc" id="L851">			mimePart.setText(text);</span>
		}
<span class="fc" id="L853">	}</span>

	private void setHtmlTextToMimePart(MimePart mimePart, String text) throws MessagingException {
<span class="nc bnc" id="L856" title="All 2 branches missed.">		if (getEncoding() != null) {</span>
<span class="nc" id="L857">			mimePart.setContent(text, CONTENT_TYPE_HTML + CONTENT_TYPE_CHARSET_SUFFIX + getEncoding());</span>
		}
		else {
<span class="nc" id="L860">			mimePart.setContent(text, CONTENT_TYPE_HTML);</span>
		}
<span class="nc" id="L862">	}</span>


	/**
	 * Add an inline element to the MimeMessage, taking the content from a
	 * {@code javax.activation.DataSource}.
	 * &lt;p&gt;Note that the InputStream returned by the DataSource implementation
	 * needs to be a &lt;i&gt;fresh one on each call&lt;/i&gt;, as JavaMail will invoke
	 * {@code getInputStream()} multiple times.
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Invoke {@code addInline} &lt;i&gt;after&lt;/i&gt; {@link #setText};
	 * else, mail readers might not be able to resolve inline references correctly.
	 * @param contentId the content ID to use. Will end up as &quot;Content-ID&quot; header
	 * in the body part, surrounded by angle brackets: e.g. &quot;myId&quot; -&gt; &quot;&amp;lt;myId&amp;gt;&quot;.
	 * Can be referenced in HTML source via src=&quot;cid:myId&quot; expressions.
	 * @param dataSource the {@code javax.activation.DataSource} to take
	 * the content from, determining the InputStream and the content type
	 * @throws MessagingException in case of errors
	 * @see #addInline(String, java.io.File)
	 * @see #addInline(String, org.springframework.core.io.Resource)
	 */
	public void addInline(String contentId, DataSource dataSource) throws MessagingException {
<span class="nc" id="L883">		Assert.notNull(contentId, &quot;Content ID must not be null&quot;);</span>
<span class="nc" id="L884">		Assert.notNull(dataSource, &quot;DataSource must not be null&quot;);</span>
<span class="nc" id="L885">		MimeBodyPart mimeBodyPart = new MimeBodyPart();</span>
<span class="nc" id="L886">		mimeBodyPart.setDisposition(MimeBodyPart.INLINE);</span>
		// We're using setHeader here to remain compatible with JavaMail 1.2,
		// rather than JavaMail 1.3's setContentID.
<span class="nc" id="L889">		mimeBodyPart.setHeader(HEADER_CONTENT_ID, &quot;&lt;&quot; + contentId + &quot;&gt;&quot;);</span>
<span class="nc" id="L890">		mimeBodyPart.setDataHandler(new DataHandler(dataSource));</span>
<span class="nc" id="L891">		getMimeMultipart().addBodyPart(mimeBodyPart);</span>
<span class="nc" id="L892">	}</span>

	/**
	 * Add an inline element to the MimeMessage, taking the content from a
	 * {@code java.io.File}.
	 * &lt;p&gt;The content type will be determined by the name of the given
	 * content file. Do not use this for temporary files with arbitrary
	 * filenames (possibly ending in &quot;.tmp&quot; or the like)!
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Invoke {@code addInline} &lt;i&gt;after&lt;/i&gt; {@link #setText};
	 * else, mail readers might not be able to resolve inline references correctly.
	 * @param contentId the content ID to use. Will end up as &quot;Content-ID&quot; header
	 * in the body part, surrounded by angle brackets: e.g. &quot;myId&quot; -&gt; &quot;&amp;lt;myId&amp;gt;&quot;.
	 * Can be referenced in HTML source via src=&quot;cid:myId&quot; expressions.
	 * @param file the File resource to take the content from
	 * @throws MessagingException in case of errors
	 * @see #setText
	 * @see #addInline(String, org.springframework.core.io.Resource)
	 * @see #addInline(String, javax.activation.DataSource)
	 */
	public void addInline(String contentId, File file) throws MessagingException {
<span class="nc" id="L912">		Assert.notNull(file, &quot;File must not be null&quot;);</span>
<span class="nc" id="L913">		FileDataSource dataSource = new FileDataSource(file);</span>
<span class="nc" id="L914">		dataSource.setFileTypeMap(getFileTypeMap());</span>
<span class="nc" id="L915">		addInline(contentId, dataSource);</span>
<span class="nc" id="L916">	}</span>

	/**
	 * Add an inline element to the MimeMessage, taking the content from a
	 * {@code org.springframework.core.io.Resource}.
	 * &lt;p&gt;The content type will be determined by the name of the given
	 * content file. Do not use this for temporary files with arbitrary
	 * filenames (possibly ending in &quot;.tmp&quot; or the like)!
	 * &lt;p&gt;Note that the InputStream returned by the Resource implementation
	 * needs to be a &lt;i&gt;fresh one on each call&lt;/i&gt;, as JavaMail will invoke
	 * {@code getInputStream()} multiple times.
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Invoke {@code addInline} &lt;i&gt;after&lt;/i&gt; {@link #setText};
	 * else, mail readers might not be able to resolve inline references correctly.
	 * @param contentId the content ID to use. Will end up as &quot;Content-ID&quot; header
	 * in the body part, surrounded by angle brackets: e.g. &quot;myId&quot; -&gt; &quot;&amp;lt;myId&amp;gt;&quot;.
	 * Can be referenced in HTML source via src=&quot;cid:myId&quot; expressions.
	 * @param resource the resource to take the content from
	 * @throws MessagingException in case of errors
	 * @see #setText
	 * @see #addInline(String, java.io.File)
	 * @see #addInline(String, javax.activation.DataSource)
	 */
	public void addInline(String contentId, Resource resource) throws MessagingException {
<span class="nc" id="L939">		Assert.notNull(resource, &quot;Resource must not be null&quot;);</span>
<span class="nc" id="L940">		String contentType = getFileTypeMap().getContentType(resource.getFilename());</span>
<span class="nc" id="L941">		addInline(contentId, resource, contentType);</span>
<span class="nc" id="L942">	}</span>

	/**
	 * Add an inline element to the MimeMessage, taking the content from an
	 * {@code org.springframework.core.InputStreamResource}, and
	 * specifying the content type explicitly.
	 * &lt;p&gt;You can determine the content type for any given filename via a Java
	 * Activation Framework's FileTypeMap, for example the one held by this helper.
	 * &lt;p&gt;Note that the InputStream returned by the InputStreamSource implementation
	 * needs to be a &lt;i&gt;fresh one on each call&lt;/i&gt;, as JavaMail will invoke
	 * {@code getInputStream()} multiple times.
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Invoke {@code addInline} &lt;i&gt;after&lt;/i&gt; {@code setText};
	 * else, mail readers might not be able to resolve inline references correctly.
	 * @param contentId the content ID to use. Will end up as &quot;Content-ID&quot; header
	 * in the body part, surrounded by angle brackets: e.g. &quot;myId&quot; -&gt; &quot;&amp;lt;myId&amp;gt;&quot;.
	 * Can be referenced in HTML source via src=&quot;cid:myId&quot; expressions.
	 * @param inputStreamSource the resource to take the content from
	 * @param contentType the content type to use for the element
	 * @throws MessagingException in case of errors
	 * @see #setText
	 * @see #getFileTypeMap
	 * @see #addInline(String, org.springframework.core.io.Resource)
	 * @see #addInline(String, javax.activation.DataSource)
	 */
	public void addInline(String contentId, InputStreamSource inputStreamSource, String contentType)
			throws MessagingException {

<span class="nc" id="L969">		Assert.notNull(inputStreamSource, &quot;InputStreamSource must not be null&quot;);</span>
<span class="nc bnc" id="L970" title="All 4 branches missed.">		if (inputStreamSource instanceof Resource &amp;&amp; ((Resource) inputStreamSource).isOpen()) {</span>
<span class="nc" id="L971">			throw new IllegalArgumentException(</span>
					&quot;Passed-in Resource contains an open stream: invalid argument. &quot; +
					&quot;JavaMail requires an InputStreamSource that creates a fresh stream for every call.&quot;);
		}
<span class="nc" id="L975">		DataSource dataSource = createDataSource(inputStreamSource, contentType, &quot;inline&quot;);</span>
<span class="nc" id="L976">		addInline(contentId, dataSource);</span>
<span class="nc" id="L977">	}</span>

	/**
	 * Add an attachment to the MimeMessage, taking the content from a
	 * {@code javax.activation.DataSource}.
	 * &lt;p&gt;Note that the InputStream returned by the DataSource implementation
	 * needs to be a &lt;i&gt;fresh one on each call&lt;/i&gt;, as JavaMail will invoke
	 * {@code getInputStream()} multiple times.
	 * @param attachmentFilename the name of the attachment as it will
	 * appear in the mail (the content type will be determined by this)
	 * @param dataSource the {@code javax.activation.DataSource} to take
	 * the content from, determining the InputStream and the content type
	 * @throws MessagingException in case of errors
	 * @see #addAttachment(String, org.springframework.core.io.InputStreamSource)
	 * @see #addAttachment(String, java.io.File)
	 */
	public void addAttachment(String attachmentFilename, DataSource dataSource) throws MessagingException {
<span class="nc" id="L994">		Assert.notNull(attachmentFilename, &quot;Attachment filename must not be null&quot;);</span>
<span class="nc" id="L995">		Assert.notNull(dataSource, &quot;DataSource must not be null&quot;);</span>
		try {
<span class="nc" id="L997">			MimeBodyPart mimeBodyPart = new MimeBodyPart();</span>
<span class="nc" id="L998">			mimeBodyPart.setDisposition(MimeBodyPart.ATTACHMENT);</span>
<span class="nc" id="L999">			mimeBodyPart.setFileName(MimeUtility.encodeText(attachmentFilename));</span>
<span class="nc" id="L1000">			mimeBodyPart.setDataHandler(new DataHandler(dataSource));</span>
<span class="nc" id="L1001">			getRootMimeMultipart().addBodyPart(mimeBodyPart);</span>
		}
<span class="nc" id="L1003">		catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L1004">			throw new MessagingException(&quot;Failed to encode attachment filename&quot;, ex);</span>
<span class="nc" id="L1005">		}</span>
<span class="nc" id="L1006">	}</span>

	/**
	 * Add an attachment to the MimeMessage, taking the content from a
	 * {@code java.io.File}.
	 * &lt;p&gt;The content type will be determined by the name of the given
	 * content file. Do not use this for temporary files with arbitrary
	 * filenames (possibly ending in &quot;.tmp&quot; or the like)!
	 * @param attachmentFilename the name of the attachment as it will
	 * appear in the mail
	 * @param file the File resource to take the content from
	 * @throws MessagingException in case of errors
	 * @see #addAttachment(String, org.springframework.core.io.InputStreamSource)
	 * @see #addAttachment(String, javax.activation.DataSource)
	 */
	public void addAttachment(String attachmentFilename, File file) throws MessagingException {
<span class="nc" id="L1022">		Assert.notNull(file, &quot;File must not be null&quot;);</span>
<span class="nc" id="L1023">		FileDataSource dataSource = new FileDataSource(file);</span>
<span class="nc" id="L1024">		dataSource.setFileTypeMap(getFileTypeMap());</span>
<span class="nc" id="L1025">		addAttachment(attachmentFilename, dataSource);</span>
<span class="nc" id="L1026">	}</span>

	/**
	 * Add an attachment to the MimeMessage, taking the content from an
	 * {@code org.springframework.core.io.InputStreamResource}.
	 * &lt;p&gt;The content type will be determined by the given filename for
	 * the attachment. Thus, any content source will be fine, including
	 * temporary files with arbitrary filenames.
	 * &lt;p&gt;Note that the InputStream returned by the InputStreamSource
	 * implementation needs to be a &lt;i&gt;fresh one on each call&lt;/i&gt;, as
	 * JavaMail will invoke {@code getInputStream()} multiple times.
	 * @param attachmentFilename the name of the attachment as it will
	 * appear in the mail
	 * @param inputStreamSource the resource to take the content from
	 * (all of Spring's Resource implementations can be passed in here)
	 * @throws MessagingException in case of errors
	 * @see #addAttachment(String, java.io.File)
	 * @see #addAttachment(String, javax.activation.DataSource)
	 * @see org.springframework.core.io.Resource
	 */
	public void addAttachment(String attachmentFilename, InputStreamSource inputStreamSource)
			throws MessagingException {

<span class="nc" id="L1049">		String contentType = getFileTypeMap().getContentType(attachmentFilename);</span>
<span class="nc" id="L1050">		addAttachment(attachmentFilename, inputStreamSource, contentType);</span>
<span class="nc" id="L1051">	}</span>

	/**
	 * Add an attachment to the MimeMessage, taking the content from an
	 * {@code org.springframework.core.io.InputStreamResource}.
	 * &lt;p&gt;Note that the InputStream returned by the InputStreamSource
	 * implementation needs to be a &lt;i&gt;fresh one on each call&lt;/i&gt;, as
	 * JavaMail will invoke {@code getInputStream()} multiple times.
	 * @param attachmentFilename the name of the attachment as it will
	 * appear in the mail
	 * @param inputStreamSource the resource to take the content from
	 * (all of Spring's Resource implementations can be passed in here)
	 * @param contentType the content type to use for the element
	 * @throws MessagingException in case of errors
	 * @see #addAttachment(String, java.io.File)
	 * @see #addAttachment(String, javax.activation.DataSource)
	 * @see org.springframework.core.io.Resource
	 */
	public void addAttachment(
			String attachmentFilename, InputStreamSource inputStreamSource, String contentType)
			throws MessagingException {

<span class="nc" id="L1073">		Assert.notNull(inputStreamSource, &quot;InputStreamSource must not be null&quot;);</span>
<span class="nc bnc" id="L1074" title="All 4 branches missed.">		if (inputStreamSource instanceof Resource &amp;&amp; ((Resource) inputStreamSource).isOpen()) {</span>
<span class="nc" id="L1075">			throw new IllegalArgumentException(</span>
					&quot;Passed-in Resource contains an open stream: invalid argument. &quot; +
					&quot;JavaMail requires an InputStreamSource that creates a fresh stream for every call.&quot;);
		}
<span class="nc" id="L1079">		DataSource dataSource = createDataSource(inputStreamSource, contentType, attachmentFilename);</span>
<span class="nc" id="L1080">		addAttachment(attachmentFilename, dataSource);</span>
<span class="nc" id="L1081">	}</span>

	/**
	 * Create an Activation Framework DataSource for the given InputStreamSource.
	 * @param inputStreamSource the InputStreamSource (typically a Spring Resource)
	 * @param contentType the content type
	 * @param name the name of the DataSource
	 * @return the Activation Framework DataSource
	 */
	protected DataSource createDataSource(
		final InputStreamSource inputStreamSource, final String contentType, final String name) {

<span class="nc" id="L1093">		return new DataSource() {</span>
			@Override
			public InputStream getInputStream() throws IOException {
<span class="nc" id="L1096">				return inputStreamSource.getInputStream();</span>
			}
			@Override
			public OutputStream getOutputStream() {
<span class="nc" id="L1100">				throw new UnsupportedOperationException(&quot;Read-only javax.activation.DataSource&quot;);</span>
			}
			@Override
			public String getContentType() {
<span class="nc" id="L1104">				return contentType;</span>
			}
			@Override
			public String getName() {
<span class="nc" id="L1108">				return name;</span>
			}
		};
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>