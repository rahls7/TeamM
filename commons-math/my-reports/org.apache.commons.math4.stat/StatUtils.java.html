<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StatUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.stat</a> &gt; <span class="el_source">StatUtils.java</span></div><h1>StatUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.stat;

import java.util.List;

import org.apache.commons.math4.exception.DimensionMismatchException;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.exception.NoDataException;
import org.apache.commons.math4.exception.NotPositiveException;
import org.apache.commons.math4.exception.NullArgumentException;
import org.apache.commons.math4.exception.NumberIsTooSmallException;
import org.apache.commons.math4.exception.util.LocalizedFormats;
import org.apache.commons.math4.stat.descriptive.DescriptiveStatistics;
import org.apache.commons.math4.stat.descriptive.UnivariateStatistic;
import org.apache.commons.math4.stat.descriptive.moment.GeometricMean;
import org.apache.commons.math4.stat.descriptive.moment.Mean;
import org.apache.commons.math4.stat.descriptive.moment.Variance;
import org.apache.commons.math4.stat.descriptive.rank.Max;
import org.apache.commons.math4.stat.descriptive.rank.Min;
import org.apache.commons.math4.stat.descriptive.rank.Percentile;
import org.apache.commons.math4.stat.descriptive.summary.Product;
import org.apache.commons.math4.stat.descriptive.summary.Sum;
import org.apache.commons.math4.stat.descriptive.summary.SumOfLogs;
import org.apache.commons.math4.stat.descriptive.summary.SumOfSquares;

/**
 * StatUtils provides static methods for computing statistics based on data
 * stored in double[] arrays.
 */
public final class StatUtils {

    /** sum */
<span class="fc" id="L48">    private static final UnivariateStatistic SUM = new Sum();</span>

    /** sumSq */
<span class="fc" id="L51">    private static final UnivariateStatistic SUM_OF_SQUARES = new SumOfSquares();</span>

    /** prod */
<span class="fc" id="L54">    private static final UnivariateStatistic PRODUCT = new Product();</span>

    /** sumLog */
<span class="fc" id="L57">    private static final UnivariateStatistic SUM_OF_LOGS = new SumOfLogs();</span>

    /** min */
<span class="fc" id="L60">    private static final UnivariateStatistic MIN = new Min();</span>

    /** max */
<span class="fc" id="L63">    private static final UnivariateStatistic MAX = new Max();</span>

    /** mean */
<span class="fc" id="L66">    private static final UnivariateStatistic MEAN = new Mean();</span>

    /** variance */
<span class="fc" id="L69">    private static final Variance VARIANCE = new Variance();</span>

    /** percentile */
<span class="fc" id="L72">    private static final Percentile PERCENTILE = new Percentile();</span>

    /** geometric mean */
<span class="fc" id="L75">    private static final GeometricMean GEOMETRIC_MEAN = new GeometricMean();</span>

    /**
     * Private Constructor
     */
    private StatUtils() {
    }

    /**
     * Returns the sum of the values in the input array, or
     * &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the input array is null.
     *
     * @param values  array of values to sum
     * @return the sum of the values or &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty
     * @throws MathIllegalArgumentException if the array is null
     */
    public static double sum(final double[] values) throws MathIllegalArgumentException {
<span class="fc" id="L94">        return SUM.evaluate(values);</span>
    }

    /**
     * Returns the sum of the entries in the specified portion of
     * the input array, or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null.
     *
     * @param values the input array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return the sum of the values or Double.NaN if length = 0
     * @throws MathIllegalArgumentException if the array is null or the array index
     *  parameters are not valid
     */
    public static double sum(final double[] values, final int begin, final int length)
        throws MathIllegalArgumentException {
<span class="fc" id="L112">        return SUM.evaluate(values, begin, length);</span>
    }

    /**
     * Returns the sum of the squares of the entries in the input array, or
     * &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null.
     *
     * @param values  input array
     * @return the sum of the squared values or &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty
     * @throws MathIllegalArgumentException if the array is null
     */
    public static double sumSq(final double[] values) throws MathIllegalArgumentException {
<span class="fc" id="L126">        return SUM_OF_SQUARES.evaluate(values);</span>
    }

    /**
     * Returns the sum of the squares of the entries in the specified portion of
     * the input array, or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray
     * is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null.
     *
     * @param values the input array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return the sum of the squares of the values or Double.NaN if length = 0
     * @throws MathIllegalArgumentException if the array is null or the array index
     *  parameters are not valid
     */
    public static double sumSq(final double[] values, final int begin, final int length)
        throws MathIllegalArgumentException {
<span class="fc" id="L145">        return SUM_OF_SQUARES.evaluate(values, begin, length);</span>
    }

    /**
     * Returns the product of the entries in the input array, or
     * &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null.
     *
     * @param values the input array
     * @return the product of the values or Double.NaN if the array is empty
     * @throws MathIllegalArgumentException if the array is null
     */
    public static double product(final double[] values) throws MathIllegalArgumentException {
<span class="fc" id="L159">        return PRODUCT.evaluate(values);</span>
    }

    /**
     * Returns the product of the entries in the specified portion of
     * the input array, or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray
     * is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null.
     *
     * @param values the input array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return the product of the values or Double.NaN if length = 0
     * @throws MathIllegalArgumentException if the array is null or the array index
     *  parameters are not valid
     */
    public static double product(final double[] values, final int begin, final int length)
        throws MathIllegalArgumentException {
<span class="fc" id="L178">        return PRODUCT.evaluate(values, begin, length);</span>
    }

    /**
     * Returns the sum of the natural logs of the entries in the input array, or
     * &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.summary.SumOfLogs}.
     *
     * @param values the input array
     * @return the sum of the natural logs of the values or Double.NaN if the array is empty
     * @throws MathIllegalArgumentException if the array is null
     */
    public static double sumLog(final double[] values) throws MathIllegalArgumentException {
<span class="fc" id="L194">        return SUM_OF_LOGS.evaluate(values);</span>
    }

    /**
     * Returns the sum of the natural logs of the entries in the specified portion of
     * the input array, or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.summary.SumOfLogs}.
     *
     * @param values the input array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return the sum of the natural logs of the values or Double.NaN if
     * length = 0
     * @throws MathIllegalArgumentException if the array is null or the array index
     * parameters are not valid
     */
    public static double sumLog(final double[] values, final int begin, final int length)
        throws MathIllegalArgumentException {
<span class="fc" id="L215">        return SUM_OF_LOGS.evaluate(values, begin, length);</span>
    }

    /**
     * Returns the arithmetic mean of the entries in the input array, or
     * &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.moment.Mean} for
     * details on the computing algorithm.
     *
     * @param values the input array
     * @return the mean of the values or Double.NaN if the array is empty
     * @throws MathIllegalArgumentException if the array is null
     */
    public static double mean(final double[] values) throws MathIllegalArgumentException {
<span class="fc" id="L232">        return MEAN.evaluate(values);</span>
    }

    /**
     * Returns the arithmetic mean of the entries in the specified portion of
     * the input array, or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray
     * is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.moment.Mean Mean} for
     * details on the computing algorithm.
     *
     * @param values the input array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return the mean of the values or Double.NaN if length = 0
     * @throws MathIllegalArgumentException if the array is null or the array index
     * parameters are not valid
     */
    public static double mean(final double[] values, final int begin, final int length)
        throws MathIllegalArgumentException {
<span class="fc" id="L254">        return MEAN.evaluate(values, begin, length);</span>
    }

    /**
     * Returns the geometric mean of the entries in the input array, or
     * &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.moment.GeometricMean GeometricMean}
     * for details on the computing algorithm.
     *
     * @param values the input array
     * @return the geometric mean of the values or Double.NaN if the array is empty
     * @throws MathIllegalArgumentException if the array is null
     */
    public static double geometricMean(final double[] values) throws MathIllegalArgumentException {
<span class="fc" id="L271">        return GEOMETRIC_MEAN.evaluate(values);</span>
    }

    /**
     * Returns the geometric mean of the entries in the specified portion of
     * the input array, or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray
     * is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.moment.GeometricMean GeometricMean}
     * for details on the computing algorithm.
     *
     * @param values the input array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return the geometric mean of the values or Double.NaN if length = 0
     * @throws MathIllegalArgumentException if the array is null or the array index
     *  parameters are not valid
     */
    public static double geometricMean(final double[] values, final int begin, final int length)
        throws MathIllegalArgumentException {
<span class="fc" id="L293">        return GEOMETRIC_MEAN.evaluate(values, begin, length);</span>
    }

    /**
     * Returns the variance of the entries in the input array, or
     * &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
     * &lt;p&gt;
     * This method returns the bias-corrected sample variance (using {@code n - 1} in
     * the denominator). Use {@link #populationVariance(double[])} for the non-bias-corrected
     * population variance.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.moment.Variance Variance} for
     * details on the computing algorithm.
     * &lt;p&gt;
     * Returns 0 for a single-value (i.e. length = 1) sample.
     * &lt;p&gt;
     * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.
     *
     * @param values the input array
     * @return the variance of the values or Double.NaN if the array is empty
     * @throws MathIllegalArgumentException if the array is null
     */
    public static double variance(final double[] values) throws MathIllegalArgumentException {
<span class="fc" id="L316">        return VARIANCE.evaluate(values);</span>
    }

    /**
     * Returns the variance of the entries in the specified portion of
     * the input array, or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray
     * is empty.
     * &lt;p&gt;
     * This method returns the bias-corrected sample variance (using {@code n - 1} in
     * the denominator). Use {@link #populationVariance(double[], int, int)} for the non-bias-corrected
     * population variance.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.moment.Variance Variance} for
     * details on the computing algorithm.
     * &lt;p&gt;
     * Returns 0 for a single-value (i.e. length = 1) sample.
     * &lt;p&gt;
     * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null or the
     * array index parameters are not valid.
     *
     * @param values the input array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return the variance of the values or Double.NaN if length = 0
     * @throws MathIllegalArgumentException if the array is null or the array index
     *  parameters are not valid
     */
    public static double variance(final double[] values, final int begin, final int length)
        throws MathIllegalArgumentException {
<span class="fc" id="L345">        return VARIANCE.evaluate(values, begin, length);</span>
    }

    /**
     * Returns the variance of the entries in the specified portion of
     * the input array, using the precomputed mean value.  Returns
     * &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray is empty.
     * &lt;p&gt;
     * This method returns the bias-corrected sample variance (using {@code n - 1} in
     * the denominator). Use {@link #populationVariance(double[], double, int, int)} for
     * the non-bias-corrected population variance.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.moment.Variance Variance} for
     * details on the computing algorithm.
     * &lt;p&gt;
     * The formula used assumes that the supplied mean value is the arithmetic
     * mean of the sample data, not a known population parameter.  This method
     * is supplied only to save computation when the mean has already been
     * computed.
     * &lt;p&gt;
     * Returns 0 for a single-value (i.e. length = 1) sample.
     * &lt;p&gt;
     * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null or the
     * array index parameters are not valid.
     *
     * @param values the input array
     * @param mean the precomputed mean value
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return the variance of the values or Double.NaN if length = 0
     * @throws MathIllegalArgumentException if the array is null or the array index
     *  parameters are not valid
     */
    public static double variance(final double[] values, final double mean, final int begin, final int length)
        throws MathIllegalArgumentException {
<span class="fc" id="L380">        return VARIANCE.evaluate(values, mean, begin, length);</span>
    }

    /**
     * Returns the variance of the entries in the input array, using the
     * precomputed mean value.  Returns &lt;code&gt;Double.NaN&lt;/code&gt; if the array
     * is empty.
     * &lt;p&gt;
     * This method returns the bias-corrected sample variance (using {@code n - 1} in
     * the denominator).  Use {@link #populationVariance(double[], double)} for the
     * non-bias-corrected population variance.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.moment.Variance Variance} for
     * details on the computing algorithm.
     * &lt;p&gt;
     * The formula used assumes that the supplied mean value is the arithmetic
     * mean of the sample data, not a known population parameter.  This method
     * is supplied only to save computation when the mean has already been
     * computed.
     * &lt;p&gt;
     * Returns 0 for a single-value (i.e. length = 1) sample.
     * &lt;p&gt;
     * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.
     *
     * @param values the input array
     * @param mean the precomputed mean value
     * @return the variance of the values or Double.NaN if the array is empty
     * @throws MathIllegalArgumentException if the array is null
     */
    public static double variance(final double[] values, final double mean) throws MathIllegalArgumentException {
<span class="fc" id="L410">        return VARIANCE.evaluate(values, mean);</span>
    }

    /**
     * Returns the &lt;a href=&quot;http://en.wikibooks.org/wiki/Statistics/Summary/Variance&quot;&gt;
     * population variance&lt;/a&gt; of the entries in the input array, or
     * &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.moment.Variance Variance} for
     * details on the formula and computing algorithm.
     * &lt;p&gt;
     * Returns 0 for a single-value (i.e. length = 1) sample.
     * &lt;p&gt;
     * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.
     *
     * @param values the input array
     * @return the population variance of the values or Double.NaN if the array is empty
     * @throws MathIllegalArgumentException if the array is null
     */
    public static double populationVariance(final double[] values) throws MathIllegalArgumentException {
<span class="nc" id="L430">        return new Variance(false).evaluate(values);</span>
    }

    /**
     * Returns the &lt;a href=&quot;http://en.wikibooks.org/wiki/Statistics/Summary/Variance&quot;&gt;
     * population variance&lt;/a&gt; of the entries in the specified portion of
     * the input array, or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray
     * is empty.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.moment.Variance Variance} for
     * details on the computing algorithm.
     * &lt;p&gt;
     * Returns 0 for a single-value (i.e. length = 1) sample.
     * &lt;p&gt;
     * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null or the
     * array index parameters are not valid.
     *
     * @param values the input array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return the population variance of the values or Double.NaN if length = 0
     * @throws MathIllegalArgumentException if the array is null or the array index
     *  parameters are not valid
     */
    public static double populationVariance(final double[] values, final int begin, final int length)
        throws MathIllegalArgumentException {
<span class="fc" id="L456">        return new Variance(false).evaluate(values, begin, length);</span>
    }

    /**
     * Returns the &lt;a href=&quot;http://en.wikibooks.org/wiki/Statistics/Summary/Variance&quot;&gt;
     * population variance&lt;/a&gt; of the entries in the specified portion of
     * the input array, using the precomputed mean value.  Returns
     * &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray is empty.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.moment.Variance Variance} for
     * details on the computing algorithm.
     * &lt;p&gt;
     * The formula used assumes that the supplied mean value is the arithmetic
     * mean of the sample data, not a known population parameter.  This method
     * is supplied only to save computation when the mean has already been
     * computed.
     * &lt;p&gt;
     * Returns 0 for a single-value (i.e. length = 1) sample.
     * &lt;p&gt;
     * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null or the
     * array index parameters are not valid.
     *
     * @param values the input array
     * @param mean the precomputed mean value
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return the population variance of the values or Double.NaN if length = 0
     * @throws MathIllegalArgumentException if the array is null or the array index
     *  parameters are not valid
     */
    public static double populationVariance(final double[] values, final double mean,
                                            final int begin, final int length)
        throws MathIllegalArgumentException {
<span class="fc" id="L489">        return new Variance(false).evaluate(values, mean, begin, length);</span>
    }

    /**
     * Returns the &lt;a href=&quot;http://en.wikibooks.org/wiki/Statistics/Summary/Variance&quot;&gt;
     * population variance&lt;/a&gt; of the entries in the input array, using the precomputed
     * mean value. Returns &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.moment.Variance Variance} for
     * details on the computing algorithm.
     * &lt;p&gt;
     * The formula used assumes that the supplied mean value is the arithmetic
     * mean of the sample data, not a known population parameter. This method is
     * supplied only to save computation when the mean has already been computed.
     * &lt;p&gt;
     * Returns 0 for a single-value (i.e. length = 1) sample.
     * &lt;p&gt;
     * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.
     *
     * @param values the input array
     * @param mean the precomputed mean value
     * @return the population variance of the values or Double.NaN if the array is empty
     * @throws MathIllegalArgumentException if the array is null
     */
    public static double populationVariance(final double[] values, final double mean)
        throws MathIllegalArgumentException {
<span class="nc" id="L515">        return new Variance(false).evaluate(values, mean);</span>
    }

    /**
     * Returns the maximum of the entries in the input array, or
     * &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.
     * &lt;ul&gt;
     * &lt;li&gt;The result is &lt;code&gt;NaN&lt;/code&gt; iff all values are &lt;code&gt;NaN&lt;/code&gt;
     * (i.e. &lt;code&gt;NaN&lt;/code&gt; values have no impact on the value of the statistic).&lt;/li&gt;
     * &lt;li&gt;If any of the values equals &lt;code&gt;Double.POSITIVE_INFINITY&lt;/code&gt;,
     * the result is &lt;code&gt;Double.POSITIVE_INFINITY.&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param values the input array
     * @return the maximum of the values or Double.NaN if the array is empty
     * @throws MathIllegalArgumentException if the array is null
     */
    public static double max(final double[] values) throws MathIllegalArgumentException {
<span class="fc" id="L535">        return MAX.evaluate(values);</span>
    }

    /**
     * Returns the maximum of the entries in the specified portion of the input array,
     * or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null or
     * the array index parameters are not valid.
     * &lt;ul&gt;
     * &lt;li&gt;The result is &lt;code&gt;NaN&lt;/code&gt; iff all values are &lt;code&gt;NaN&lt;/code&gt;
     * (i.e. &lt;code&gt;NaN&lt;/code&gt; values have no impact on the value of the statistic).&lt;/li&gt;
     * &lt;li&gt;If any of the values equals &lt;code&gt;Double.POSITIVE_INFINITY&lt;/code&gt;,
     * the result is &lt;code&gt;Double.POSITIVE_INFINITY.&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param values the input array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return the maximum of the values or Double.NaN if length = 0
     * @throws MathIllegalArgumentException if the array is null or the array index
     *  parameters are not valid
     */
    public static double max(final double[] values, final int begin, final int length)
        throws MathIllegalArgumentException {
<span class="fc" id="L560">        return MAX.evaluate(values, begin, length);</span>
    }

    /**
     * Returns the minimum of the entries in the input array, or
     * &lt;code&gt;Double.NaN&lt;/code&gt; if the array is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null.
     * &lt;ul&gt;
     * &lt;li&gt;The result is &lt;code&gt;NaN&lt;/code&gt; iff all values are &lt;code&gt;NaN&lt;/code&gt;
     * (i.e. &lt;code&gt;NaN&lt;/code&gt; values have no impact on the value of the statistic).&lt;/li&gt;
     * &lt;li&gt;If any of the values equals &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt;,
     * the result is &lt;code&gt;Double.NEGATIVE_INFINITY.&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param values the input array
     * @return the minimum of the values or Double.NaN if the array is empty
     * @throws MathIllegalArgumentException if the array is null
     */
    public static double min(final double[] values) throws MathIllegalArgumentException {
<span class="fc" id="L580">        return MIN.evaluate(values);</span>
    }

    /**
     * Returns the minimum of the entries in the specified portion of the input array,
     * or &lt;code&gt;Double.NaN&lt;/code&gt; if the designated subarray is empty.
     * &lt;p&gt;
     * Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null or
     * the array index parameters are not valid.
     * &lt;ul&gt;
     * &lt;li&gt;The result is &lt;code&gt;NaN&lt;/code&gt; iff all values are &lt;code&gt;NaN&lt;/code&gt;
     * (i.e. &lt;code&gt;NaN&lt;/code&gt; values have no impact on the value of the statistic).&lt;/li&gt;
     * &lt;li&gt;If any of the values equals &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt;,
     * the result is &lt;code&gt;Double.NEGATIVE_INFINITY.&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param values the input array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return the minimum of the values or Double.NaN if length = 0
     * @throws MathIllegalArgumentException if the array is null or the array index
     *  parameters are not valid
     */
    public static double min(final double[] values, final int begin, final int length)
        throws MathIllegalArgumentException {
<span class="fc" id="L605">        return MIN.evaluate(values, begin, length);</span>
    }

    /**
     * Returns an estimate of the &lt;code&gt;p&lt;/code&gt;th percentile of the values
     * in the &lt;code&gt;values&lt;/code&gt; array.
     * &lt;ul&gt;
     * &lt;li&gt;Returns &lt;code&gt;Double.NaN&lt;/code&gt; if &lt;code&gt;values&lt;/code&gt; has length
     *  &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;Returns (for any value of &lt;code&gt;p&lt;/code&gt;) &lt;code&gt;values[0]&lt;/code&gt;
     *  if &lt;code&gt;values&lt;/code&gt; has length &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;Throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if &lt;code&gt;values&lt;/code&gt;
     *  is null  or p is not a valid quantile value (p must be greater than 0
     *  and less than or equal to 100)&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.rank.Percentile Percentile}
     * for a description of the percentile estimation algorithm used.
     *
     * @param values input array of values
     * @param p the percentile value to compute
     * @return the percentile value or Double.NaN if the array is empty
     * @throws MathIllegalArgumentException if &lt;code&gt;values&lt;/code&gt; is null or p is invalid
     */
    public static double percentile(final double[] values, final double p) throws MathIllegalArgumentException {
<span class="fc" id="L630">        return PERCENTILE.evaluate(values,p);</span>
    }

    /**
     * Returns an estimate of the &lt;code&gt;p&lt;/code&gt;th percentile of the values
     * in the &lt;code&gt;values&lt;/code&gt; array, starting with the element in (0-based)
     * position &lt;code&gt;begin&lt;/code&gt; in the array and including &lt;code&gt;length&lt;/code&gt;
     * values.
     * &lt;ul&gt;
     * &lt;li&gt;Returns &lt;code&gt;Double.NaN&lt;/code&gt; if &lt;code&gt;length = 0&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;Returns (for any value of &lt;code&gt;p&lt;/code&gt;) &lt;code&gt;values[begin]&lt;/code&gt;
     *  if &lt;code&gt;length = 1 &lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;Throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if &lt;code&gt;values&lt;/code&gt;
     *  is null, &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;length&lt;/code&gt; is invalid, or
     *  &lt;code&gt;p&lt;/code&gt; is not a valid quantile value (p must be greater than 0
     *  and less than or equal to 100)&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * See {@link org.apache.commons.math4.stat.descriptive.rank.Percentile Percentile}
     * for a description of the percentile estimation algorithm used.
     *
     * @param values array of input values
     * @param p the percentile to compute
     * @param begin the first (0-based) element to include in the computation
     * @param length the number of array elements to include
     * @return the percentile value
     * @throws MathIllegalArgumentException if the parameters are not valid or the input array is null
     */
    public static double percentile(final double[] values, final int begin, final int length, final double p)
        throws MathIllegalArgumentException {
<span class="fc" id="L660">        return PERCENTILE.evaluate(values, begin, length, p);</span>
    }

    /**
     * Returns the sum of the (signed) differences between corresponding elements of the
     * input arrays -- i.e., sum(sample1[i] - sample2[i]).
     *
     * @param sample1  the first array
     * @param sample2  the second array
     * @return sum of paired differences
     * @throws DimensionMismatchException if the arrays do not have the same (positive) length.
     * @throws NoDataException if the sample arrays are empty.
     */
    public static double sumDifference(final double[] sample1, final double[] sample2)
        throws DimensionMismatchException, NoDataException {

<span class="fc" id="L676">        int n = sample1.length;</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">        if (n != sample2.length) {</span>
<span class="fc" id="L678">            throw new DimensionMismatchException(n, sample2.length);</span>
        }
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">        if (n &lt;= 0) {</span>
<span class="nc" id="L681">            throw new NoDataException(LocalizedFormats.INSUFFICIENT_DIMENSION);</span>
        }
<span class="fc" id="L683">        double result = 0;</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L685">            result += sample1[i] - sample2[i];</span>
        }
<span class="fc" id="L687">        return result;</span>
    }

    /**
     * Returns the mean of the (signed) differences between corresponding elements of the
     * input arrays -- i.e., sum(sample1[i] - sample2[i]) / sample1.length.
     *
     * @param sample1  the first array
     * @param sample2  the second array
     * @return mean of paired differences
     * @throws DimensionMismatchException if the arrays do not have the same (positive) length.
     * @throws NoDataException if the sample arrays are empty.
     */
    public static double meanDifference(final double[] sample1, final double[] sample2)
        throws DimensionMismatchException, NoDataException {
<span class="fc" id="L702">        return sumDifference(sample1, sample2) / sample1.length;</span>
    }

    /**
     * Returns the variance of the (signed) differences between corresponding elements of the
     * input arrays -- i.e., var(sample1[i] - sample2[i]).
     *
     * @param sample1  the first array
     * @param sample2  the second array
     * @param meanDifference   the mean difference between corresponding entries
     * @return variance of paired differences
     * @throws DimensionMismatchException if the arrays do not have the same length.
     * @throws NumberIsTooSmallException if the arrays length is less than 2.
     * @see #meanDifference(double[],double[])
     */
    public static double varianceDifference(final double[] sample1, final double[] sample2, double meanDifference)
        throws DimensionMismatchException, NumberIsTooSmallException {

<span class="fc" id="L720">        double sum1 = 0d;</span>
<span class="fc" id="L721">        double sum2 = 0d;</span>
<span class="fc" id="L722">        double diff = 0d;</span>
<span class="fc" id="L723">        int n = sample1.length;</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">        if (n != sample2.length) {</span>
<span class="fc" id="L725">            throw new DimensionMismatchException(n, sample2.length);</span>
        }
<span class="fc bfc" id="L727" title="All 2 branches covered.">        if (n &lt; 2) {</span>
<span class="fc" id="L728">            throw new NumberIsTooSmallException(n, 2, true);</span>
        }
<span class="fc bfc" id="L730" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L731">            diff = sample1[i] - sample2[i];</span>
<span class="fc" id="L732">            sum1 += (diff - meanDifference) *(diff - meanDifference);</span>
<span class="fc" id="L733">            sum2 += diff - meanDifference;</span>
        }
<span class="fc" id="L735">        return (sum1 - (sum2 * sum2 / n)) / (n - 1);</span>
    }

    /**
     * Normalize (standardize) the sample, so it is has a mean of 0 and a standard deviation of 1.
     *
     * @param sample Sample to normalize.
     * @return normalized (standardized) sample.
     * @since 2.2
     */
    public static double[] normalize(final double[] sample) {
<span class="fc" id="L746">        DescriptiveStatistics stats = new DescriptiveStatistics();</span>

        // Add the data from the series to stats
<span class="fc bfc" id="L749" title="All 2 branches covered.">        for (int i = 0; i &lt; sample.length; i++) {</span>
<span class="fc" id="L750">            stats.addValue(sample[i]);</span>
        }

        // Compute mean and standard deviation
<span class="fc" id="L754">        double mean = stats.getMean();</span>
<span class="fc" id="L755">        double standardDeviation = stats.getStandardDeviation();</span>

        // initialize the standardizedSample, which has the same length as the sample
<span class="fc" id="L758">        double[] standardizedSample = new double[sample.length];</span>

<span class="fc bfc" id="L760" title="All 2 branches covered.">        for (int i = 0; i &lt; sample.length; i++) {</span>
            // z = (x- mean)/standardDeviation
<span class="fc" id="L762">            standardizedSample[i] = (sample[i] - mean) / standardDeviation;</span>
        }
<span class="fc" id="L764">        return standardizedSample;</span>
    }

    /**
     * Returns the sample mode(s).
     * &lt;p&gt;
     * The mode is the most frequently occurring value in the sample.
     * If there is a unique value with maximum frequency, this value is returned
     * as the only element of the output array. Otherwise, the returned array
     * contains the maximum frequency elements in increasing order.
     * &lt;p&gt;
     * For example, if {@code sample} is {0, 12, 5, 6, 0, 13, 5, 17},
     * the returned array will have length two, with 0 in the first element and
     * 5 in the second.
     * &lt;p&gt;
     * NaN values are ignored when computing the mode - i.e., NaNs will never
     * appear in the output array.  If the sample includes only NaNs or has
     * length 0, an empty array is returned.
     *
     * @param sample input data
     * @return array of array of the most frequently occurring element(s) sorted in ascending order.
     * @throws MathIllegalArgumentException if the indices are invalid or the array is null
     * @since 3.3
     */
    public static double[] mode(double[] sample) throws MathIllegalArgumentException {
<span class="fc bfc" id="L789" title="All 2 branches covered.">        if (sample == null) {</span>
<span class="fc" id="L790">            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);</span>
        }
<span class="fc" id="L792">        return getMode(sample, 0, sample.length);</span>
    }

    /**
     * Returns the sample mode(s).
     * &lt;p&gt;
     * The mode is the most frequently occurring value in the sample.
     * If there is a unique value with maximum frequency, this value is returned
     * as the only element of the output array. Otherwise, the returned array
     * contains the maximum frequency elements in increasing order.
     * &lt;p&gt;
     * For example, if {@code sample} is {0, 12, 5, 6, 0, 13, 5, 17},
     * the returned array will have length two, with 0 in the first element and
     * 5 in the second.
     * &lt;p&gt;
     * NaN values are ignored when computing the mode - i.e., NaNs will never
     * appear in the output array.  If the sample includes only NaNs or has
     * length 0, an empty array is returned.
     *
     * @param sample input data
     * @param begin index (0-based) of the first array element to include
     * @param length the number of elements to include
     * @return array of array of the most frequently occurring element(s) sorted in ascending order.
     * @throws MathIllegalArgumentException if the indices are invalid or the array is null
     * @since 3.3
     */
    public static double[] mode(double[] sample, final int begin, final int length) {
<span class="nc bnc" id="L819" title="All 2 branches missed.">        if (sample == null) {</span>
<span class="nc" id="L820">            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);</span>
        }

<span class="nc bnc" id="L823" title="All 2 branches missed.">        if (begin &lt; 0) {</span>
<span class="nc" id="L824">            throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));</span>
        }

<span class="nc bnc" id="L827" title="All 2 branches missed.">        if (length &lt; 0) {</span>
<span class="nc" id="L828">            throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));</span>
        }

<span class="nc" id="L831">        return getMode(sample, begin, length);</span>
    }

    /**
     * Private helper method.
     * Assumes parameters have been validated.
     * @param values input data
     * @param begin index (0-based) of the first array element to include
     * @param length the number of elements to include
     * @return array of array of the most frequently occurring element(s) sorted in ascending order.
     */
    private static double[] getMode(double[] values, final int begin, final int length) {
        // Add the values to the frequency table
<span class="fc" id="L844">        Frequency&lt;Double&gt; freq = new Frequency&lt;&gt;();</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">        for (int i = begin; i &lt; begin + length; i++) {</span>
<span class="fc" id="L846">            final double value = values[i];</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">            if (!Double.isNaN(value)) {</span>
<span class="fc" id="L848">                freq.addValue(Double.valueOf(value));</span>
            }
        }
<span class="fc" id="L851">        List&lt;Double&gt; list = freq.getMode();</span>
        // Convert the list to an array of primitive double
<span class="fc" id="L853">        double[] modes = new double[list.size()];</span>
<span class="fc" id="L854">        int i = 0;</span>
<span class="fc bfc" id="L855" title="All 2 branches covered.">        for(Double c : list) {</span>
<span class="fc" id="L856">            modes[i++] = c.doubleValue();</span>
<span class="fc" id="L857">        }</span>
<span class="fc" id="L858">        return modes;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>