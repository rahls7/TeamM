<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PSquarePercentile.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.stat.descriptive.rank</a> &gt; <span class="el_source">PSquarePercentile.java</span></div><h1>PSquarePercentile.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.stat.descriptive.rank;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.apache.commons.math4.analysis.UnivariateFunction;
import org.apache.commons.math4.analysis.interpolation.LinearInterpolator;
import org.apache.commons.math4.analysis.interpolation.NevilleInterpolator;
import org.apache.commons.math4.analysis.interpolation.UnivariateInterpolator;
import org.apache.commons.math4.exception.InsufficientDataException;
import org.apache.commons.math4.exception.OutOfRangeException;
import org.apache.commons.math4.exception.util.LocalizedFormats;
import org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic;
import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic;
import org.apache.commons.math4.util.MathArrays;
import org.apache.commons.math4.util.MathUtils;
import org.apache.commons.numbers.core.Precision;

/**
 * A {@link StorelessUnivariateStatistic} estimating percentiles using the
 * &lt;a href=http://www.cs.wustl.edu/~jain/papers/ftp/psqr.pdf&gt;P&lt;SUP&gt;2&lt;/SUP&gt;&lt;/a&gt;
 * Algorithm as explained by &lt;a href=http://www.cse.wustl.edu/~jain/&gt;Raj
 * Jain&lt;/a&gt; and Imrich Chlamtac in
 * &lt;a href=http://www.cse.wustl.edu/~jain/papers/psqr.htm&gt;P&lt;SUP&gt;2&lt;/SUP&gt; Algorithm
 * for Dynamic Calculation of Quantiles and Histogram Without Storing
 * Observations&lt;/a&gt;.
 * &lt;p&gt;
 * Note: This implementation is not synchronized and produces an approximate
 * result. For small samples, where data can be stored and processed in memory,
 * {@link Percentile} should be used.&lt;/p&gt;
 */
public class PSquarePercentile extends AbstractStorelessUnivariateStatistic
        implements StorelessUnivariateStatistic, Serializable {

    /**
     * The maximum array size used for psquare algorithm
     */
    private static final int PSQUARE_CONSTANT = 5;

    /**
     * A Default quantile needed in case if user prefers to use default no
     * argument constructor.
     */
    private static final double DEFAULT_QUANTILE_DESIRED = 50d;

    /**
     * Serial ID
     */
    private static final long serialVersionUID = 20150412L;

    /**
     * A decimal formatter for print convenience
     */
<span class="fc" id="L77">    private static final DecimalFormat DECIMAL_FORMAT = new DecimalFormat(&quot;00.00&quot;);</span>

    /**
     * Initial list of 5 numbers corresponding to 5 markers. &lt;b&gt;NOTE:&lt;/b&gt;watch
     * out for the add methods that are overloaded
     */
<span class="fc" id="L83">    private final List&lt;Double&gt; initialFive = new FixedCapacityList&lt;&gt;(PSQUARE_CONSTANT);</span>

    /**
     * The quantile needed should be in range of 0-1. The constructor
     * {@link #PSquarePercentile(double)} ensures that passed in percentile is
     * divided by 100.
     */
    private final double quantile;

    /**
     * lastObservation is the last observation value/input sample. No need to
     * serialize
     */
    private transient double lastObservation;

    /**
     * Markers is the marker collection object which comes to effect
     * only after 5 values are inserted
     */
<span class="fc" id="L102">    private PSquareMarkers markers = null;</span>

    /**
     * Computed p value (i,e percentile value of data set hither to received)
     */
<span class="fc" id="L107">    private double pValue = Double.NaN;</span>

    /**
     * Counter to count the values/observations accepted into this data set
     */
    private long countOfObservations;

    /**
     * Constructs a PSquarePercentile with the specific percentile value.
     * @param p the percentile
     * @throws OutOfRangeException  if p is not greater than 0 and less
     * than or equal to 100
     */
<span class="fc" id="L120">    public PSquarePercentile(final double p) {</span>
<span class="fc bfc" id="L121" title="All 4 branches covered.">        if (p &gt; 100 || p &lt; 0) {</span>
<span class="fc" id="L122">            throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE, p, 0, 100);</span>
        }
<span class="fc" id="L124">        this.quantile = p / 100d;// always set it within (0,1]</span>
<span class="fc" id="L125">    }</span>

    /**
     * Default constructor that assumes a {@link #DEFAULT_QUANTILE_DESIRED
     * default quantile} needed.
     */
    PSquarePercentile() {
<span class="fc" id="L132">        this(DEFAULT_QUANTILE_DESIRED);</span>
<span class="fc" id="L133">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
<span class="fc" id="L140">        double result = getResult();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        result = Double.isNaN(result) ? 37 : result;</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        final double markersHash = markers == null ? 0 : markers.hashCode();</span>
<span class="fc" id="L143">        final double[] toHash = {result, quantile, markersHash, countOfObservations};</span>
<span class="fc" id="L144">        return Arrays.hashCode(toHash);</span>
    }

    /**
     * Returns true iff {@code o} is a {@code PSquarePercentile} returning the
     * same values as this for {@code getResult()} and {@code getN()} and also
     * having equal markers
     *
     * @param o object to compare
     * @return true if {@code o} is a {@code PSquarePercentile} with
     * equivalent internal state
     */
    @Override
    public boolean equals(Object o) {
<span class="fc" id="L158">        boolean result = false;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (this == o) {</span>
<span class="fc" id="L160">            result = true;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        } else if (o instanceof PSquarePercentile) {</span>
<span class="fc" id="L162">            PSquarePercentile that = (PSquarePercentile) o;</span>
<span class="pc bpc" id="L163" title="1 of 4 branches missed.">            boolean isNotNull = markers != null &amp;&amp; that.markers != null;</span>
<span class="pc bpc" id="L164" title="1 of 4 branches missed.">            boolean isNull = markers == null &amp;&amp; that.markers == null;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            result = isNotNull ? markers.equals(that.markers) : isNull;</span>
            // markers as in the case of first
            // five observations
<span class="pc bpc" id="L168" title="1 of 4 branches missed.">            result = result &amp;&amp; getN() == that.getN();</span>
        }
<span class="fc" id="L170">        return result;</span>
    }

    /**
     * {@inheritDoc}The internal state updated due to the new value in this
     * context is basically of the marker positions and computation of the
     * approximate quantile.
     *
     * @param observation the observation currently being added.
     */
    @Override
    public void increment(final double observation) {
        // Increment counter
<span class="fc" id="L183">        countOfObservations++;</span>

        // Store last observation
<span class="fc" id="L186">        this.lastObservation = observation;</span>

        // 0. Use Brute force for &lt;5
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (markers == null) {</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">            if (initialFive.add(observation)) {</span>
<span class="fc" id="L191">                Collections.sort(initialFive);</span>
<span class="fc" id="L192">                pValue =</span>
                        initialFive
<span class="fc" id="L194">                                .get((int) (quantile * (initialFive.size() - 1)));</span>
<span class="fc" id="L195">                return;</span>
            }
            // 1. Initialize once after 5th observation
<span class="fc" id="L198">            markers = newMarkers(initialFive, quantile);</span>
        }
        // 2. process a Data Point and return pValue
<span class="fc" id="L201">        pValue = markers.processDataPoint(observation);</span>
<span class="fc" id="L202">    }</span>

    /**
     * Returns a string containing the last observation, the current estimate
     * of the quantile and all markers.
     *
     * @return string representation of state data
     */
    @Override
    public String toString() {

<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (markers == null) {</span>
<span class="fc" id="L214">            return String.format(&quot;obs=%s pValue=%s&quot;,</span>
<span class="fc" id="L215">                    DECIMAL_FORMAT.format(lastObservation),</span>
<span class="fc" id="L216">                    DECIMAL_FORMAT.format(pValue));</span>
        } else {
<span class="nc" id="L218">            return String.format(&quot;obs=%s markers=%s&quot;,</span>
<span class="nc" id="L219">                    DECIMAL_FORMAT.format(lastObservation), markers.toString());</span>
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long getN() {
<span class="fc" id="L228">        return countOfObservations;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public StorelessUnivariateStatistic copy() {
        // multiply quantile by 100 now as anyway constructor divides it by 100
<span class="fc" id="L237">        PSquarePercentile copy = new PSquarePercentile(100d * quantile);</span>

<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (markers != null) {</span>
<span class="fc" id="L240">            copy.markers = (PSquareMarkers) markers.clone();</span>
        }
<span class="fc" id="L242">        copy.countOfObservations = countOfObservations;</span>
<span class="fc" id="L243">        copy.pValue = pValue;</span>
<span class="fc" id="L244">        copy.initialFive.clear();</span>
<span class="fc" id="L245">        copy.initialFive.addAll(initialFive);</span>
<span class="fc" id="L246">        return copy;</span>
    }

    /**
     * Returns the quantile estimated by this statistic in the range [0.0-1.0]
     *
     * @return quantile estimated by {@link #getResult()}
     */
    public double quantile() {
<span class="fc" id="L255">        return quantile;</span>
    }

    /**
     * {@inheritDoc}. This basically clears all the markers, the
     * initialFive list and sets countOfObservations to 0.
     */
    @Override
    public void clear() {
<span class="fc" id="L264">        markers = null;</span>
<span class="fc" id="L265">        initialFive.clear();</span>
<span class="fc" id="L266">        countOfObservations = 0L;</span>
<span class="fc" id="L267">        pValue = Double.NaN;</span>
<span class="fc" id="L268">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public double getResult() {
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if (Double.compare(quantile, 1d) == 0) {</span>
<span class="fc" id="L276">            pValue = maximum();</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">        } else if (Double.compare(quantile, 0d) == 0) {</span>
<span class="fc" id="L278">            pValue = minimum();</span>
        }
<span class="fc" id="L280">        return pValue;</span>
    }

    /**
     * @return maximum in the data set added to this statistic
     */
    private double maximum() {
<span class="fc" id="L287">        double val = Double.NaN;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (markers != null) {</span>
<span class="fc" id="L289">            val = markers.height(PSQUARE_CONSTANT);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        } else if (!initialFive.isEmpty()) {</span>
<span class="fc" id="L291">            val = initialFive.get(initialFive.size() - 1);</span>
        }
<span class="fc" id="L293">        return val;</span>
    }

    /**
     * @return minimum in the data set added to this statistic
     */
    private double minimum() {
<span class="fc" id="L300">        double val = Double.NaN;</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (markers != null) {</span>
<span class="fc" id="L302">            val = markers.height(1);</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">        } else if (!initialFive.isEmpty()) {</span>
<span class="fc" id="L304">            val = initialFive.get(0);</span>
        }
<span class="fc" id="L306">        return val;</span>
    }

    /**
     * Markers is an encapsulation of the five markers/buckets as indicated in
     * the original works.
     */
    private static class Markers implements PSquareMarkers, Serializable {
        /**
         * Serial version id
         */
        private static final long serialVersionUID = 1L;

        /** Low marker index */
        private static final int LOW = 2;

        /** High marker index */
        private static final int HIGH = 4;

        /**
         * Array of 5+1 Markers (The first marker is dummy just so we
         * can match the rest of indexes [1-5] indicated in the original works
         * which follows unit based index)
         */
        private final Marker[] markerArray;

        /**
         * Kth cell belonging to [1-5] of the markerArray. No need for
         * this to be serialized
         */
<span class="fc" id="L336">        private transient int k = -1;</span>

        /**
         * Constructor
         *
         * @param theMarkerArray marker array to be used
         */
<span class="fc" id="L343">        private Markers(final Marker[] theMarkerArray) {</span>
<span class="fc" id="L344">            MathUtils.checkNotNull(theMarkerArray);</span>
<span class="fc" id="L345">            markerArray = theMarkerArray;</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">            for (int i = 1; i &lt; PSQUARE_CONSTANT; i++) {</span>
<span class="fc" id="L347">                markerArray[i].previous(markerArray[i - 1])</span>
<span class="fc" id="L348">                        .next(markerArray[i + 1]).index(i);</span>
            }
<span class="fc" id="L350">            markerArray[0].previous(markerArray[0]).next(markerArray[1])</span>
<span class="fc" id="L351">                    .index(0);</span>
<span class="fc" id="L352">            markerArray[5].previous(markerArray[4]).next(markerArray[5])</span>
<span class="fc" id="L353">                    .index(5);</span>
<span class="fc" id="L354">        }</span>

        /**
         * Constructor
         *
         * @param initialFive elements required to build Marker
         * @param p quantile required to be computed
         */
        private Markers(final List&lt;Double&gt; initialFive, final double p) {
<span class="fc" id="L363">            this(createMarkerArray(initialFive, p));</span>
<span class="fc" id="L364">        }</span>

        /**
         * Creates a marker array using initial five elements and a quantile
         *
         * @param initialFive list of initial five elements
         * @param p the pth quantile
         * @return Marker array
         */
        private static Marker[] createMarkerArray(
                final List&lt;Double&gt; initialFive, final double p) {
<span class="fc bfc" id="L375" title="All 2 branches covered.">            final int countObserved =</span>
<span class="fc" id="L376">                    initialFive == null ? -1 : initialFive.size();</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">            if (countObserved &lt; PSQUARE_CONSTANT) {</span>
<span class="fc" id="L378">                throw new InsufficientDataException(</span>
                        LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,
<span class="fc" id="L380">                        countObserved, PSQUARE_CONSTANT);</span>
            }
<span class="fc" id="L382">            Collections.sort(initialFive);</span>
<span class="fc" id="L383">            return new Marker[] {</span>
                    new Marker(),// Null Marker
<span class="fc" id="L385">                    new Marker(initialFive.get(0), 1, 0, 1),</span>
<span class="fc" id="L386">                    new Marker(initialFive.get(1), 1 + 2 * p, p / 2, 2),</span>
<span class="fc" id="L387">                    new Marker(initialFive.get(2), 1 + 4 * p, p, 3),</span>
<span class="fc" id="L388">                    new Marker(initialFive.get(3), 3 + 2 * p, (1 + p) / 2, 4),</span>
<span class="fc" id="L389">                    new Marker(initialFive.get(4), 5, 1, 5) };</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public int hashCode() {
<span class="fc" id="L397">            return Arrays.deepHashCode(markerArray);</span>
        }

        /**
         * {@inheritDoc}.This equals method basically checks for marker array to
         * be deep equals.
         *
         * @param o is the other object
         * @return true if the object compares with this object are equivalent
         */
        @Override
        public boolean equals(Object o) {
<span class="fc" id="L409">            boolean result = false;</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">            if (this == o) {</span>
<span class="fc" id="L411">                result = true;</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">            } else if (o instanceof Markers) {</span>
<span class="fc" id="L413">                Markers that = (Markers) o;</span>
<span class="fc" id="L414">                result = Arrays.deepEquals(markerArray, that.markerArray);</span>
            }
<span class="fc" id="L416">            return result;</span>
        }

        /**
         * Process a data point
         *
         * @param inputDataPoint is the data point passed
         * @return computed percentile
         */
        @Override
        public double processDataPoint(final double inputDataPoint) {

            // 1. Find cell and update minima and maxima
<span class="fc" id="L429">            final int kthCell = findCellAndUpdateMinMax(inputDataPoint);</span>

            // 2. Increment positions
<span class="fc" id="L432">            incrementPositions(1, kthCell + 1, 5);</span>

            // 2a. Update desired position with increments
<span class="fc" id="L435">            updateDesiredPositions();</span>

            // 3. Adjust heights of m[2-4] if necessary
<span class="fc" id="L438">            adjustHeightsOfMarkers();</span>

            // 4. Return percentile
<span class="fc" id="L441">            return getPercentileValue();</span>
        }

        /**
         * Returns the percentile computed thus far.
         *
         * @return height of mid point marker
         */
        @Override
        public double getPercentileValue() {
<span class="fc" id="L451">            return height(3);</span>
        }

        /**
         * Finds the cell where the input observation / value fits.
         *
         * @param observation the input value to be checked for
         * @return kth cell (of the markers ranging from 1-5) where observed
         *         sample fits
         */
        private int findCellAndUpdateMinMax(final double observation) {
<span class="fc" id="L462">            k = -1;</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">            if (observation &lt; height(1)) {</span>
<span class="fc" id="L464">                markerArray[1].markerHeight = observation;</span>
<span class="fc" id="L465">                k = 1;</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">            } else if (observation &lt; height(2)) {</span>
<span class="fc" id="L467">                k = 1;</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">            } else if (observation &lt; height(3)) {</span>
<span class="fc" id="L469">                k = 2;</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">            } else if (observation &lt; height(4)) {</span>
<span class="fc" id="L471">                k = 3;</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">            } else if (observation &lt;= height(5)) {</span>
<span class="fc" id="L473">                k = 4;</span>
            } else {
<span class="fc" id="L475">                markerArray[5].markerHeight = observation;</span>
<span class="fc" id="L476">                k = 4;</span>
            }
<span class="fc" id="L478">            return k;</span>
        }

        /**
         * Adjust marker heights by setting quantile estimates to middle markers.
         */
        private void adjustHeightsOfMarkers() {
<span class="fc bfc" id="L485" title="All 2 branches covered.">            for (int i = LOW; i &lt;= HIGH; i++) {</span>
<span class="fc" id="L486">                estimate(i);</span>
            }
<span class="fc" id="L488">        }</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public double estimate(final int index) {
<span class="fc bfc" id="L495" title="All 4 branches covered.">            if (index &lt; LOW || index &gt; HIGH) {</span>
<span class="fc" id="L496">                throw new OutOfRangeException(index, LOW, HIGH);</span>
            }
<span class="fc" id="L498">            return markerArray[index].estimate();</span>
        }

        /**
         * Increment positions by d. Refer to algorithm paper for the
         * definition of d.
         *
         * @param d The increment value for the position
         * @param startIndex start index of the marker array
         * @param endIndex end index of the marker array
         */
        private void incrementPositions(final int d, final int startIndex,
                final int endIndex) {
<span class="fc bfc" id="L511" title="All 2 branches covered.">            for (int i = startIndex; i &lt;= endIndex; i++) {</span>
<span class="fc" id="L512">                markerArray[i].incrementPosition(d);</span>
            }
<span class="fc" id="L514">        }</span>

        /**
         * Desired positions incremented by bucket width. The bucket width is
         * basically the desired increments.
         */
        private void updateDesiredPositions() {
<span class="fc bfc" id="L521" title="All 2 branches covered.">            for (int i = 1; i &lt; markerArray.length; i++) {</span>
<span class="fc" id="L522">                markerArray[i].updateDesiredPosition();</span>
            }
<span class="fc" id="L524">        }</span>

        /**
         * Sets previous and next markers after default read is done.
         *
         * @param anInputStream the input stream to be deserialized
         * @throws ClassNotFoundException thrown when a desired class not found
         * @throws IOException thrown due to any io errors
         */
        private void readObject(ObjectInputStream anInputStream)
                throws ClassNotFoundException, IOException {
            // always perform the default de-serialization first
<span class="fc" id="L536">            anInputStream.defaultReadObject();</span>
            // Build links
<span class="fc bfc" id="L538" title="All 2 branches covered.">            for (int i = 1; i &lt; PSQUARE_CONSTANT; i++) {</span>
<span class="fc" id="L539">                markerArray[i].previous(markerArray[i - 1]).next(markerArray[i + 1]).index(i);</span>
            }
<span class="fc" id="L541">            markerArray[0].previous(markerArray[0]).next(markerArray[1]).index(0);</span>
<span class="fc" id="L542">            markerArray[5].previous(markerArray[4]).next(markerArray[5]).index(5);</span>
<span class="fc" id="L543">        }</span>

        /**
         * Return marker height given index
         *
         * @param markerIndex index of marker within (1,6)
         * @return marker height
         */
        @Override
        public double height(final int markerIndex) {
<span class="fc bfc" id="L553" title="All 4 branches covered.">            if (markerIndex &gt;= markerArray.length || markerIndex &lt;= 0) {</span>
<span class="fc" id="L554">                throw new OutOfRangeException(markerIndex, 1, markerArray.length);</span>
            }
<span class="fc" id="L556">            return markerArray[markerIndex].markerHeight;</span>
        }

        /**
         * {@inheritDoc}.Clone Markers
         *
         * @return cloned object
         */
        @Override
        public Object clone() {
<span class="fc" id="L566">            return new Markers(new Marker[] { new Marker(),</span>
<span class="fc" id="L567">                    (Marker) markerArray[1].clone(),</span>
<span class="fc" id="L568">                    (Marker) markerArray[2].clone(),</span>
<span class="fc" id="L569">                    (Marker) markerArray[3].clone(),</span>
<span class="fc" id="L570">                    (Marker) markerArray[4].clone(),</span>
<span class="fc" id="L571">                    (Marker) markerArray[5].clone() });</span>

        }

        /**
         * Returns string representation of the Marker array.
         *
         * @return Markers as a string
         */
        @Override
        public String toString() {
<span class="nc" id="L582">            return String.format(&quot;m1=[%s],m2=[%s],m3=[%s],m4=[%s],m5=[%s]&quot;,</span>
<span class="nc" id="L583">                    markerArray[1].toString(), markerArray[2].toString(),</span>
<span class="nc" id="L584">                    markerArray[3].toString(), markerArray[4].toString(),</span>
<span class="nc" id="L585">                    markerArray[5].toString());</span>
        }

    }

    /**
     * The class modeling the attributes of the marker of the P-square algorithm
     */
    private static class Marker implements Serializable, Cloneable {

        /**
         * Serial Version ID
         */
        private static final long serialVersionUID = -3575879478288538431L;

        /**
         * The marker index which is just a serial number for the marker in the
         * marker array of 5+1.
         */
        private int index;

        /**
         * The integral marker position. Refer to the variable n in the original
         * works.
         */
        private double intMarkerPosition;

        /**
         * Desired marker position. Refer to the variable n' in the original
         * works.
         */
        private double desiredMarkerPosition;

        /**
         * Marker height or the quantile. Refer to the variable q in the
         * original works.
         */
        private double markerHeight;

        /**
         * Desired marker increment. Refer to the variable dn' in the original
         * works.
         */
        private double desiredMarkerIncrement;

        /**
         * Next and previous markers for easy linked navigation in loops. this
         * is not serialized as they can be rebuilt during deserialization.
         */
        private transient Marker next;

        /**
         * The previous marker links
         */
        private transient Marker previous;

        /**
         * Nonlinear interpolator
         */
<span class="fc" id="L644">        private final UnivariateInterpolator nonLinear = new NevilleInterpolator();</span>

        /**
         * Linear interpolator which is not serializable
         */
<span class="fc" id="L649">        private transient UnivariateInterpolator linear = new LinearInterpolator();</span>

        /**
         * Default constructor
         */
<span class="fc" id="L654">        private Marker() {</span>
<span class="fc" id="L655">            this.next = this.previous = this;</span>
<span class="fc" id="L656">        }</span>

        /**
         * Constructor of the marker with parameters
         *
         * @param heightOfMarker represent the quantile value
         * @param makerPositionDesired represent the desired marker position
         * @param markerPositionIncrement represent increments for position
         * @param markerPositionNumber represent the position number of marker
         */
        private Marker(double heightOfMarker, double makerPositionDesired,
                double markerPositionIncrement, double markerPositionNumber) {
<span class="fc" id="L668">            this();</span>
<span class="fc" id="L669">            this.markerHeight = heightOfMarker;</span>
<span class="fc" id="L670">            this.desiredMarkerPosition = makerPositionDesired;</span>
<span class="fc" id="L671">            this.desiredMarkerIncrement = markerPositionIncrement;</span>
<span class="fc" id="L672">            this.intMarkerPosition = markerPositionNumber;</span>
<span class="fc" id="L673">        }</span>

        /**
         * Sets the previous marker.
         *
         * @param previousMarker the previous marker to the current marker in
         *            the array of markers
         * @return this instance
         */
        private Marker previous(final Marker previousMarker) {
<span class="fc" id="L683">            MathUtils.checkNotNull(previousMarker);</span>
<span class="fc" id="L684">            this.previous = previousMarker;</span>
<span class="fc" id="L685">            return this;</span>
        }

        /**
         * Sets the next marker.
         *
         * @param nextMarker the next marker to the current marker in the array
         *            of markers
         * @return this instance
         */
        private Marker next(final Marker nextMarker) {
<span class="fc" id="L696">            MathUtils.checkNotNull(nextMarker);</span>
<span class="fc" id="L697">            this.next = nextMarker;</span>
<span class="fc" id="L698">            return this;</span>
        }

        /**
         * Sets the index of the marker.
         *
         * @param indexOfMarker the array index of the marker in marker array
         * @return this instance
         */
        private Marker index(final int indexOfMarker) {
<span class="fc" id="L708">            this.index = indexOfMarker;</span>
<span class="fc" id="L709">            return this;</span>
        }

        /**
         * Update desired Position with increment.
         */
        private void updateDesiredPosition() {
<span class="fc" id="L716">            desiredMarkerPosition += desiredMarkerIncrement;</span>
<span class="fc" id="L717">        }</span>

        /**
         * Increment Position by d.
         *
         * @param d a delta value to increment
         */
        private void incrementPosition(final int d) {
<span class="fc" id="L725">            intMarkerPosition += d;</span>
<span class="fc" id="L726">        }</span>

        /**
         * Difference between desired and actual position
         *
         * @return difference between desired and actual position
         */
        private double difference() {
<span class="fc" id="L734">            return desiredMarkerPosition - intMarkerPosition;</span>
        }

        /**
         * Estimate the quantile for the current marker.
         *
         * @return estimated quantile
         */
        private double estimate() {
<span class="fc" id="L743">            final double di = difference();</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">            final boolean isNextHigher =</span>
                    next.intMarkerPosition - intMarkerPosition &gt; 1;
<span class="fc bfc" id="L746" title="All 2 branches covered.">            final boolean isPreviousLower =</span>
                    previous.intMarkerPosition - intMarkerPosition &lt; -1;

<span class="fc bfc" id="L749" title="All 8 branches covered.">            if (di &gt;= 1 &amp;&amp; isNextHigher || di &lt;= -1 &amp;&amp; isPreviousLower) {</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">                final int d = di &gt;= 0 ? 1 : -1;</span>
<span class="fc" id="L751">                final double[] xval =</span>
                        new double[] { previous.intMarkerPosition,
                                intMarkerPosition, next.intMarkerPosition };
<span class="fc" id="L754">                final double[] yval =</span>
                        new double[] { previous.markerHeight, markerHeight,
                                next.markerHeight };
<span class="fc" id="L757">                final double xD = intMarkerPosition + d;</span>

<span class="fc" id="L759">                UnivariateFunction univariateFunction =</span>
<span class="fc" id="L760">                        nonLinear.interpolate(xval, yval);</span>
<span class="fc" id="L761">                markerHeight = univariateFunction.value(xD);</span>

                // If parabolic estimate is bad then turn linear
<span class="fc bfc" id="L764" title="All 2 branches covered.">                if (isEstimateBad(yval, markerHeight)) {</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">                    int delta = xD - xval[1] &gt; 0 ? 1 : -1;</span>
<span class="fc" id="L766">                    final double[] xBad =</span>
                            new double[] { xval[1], xval[1 + delta] };
<span class="fc" id="L768">                    final double[] yBad =</span>
                            new double[] { yval[1], yval[1 + delta] };
<span class="fc" id="L770">                    MathArrays.sortInPlace(xBad, yBad);// since d can be +/- 1</span>
<span class="fc" id="L771">                    univariateFunction = linear.interpolate(xBad, yBad);</span>
<span class="fc" id="L772">                    markerHeight = univariateFunction.value(xD);</span>
                }
<span class="fc" id="L774">                incrementPosition(d);</span>
            }
<span class="fc" id="L776">            return markerHeight;</span>
        }

        /**
         * Check if parabolic/nonlinear estimate is bad by checking if the
         * ordinate found is beyond the y[0] and y[2].
         *
         * @param y the array to get the bounds
         * @param yD the estimate
         * @return true if yD is a bad estimate
         */
        private boolean isEstimateBad(final double[] y, final double yD) {
<span class="fc bfc" id="L788" title="All 4 branches covered.">            return yD &lt;= y[0] || yD &gt;= y[2];</span>
        }

        /**
         * {@inheritDoc}&lt;i&gt;This equals method checks for marker attributes and
         * as well checks if navigation pointers (next and previous) are the same
         * between this and passed in object&lt;/i&gt;
         *
         * @param o Other object
         * @return true if this equals passed in other object o
         */
        @Override
        public boolean equals(Object o) {
<span class="fc" id="L801">            boolean result = false;</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">            if (this == o) {</span>
<span class="nc" id="L803">                result = true;</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">            } else if (o instanceof Marker) {</span>
<span class="fc" id="L805">                Marker that = (Marker) o;</span>

<span class="fc bfc" id="L807" title="All 2 branches covered.">                result = Double.compare(markerHeight, that.markerHeight) == 0;</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">                result =</span>
                        result &amp;&amp;
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">                                Double.compare(intMarkerPosition,</span>
                                        that.intMarkerPosition) == 0;
<span class="fc bfc" id="L812" title="All 2 branches covered.">                result =</span>
                        result &amp;&amp;
<span class="fc bfc" id="L814" title="All 2 branches covered.">                                Double.compare(desiredMarkerPosition,</span>
                                        that.desiredMarkerPosition) == 0;
<span class="fc bfc" id="L816" title="All 2 branches covered.">                result =</span>
                        result &amp;&amp;
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">                                Double.compare(desiredMarkerIncrement,</span>
                                        that.desiredMarkerIncrement) == 0;

<span class="pc bpc" id="L821" title="1 of 4 branches missed.">                result = result &amp;&amp; next.index == that.next.index;</span>
<span class="pc bpc" id="L822" title="1 of 4 branches missed.">                result = result &amp;&amp; previous.index == that.previous.index;</span>
            }
<span class="fc" id="L824">            return result;</span>
        }

        /** {@inheritDoc} */
        @Override
        public int hashCode() {
<span class="fc" id="L830">            return Arrays.hashCode(new double[] {markerHeight, intMarkerPosition,</span>
                desiredMarkerIncrement, desiredMarkerPosition, previous.index, next.index});
        }

        /**
         * Read Object to deserialize.
         *
         * @param anInstream Stream Object data
         * @throws IOException thrown for IO Errors
         * @throws ClassNotFoundException thrown for class not being found
         */
        private void readObject(ObjectInputStream anInstream)
                throws ClassNotFoundException, IOException {
<span class="fc" id="L843">            anInstream.defaultReadObject();</span>
<span class="fc" id="L844">            previous=next=this;</span>
<span class="fc" id="L845">            linear = new LinearInterpolator();</span>
<span class="fc" id="L846">        }</span>

        /**
         * Clone this instance.
         *
         * @return cloned marker
         */
        @Override
        public Object clone() {
<span class="fc" id="L855">            return new Marker(markerHeight, desiredMarkerPosition, desiredMarkerIncrement, intMarkerPosition);</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L863">            return String.format(</span>
                    &quot;index=%.0f,n=%.0f,np=%.2f,q=%.2f,dn=%.2f,prev=%d,next=%d&quot;,
<span class="nc" id="L865">                    (double) index, Precision.round(intMarkerPosition, 0),</span>
<span class="nc" id="L866">                    Precision.round(desiredMarkerPosition, 2),</span>
<span class="nc" id="L867">                    Precision.round(markerHeight, 2),</span>
<span class="nc" id="L868">                    Precision.round(desiredMarkerIncrement, 2), previous.index,</span>
<span class="nc" id="L869">                    next.index);</span>
        }
    }

    /**
     * A simple fixed capacity list that has an upper bound to growth.
     * Once its capacity is reached, {@code add} is a no-op, returning
     * {@code false}.
     *
     * @param &lt;E&gt; type for fixed capacity list
     */
    private static class FixedCapacityList&lt;E&gt; extends ArrayList&lt;E&gt; implements Serializable {

        /**
         * Serialization Version Id
         */
        private static final long serialVersionUID = 2283952083075725479L;
        /**
         * Capacity of the list
         */
        private final int capacity;

        /**
         * This constructor constructs the list with given capacity and as well
         * as stores the capacity
         *
         * @param fixedCapacity the capacity to be fixed for this list
         */
        FixedCapacityList(final int fixedCapacity) {
<span class="fc" id="L898">            super(fixedCapacity);</span>
<span class="fc" id="L899">            this.capacity = fixedCapacity;</span>
<span class="fc" id="L900">        }</span>

        /**
         * {@inheritDoc} In addition it checks if the {@link #size()} returns a
         * size that is within capacity and if true it adds; otherwise the list
         * contents are unchanged and {@code false} is returned.
         *
         * @return true if addition is successful and false otherwise
         */
        @Override
        public boolean add(final E e) {
<span class="fc bfc" id="L911" title="All 2 branches covered.">            return size() &lt; capacity ? super.add(e) : false;</span>
        }

        /**
         * {@inheritDoc} In addition it checks if the sum of Collection size and
         * this instance's {@link #size()} returns a value that is within
         * capacity and if true it adds the collection; otherwise the list
         * contents are unchanged and {@code false} is returned.
         *
         * @return true if addition is successful and false otherwise
         */
        @Override
        public boolean addAll(Collection&lt;? extends E&gt; collection) {
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">            boolean isCollectionLess =</span>
                    collection != null &amp;&amp;
<span class="pc bpc" id="L926" title="1 of 2 branches missed.">                            collection.size() + size() &lt;= capacity;</span>
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">            return isCollectionLess ? super.addAll(collection) : false;</span>
        }
    }

    /**
     * A creation method to build Markers
     *
     * @param initialFive list of initial five elements
     * @param p the quantile desired
     * @return an instance of PSquareMarkers
     */
    public static PSquareMarkers newMarkers(final List&lt;Double&gt; initialFive, final double p) {
<span class="fc" id="L939">        return new Markers(initialFive, p);</span>
    }

    /**
     * An interface that encapsulates abstractions of the
     * P-square algorithm markers as is explained in the original works. This
     * interface is exposed with protected access to help in testability.
     */
    protected interface PSquareMarkers extends Cloneable {
        /**
         * Returns Percentile value computed thus far.
         *
         * @return percentile
         */
        double getPercentileValue();

        /**
         * A clone function to clone the current instance. It's created as an
         * interface method as well for convenience though Cloneable is just a
         * marker interface.
         *
         * @return clone of this instance
         */
        Object clone();

        /**
         * Returns the marker height (or percentile) of a given marker index.
         *
         * @param markerIndex is the index of marker in the marker array
         * @return percentile value of the marker index passed
         * @throws OutOfRangeException in case the index is not within [1-5]
         */
        double height(final int markerIndex);

        /**
         * Process a data point by moving the marker heights based on estimator.
         *
         * @param inputDataPoint is the data point passed
         * @return computed percentile
         */
        double processDataPoint(final double inputDataPoint);

        /**
         * An Estimate of the percentile value of a given Marker
         *
         * @param index the marker's index in the array of markers
         * @return percentile estimate
         * @throws OutOfRangeException in case if index is not within [1-5]
         */
        double estimate(final int index);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>