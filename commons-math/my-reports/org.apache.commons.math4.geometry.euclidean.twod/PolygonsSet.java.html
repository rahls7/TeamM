<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PolygonsSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.geometry.euclidean.twod</a> &gt; <span class="el_source">PolygonsSet.java</span></div><h1>PolygonsSet.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.geometry.euclidean.twod;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.commons.math4.geometry.Point;
import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
import org.apache.commons.math4.geometry.euclidean.oned.Interval;
import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
import org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D;
import org.apache.commons.math4.geometry.partitioning.AbstractRegion;
import org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane;
import org.apache.commons.math4.geometry.partitioning.BSPTree;
import org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor;
import org.apache.commons.math4.geometry.partitioning.BoundaryAttribute;
import org.apache.commons.math4.geometry.partitioning.Hyperplane;
import org.apache.commons.math4.geometry.partitioning.Side;
import org.apache.commons.math4.geometry.partitioning.SubHyperplane;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.numbers.core.Precision;

/** This class represents a 2D region: a set of polygons.
 * @since 3.0
 */
public class PolygonsSet extends AbstractRegion&lt;Euclidean2D, Euclidean1D&gt; {

    /** Vertices organized as boundary loops. */
    private Cartesian2D[][] vertices;

    /** Build a polygons set representing the whole plane.
     * @param tolerance tolerance below which points are considered identical
     * @since 3.3
     */
    public PolygonsSet(final double tolerance) {
<span class="fc" id="L52">        super(tolerance);</span>
<span class="fc" id="L53">    }</span>

    /** Build a polygons set from a BSP tree.
     * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a
     * {@code Boolean} attribute representing the inside status of
     * the corresponding cell (true for inside cells, false for outside
     * cells). In order to avoid building too many small objects, it is
     * recommended to use the predefined constants
     * {@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;
     * &lt;p&gt;
     * This constructor is aimed at expert use, as building the tree may
     * be a difficult task. It is not intended for general use and for
     * performances reasons does not check thoroughly its input, as this would
     * require walking the full tree each time. Failing to provide a tree with
     * the proper attributes, &lt;em&gt;will&lt;/em&gt; therefore generate problems like
     * {@link NullPointerException} or {@link ClassCastException} only later on.
     * This limitation is known and explains why this constructor is for expert
     * use only. The caller does have the responsibility to provided correct arguments.
     * &lt;/p&gt;
     * @param tree inside/outside BSP tree representing the region
     * @param tolerance tolerance below which points are considered identical
     * @since 3.3
     */
    public PolygonsSet(final BSPTree&lt;Euclidean2D&gt; tree, final double tolerance) {
<span class="fc" id="L77">        super(tree, tolerance);</span>
<span class="fc" id="L78">    }</span>

    /** Build a polygons set from a Boundary REPresentation (B-rep).
     * &lt;p&gt;The boundary is provided as a collection of {@link
     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
     * interior part of the region on its minus side and the exterior on
     * its plus side.&lt;/p&gt;
     * &lt;p&gt;The boundary elements can be in any order, and can form
     * several non-connected sets (like for example polygons with holes
     * or a set of disjoint polygons considered as a whole). In
     * fact, the elements do not even need to be connected together
     * (their topological connections are not used here). However, if the
     * boundary does not really separate an inside open from an outside
     * open (open having here its topological meaning), then subsequent
     * calls to the {@link
     * org.apache.commons.math4.geometry.partitioning.Region#checkPoint(org.apache.commons.math4.geometry.Point)
     * checkPoint} method will not be meaningful anymore.&lt;/p&gt;
     * &lt;p&gt;If the boundary is empty, the region will represent the whole
     * space.&lt;/p&gt;
     * @param boundary collection of boundary elements, as a
     * collection of {@link SubHyperplane SubHyperplane} objects
     * @param tolerance tolerance below which points are considered identical
     * @since 3.3
     */
    public PolygonsSet(final Collection&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; boundary, final double tolerance) {
<span class="fc" id="L103">        super(boundary, tolerance);</span>
<span class="fc" id="L104">    }</span>

    /** Build a parallellepipedic box.
     * @param xMin low bound along the x direction
     * @param xMax high bound along the x direction
     * @param yMin low bound along the y direction
     * @param yMax high bound along the y direction
     * @param tolerance tolerance below which points are considered identical
     * @since 3.3
     */
    public PolygonsSet(final double xMin, final double xMax,
                       final double yMin, final double yMax,
                       final double tolerance) {
<span class="fc" id="L117">        super(boxBoundary(xMin, xMax, yMin, yMax, tolerance), tolerance);</span>
<span class="fc" id="L118">    }</span>

    /** Build a polygon from a simple list of vertices.
     * &lt;p&gt;The boundary is provided as a list of points considering to
     * represent the vertices of a simple loop. The interior part of the
     * region is on the left side of this path and the exterior is on its
     * right side.&lt;/p&gt;
     * &lt;p&gt;This constructor does not handle polygons with a boundary
     * forming several disconnected paths (such as polygons with holes).&lt;/p&gt;
     * &lt;p&gt;For cases where this simple constructor applies, it is expected to
     * be numerically more robust than the {@link #PolygonsSet(Collection,double) general
     * constructor} using {@link SubHyperplane subhyperplanes}.&lt;/p&gt;
     * &lt;p&gt;If the list is empty, the region will represent the whole
     * space.&lt;/p&gt;
     * &lt;p&gt;
     * Polygons with thin pikes or dents are inherently difficult to handle because
     * they involve lines with almost opposite directions at some vertices. Polygons
     * whose vertices come from some physical measurement with noise are also
     * difficult because an edge that should be straight may be broken in lots of
     * different pieces with almost equal directions. In both cases, computing the
     * lines intersections is not numerically robust due to the almost 0 or almost
     * &amp;pi; angle. Such cases need to carefully adjust the {@code hyperplaneThickness}
     * parameter. A too small value would often lead to completely wrong polygons
     * with large area wrongly identified as inside or outside. Large values are
     * often much safer. As a rule of thumb, a value slightly below the size of the
     * most accurate detail needed is a good value for the {@code hyperplaneThickness}
     * parameter.
     * &lt;/p&gt;
     * @param hyperplaneThickness tolerance below which points are considered to
     * belong to the hyperplane (which is therefore more a slab)
     * @param vertices vertices of the simple loop boundary
     */
    public PolygonsSet(final double hyperplaneThickness, final Cartesian2D ... vertices) {
<span class="fc" id="L151">        super(verticesToTree(hyperplaneThickness, vertices), hyperplaneThickness);</span>
<span class="fc" id="L152">    }</span>

    /** Create a list of hyperplanes representing the boundary of a box.
     * @param xMin low bound along the x direction
     * @param xMax high bound along the x direction
     * @param yMin low bound along the y direction
     * @param yMax high bound along the y direction
     * @param tolerance tolerance below which points are considered identical
     * @return boundary of the box
     */
    private static Line[] boxBoundary(final double xMin, final double xMax,
                                      final double yMin, final double yMax,
                                      final double tolerance) {
<span class="pc bpc" id="L165" title="1 of 4 branches missed.">        if ((xMin &gt;= xMax - tolerance) || (yMin &gt;= yMax - tolerance)) {</span>
            // too thin box, build an empty polygons set
<span class="fc" id="L167">            return null;</span>
        }
<span class="fc" id="L169">        final Cartesian2D minMin = new Cartesian2D(xMin, yMin);</span>
<span class="fc" id="L170">        final Cartesian2D minMax = new Cartesian2D(xMin, yMax);</span>
<span class="fc" id="L171">        final Cartesian2D maxMin = new Cartesian2D(xMax, yMin);</span>
<span class="fc" id="L172">        final Cartesian2D maxMax = new Cartesian2D(xMax, yMax);</span>
<span class="fc" id="L173">        return new Line[] {</span>
            new Line(minMin, maxMin, tolerance),
            new Line(maxMin, maxMax, tolerance),
            new Line(maxMax, minMax, tolerance),
            new Line(minMax, minMin, tolerance)
        };
    }

    /** Build the BSP tree of a polygons set from a simple list of vertices.
     * &lt;p&gt;The boundary is provided as a list of points considering to
     * represent the vertices of a simple loop. The interior part of the
     * region is on the left side of this path and the exterior is on its
     * right side.&lt;/p&gt;
     * &lt;p&gt;This constructor does not handle polygons with a boundary
     * forming several disconnected paths (such as polygons with holes).&lt;/p&gt;
     * &lt;p&gt;For cases where this simple constructor applies, it is expected to
     * be numerically more robust than the {@link #PolygonsSet(Collection,double) general
     * constructor} using {@link SubHyperplane subhyperplanes}.&lt;/p&gt;
     * @param hyperplaneThickness tolerance below which points are consider to
     * belong to the hyperplane (which is therefore more a slab)
     * @param vertices vertices of the simple loop boundary
     * @return the BSP tree of the input vertices
     */
    private static BSPTree&lt;Euclidean2D&gt; verticesToTree(final double hyperplaneThickness,
                                                       final Cartesian2D ... vertices) {

<span class="fc" id="L199">        final int n = vertices.length;</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (n == 0) {</span>
            // the tree represents the whole space
<span class="nc" id="L202">            return new BSPTree&lt;&gt;(Boolean.TRUE);</span>
        }

        // build the vertices
<span class="fc" id="L206">        final Vertex[] vArray = new Vertex[n];</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L208">            vArray[i] = new Vertex(vertices[i]);</span>
        }

        // build the edges
<span class="fc" id="L212">        List&lt;Edge&gt; edges = new ArrayList&lt;&gt;(n);</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>

            // get the endpoints of the edge
<span class="fc" id="L216">            final Vertex start = vArray[i];</span>
<span class="fc" id="L217">            final Vertex end   = vArray[(i + 1) % n];</span>

            // get the line supporting the edge, taking care not to recreate it
            // if it was already created earlier due to another edge being aligned
            // with the current one
<span class="fc" id="L222">            Line line = start.sharedLineWith(end);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (line == null) {</span>
<span class="fc" id="L224">                line = new Line(start.getLocation(), end.getLocation(), hyperplaneThickness);</span>
            }

            // create the edge and store it
<span class="fc" id="L228">            edges.add(new Edge(start, end, line));</span>

            // check if another vertex also happens to be on this line
<span class="fc bfc" id="L231" title="All 2 branches covered.">            for (final Vertex vertex : vArray) {</span>
<span class="fc bfc" id="L232" title="All 4 branches covered.">                if (vertex != start &amp;&amp; vertex != end &amp;&amp;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">                    FastMath.abs(line.getOffset((Point&lt;Euclidean2D&gt;) vertex.getLocation())) &lt;= hyperplaneThickness) {</span>
<span class="fc" id="L234">                    vertex.bindWith(line);</span>
                }
            }

        }

        // build the tree top-down
<span class="fc" id="L241">        final BSPTree&lt;Euclidean2D&gt; tree = new BSPTree&lt;&gt;();</span>
<span class="fc" id="L242">        insertEdges(hyperplaneThickness, tree, edges);</span>

<span class="fc" id="L244">        return tree;</span>

    }

    /** Recursively build a tree by inserting cut sub-hyperplanes.
     * @param hyperplaneThickness tolerance below which points are consider to
     * belong to the hyperplane (which is therefore more a slab)
     * @param node current tree node (it is a leaf node at the beginning
     * of the call)
     * @param edges list of edges to insert in the cell defined by this node
     * (excluding edges not belonging to the cell defined by this node)
     */
    private static void insertEdges(final double hyperplaneThickness,
                                    final BSPTree&lt;Euclidean2D&gt; node,
                                    final List&lt;Edge&gt; edges) {

        // find an edge with an hyperplane that can be inserted in the node
<span class="fc" id="L261">        int index = 0;</span>
<span class="fc" id="L262">        Edge inserted =null;</span>
<span class="pc bpc" id="L263" title="1 of 4 branches missed.">        while (inserted == null &amp;&amp; index &lt; edges.size()) {</span>
<span class="fc" id="L264">            inserted = edges.get(index++);</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">            if (inserted.getNode() == null) {</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">                if (node.insertCut(inserted.getLine())) {</span>
<span class="fc" id="L267">                    inserted.setNode(node);</span>
                } else {
<span class="nc" id="L269">                    inserted = null;</span>
                }
            } else {
<span class="nc" id="L272">                inserted = null;</span>
            }
        }

<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        if (inserted == null) {</span>
            // no suitable edge was found, the node remains a leaf node
            // we need to set its inside/outside boolean indicator
<span class="nc" id="L279">            final BSPTree&lt;Euclidean2D&gt; parent = node.getParent();</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">            if (parent == null || node == parent.getMinus()) {</span>
<span class="nc" id="L281">                node.setAttribute(Boolean.TRUE);</span>
            } else {
<span class="nc" id="L283">                node.setAttribute(Boolean.FALSE);</span>
            }
<span class="nc" id="L285">            return;</span>
        }

        // we have split the node by inserting an edge as a cut sub-hyperplane
        // distribute the remaining edges in the two sub-trees
<span class="fc" id="L290">        final List&lt;Edge&gt; plusList  = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L291">        final List&lt;Edge&gt; minusList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">        for (final Edge edge : edges) {</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">            if (edge != inserted) {</span>
<span class="fc" id="L294">                final double startOffset = inserted.getLine().getOffset((Point&lt;Euclidean2D&gt;) edge.getStart().getLocation());</span>
<span class="fc" id="L295">                final double endOffset   = inserted.getLine().getOffset((Point&lt;Euclidean2D&gt;) edge.getEnd().getLocation());</span>
<span class="fc bfc" id="L296" title="All 4 branches covered.">                Side startSide = (FastMath.abs(startOffset) &lt;= hyperplaneThickness) ?</span>
                                 Side.HYPER : ((startOffset &lt; 0) ? Side.MINUS : Side.PLUS);
<span class="fc bfc" id="L298" title="All 4 branches covered.">                Side endSide   = (FastMath.abs(endOffset) &lt;= hyperplaneThickness) ?</span>
                                 Side.HYPER : ((endOffset &lt; 0) ? Side.MINUS : Side.PLUS);
<span class="fc bfc" id="L300" title="All 3 branches covered.">                switch (startSide) {</span>
                    case PLUS:
<span class="fc bfc" id="L302" title="All 2 branches covered.">                        if (endSide == Side.MINUS) {</span>
                            // we need to insert a split point on the hyperplane
<span class="fc" id="L304">                            final Vertex splitPoint = edge.split(inserted.getLine());</span>
<span class="fc" id="L305">                            minusList.add(splitPoint.getOutgoing());</span>
<span class="fc" id="L306">                            plusList.add(splitPoint.getIncoming());</span>
<span class="fc" id="L307">                        } else {</span>
<span class="fc" id="L308">                            plusList.add(edge);</span>
                        }
<span class="fc" id="L310">                        break;</span>
                    case MINUS:
<span class="fc bfc" id="L312" title="All 2 branches covered.">                        if (endSide == Side.PLUS) {</span>
                            // we need to insert a split point on the hyperplane
<span class="fc" id="L314">                            final Vertex splitPoint = edge.split(inserted.getLine());</span>
<span class="fc" id="L315">                            minusList.add(splitPoint.getIncoming());</span>
<span class="fc" id="L316">                            plusList.add(splitPoint.getOutgoing());</span>
<span class="fc" id="L317">                        } else {</span>
<span class="fc" id="L318">                            minusList.add(edge);</span>
                        }
<span class="fc" id="L320">                        break;</span>
                    default:
<span class="fc bfc" id="L322" title="All 2 branches covered.">                        if (endSide == Side.PLUS) {</span>
<span class="fc" id="L323">                            plusList.add(edge);</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">                        } else if (endSide == Side.MINUS) {</span>
<span class="fc" id="L325">                            minusList.add(edge);</span>
                        }
                        break;
                }
            }
<span class="fc" id="L330">        }</span>

        // recurse through lower levels
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (!plusList.isEmpty()) {</span>
<span class="fc" id="L334">            insertEdges(hyperplaneThickness, node.getPlus(),  plusList);</span>
        } else {
<span class="fc" id="L336">            node.getPlus().setAttribute(Boolean.FALSE);</span>
        }
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (!minusList.isEmpty()) {</span>
<span class="fc" id="L339">            insertEdges(hyperplaneThickness, node.getMinus(), minusList);</span>
        } else {
<span class="fc" id="L341">            node.getMinus().setAttribute(Boolean.TRUE);</span>
        }

<span class="fc" id="L344">    }</span>

    /** Internal class for holding vertices while they are processed to build a BSP tree. */
    private static class Vertex {

        /** Vertex location. */
        private final Cartesian2D location;

        /** Incoming edge. */
        private Edge incoming;

        /** Outgoing edge. */
        private Edge outgoing;

        /** Lines bound with this vertex. */
        private final List&lt;Line&gt; lines;

        /** Build a non-processed vertex not owned by any node yet.
         * @param location vertex location
         */
<span class="fc" id="L364">        Vertex(final Cartesian2D location) {</span>
<span class="fc" id="L365">            this.location = location;</span>
<span class="fc" id="L366">            this.incoming = null;</span>
<span class="fc" id="L367">            this.outgoing = null;</span>
<span class="fc" id="L368">            this.lines    = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L369">        }</span>

        /** Get Vertex location.
         * @return vertex location
         */
        public Cartesian2D getLocation() {
<span class="fc" id="L375">            return location;</span>
        }

        /** Bind a line considered to contain this vertex.
         * @param line line to bind with this vertex
         */
        public void bindWith(final Line line) {
<span class="fc" id="L382">            lines.add(line);</span>
<span class="fc" id="L383">        }</span>

        /** Get the common line bound with both the instance and another vertex, if any.
         * &lt;p&gt;
         * When two vertices are both bound to the same line, this means they are
         * already handled by node associated with this line, so there is no need
         * to create a cut hyperplane for them.
         * &lt;/p&gt;
         * @param vertex other vertex to check instance against
         * @return line bound with both the instance and another vertex, or null if the
         * two vertices do not share a line yet
         */
        public Line sharedLineWith(final Vertex vertex) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">            for (final Line line1 : lines) {</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                for (final Line line2 : vertex.lines) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">                    if (line1 == line2) {</span>
<span class="fc" id="L399">                        return line1;</span>
                    }
<span class="fc" id="L401">                }</span>
<span class="fc" id="L402">            }</span>
<span class="fc" id="L403">            return null;</span>
        }

        /** Set incoming edge.
         * &lt;p&gt;
         * The line supporting the incoming edge is automatically bound
         * with the instance.
         * &lt;/p&gt;
         * @param incoming incoming edge
         */
        public void setIncoming(final Edge incoming) {
<span class="fc" id="L414">            this.incoming = incoming;</span>
<span class="fc" id="L415">            bindWith(incoming.getLine());</span>
<span class="fc" id="L416">        }</span>

        /** Get incoming edge.
         * @return incoming edge
         */
        public Edge getIncoming() {
<span class="fc" id="L422">            return incoming;</span>
        }

        /** Set outgoing edge.
         * &lt;p&gt;
         * The line supporting the outgoing edge is automatically bound
         * with the instance.
         * &lt;/p&gt;
         * @param outgoing outgoing edge
         */
        public void setOutgoing(final Edge outgoing) {
<span class="fc" id="L433">            this.outgoing = outgoing;</span>
<span class="fc" id="L434">            bindWith(outgoing.getLine());</span>
<span class="fc" id="L435">        }</span>

        /** Get outgoing edge.
         * @return outgoing edge
         */
        public Edge getOutgoing() {
<span class="fc" id="L441">            return outgoing;</span>
        }

    }

    /** Internal class for holding edges while they are processed to build a BSP tree. */
    private static class Edge {

        /** Start vertex. */
        private final Vertex start;

        /** End vertex. */
        private final Vertex end;

        /** Line supporting the edge. */
        private final Line line;

        /** Node whose cut hyperplane contains this edge. */
        private BSPTree&lt;Euclidean2D&gt; node;

        /** Build an edge not contained in any node yet.
         * @param start start vertex
         * @param end end vertex
         * @param line line supporting the edge
         */
<span class="fc" id="L466">        Edge(final Vertex start, final Vertex end, final Line line) {</span>

<span class="fc" id="L468">            this.start = start;</span>
<span class="fc" id="L469">            this.end   = end;</span>
<span class="fc" id="L470">            this.line  = line;</span>
<span class="fc" id="L471">            this.node  = null;</span>

            // connect the vertices back to the edge
<span class="fc" id="L474">            start.setOutgoing(this);</span>
<span class="fc" id="L475">            end.setIncoming(this);</span>

<span class="fc" id="L477">        }</span>

        /** Get start vertex.
         * @return start vertex
         */
        public Vertex getStart() {
<span class="fc" id="L483">            return start;</span>
        }

        /** Get end vertex.
         * @return end vertex
         */
        public Vertex getEnd() {
<span class="fc" id="L490">            return end;</span>
        }

        /** Get the line supporting this edge.
         * @return line supporting this edge
         */
        public Line getLine() {
<span class="fc" id="L497">            return line;</span>
        }

        /** Set the node whose cut hyperplane contains this edge.
         * @param node node whose cut hyperplane contains this edge
         */
        public void setNode(final BSPTree&lt;Euclidean2D&gt; node) {
<span class="fc" id="L504">            this.node = node;</span>
<span class="fc" id="L505">        }</span>

        /** Get the node whose cut hyperplane contains this edge.
         * @return node whose cut hyperplane contains this edge
         * (null if edge has not yet been inserted into the BSP tree)
         */
        public BSPTree&lt;Euclidean2D&gt; getNode() {
<span class="fc" id="L512">            return node;</span>
        }

        /** Split the edge.
         * &lt;p&gt;
         * Once split, this edge is not referenced anymore by the vertices,
         * it is replaced by the two half-edges and an intermediate splitting
         * vertex is introduced to connect these two halves.
         * &lt;/p&gt;
         * @param splitLine line splitting the edge in two halves
         * @return split vertex (its incoming and outgoing edges are the two halves)
         */
        public Vertex split(final Line splitLine) {
<span class="fc" id="L525">            final Vertex splitVertex = new Vertex(line.intersection(splitLine));</span>
<span class="fc" id="L526">            splitVertex.bindWith(splitLine);</span>
<span class="fc" id="L527">            final Edge startHalf = new Edge(start, splitVertex, line);</span>
<span class="fc" id="L528">            final Edge endHalf   = new Edge(splitVertex, end, line);</span>
<span class="fc" id="L529">            startHalf.node = node;</span>
<span class="fc" id="L530">            endHalf.node   = node;</span>
<span class="fc" id="L531">            return splitVertex;</span>
        }

    }

    /** {@inheritDoc} */
    @Override
    public PolygonsSet buildNew(final BSPTree&lt;Euclidean2D&gt; tree) {
<span class="fc" id="L539">        return new PolygonsSet(tree, getTolerance());</span>
    }

    /** {@inheritDoc} */
    @Override
    protected void computeGeometricalProperties() {

<span class="fc" id="L546">        final Cartesian2D[][] v = getVertices();</span>

<span class="fc bfc" id="L548" title="All 2 branches covered.">        if (v.length == 0) {</span>
<span class="fc" id="L549">            final BSPTree&lt;Euclidean2D&gt; tree = getTree(false);</span>
<span class="fc bfc" id="L550" title="All 4 branches covered.">            if (tree.getCut() == null &amp;&amp; (Boolean) tree.getAttribute()) {</span>
                // the instance covers the whole space
<span class="fc" id="L552">                setSize(Double.POSITIVE_INFINITY);</span>
<span class="fc" id="L553">                setBarycenter((Point&lt;Euclidean2D&gt;) Cartesian2D.NaN);</span>
            } else {
<span class="fc" id="L555">                setSize(0);</span>
<span class="fc" id="L556">                setBarycenter((Point&lt;Euclidean2D&gt;) Cartesian2D.NaN);</span>
            }
<span class="fc bfc" id="L558" title="All 2 branches covered.">        } else if (v[0][0] == null) {</span>
            // there is at least one open-loop: the polygon is infinite
<span class="fc" id="L560">            setSize(Double.POSITIVE_INFINITY);</span>
<span class="fc" id="L561">            setBarycenter((Point&lt;Euclidean2D&gt;) Cartesian2D.NaN);</span>
        } else {
            // all loops are closed, we compute some integrals around the shape

<span class="fc" id="L565">            double sum  = 0;</span>
<span class="fc" id="L566">            double sumX = 0;</span>
<span class="fc" id="L567">            double sumY = 0;</span>

<span class="fc bfc" id="L569" title="All 2 branches covered.">            for (Cartesian2D[] loop : v) {</span>
<span class="fc" id="L570">                double x1 = loop[loop.length - 1].getX();</span>
<span class="fc" id="L571">                double y1 = loop[loop.length - 1].getY();</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">                for (final Cartesian2D point : loop) {</span>
<span class="fc" id="L573">                    final double x0 = x1;</span>
<span class="fc" id="L574">                    final double y0 = y1;</span>
<span class="fc" id="L575">                    x1 = point.getX();</span>
<span class="fc" id="L576">                    y1 = point.getY();</span>
<span class="fc" id="L577">                    final double factor = x0 * y1 - y0 * x1;</span>
<span class="fc" id="L578">                    sum  += factor;</span>
<span class="fc" id="L579">                    sumX += factor * (x0 + x1);</span>
<span class="fc" id="L580">                    sumY += factor * (y0 + y1);</span>
                }
            }

<span class="fc bfc" id="L584" title="All 2 branches covered.">            if (sum &lt; 0) {</span>
                // the polygon as a finite outside surrounded by an infinite inside
<span class="fc" id="L586">                setSize(Double.POSITIVE_INFINITY);</span>
<span class="fc" id="L587">                setBarycenter((Point&lt;Euclidean2D&gt;) Cartesian2D.NaN);</span>
            } else {
<span class="fc" id="L589">                setSize(sum / 2);</span>
<span class="fc" id="L590">                setBarycenter((Point&lt;Euclidean2D&gt;) new Cartesian2D(sumX / (3 * sum), sumY / (3 * sum)));</span>
            }

        }

<span class="fc" id="L595">    }</span>

    /** Get the vertices of the polygon.
     * &lt;p&gt;The polygon boundary can be represented as an array of loops,
     * each loop being itself an array of vertices.&lt;/p&gt;
     * &lt;p&gt;In order to identify open loops which start and end by
     * infinite edges, the open loops arrays start with a null point. In
     * this case, the first non null point and the last point of the
     * array do not represent real vertices, they are dummy points
     * intended only to get the direction of the first and last edge. An
     * open loop consisting of a single infinite line will therefore be
     * represented by a three elements array with one null point
     * followed by two dummy points. The open loops are always the first
     * ones in the loops array.&lt;/p&gt;
     * &lt;p&gt;If the polygon has no boundary at all, a zero length loop
     * array will be returned.&lt;/p&gt;
     * &lt;p&gt;All line segments in the various loops have the inside of the
     * region on their left side and the outside on their right side
     * when moving in the underlying line direction. This means that
     * closed loops surrounding finite areas obey the direct
     * trigonometric orientation.&lt;/p&gt;
     * @return vertices of the polygon, organized as oriented boundary
     * loops with the open loops first (the returned value is guaranteed
     * to be non-null)
     */
    public Cartesian2D[][] getVertices() {
<span class="fc bfc" id="L621" title="All 2 branches covered.">        if (vertices == null) {</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">            if (getTree(false).getCut() == null) {</span>
<span class="fc" id="L623">                vertices = new Cartesian2D[0][];</span>
            } else {

                // build the unconnected segments
<span class="fc" id="L627">                final SegmentsBuilder visitor = new SegmentsBuilder(getTolerance());</span>
<span class="fc" id="L628">                getTree(true).visit(visitor);</span>
<span class="fc" id="L629">                final List&lt;ConnectableSegment&gt; segments = visitor.getSegments();</span>

                // connect all segments, using topological criteria first
                // and using Euclidean distance only as a last resort
<span class="fc" id="L633">                int pending = segments.size();</span>
<span class="fc" id="L634">                pending -= naturalFollowerConnections(segments);</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">                if (pending &gt; 0) {</span>
<span class="fc" id="L636">                    pending -= splitEdgeConnections(segments);</span>
                }
<span class="fc bfc" id="L638" title="All 2 branches covered.">                if (pending &gt; 0) {</span>
<span class="fc" id="L639">                    pending -= closeVerticesConnections(segments);</span>
                }

                // create the segment loops
<span class="fc" id="L643">                final ArrayList&lt;List&lt;Segment&gt;&gt; loops = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">                for (ConnectableSegment s = getUnprocessed(segments); s != null; s = getUnprocessed(segments)) {</span>
<span class="fc" id="L645">                    final List&lt;Segment&gt; loop = followLoop(s);</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">                    if (loop != null) {</span>
                        // an open loop is one that has fewer than two segments or has a null
                        // start point; the case where we have two segments in a closed loop
                        // (ie, an infinitely thin, degenerate loop) will result in null being
                        // returned from the followLoops method
<span class="fc bfc" id="L651" title="All 4 branches covered.">                        if (loop.size() &lt; 2 || loop.get(0).getStart() == null) {</span>
                            // this is an open loop, we put it on the front
<span class="fc" id="L653">                            loops.add(0, loop);</span>
                        } else {
                            // this is a closed loop, we put it on the back
<span class="fc" id="L656">                            loops.add(loop);</span>
                        }
                    }
                }

                // transform the loops in an array of arrays of points
<span class="fc" id="L662">                vertices = new Cartesian2D[loops.size()][];</span>
<span class="fc" id="L663">                int i = 0;</span>

<span class="fc bfc" id="L665" title="All 2 branches covered.">                for (final List&lt;Segment&gt; loop : loops) {</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">                    if (loop.size() &lt; 2 ||</span>
<span class="pc bpc" id="L667" title="5 of 6 branches missed.">                        (loop.size() == 2 &amp;&amp; loop.get(0).getStart() == null &amp;&amp; loop.get(1).getEnd() == null)) {</span>
                        // single infinite line
<span class="fc" id="L669">                        final Line line = loop.get(0).getLine();</span>
<span class="fc" id="L670">                        vertices[i++] = new Cartesian2D[] {</span>
                            null,
<span class="fc" id="L672">                            line.toSpace(new Cartesian1D(-Float.MAX_VALUE)),</span>
<span class="fc" id="L673">                            line.toSpace(new Cartesian1D(+Float.MAX_VALUE))</span>
                        };
<span class="fc bfc" id="L675" title="All 2 branches covered.">                    } else if (loop.get(0).getStart() == null) {</span>
                        // open loop with at least one real point
<span class="fc" id="L677">                        final Cartesian2D[] array = new Cartesian2D[loop.size() + 2];</span>
<span class="fc" id="L678">                        int j = 0;</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">                        for (Segment segment : loop) {</span>

<span class="fc bfc" id="L681" title="All 2 branches covered.">                            if (j == 0) {</span>
                                // null point and first dummy point
<span class="fc" id="L683">                                double x = segment.getLine().toSubSpace(segment.getEnd()).getX();</span>
<span class="fc" id="L684">                                x -= FastMath.max(1.0, FastMath.abs(x / 2));</span>
<span class="fc" id="L685">                                array[j++] = null;</span>
<span class="fc" id="L686">                                array[j++] = segment.getLine().toSpace(new Cartesian1D(x));</span>
                            }

<span class="fc bfc" id="L689" title="All 2 branches covered.">                            if (j &lt; (array.length - 1)) {</span>
                                // current point
<span class="fc" id="L691">                                array[j++] = segment.getEnd();</span>
<span class="pc bpc" id="L692" title="1 of 2 branches missed.">                            } else if (j == (array.length - 1)) {</span>
                                // last dummy point
<span class="fc" id="L694">                                double x = segment.getLine().toSubSpace(segment.getStart()).getX();</span>
<span class="fc" id="L695">                                x += FastMath.max(1.0, FastMath.abs(x / 2));</span>
<span class="fc" id="L696">                                array[j++] = segment.getLine().toSpace(new Cartesian1D(x));</span>
                            }

<span class="fc" id="L699">                        }</span>
<span class="fc" id="L700">                        vertices[i++] = array;</span>
<span class="fc" id="L701">                    } else {</span>
<span class="fc" id="L702">                        final Cartesian2D[] array = new Cartesian2D[loop.size()];</span>
<span class="fc" id="L703">                        int j = 0;</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">                        for (Segment segment : loop) {</span>
<span class="fc" id="L705">                            array[j++] = segment.getStart();</span>
<span class="fc" id="L706">                        }</span>
<span class="fc" id="L707">                        vertices[i++] = array;</span>
                    }
<span class="fc" id="L709">                }</span>

            }
        }

<span class="fc" id="L714">        return vertices.clone();</span>

    }

    /** Connect the segments using only natural follower information.
     * @param segments segments complete segments list
     * @return number of connections performed
     */
    private int naturalFollowerConnections(final List&lt;ConnectableSegment&gt; segments) {
<span class="fc" id="L723">        int connected = 0;</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">        for (final ConnectableSegment segment : segments) {</span>
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">            if (segment.getNext() == null) {</span>
<span class="fc" id="L726">                final BSPTree&lt;Euclidean2D&gt; node = segment.getNode();</span>
<span class="fc" id="L727">                final BSPTree&lt;Euclidean2D&gt; end  = segment.getEndNode();</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">                for (final ConnectableSegment candidateNext : segments) {</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">                    if (candidateNext.getPrevious()  == null &amp;&amp;</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">                        candidateNext.getNode()      == end &amp;&amp;</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">                        candidateNext.getStartNode() == node) {</span>
                        // connect the two segments
<span class="fc" id="L733">                        segment.setNext(candidateNext);</span>
<span class="fc" id="L734">                        candidateNext.setPrevious(segment);</span>
<span class="fc" id="L735">                        ++connected;</span>
<span class="fc" id="L736">                        break;</span>
                    }
<span class="fc" id="L738">                }</span>
            }
<span class="fc" id="L740">        }</span>
<span class="fc" id="L741">        return connected;</span>
    }

    /** Connect the segments resulting from a line splitting a straight edge.
     * @param segments segments complete segments list
     * @return number of connections performed
     */
    private int splitEdgeConnections(final List&lt;ConnectableSegment&gt; segments) {
<span class="fc" id="L749">        int connected = 0;</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">        for (final ConnectableSegment segment : segments) {</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">            if (segment.getNext() == null) {</span>
<span class="fc" id="L752">                final Hyperplane&lt;Euclidean2D&gt; hyperplane = segment.getNode().getCut().getHyperplane();</span>
<span class="fc" id="L753">                final BSPTree&lt;Euclidean2D&gt; end  = segment.getEndNode();</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">                for (final ConnectableSegment candidateNext : segments) {</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">                    if (candidateNext.getPrevious()                      == null &amp;&amp;</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">                        candidateNext.getNode().getCut().getHyperplane() == hyperplane &amp;&amp;</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">                        candidateNext.getStartNode()                     == end) {</span>
                        // connect the two segments
<span class="fc" id="L759">                        segment.setNext(candidateNext);</span>
<span class="fc" id="L760">                        candidateNext.setPrevious(segment);</span>
<span class="fc" id="L761">                        ++connected;</span>
<span class="fc" id="L762">                        break;</span>
                    }
<span class="fc" id="L764">                }</span>
            }
<span class="fc" id="L766">        }</span>
<span class="fc" id="L767">        return connected;</span>
    }

    /** Connect the segments using Euclidean distance.
     * &lt;p&gt;
     * This connection heuristic should be used last, as it relies
     * only on a fuzzy distance criterion.
     * &lt;/p&gt;
     * @param segments segments complete segments list
     * @return number of connections performed
     */
    private int closeVerticesConnections(final List&lt;ConnectableSegment&gt; segments) {
<span class="fc" id="L779">        int connected = 0;</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">        for (final ConnectableSegment segment : segments) {</span>
<span class="fc bfc" id="L781" title="All 4 branches covered.">            if (segment.getNext() == null &amp;&amp; segment.getEnd() != null) {</span>
<span class="fc" id="L782">                final Cartesian2D end = segment.getEnd();</span>
<span class="fc" id="L783">                ConnectableSegment selectedNext = null;</span>
<span class="fc" id="L784">                double min = Double.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">                for (final ConnectableSegment candidateNext : segments) {</span>
<span class="fc bfc" id="L786" title="All 4 branches covered.">                    if (candidateNext.getPrevious() == null &amp;&amp; candidateNext.getStart() != null) {</span>
<span class="fc" id="L787">                        final double distance = Cartesian2D.distance(end, candidateNext.getStart());</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">                        if (distance &lt; min) {</span>
<span class="fc" id="L789">                            selectedNext = candidateNext;</span>
<span class="fc" id="L790">                            min          = distance;</span>
                        }
                    }
<span class="fc" id="L793">                }</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">                if (min &lt;= getTolerance()) {</span>
                    // connect the two segments
<span class="fc" id="L796">                    segment.setNext(selectedNext);</span>
<span class="fc" id="L797">                    selectedNext.setPrevious(segment);</span>
<span class="fc" id="L798">                    ++connected;</span>
                }
            }
<span class="fc" id="L801">        }</span>
<span class="fc" id="L802">        return connected;</span>
    }

    /** Get first unprocessed segment from a list.
     * @param segments segments list
     * @return first segment that has not been processed yet
     * or null if all segments have been processed
     */
    private ConnectableSegment getUnprocessed(final List&lt;ConnectableSegment&gt; segments) {
<span class="fc bfc" id="L811" title="All 2 branches covered.">        for (final ConnectableSegment segment : segments) {</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">            if (!segment.isProcessed()) {</span>
<span class="fc" id="L813">                return segment;</span>
            }
<span class="fc" id="L815">        }</span>
<span class="fc" id="L816">        return null;</span>
    }

    /** Build the loop containing a segment.
     * &lt;p&gt;
     * The segment put in the loop will be marked as processed.
     * &lt;/p&gt;
     * @param defining segment used to define the loop
     * @return loop containing the segment (may be null if the loop is a
     * degenerated infinitely thin 2 points loop
     */
    private List&lt;Segment&gt; followLoop(final ConnectableSegment defining) {

<span class="fc" id="L829">        final List&lt;Segment&gt; loop = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L830">        loop.add(defining);</span>
<span class="fc" id="L831">        defining.setProcessed(true);</span>

        // add segments in connection order
<span class="fc" id="L834">        ConnectableSegment next = defining.getNext();</span>
<span class="fc bfc" id="L835" title="All 4 branches covered.">        while (next != defining &amp;&amp; next != null) {</span>
<span class="fc" id="L836">            loop.add(next);</span>
<span class="fc" id="L837">            next.setProcessed(true);</span>
<span class="fc" id="L838">            next = next.getNext();</span>
        }

<span class="fc bfc" id="L841" title="All 2 branches covered.">        if (next == null) {</span>
            // the loop is open and we have found its end,
            // we need to find its start too
<span class="fc" id="L844">            ConnectableSegment previous = defining.getPrevious();</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">            while (previous != null) {</span>
<span class="fc" id="L846">                loop.add(0, previous);</span>
<span class="fc" id="L847">                previous.setProcessed(true);</span>
<span class="fc" id="L848">                previous = previous.getPrevious();</span>
            }
        }

        // filter out spurious vertices
<span class="fc" id="L853">        filterSpuriousVertices(loop);</span>

<span class="pc bpc" id="L855" title="1 of 4 branches missed.">        if (loop.size() == 2 &amp;&amp; loop.get(0).getStart() != null) {</span>
            // this is a degenerated infinitely thin closed loop, we simply ignore it
<span class="fc" id="L857">            return null;</span>
        } else {
<span class="fc" id="L859">            return loop;</span>
        }

    }

    /** Filter out spurious vertices on straight lines (at machine precision).
     * @param loop segments loop to filter (will be modified in-place)
     */
    private void filterSpuriousVertices(final List&lt;Segment&gt; loop) {
        // we need at least 2 segments in order for one of the contained vertices
        // to be unnecessary
<span class="fc bfc" id="L870" title="All 2 branches covered.">        if (loop.size() &gt; 1) {</span>
            // Go through the list and compare each segment with the next
            // one in line. We can remove the shared vertex if the segments
            // are not infinite and they lie on the same line.
<span class="fc bfc" id="L874" title="All 2 branches covered.">            for (int i = 0; i &lt; loop.size(); ++i) {</span>
<span class="fc" id="L875">                final Segment previous = loop.get(i);</span>
<span class="fc" id="L876">                int j = (i + 1) % loop.size();</span>
<span class="fc" id="L877">                final Segment next = loop.get(j);</span>
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">                if (next != null &amp;&amp;</span>
<span class="fc bfc" id="L879" title="All 4 branches covered.">                    previous.getStart() != null &amp;&amp; next.getEnd() != null &amp;&amp;</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">                    Precision.equals(previous.getLine().getAngle(), next.getLine().getAngle(), Precision.EPSILON)) {</span>
                    // the vertex between the two edges is a spurious one
                    // replace the two segments by a single one
<span class="fc" id="L883">                    loop.set(j, new Segment(previous.getStart(), next.getEnd(), previous.getLine()));</span>
<span class="fc" id="L884">                    loop.remove(i--);</span>
                }
            }
        }
<span class="fc" id="L888">    }</span>

    /** Private extension of Segment allowing connection. */
    private static class ConnectableSegment extends Segment {

        /** Node containing segment. */
        private final BSPTree&lt;Euclidean2D&gt; node;

        /** Node whose intersection with current node defines start point. */
        private final BSPTree&lt;Euclidean2D&gt; startNode;

        /** Node whose intersection with current node defines end point. */
        private final BSPTree&lt;Euclidean2D&gt; endNode;

        /** Previous segment. */
        private ConnectableSegment previous;

        /** Next segment. */
        private ConnectableSegment next;

        /** Indicator for completely processed segments. */
        private boolean processed;

        /** Build a segment.
         * @param start start point of the segment
         * @param end end point of the segment
         * @param line line containing the segment
         * @param node node containing the segment
         * @param startNode node whose intersection with current node defines start point
         * @param endNode node whose intersection with current node defines end point
         */
        ConnectableSegment(final Cartesian2D start, final Cartesian2D end, final Line line,
                           final BSPTree&lt;Euclidean2D&gt; node,
                           final BSPTree&lt;Euclidean2D&gt; startNode,
                           final BSPTree&lt;Euclidean2D&gt; endNode) {
<span class="fc" id="L923">            super(start, end, line);</span>
<span class="fc" id="L924">            this.node      = node;</span>
<span class="fc" id="L925">            this.startNode = startNode;</span>
<span class="fc" id="L926">            this.endNode   = endNode;</span>
<span class="fc" id="L927">            this.previous  = null;</span>
<span class="fc" id="L928">            this.next      = null;</span>
<span class="fc" id="L929">            this.processed = false;</span>
<span class="fc" id="L930">        }</span>

        /** Get the node containing segment.
         * @return node containing segment
         */
        public BSPTree&lt;Euclidean2D&gt; getNode() {
<span class="fc" id="L936">            return node;</span>
        }

        /** Get the node whose intersection with current node defines start point.
         * @return node whose intersection with current node defines start point
         */
        public BSPTree&lt;Euclidean2D&gt; getStartNode() {
<span class="fc" id="L943">            return startNode;</span>
        }

        /** Get the node whose intersection with current node defines end point.
         * @return node whose intersection with current node defines end point
         */
        public BSPTree&lt;Euclidean2D&gt; getEndNode() {
<span class="fc" id="L950">            return endNode;</span>
        }

        /** Get the previous segment.
         * @return previous segment
         */
        public ConnectableSegment getPrevious() {
<span class="fc" id="L957">            return previous;</span>
        }

        /** Set the previous segment.
         * @param previous previous segment
         */
        public void setPrevious(final ConnectableSegment previous) {
<span class="fc" id="L964">            this.previous = previous;</span>
<span class="fc" id="L965">        }</span>

        /** Get the next segment.
         * @return next segment
         */
        public ConnectableSegment getNext() {
<span class="fc" id="L971">            return next;</span>
        }

        /** Set the next segment.
         * @param next previous segment
         */
        public void setNext(final ConnectableSegment next) {
<span class="fc" id="L978">            this.next = next;</span>
<span class="fc" id="L979">        }</span>

        /** Set the processed flag.
         * @param processed processed flag to set
         */
        public void setProcessed(final boolean processed) {
<span class="fc" id="L985">            this.processed = processed;</span>
<span class="fc" id="L986">        }</span>

        /** Check if the segment has been processed.
         * @return true if the segment has been processed
         */
        public boolean isProcessed() {
<span class="fc" id="L992">            return processed;</span>
        }

    }

    /** Visitor building segments. */
    private static class SegmentsBuilder implements BSPTreeVisitor&lt;Euclidean2D&gt; {

        /** Tolerance for close nodes connection. */
        private final double tolerance;

        /** Built segments. */
        private final List&lt;ConnectableSegment&gt; segments;

        /** Simple constructor.
         * @param tolerance tolerance for close nodes connection
         */
<span class="fc" id="L1009">        SegmentsBuilder(final double tolerance) {</span>
<span class="fc" id="L1010">            this.tolerance = tolerance;</span>
<span class="fc" id="L1011">            this.segments  = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1012">        }</span>

        /** {@inheritDoc} */
        @Override
        public Order visitOrder(final BSPTree&lt;Euclidean2D&gt; node) {
<span class="fc" id="L1017">            return Order.MINUS_SUB_PLUS;</span>
        }

        /** {@inheritDoc} */
        @Override
        public void visitInternalNode(final BSPTree&lt;Euclidean2D&gt; node) {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1024">            final BoundaryAttribute&lt;Euclidean2D&gt; attribute = (BoundaryAttribute&lt;Euclidean2D&gt;) node.getAttribute();</span>
<span class="fc" id="L1025">            final Iterable&lt;BSPTree&lt;Euclidean2D&gt;&gt; splitters = attribute.getSplitters();</span>
<span class="fc bfc" id="L1026" title="All 2 branches covered.">            if (attribute.getPlusOutside() != null) {</span>
<span class="fc" id="L1027">                addContribution(attribute.getPlusOutside(), node, splitters, false);</span>
            }
<span class="fc bfc" id="L1029" title="All 2 branches covered.">            if (attribute.getPlusInside() != null) {</span>
<span class="fc" id="L1030">                addContribution(attribute.getPlusInside(), node, splitters, true);</span>
            }
<span class="fc" id="L1032">        }</span>

        /** {@inheritDoc} */
        @Override
        public void visitLeafNode(final BSPTree&lt;Euclidean2D&gt; node) {
<span class="fc" id="L1037">        }</span>

        /** Add the contribution of a boundary facet.
         * @param sub boundary facet
         * @param node node containing segment
         * @param splitters splitters for the boundary facet
         * @param reversed if true, the facet has the inside on its plus side
         */
        private void addContribution(final SubHyperplane&lt;Euclidean2D&gt; sub,
                                     final BSPTree&lt;Euclidean2D&gt; node,
                                     final Iterable&lt;BSPTree&lt;Euclidean2D&gt;&gt; splitters,
                                     final boolean reversed) {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1050">            final AbstractSubHyperplane&lt;Euclidean2D, Euclidean1D&gt; absSub =</span>
                (AbstractSubHyperplane&lt;Euclidean2D, Euclidean1D&gt;) sub;
<span class="fc" id="L1052">            final Line line      = (Line) sub.getHyperplane();</span>
<span class="fc" id="L1053">            final List&lt;Interval&gt; intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();</span>
<span class="fc bfc" id="L1054" title="All 2 branches covered.">            for (final Interval i : intervals) {</span>

                // find the 2D points
<span class="fc bfc" id="L1057" title="All 2 branches covered.">                final Cartesian2D startV = Double.isInfinite(i.getInf()) ?</span>
<span class="fc" id="L1058">                                        null : line.toSpace(new Cartesian1D(i.getInf()));</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">                final Cartesian2D endV   = Double.isInfinite(i.getSup()) ?</span>
<span class="fc" id="L1060">                                        null : line.toSpace(new Cartesian1D(i.getSup()));</span>

                // recover the connectivity information
<span class="fc" id="L1063">                final BSPTree&lt;Euclidean2D&gt; startN = selectClosest(startV, splitters);</span>
<span class="fc" id="L1064">                final BSPTree&lt;Euclidean2D&gt; endN   = selectClosest(endV, splitters);</span>

<span class="fc bfc" id="L1066" title="All 2 branches covered.">                if (reversed) {</span>
<span class="fc" id="L1067">                    segments.add(new ConnectableSegment(endV, startV, line.getReverse(),</span>
                                                        node, endN, startN));
                } else {
<span class="fc" id="L1070">                    segments.add(new ConnectableSegment(startV, endV, line,</span>
                                                        node, startN, endN));
                }

<span class="fc" id="L1074">            }</span>
<span class="fc" id="L1075">        }</span>

        /** Select the node whose cut sub-hyperplane is closest to specified point.
         * @param point reference point
         * @param candidates candidate nodes
         * @return node closest to point, or null if point is null or no node is closer than tolerance
         */
        private BSPTree&lt;Euclidean2D&gt; selectClosest(final Cartesian2D point, final Iterable&lt;BSPTree&lt;Euclidean2D&gt;&gt; candidates) {
<span class="fc bfc" id="L1083" title="All 2 branches covered.">            if (point != null) {</span>
<span class="fc" id="L1084">                BSPTree&lt;Euclidean2D&gt; selected = null;</span>
<span class="fc" id="L1085">                double min = Double.POSITIVE_INFINITY;</span>

<span class="fc bfc" id="L1087" title="All 2 branches covered.">                for (final BSPTree&lt;Euclidean2D&gt; node : candidates) {</span>
<span class="fc" id="L1088">                    final double distance = FastMath.abs(node.getCut().getHyperplane().getOffset(point));</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">                    if (distance &lt; min) {</span>
<span class="fc" id="L1090">                        selected = node;</span>
<span class="fc" id="L1091">                        min      = distance;</span>
                    }
<span class="fc" id="L1093">                }</span>

<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">                if (min &lt;= tolerance) {</span>
<span class="fc" id="L1096">                    return selected;</span>
                }
            }
<span class="fc" id="L1099">            return null;</span>
        }

        /** Get the segments.
         * @return built segments
         */
        public List&lt;ConnectableSegment&gt; getSegments() {
<span class="fc" id="L1106">            return segments;</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>