<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SparseFieldVector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.linear</a> &gt; <span class="el_source">SparseFieldVector.java</span></div><h1>SparseFieldVector.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.linear;

import java.io.Serializable;

import org.apache.commons.math4.Field;
import org.apache.commons.math4.FieldElement;
import org.apache.commons.math4.exception.DimensionMismatchException;
import org.apache.commons.math4.exception.MathArithmeticException;
import org.apache.commons.math4.exception.NotPositiveException;
import org.apache.commons.math4.exception.NullArgumentException;
import org.apache.commons.math4.exception.NumberIsTooSmallException;
import org.apache.commons.math4.exception.OutOfRangeException;
import org.apache.commons.math4.exception.util.LocalizedFormats;
import org.apache.commons.math4.util.MathArrays;
import org.apache.commons.math4.util.MathUtils;
import org.apache.commons.math4.util.OpenIntToFieldHashMap;

/**
 * This class implements the {@link FieldVector} interface with a {@link OpenIntToFieldHashMap} backing store.
 * &lt;p&gt;
 *  Caveat: This implementation assumes that, for any {@code x},
 *  the equality {@code x * 0d == 0d} holds. But it is is not true for
 *  {@code NaN}. Moreover, zero entries will lose their sign.
 *  Some operations (that involve {@code NaN} and/or infinities) may
 *  thus give incorrect results.
 * &lt;/p&gt;
 * @param &lt;T&gt; the type of the field elements
 * @since 2.0
 */
public class SparseFieldVector&lt;T extends FieldElement&lt;T&gt;&gt; implements FieldVector&lt;T&gt;, Serializable {
    /**  Serialization identifier. */
    private static final long serialVersionUID = 7841233292190413362L;
    /** Field to which the elements belong. */
    private final Field&lt;T&gt; field;
    /** Entries of the vector. */
    private final OpenIntToFieldHashMap&lt;T&gt; entries;
    /** Dimension of the vector. */
    private final int virtualSize;

    /**
     * Build a 0-length vector.
     * Zero-length vectors may be used to initialize construction of vectors
     * by data gathering. We start with zero-length and use either the {@link
     * #SparseFieldVector(SparseFieldVector, int)} constructor
     * or one of the {@code append} method ({@link #append(FieldVector)} or
     * {@link #append(SparseFieldVector)}) to gather data into this vector.
     *
     * @param field Field to which the elements belong.
     */
    public SparseFieldVector(Field&lt;T&gt; field) {
<span class="nc" id="L67">        this(field, 0);</span>
<span class="nc" id="L68">    }</span>


    /**
     * Construct a vector of zeroes.
     *
     * @param field Field to which the elements belong.
     * @param dimension Size of the vector.
     */
<span class="fc" id="L77">    public SparseFieldVector(Field&lt;T&gt; field, int dimension) {</span>
<span class="fc" id="L78">        this.field = field;</span>
<span class="fc" id="L79">        virtualSize = dimension;</span>
<span class="fc" id="L80">        entries = new OpenIntToFieldHashMap&lt;&gt;(field);</span>
<span class="fc" id="L81">    }</span>

    /**
     * Build a resized vector, for use with append.
     *
     * @param v Original vector
     * @param resize Amount to add.
     */
<span class="nc" id="L89">    protected SparseFieldVector(SparseFieldVector&lt;T&gt; v, int resize) {</span>
<span class="nc" id="L90">        field = v.field;</span>
<span class="nc" id="L91">        virtualSize = v.getDimension() + resize;</span>
<span class="nc" id="L92">        entries = new OpenIntToFieldHashMap&lt;&gt;(v.entries);</span>
<span class="nc" id="L93">    }</span>


    /**
     * Build a vector with known the sparseness (for advanced use only).
     *
     * @param field Field to which the elements belong.
     * @param dimension Size of the vector.
     * @param expectedSize Expected number of non-zero entries.
     */
<span class="nc" id="L103">    public SparseFieldVector(Field&lt;T&gt; field, int dimension, int expectedSize) {</span>
<span class="nc" id="L104">        this.field = field;</span>
<span class="nc" id="L105">        virtualSize = dimension;</span>
<span class="nc" id="L106">        entries = new OpenIntToFieldHashMap&lt;&gt;(field,expectedSize);</span>
<span class="nc" id="L107">    }</span>

    /**
     * Create from a Field array.
     * Only non-zero entries will be stored.
     *
     * @param field Field to which the elements belong.
     * @param values Set of values to create from.
     * @exception NullArgumentException if values is null
     */
<span class="fc" id="L117">    public SparseFieldVector(Field&lt;T&gt; field, T[] values) throws NullArgumentException {</span>
<span class="fc" id="L118">        MathUtils.checkNotNull(values);</span>
<span class="fc" id="L119">        this.field = field;</span>
<span class="fc" id="L120">        virtualSize = values.length;</span>
<span class="fc" id="L121">        entries = new OpenIntToFieldHashMap&lt;&gt;(field);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for (int key = 0; key &lt; values.length; key++) {</span>
<span class="fc" id="L123">            T value = values[key];</span>
<span class="fc" id="L124">            entries.put(key, value);</span>
        }
<span class="fc" id="L126">    }</span>

    /**
     * Copy constructor.
     *
     * @param v Instance to copy.
     */
<span class="fc" id="L133">    public SparseFieldVector(SparseFieldVector&lt;T&gt; v) {</span>
<span class="fc" id="L134">        field = v.field;</span>
<span class="fc" id="L135">        virtualSize = v.getDimension();</span>
<span class="fc" id="L136">        entries = new OpenIntToFieldHashMap&lt;&gt;(v.getEntries());</span>
<span class="fc" id="L137">    }</span>

    /**
     * Get the entries of this instance.
     *
     * @return the entries of this instance
     */
    private OpenIntToFieldHashMap&lt;T&gt; getEntries() {
<span class="fc" id="L145">        return entries;</span>
    }

    /**
     * Optimized method to add sparse vectors.
     *
     * @param v Vector to add.
     * @return {@code this + v}.
     * @throws DimensionMismatchException if {@code v} is not the same size as
     * {@code this}.
     */
    public FieldVector&lt;T&gt; add(SparseFieldVector&lt;T&gt; v)
        throws DimensionMismatchException {
<span class="fc" id="L158">        checkVectorDimensions(v.getDimension());</span>
<span class="fc" id="L159">        SparseFieldVector&lt;T&gt; res = (SparseFieldVector&lt;T&gt;)copy();</span>
<span class="fc" id="L160">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = v.getEntries().iterator();</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L162">            iter.advance();</span>
<span class="fc" id="L163">            int key = iter.key();</span>
<span class="fc" id="L164">            T value = iter.value();</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">            if (entries.containsKey(key)) {</span>
<span class="fc" id="L166">                res.setEntry(key, entries.get(key).add(value));</span>
            } else {
<span class="nc" id="L168">                res.setEntry(key, value);</span>
            }
<span class="fc" id="L170">        }</span>
<span class="fc" id="L171">        return res;</span>

    }

    /**
     * Construct a vector by appending a vector to this vector.
     *
     * @param v Vector to append to this one.
     * @return a new vector.
     */
    public FieldVector&lt;T&gt; append(SparseFieldVector&lt;T&gt; v) {
<span class="nc" id="L182">        SparseFieldVector&lt;T&gt; res = new SparseFieldVector&lt;&gt;(this, v.getDimension());</span>
<span class="nc" id="L183">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = v.entries.iterator();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L185">            iter.advance();</span>
<span class="nc" id="L186">            res.setEntry(iter.key() + virtualSize, iter.value());</span>
        }
<span class="nc" id="L188">        return res;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; append(FieldVector&lt;T&gt; v) {
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (v instanceof SparseFieldVector&lt;?&gt;) {</span>
<span class="nc" id="L195">            return append((SparseFieldVector&lt;T&gt;) v);</span>
        } else {
<span class="nc" id="L197">            final int n = v.getDimension();</span>
<span class="nc" id="L198">            FieldVector&lt;T&gt; res = new SparseFieldVector&lt;&gt;(this, n);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L200">                res.setEntry(i + virtualSize, v.getEntry(i));</span>
            }
<span class="nc" id="L202">            return res;</span>
        }
    }

    /** {@inheritDoc}
     * @exception NullArgumentException if d is null
     */
    @Override
    public FieldVector&lt;T&gt; append(T d) throws NullArgumentException {
<span class="nc" id="L211">        MathUtils.checkNotNull(d);</span>
<span class="nc" id="L212">        FieldVector&lt;T&gt; res = new SparseFieldVector&lt;&gt;(this, 1);</span>
<span class="nc" id="L213">        res.setEntry(virtualSize, d);</span>
<span class="nc" id="L214">        return res;</span>
     }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; copy() {
<span class="fc" id="L220">        return new SparseFieldVector&lt;&gt;(this);</span>
    }

    /** {@inheritDoc} */
    @Override
    public T dotProduct(FieldVector&lt;T&gt; v) throws DimensionMismatchException {
<span class="fc" id="L226">        checkVectorDimensions(v.getDimension());</span>
<span class="fc" id="L227">        T res = field.getZero();</span>
<span class="fc" id="L228">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = entries.iterator();</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L230">            iter.advance();</span>
<span class="fc" id="L231">            res = res.add(v.getEntry(iter.key()).multiply(iter.value()));</span>
        }
<span class="fc" id="L233">        return res;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; ebeDivide(FieldVector&lt;T&gt; v)
        throws DimensionMismatchException, MathArithmeticException {
<span class="fc" id="L240">        checkVectorDimensions(v.getDimension());</span>
<span class="fc" id="L241">        SparseFieldVector&lt;T&gt; res = new SparseFieldVector&lt;&gt;(this);</span>
<span class="fc" id="L242">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = res.entries.iterator();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L244">            iter.advance();</span>
<span class="fc" id="L245">            res.setEntry(iter.key(), iter.value().divide(v.getEntry(iter.key())));</span>
        }
<span class="fc" id="L247">        return res;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; ebeMultiply(FieldVector&lt;T&gt; v)
        throws DimensionMismatchException {
<span class="fc" id="L254">        checkVectorDimensions(v.getDimension());</span>
<span class="fc" id="L255">        SparseFieldVector&lt;T&gt; res = new SparseFieldVector&lt;&gt;(this);</span>
<span class="fc" id="L256">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = res.entries.iterator();</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L258">            iter.advance();</span>
<span class="fc" id="L259">            res.setEntry(iter.key(), iter.value().multiply(v.getEntry(iter.key())));</span>
        }
<span class="fc" id="L261">        return res;</span>
    }

    /** {@inheritDoc} */
    @Override
    public int getDimension() {
<span class="fc" id="L267">        return virtualSize;</span>
    }

    /** {@inheritDoc} */
    @Override
    public T getEntry(int index) throws OutOfRangeException {
<span class="fc" id="L273">        checkIndex(index);</span>
<span class="fc" id="L274">        return entries.get(index);</span>
   }

    /** {@inheritDoc} */
    @Override
    public Field&lt;T&gt; getField() {
<span class="nc" id="L280">        return field;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; getSubVector(int index, int n)
        throws OutOfRangeException, NotPositiveException {
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (n &lt; 0) {</span>
<span class="nc" id="L288">            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);</span>
        }
<span class="nc" id="L290">        checkIndex(index);</span>
<span class="nc" id="L291">        checkIndex(index + n - 1);</span>
<span class="nc" id="L292">        SparseFieldVector&lt;T&gt; res = new SparseFieldVector&lt;&gt;(field,n);</span>
<span class="nc" id="L293">        int end = index + n;</span>
<span class="nc" id="L294">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = entries.iterator();</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L296">            iter.advance();</span>
<span class="nc" id="L297">            int key = iter.key();</span>
<span class="nc bnc" id="L298" title="All 4 branches missed.">            if (key &gt;= index &amp;&amp; key &lt; end) {</span>
<span class="nc" id="L299">                res.setEntry(key - index, iter.value());</span>
            }
<span class="nc" id="L301">        }</span>
<span class="nc" id="L302">        return res;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; mapAdd(T d) throws NullArgumentException {
<span class="fc" id="L308">        return copy().mapAddToSelf(d);</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; mapAddToSelf(T d) throws NullArgumentException {
<span class="fc bfc" id="L314" title="All 2 branches covered.">        for (int i = 0; i &lt; virtualSize; i++) {</span>
<span class="fc" id="L315">            setEntry(i, getEntry(i).add(d));</span>
        }
<span class="fc" id="L317">        return this;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; mapDivide(T d)
        throws NullArgumentException, MathArithmeticException {
<span class="fc" id="L324">        return copy().mapDivideToSelf(d);</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; mapDivideToSelf(T d)
        throws NullArgumentException, MathArithmeticException {
<span class="fc" id="L331">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = entries.iterator();</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L333">            iter.advance();</span>
<span class="fc" id="L334">            entries.put(iter.key(), iter.value().divide(d));</span>
        }
<span class="fc" id="L336">        return this;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; mapInv() throws MathArithmeticException {
<span class="fc" id="L342">        return copy().mapInvToSelf();</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; mapInvToSelf() throws MathArithmeticException {
<span class="fc bfc" id="L348" title="All 2 branches covered.">        for (int i = 0; i &lt; virtualSize; i++) {</span>
<span class="fc" id="L349">            setEntry(i, field.getOne().divide(getEntry(i)));</span>
        }
<span class="fc" id="L351">        return this;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; mapMultiply(T d) throws NullArgumentException {
<span class="fc" id="L357">        return copy().mapMultiplyToSelf(d);</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; mapMultiplyToSelf(T d) throws NullArgumentException {
<span class="fc" id="L363">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = entries.iterator();</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L365">            iter.advance();</span>
<span class="fc" id="L366">            entries.put(iter.key(), iter.value().multiply(d));</span>
        }
<span class="fc" id="L368">        return this;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; mapSubtract(T d) throws NullArgumentException {
<span class="fc" id="L374">        return copy().mapSubtractToSelf(d);</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; mapSubtractToSelf(T d) throws NullArgumentException {
<span class="fc" id="L380">        return mapAddToSelf(field.getZero().subtract(d));</span>
    }

    /**
     * Optimized method to compute outer product when both vectors are sparse.
     * @param v vector with which outer product should be computed
     * @return the matrix outer product between instance and v
     */
    public FieldMatrix&lt;T&gt; outerProduct(SparseFieldVector&lt;T&gt; v) {
<span class="fc" id="L389">        final int n = v.getDimension();</span>
<span class="fc" id="L390">        SparseFieldMatrix&lt;T&gt; res = new SparseFieldMatrix&lt;&gt;(field, virtualSize, n);</span>
<span class="fc" id="L391">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = entries.iterator();</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L393">            iter.advance();</span>
<span class="fc" id="L394">            OpenIntToFieldHashMap&lt;T&gt;.Iterator iter2 = v.entries.iterator();</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
<span class="fc" id="L396">                iter2.advance();</span>
<span class="fc" id="L397">                res.setEntry(iter.key(), iter2.key(), iter.value().multiply(iter2.value()));</span>
            }
<span class="fc" id="L399">        }</span>
<span class="fc" id="L400">        return res;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldMatrix&lt;T&gt; outerProduct(FieldVector&lt;T&gt; v) {
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (v instanceof SparseFieldVector&lt;?&gt;) {</span>
<span class="nc" id="L407">            return outerProduct((SparseFieldVector&lt;T&gt;)v);</span>
        } else {
<span class="fc" id="L409">            final int n = v.getDimension();</span>
<span class="fc" id="L410">            FieldMatrix&lt;T&gt; res = new SparseFieldMatrix&lt;&gt;(field, virtualSize, n);</span>
<span class="fc" id="L411">            OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = entries.iterator();</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L413">                iter.advance();</span>
<span class="fc" id="L414">                int row = iter.key();</span>
<span class="fc" id="L415">                FieldElement&lt;T&gt;value = iter.value();</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">                for (int col = 0; col &lt; n; col++) {</span>
<span class="fc" id="L417">                    res.setEntry(row, col, value.multiply(v.getEntry(col)));</span>
                }
<span class="fc" id="L419">            }</span>
<span class="fc" id="L420">            return res;</span>
        }
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; projection(FieldVector&lt;T&gt; v)
        throws DimensionMismatchException, MathArithmeticException {
<span class="nc" id="L428">        checkVectorDimensions(v.getDimension());</span>
<span class="nc" id="L429">        return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));</span>
    }

    /** {@inheritDoc}
     * @exception NullArgumentException if value is null
     */
    @Override
    public void set(T value) {
<span class="nc" id="L437">        MathUtils.checkNotNull(value);</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">        for (int i = 0; i &lt; virtualSize; i++) {</span>
<span class="nc" id="L439">            setEntry(i, value);</span>
        }
<span class="nc" id="L441">    }</span>

    /** {@inheritDoc}
     * @exception NullArgumentException if value is null
     */
    @Override
    public void setEntry(int index, T value) throws NullArgumentException, OutOfRangeException {
<span class="fc" id="L448">        MathUtils.checkNotNull(value);</span>
<span class="fc" id="L449">        checkIndex(index);</span>
<span class="fc" id="L450">        entries.put(index, value);</span>
<span class="fc" id="L451">    }</span>

    /** {@inheritDoc} */
    @Override
    public void setSubVector(int index, FieldVector&lt;T&gt; v)
        throws OutOfRangeException {
<span class="nc" id="L457">        checkIndex(index);</span>
<span class="nc" id="L458">        checkIndex(index + v.getDimension() - 1);</span>
<span class="nc" id="L459">        final int n = v.getDimension();</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L461">            setEntry(i + index, v.getEntry(i));</span>
        }
<span class="nc" id="L463">    }</span>

    /**
     * Optimized method to compute {@code this} minus {@code v}.
     * @param v vector to be subtracted
     * @return {@code this - v}
     * @throws DimensionMismatchException if {@code v} is not the same size as
     * {@code this}.
     */
    public SparseFieldVector&lt;T&gt; subtract(SparseFieldVector&lt;T&gt; v)
        throws DimensionMismatchException {
<span class="fc" id="L474">        checkVectorDimensions(v.getDimension());</span>
<span class="fc" id="L475">        SparseFieldVector&lt;T&gt; res = (SparseFieldVector&lt;T&gt;)copy();</span>
<span class="fc" id="L476">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = v.getEntries().iterator();</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L478">            iter.advance();</span>
<span class="fc" id="L479">            int key = iter.key();</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">            if (entries.containsKey(key)) {</span>
<span class="fc" id="L481">                res.setEntry(key, entries.get(key).subtract(iter.value()));</span>
            } else {
<span class="nc" id="L483">                res.setEntry(key, field.getZero().subtract(iter.value()));</span>
            }
<span class="fc" id="L485">        }</span>
<span class="fc" id="L486">        return res;</span>
    }

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; subtract(FieldVector&lt;T&gt; v)
        throws DimensionMismatchException {
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">        if (v instanceof SparseFieldVector&lt;?&gt;) {</span>
<span class="nc" id="L494">            return subtract((SparseFieldVector&lt;T&gt;)v);</span>
        } else {
<span class="fc" id="L496">            final int n = v.getDimension();</span>
<span class="fc" id="L497">            checkVectorDimensions(n);</span>
<span class="fc" id="L498">            SparseFieldVector&lt;T&gt; res = new SparseFieldVector&lt;&gt;(this);</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">                if (entries.containsKey(i)) {</span>
<span class="fc" id="L501">                    res.setEntry(i, entries.get(i).subtract(v.getEntry(i)));</span>
                } else {
<span class="nc" id="L503">                    res.setEntry(i, field.getZero().subtract(v.getEntry(i)));</span>
                }
            }
<span class="fc" id="L506">            return res;</span>
        }
    }

    /** {@inheritDoc} */
    @Override
    public T[] toArray() {
<span class="fc" id="L513">        T[] res = MathArrays.buildArray(field, virtualSize);</span>
<span class="fc" id="L514">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = entries.iterator();</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L516">            iter.advance();</span>
<span class="fc" id="L517">            res[iter.key()] = iter.value();</span>
        }
<span class="fc" id="L519">        return res;</span>
    }

    /**
     * Check whether an index is valid.
     *
     * @param index Index to check.
     * @throws OutOfRangeException if the index is not valid.
     */
    private void checkIndex(final int index) throws OutOfRangeException {
<span class="pc bpc" id="L529" title="2 of 4 branches missed.">        if (index &lt; 0 || index &gt;= getDimension()) {</span>
<span class="nc" id="L530">            throw new OutOfRangeException(index, 0, getDimension() - 1);</span>
        }
<span class="fc" id="L532">    }</span>

    /**
     * Checks that the indices of a subvector are valid.
     *
     * @param start the index of the first entry of the subvector
     * @param end the index of the last entry of the subvector (inclusive)
     * @throws OutOfRangeException if {@code start} of {@code end} are not valid
     * @throws NumberIsTooSmallException if {@code end &lt; start}
     * @since 3.3
     */
    private void checkIndices(final int start, final int end)
        throws NumberIsTooSmallException, OutOfRangeException {
<span class="fc" id="L545">        final int dim = getDimension();</span>
<span class="fc bfc" id="L546" title="All 4 branches covered.">        if ((start &lt; 0) || (start &gt;= dim)) {</span>
<span class="fc" id="L547">            throw new OutOfRangeException(LocalizedFormats.INDEX, start, 0,</span>
<span class="fc" id="L548">                                          dim - 1);</span>
        }
<span class="fc bfc" id="L550" title="All 4 branches covered.">        if ((end &lt; 0) || (end &gt;= dim)) {</span>
<span class="fc" id="L551">            throw new OutOfRangeException(LocalizedFormats.INDEX, end, 0,</span>
<span class="fc" id="L552">                                          dim - 1);</span>
        }
<span class="fc bfc" id="L554" title="All 2 branches covered.">        if (end &lt; start) {</span>
<span class="fc" id="L555">            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,</span>
<span class="fc" id="L556">                                                end, start, false);</span>
        }
<span class="fc" id="L558">    }</span>

    /**
     * Check if instance dimension is equal to some expected value.
     *
     * @param n Expected dimension.
     * @throws DimensionMismatchException if the dimensions do not match.
     */
    protected void checkVectorDimensions(int n)
        throws DimensionMismatchException {
<span class="fc bfc" id="L568" title="All 2 branches covered.">        if (getDimension() != n) {</span>
<span class="fc" id="L569">            throw new DimensionMismatchException(getDimension(), n);</span>
        }
<span class="fc" id="L571">    }</span>

    /** {@inheritDoc} */
    @Override
    public FieldVector&lt;T&gt; add(FieldVector&lt;T&gt; v) throws DimensionMismatchException {
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">        if (v instanceof SparseFieldVector&lt;?&gt;) {</span>
<span class="nc" id="L577">            return add((SparseFieldVector&lt;T&gt;) v);</span>
        } else {
<span class="fc" id="L579">            final int n = v.getDimension();</span>
<span class="fc" id="L580">            checkVectorDimensions(n);</span>
<span class="fc" id="L581">            SparseFieldVector&lt;T&gt; res = new SparseFieldVector&lt;&gt;(field,</span>
<span class="fc" id="L582">                                                                getDimension());</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L584">                res.setEntry(i, v.getEntry(i).add(getEntry(i)));</span>
            }
<span class="fc" id="L586">            return res;</span>
        }
    }

    /**
     * Visits (but does not alter) all entries of this vector in default order
     * (increasing index).
     *
     * @param visitor the visitor to be used to process the entries of this
     * vector
     * @return the value returned by {@link FieldVectorPreservingVisitor#end()}
     * at the end of the walk
     * @since 3.3
     */
    public T walkInDefaultOrder(final FieldVectorPreservingVisitor&lt;T&gt; visitor) {
<span class="fc" id="L601">        final int dim = getDimension();</span>
<span class="fc" id="L602">        visitor.start(dim, 0, dim - 1);</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">        for (int i = 0; i &lt; dim; i++) {</span>
<span class="fc" id="L604">            visitor.visit(i, getEntry(i));</span>
        }
<span class="fc" id="L606">        return visitor.end();</span>
    }

    /**
     * Visits (but does not alter) some entries of this vector in default order
     * (increasing index).
     *
     * @param visitor visitor to be used to process the entries of this vector
     * @param start the index of the first entry to be visited
     * @param end the index of the last entry to be visited (inclusive)
     * @return the value returned by {@link FieldVectorPreservingVisitor#end()}
     * at the end of the walk
     * @throws NumberIsTooSmallException if {@code end &lt; start}.
     * @throws OutOfRangeException if the indices are not valid.
     * @since 3.3
     */
    public T walkInDefaultOrder(final FieldVectorPreservingVisitor&lt;T&gt; visitor,
                                final int start, final int end)
        throws NumberIsTooSmallException, OutOfRangeException {
<span class="fc" id="L625">        checkIndices(start, end);</span>
<span class="fc" id="L626">        visitor.start(getDimension(), start, end);</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">        for (int i = start; i &lt;= end; i++) {</span>
<span class="fc" id="L628">            visitor.visit(i, getEntry(i));</span>
        }
<span class="fc" id="L630">        return visitor.end();</span>
    }

    /**
     * Visits (but does not alter) all entries of this vector in optimized
     * order. The order in which the entries are visited is selected so as to
     * lead to the most efficient implementation; it might depend on the
     * concrete implementation of this abstract class.
     *
     * @param visitor the visitor to be used to process the entries of this
     * vector
     * @return the value returned by {@link FieldVectorPreservingVisitor#end()}
     * at the end of the walk
     * @since 3.3
     */
    public T walkInOptimizedOrder(final FieldVectorPreservingVisitor&lt;T&gt; visitor) {
<span class="fc" id="L646">        return walkInDefaultOrder(visitor);</span>
    }

    /**
     * Visits (but does not alter) some entries of this vector in optimized
     * order. The order in which the entries are visited is selected so as to
     * lead to the most efficient implementation; it might depend on the
     * concrete implementation of this abstract class.
     *
     * @param visitor visitor to be used to process the entries of this vector
     * @param start the index of the first entry to be visited
     * @param end the index of the last entry to be visited (inclusive)
     * @return the value returned by {@link FieldVectorPreservingVisitor#end()}
     * at the end of the walk
     * @throws NumberIsTooSmallException if {@code end &lt; start}.
     * @throws OutOfRangeException if the indices are not valid.
     * @since 3.3
     */
    public T walkInOptimizedOrder(final FieldVectorPreservingVisitor&lt;T&gt; visitor,
                                  final int start, final int end)
        throws NumberIsTooSmallException, OutOfRangeException {
<span class="fc" id="L667">        return walkInDefaultOrder(visitor, start, end);</span>
    }

    /**
     * Visits (and possibly alters) all entries of this vector in default order
     * (increasing index).
     *
     * @param visitor the visitor to be used to process and modify the entries
     * of this vector
     * @return the value returned by {@link FieldVectorChangingVisitor#end()}
     * at the end of the walk
     * @since 3.3
     */
    public T walkInDefaultOrder(final FieldVectorChangingVisitor&lt;T&gt; visitor) {
<span class="fc" id="L681">        final int dim = getDimension();</span>
<span class="fc" id="L682">        visitor.start(dim, 0, dim - 1);</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">        for (int i = 0; i &lt; dim; i++) {</span>
<span class="fc" id="L684">            setEntry(i, visitor.visit(i, getEntry(i)));</span>
        }
<span class="fc" id="L686">        return visitor.end();</span>
    }

    /**
     * Visits (and possibly alters) some entries of this vector in default order
     * (increasing index).
     *
     * @param visitor visitor to be used to process the entries of this vector
     * @param start the index of the first entry to be visited
     * @param end the index of the last entry to be visited (inclusive)
     * @return the value returned by {@link FieldVectorChangingVisitor#end()}
     * at the end of the walk
     * @throws NumberIsTooSmallException if {@code end &lt; start}.
     * @throws OutOfRangeException if the indices are not valid.
     * @since 3.3
     */
    public T walkInDefaultOrder(final FieldVectorChangingVisitor&lt;T&gt; visitor,
                                final int start, final int end)
        throws NumberIsTooSmallException, OutOfRangeException {
<span class="fc" id="L705">        checkIndices(start, end);</span>
<span class="fc" id="L706">        visitor.start(getDimension(), start, end);</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">        for (int i = start; i &lt;= end; i++) {</span>
<span class="fc" id="L708">            setEntry(i, visitor.visit(i, getEntry(i)));</span>
        }
<span class="fc" id="L710">        return visitor.end();</span>
    }

    /**
     * Visits (and possibly alters) all entries of this vector in optimized
     * order. The order in which the entries are visited is selected so as to
     * lead to the most efficient implementation; it might depend on the
     * concrete implementation of this abstract class.
     *
     * @param visitor the visitor to be used to process the entries of this
     * vector
     * @return the value returned by {@link FieldVectorChangingVisitor#end()}
     * at the end of the walk
     * @since 3.3
     */
    public T walkInOptimizedOrder(final FieldVectorChangingVisitor&lt;T&gt; visitor) {
<span class="fc" id="L726">        return walkInDefaultOrder(visitor);</span>
    }

    /**
     * Visits (and possibly change) some entries of this vector in optimized
     * order. The order in which the entries are visited is selected so as to
     * lead to the most efficient implementation; it might depend on the
     * concrete implementation of this abstract class.
     *
     * @param visitor visitor to be used to process the entries of this vector
     * @param start the index of the first entry to be visited
     * @param end the index of the last entry to be visited (inclusive)
     * @return the value returned by {@link FieldVectorChangingVisitor#end()}
     * at the end of the walk
     * @throws NumberIsTooSmallException if {@code end &lt; start}.
     * @throws OutOfRangeException if the indices are not valid.
     * @since 3.3
     */
    public T walkInOptimizedOrder(final FieldVectorChangingVisitor&lt;T&gt; visitor,
                                  final int start, final int end)
        throws NumberIsTooSmallException, OutOfRangeException {
<span class="fc" id="L747">        return walkInDefaultOrder(visitor, start, end);</span>
    }

    /** {@inheritDoc} */
    @Override
    public int hashCode() {
<span class="fc" id="L753">        final int prime = 31;</span>
<span class="fc" id="L754">        int result = 1;</span>
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">        result = prime * result + ((field == null) ? 0 : field.hashCode());</span>
<span class="fc" id="L756">        result = prime * result + virtualSize;</span>
<span class="fc" id="L757">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = entries.iterator();</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L759">            iter.advance();</span>
<span class="fc" id="L760">            int temp = iter.value().hashCode();</span>
<span class="fc" id="L761">            result = prime * result + temp;</span>
<span class="fc" id="L762">        }</span>
<span class="fc" id="L763">        return result;</span>
    }


    /** {@inheritDoc} */
    @Override
    public boolean equals(Object obj) {

<span class="pc bpc" id="L771" title="1 of 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L772">            return true;</span>
        }

<span class="pc bpc" id="L775" title="1 of 2 branches missed.">        if (!(obj instanceof SparseFieldVector&lt;?&gt;)) {</span>
<span class="nc" id="L776">            return false;</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;) // OK, because &quot;else if&quot; check below ensures that
                                       // other must be the same type as this
<span class="fc" id="L781">        SparseFieldVector&lt;T&gt; other = (SparseFieldVector&lt;T&gt;) obj;</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">        if (field == null) {</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">            if (other.field != null) {</span>
<span class="nc" id="L784">                return false;</span>
            }
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">        } else if (!field.equals(other.field)) {</span>
<span class="nc" id="L787">            return false;</span>
        }
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">        if (virtualSize != other.virtualSize) {</span>
<span class="nc" id="L790">            return false;</span>
        }

<span class="fc" id="L793">        OpenIntToFieldHashMap&lt;T&gt;.Iterator iter = entries.iterator();</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L795">            iter.advance();</span>
<span class="fc" id="L796">            T test = other.getEntry(iter.key());</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">            if (!test.equals(iter.value())) {</span>
<span class="nc" id="L798">                return false;</span>
            }
<span class="fc" id="L800">        }</span>
<span class="fc" id="L801">        iter = other.getEntries().iterator();</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L803">            iter.advance();</span>
<span class="fc" id="L804">            T test = iter.value();</span>
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">            if (!test.equals(getEntry(iter.key()))) {</span>
<span class="nc" id="L806">                return false;</span>
            }
<span class="fc" id="L808">        }</span>
<span class="fc" id="L809">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>