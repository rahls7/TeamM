<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeanUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-beans</a> &gt; <a href="index.source.html" class="el_package">org.springframework.beans</a> &gt; <span class="el_source">BeanUtils.java</span></div><h1>BeanUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.beans;

import java.beans.PropertyDescriptor;
import java.beans.PropertyEditor;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URI;
import java.net.URL;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import kotlin.jvm.JvmClassMappingKt;
import kotlin.reflect.KFunction;
import kotlin.reflect.KParameter;
import kotlin.reflect.full.KClasses;
import kotlin.reflect.jvm.ReflectJvmMapping;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.core.KotlinDetector;
import org.springframework.core.MethodParameter;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ConcurrentReferenceHashMap;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;

/**
 * Static convenience methods for JavaBeans: for instantiating beans,
 * checking bean property types, copying bean properties, etc.
 *
 * &lt;p&gt;Mainly for use within the framework, but to some degree also
 * useful for application classes.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Rob Harrop
 * @author Sam Brannen
 * @author Sebastien Deleuze
 */
<span class="nc" id="L66">public abstract class BeanUtils {</span>

<span class="fc" id="L68">	private static final Log logger = LogFactory.getLog(BeanUtils.class);</span>

<span class="fc" id="L70">	private static final Set&lt;Class&lt;?&gt;&gt; unknownEditorTypes =</span>
<span class="fc" id="L71">			Collections.newSetFromMap(new ConcurrentReferenceHashMap&lt;&gt;(64));</span>

	private static final Map&lt;Class&lt;?&gt;, Object&gt; DEFAULT_TYPE_VALUES;

	static {
<span class="fc" id="L76">		Map&lt;Class&lt;?&gt;, Object&gt; values = new HashMap&lt;&gt;();</span>
<span class="fc" id="L77">		values.put(boolean.class, false);</span>
<span class="fc" id="L78">		values.put(byte.class, (byte) 0);</span>
<span class="fc" id="L79">		values.put(short.class, (short) 0);</span>
<span class="fc" id="L80">		values.put(int.class, 0);</span>
<span class="fc" id="L81">		values.put(long.class, (long) 0);</span>
<span class="fc" id="L82">		DEFAULT_TYPE_VALUES = Collections.unmodifiableMap(values);</span>
<span class="fc" id="L83">	}</span>


	/**
	 * Convenience method to instantiate a class using its no-arg constructor.
	 * @param clazz class to instantiate
	 * @return the new instance
	 * @throws BeanInstantiationException if the bean cannot be instantiated
	 * @deprecated as of Spring 5.0, following the deprecation of
	 * {@link Class#newInstance()} in JDK 9
	 * @see Class#newInstance()
	 */
	@Deprecated
	public static &lt;T&gt; T instantiate(Class&lt;T&gt; clazz) throws BeanInstantiationException {
<span class="nc" id="L97">		Assert.notNull(clazz, &quot;Class must not be null&quot;);</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">		if (clazz.isInterface()) {</span>
<span class="nc" id="L99">			throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);</span>
		}
		try {
<span class="nc" id="L102">			return clazz.newInstance();</span>
		}
<span class="nc" id="L104">		catch (InstantiationException ex) {</span>
<span class="nc" id="L105">			throw new BeanInstantiationException(clazz, &quot;Is it an abstract class?&quot;, ex);</span>
		}
<span class="nc" id="L107">		catch (IllegalAccessException ex) {</span>
<span class="nc" id="L108">			throw new BeanInstantiationException(clazz, &quot;Is the constructor accessible?&quot;, ex);</span>
		}
	}

	/**
	 * Instantiate a class using its 'primary' constructor (for Kotlin classes,
	 * potentially having default arguments declared) or its default constructor
	 * (for regular Java classes, expecting a standard no-arg setup).
	 * &lt;p&gt;Note that this method tries to set the constructor accessible
	 * if given a non-accessible (that is, non-public) constructor.
	 * @param clazz the class to instantiate
	 * @return the new instance
	 * @throws BeanInstantiationException if the bean cannot be instantiated.
	 * The cause may notably indicate a {@link NoSuchMethodException} if no
	 * primary/default constructor was found, a {@link NoClassDefFoundError}
	 * or other {@link LinkageError} in case of an unresolvable class definition
	 * (e.g. due to a missing dependency at runtime), or an exception thrown
	 * from the constructor invocation itself.
	 * @see Constructor#newInstance
	 */
	public static &lt;T&gt; T instantiateClass(Class&lt;T&gt; clazz) throws BeanInstantiationException {
<span class="fc" id="L129">		Assert.notNull(clazz, &quot;Class must not be null&quot;);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">		if (clazz.isInterface()) {</span>
<span class="fc" id="L131">			throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);</span>
		}
		try {
<span class="fc" id="L134">			return instantiateClass(clazz.getDeclaredConstructor());</span>
		}
<span class="fc" id="L136">		catch (NoSuchMethodException ex) {</span>
<span class="fc" id="L137">			Constructor&lt;T&gt; ctor = findPrimaryConstructor(clazz);</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">			if (ctor != null) {</span>
<span class="nc" id="L139">				return instantiateClass(ctor);</span>
			}
<span class="fc" id="L141">			throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);</span>
		}
<span class="nc" id="L143">		catch (LinkageError err) {</span>
<span class="nc" id="L144">			throw new BeanInstantiationException(clazz, &quot;Unresolvable class definition&quot;, err);</span>
		}
	}

	/**
	 * Instantiate a class using its no-arg constructor and return the new instance
	 * as the specified assignable type.
	 * &lt;p&gt;Useful in cases where the type of the class to instantiate (clazz) is not
	 * available, but the type desired (assignableTo) is known.
	 * &lt;p&gt;Note that this method tries to set the constructor accessible if given a
	 * non-accessible (that is, non-public) constructor.
	 * @param clazz class to instantiate
	 * @param assignableTo type that clazz must be assignableTo
	 * @return the new instance
	 * @throws BeanInstantiationException if the bean cannot be instantiated
	 * @see Constructor#newInstance
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;T&gt; T instantiateClass(Class&lt;?&gt; clazz, Class&lt;T&gt; assignableTo) throws BeanInstantiationException {
<span class="nc" id="L163">		Assert.isAssignable(assignableTo, clazz);</span>
<span class="nc" id="L164">		return (T) instantiateClass(clazz);</span>
	}

	/**
	 * Convenience method to instantiate a class using the given constructor.
	 * &lt;p&gt;Note that this method tries to set the constructor accessible if given a
	 * non-accessible (that is, non-public) constructor, and supports Kotlin classes
	 * with optional parameters and default values.
	 * @param ctor the constructor to instantiate
	 * @param args the constructor arguments to apply (use {@code null} for an unspecified
	 * parameter, Kotlin optional parameters and Java primitive types are supported)
	 * @return the new instance
	 * @throws BeanInstantiationException if the bean cannot be instantiated
	 * @see Constructor#newInstance
	 */
	public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args) throws BeanInstantiationException {
<span class="fc" id="L180">		Assert.notNull(ctor, &quot;Constructor must not be null&quot;);</span>
		try {
<span class="fc" id="L182">			ReflectionUtils.makeAccessible(ctor);</span>
<span class="pc bpc" id="L183" title="1 of 4 branches missed.">			if (KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {</span>
<span class="fc" id="L184">				return KotlinDelegate.instantiateClass(ctor, args);</span>
			}
			else {
<span class="fc" id="L187">				Class&lt;?&gt;[] parameterTypes = ctor.getParameterTypes();</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">				Assert.isTrue(args.length &lt;= parameterTypes.length, &quot;Can't specify more arguments than constructor parameters&quot;);</span>
<span class="fc" id="L189">				Object[] argsWithDefaultValues = new Object[args.length];</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">				for (int i = 0 ; i &lt; args.length; i++) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">					if (args[i] == null) {</span>
<span class="fc" id="L192">						Class&lt;?&gt; parameterType = parameterTypes[i];</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">						argsWithDefaultValues[i] = (parameterType.isPrimitive() ? DEFAULT_TYPE_VALUES.get(parameterType) : null);</span>
<span class="fc" id="L194">					}</span>
					else {
<span class="fc" id="L196">						argsWithDefaultValues[i] = args[i];</span>
					}
				}
<span class="fc" id="L199">				return ctor.newInstance(argsWithDefaultValues);</span>
			}
		}
<span class="fc" id="L202">		catch (InstantiationException ex) {</span>
<span class="fc" id="L203">			throw new BeanInstantiationException(ctor, &quot;Is it an abstract class?&quot;, ex);</span>
		}
<span class="nc" id="L205">		catch (IllegalAccessException ex) {</span>
<span class="nc" id="L206">			throw new BeanInstantiationException(ctor, &quot;Is the constructor accessible?&quot;, ex);</span>
		}
<span class="fc" id="L208">		catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L209">			throw new BeanInstantiationException(ctor, &quot;Illegal arguments for constructor&quot;, ex);</span>
		}
<span class="fc" id="L211">		catch (InvocationTargetException ex) {</span>
<span class="fc" id="L212">			throw new BeanInstantiationException(ctor, &quot;Constructor threw exception&quot;, ex.getTargetException());</span>
		}
	}

	/**
	 * Return the primary constructor of the provided class. For Kotlin classes, this
	 * returns the Java constructor corresponding to the Kotlin primary constructor
	 * (as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin
	 * classes, this simply returns {@code null}.
	 * @param clazz the class to check
	 * @since 5.0
	 * @see &lt;a href=&quot;https://kotlinlang.org/docs/reference/classes.html#constructors&quot;&gt;Kotlin docs&lt;/a&gt;
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	@Nullable
	public static &lt;T&gt; Constructor&lt;T&gt; findPrimaryConstructor(Class&lt;T&gt; clazz) {
<span class="fc" id="L228">		Assert.notNull(clazz, &quot;Class must not be null&quot;);</span>
<span class="pc bpc" id="L229" title="1 of 4 branches missed.">		if (KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(clazz)) {</span>
<span class="fc" id="L230">			Constructor&lt;T&gt; kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz);</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">			if (kotlinPrimaryConstructor != null) {</span>
<span class="fc" id="L232">				return kotlinPrimaryConstructor;</span>
			}
		}
<span class="fc" id="L235">		return null;</span>
	}

	/**
	 * Find a method with the given method name and the given parameter types,
	 * declared on the given class or one of its superclasses. Prefers public methods,
	 * but will return a protected, package access, or private method too.
	 * &lt;p&gt;Checks {@code Class.getMethod} first, falling back to
	 * {@code findDeclaredMethod}. This allows to find public methods
	 * without issues even in environments with restricted Java security settings.
	 * @param clazz the class to check
	 * @param methodName the name of the method to find
	 * @param paramTypes the parameter types of the method to find
	 * @return the Method object, or {@code null} if not found
	 * @see Class#getMethod
	 * @see #findDeclaredMethod
	 */
	@Nullable
	public static Method findMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... paramTypes) {
		try {
<span class="fc" id="L255">			return clazz.getMethod(methodName, paramTypes);</span>
		}
<span class="fc" id="L257">		catch (NoSuchMethodException ex) {</span>
<span class="fc" id="L258">			return findDeclaredMethod(clazz, methodName, paramTypes);</span>
		}
	}

	/**
	 * Find a method with the given method name and the given parameter types,
	 * declared on the given class or one of its superclasses. Will return a public,
	 * protected, package access, or private method.
	 * &lt;p&gt;Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses.
	 * @param clazz the class to check
	 * @param methodName the name of the method to find
	 * @param paramTypes the parameter types of the method to find
	 * @return the Method object, or {@code null} if not found
	 * @see Class#getDeclaredMethod
	 */
	@Nullable
	public static Method findDeclaredMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... paramTypes) {
		try {
<span class="fc" id="L276">			return clazz.getDeclaredMethod(methodName, paramTypes);</span>
		}
<span class="fc" id="L278">		catch (NoSuchMethodException ex) {</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">			if (clazz.getSuperclass() != null) {</span>
<span class="fc" id="L280">				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes);</span>
			}
<span class="fc" id="L282">			return null;</span>
		}
	}

	/**
	 * Find a method with the given method name and minimal parameters (best case: none),
	 * declared on the given class or one of its superclasses. Prefers public methods,
	 * but will return a protected, package access, or private method too.
	 * &lt;p&gt;Checks {@code Class.getMethods} first, falling back to
	 * {@code findDeclaredMethodWithMinimalParameters}. This allows for finding public
	 * methods without issues even in environments with restricted Java security settings.
	 * @param clazz the class to check
	 * @param methodName the name of the method to find
	 * @return the Method object, or {@code null} if not found
	 * @throws IllegalArgumentException if methods of the given name were found but
	 * could not be resolved to a unique method with minimal parameters
	 * @see Class#getMethods
	 * @see #findDeclaredMethodWithMinimalParameters
	 */
	@Nullable
	public static Method findMethodWithMinimalParameters(Class&lt;?&gt; clazz, String methodName)
			throws IllegalArgumentException {

<span class="fc" id="L305">		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName);</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">		if (targetMethod == null) {</span>
<span class="fc" id="L307">			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName);</span>
		}
<span class="fc" id="L309">		return targetMethod;</span>
	}

	/**
	 * Find a method with the given method name and minimal parameters (best case: none),
	 * declared on the given class or one of its superclasses. Will return a public,
	 * protected, package access, or private method.
	 * &lt;p&gt;Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses.
	 * @param clazz the class to check
	 * @param methodName the name of the method to find
	 * @return the Method object, or {@code null} if not found
	 * @throws IllegalArgumentException if methods of the given name were found but
	 * could not be resolved to a unique method with minimal parameters
	 * @see Class#getDeclaredMethods
	 */
	@Nullable
	public static Method findDeclaredMethodWithMinimalParameters(Class&lt;?&gt; clazz, String methodName)
			throws IllegalArgumentException {

<span class="fc" id="L328">		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName);</span>
<span class="fc bfc" id="L329" title="All 4 branches covered.">		if (targetMethod == null &amp;&amp; clazz.getSuperclass() != null) {</span>
<span class="fc" id="L330">			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName);</span>
		}
<span class="fc" id="L332">		return targetMethod;</span>
	}

	/**
	 * Find a method with the given method name and minimal parameters (best case: none)
	 * in the given list of methods.
	 * @param methods the methods to check
	 * @param methodName the name of the method to find
	 * @return the Method object, or {@code null} if not found
	 * @throws IllegalArgumentException if methods of the given name were found but
	 * could not be resolved to a unique method with minimal parameters
	 */
	@Nullable
	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)
			throws IllegalArgumentException {

<span class="fc" id="L348">		Method targetMethod = null;</span>
<span class="fc" id="L349">		int numMethodsFoundWithCurrentMinimumArgs = 0;</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">		for (Method method : methods) {</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">			if (method.getName().equals(methodName)) {</span>
<span class="fc" id="L352">				int numParams = method.getParameterCount();</span>
<span class="pc bpc" id="L353" title="1 of 4 branches missed.">				if (targetMethod == null || numParams &lt; targetMethod.getParameterCount()) {</span>
<span class="fc" id="L354">					targetMethod = method;</span>
<span class="fc" id="L355">					numMethodsFoundWithCurrentMinimumArgs = 1;</span>
				}
<span class="pc bpc" id="L357" title="2 of 4 branches missed.">				else if (!method.isBridge() &amp;&amp; targetMethod.getParameterCount() == numParams) {</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">					if (targetMethod.isBridge()) {</span>
						// Prefer regular method over bridge...
<span class="fc" id="L360">						targetMethod = method;</span>
					}
					else {
						// Additional candidate with same length
<span class="nc" id="L364">						numMethodsFoundWithCurrentMinimumArgs++;</span>
					}
				}
			}
		}
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">		if (numMethodsFoundWithCurrentMinimumArgs &gt; 1) {</span>
<span class="nc" id="L370">			throw new IllegalArgumentException(&quot;Cannot resolve method '&quot; + methodName +</span>
					&quot;' to a unique method. Attempted to resolve to overloaded method with &quot; +
					&quot;the least number of parameters but there were &quot; +
					numMethodsFoundWithCurrentMinimumArgs + &quot; candidates.&quot;);
		}
<span class="fc" id="L375">		return targetMethod;</span>
	}

	/**
	 * Parse a method signature in the form {@code methodName[([arg_list])]},
	 * where {@code arg_list} is an optional, comma-separated list of fully-qualified
	 * type names, and attempts to resolve that signature against the supplied {@code Class}.
	 * &lt;p&gt;When not supplying an argument list ({@code methodName}) the method whose name
	 * matches and has the least number of parameters will be returned. When supplying an
	 * argument type list, only the method whose name and argument types match will be returned.
	 * &lt;p&gt;Note then that {@code methodName} and {@code methodName()} are &lt;strong&gt;not&lt;/strong&gt;
	 * resolved in the same way. The signature {@code methodName} means the method called
	 * {@code methodName} with the least number of arguments, whereas {@code methodName()}
	 * means the method called {@code methodName} with exactly 0 arguments.
	 * &lt;p&gt;If no method can be found, then {@code null} is returned.
	 * @param signature the method signature as String representation
	 * @param clazz the class to resolve the method signature against
	 * @return the resolved Method
	 * @see #findMethod
	 * @see #findMethodWithMinimalParameters
	 */
	@Nullable
	public static Method resolveSignature(String signature, Class&lt;?&gt; clazz) {
<span class="fc" id="L398">		Assert.hasText(signature, &quot;'signature' must not be empty&quot;);</span>
<span class="fc" id="L399">		Assert.notNull(clazz, &quot;Class must not be null&quot;);</span>
<span class="fc" id="L400">		int startParen = signature.indexOf('(');</span>
<span class="fc" id="L401">		int endParen = signature.indexOf(')');</span>
<span class="fc bfc" id="L402" title="All 4 branches covered.">		if (startParen &gt; -1 &amp;&amp; endParen == -1) {</span>
<span class="fc" id="L403">			throw new IllegalArgumentException(&quot;Invalid method signature '&quot; + signature +</span>
					&quot;': expected closing ')' for args list&quot;);
		}
<span class="fc bfc" id="L406" title="All 4 branches covered.">		else if (startParen == -1 &amp;&amp; endParen &gt; -1) {</span>
<span class="fc" id="L407">			throw new IllegalArgumentException(&quot;Invalid method signature '&quot; + signature +</span>
					&quot;': expected opening '(' for args list&quot;);
		}
<span class="fc bfc" id="L410" title="All 2 branches covered.">		else if (startParen == -1) {</span>
<span class="fc" id="L411">			return findMethodWithMinimalParameters(clazz, signature);</span>
		}
		else {
<span class="fc" id="L414">			String methodName = signature.substring(0, startParen);</span>
<span class="fc" id="L415">			String[] parameterTypeNames =</span>
<span class="fc" id="L416">					StringUtils.commaDelimitedListToStringArray(signature.substring(startParen + 1, endParen));</span>
<span class="fc" id="L417">			Class&lt;?&gt;[] parameterTypes = new Class&lt;?&gt;[parameterTypeNames.length];</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">			for (int i = 0; i &lt; parameterTypeNames.length; i++) {</span>
<span class="fc" id="L419">				String parameterTypeName = parameterTypeNames[i].trim();</span>
				try {
<span class="fc" id="L421">					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader());</span>
				}
<span class="nc" id="L423">				catch (Throwable ex) {</span>
<span class="nc" id="L424">					throw new IllegalArgumentException(&quot;Invalid method signature: unable to resolve type [&quot; +</span>
							parameterTypeName + &quot;] for argument &quot; + i + &quot;. Root cause: &quot; + ex);
<span class="fc" id="L426">				}</span>
			}
<span class="fc" id="L428">			return findMethod(clazz, methodName, parameterTypes);</span>
		}
	}


	/**
	 * Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class.
	 * @param clazz the Class to retrieve the PropertyDescriptors for
	 * @return an array of {@code PropertyDescriptors} for the given class
	 * @throws BeansException if PropertyDescriptor look fails
	 */
	public static PropertyDescriptor[] getPropertyDescriptors(Class&lt;?&gt; clazz) throws BeansException {
<span class="fc" id="L440">		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz);</span>
<span class="fc" id="L441">		return cr.getPropertyDescriptors();</span>
	}

	/**
	 * Retrieve the JavaBeans {@code PropertyDescriptors} for the given property.
	 * @param clazz the Class to retrieve the PropertyDescriptor for
	 * @param propertyName the name of the property
	 * @return the corresponding PropertyDescriptor, or {@code null} if none
	 * @throws BeansException if PropertyDescriptor lookup fails
	 */
	@Nullable
	public static PropertyDescriptor getPropertyDescriptor(Class&lt;?&gt; clazz, String propertyName)
			throws BeansException {

<span class="fc" id="L455">		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz);</span>
<span class="fc" id="L456">		return cr.getPropertyDescriptor(propertyName);</span>
	}

	/**
	 * Find a JavaBeans {@code PropertyDescriptor} for the given method,
	 * with the method either being the read method or the write method for
	 * that bean property.
	 * @param method the method to find a corresponding PropertyDescriptor for,
	 * introspecting its declaring class
	 * @return the corresponding PropertyDescriptor, or {@code null} if none
	 * @throws BeansException if PropertyDescriptor lookup fails
	 */
	@Nullable
	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {
<span class="nc" id="L470">		return findPropertyForMethod(method, method.getDeclaringClass());</span>
	}

	/**
	 * Find a JavaBeans {@code PropertyDescriptor} for the given method,
	 * with the method either being the read method or the write method for
	 * that bean property.
	 * @param method the method to find a corresponding PropertyDescriptor for
	 * @param clazz the (most specific) class to introspect for descriptors
	 * @return the corresponding PropertyDescriptor, or {@code null} if none
	 * @throws BeansException if PropertyDescriptor lookup fails
	 * @since 3.2.13
	 */
	@Nullable
	public static PropertyDescriptor findPropertyForMethod(Method method, Class&lt;?&gt; clazz) throws BeansException {
<span class="fc" id="L485">		Assert.notNull(method, &quot;Method must not be null&quot;);</span>
<span class="fc" id="L486">		PropertyDescriptor[] pds = getPropertyDescriptors(clazz);</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">		for (PropertyDescriptor pd : pds) {</span>
<span class="pc bpc" id="L488" title="1 of 4 branches missed.">			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {</span>
<span class="fc" id="L489">				return pd;</span>
			}
		}
<span class="fc" id="L492">		return null;</span>
	}

	/**
	 * Find a JavaBeans PropertyEditor following the 'Editor' suffix convention
	 * (e.g. &quot;mypackage.MyDomainClass&quot; -&gt; &quot;mypackage.MyDomainClassEditor&quot;).
	 * &lt;p&gt;Compatible to the standard JavaBeans convention as implemented by
	 * {@link java.beans.PropertyEditorManager} but isolated from the latter's
	 * registered default editors for primitive types.
	 * @param targetType the type to find an editor for
	 * @return the corresponding editor, or {@code null} if none found
	 */
	@Nullable
	public static PropertyEditor findEditorByConvention(@Nullable Class&lt;?&gt; targetType) {
<span class="pc bpc" id="L506" title="1 of 6 branches missed.">		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {</span>
<span class="fc" id="L507">			return null;</span>
		}
<span class="fc" id="L509">		ClassLoader cl = targetType.getClassLoader();</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">		if (cl == null) {</span>
			try {
<span class="fc" id="L512">				cl = ClassLoader.getSystemClassLoader();</span>
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">				if (cl == null) {</span>
<span class="nc" id="L514">					return null;</span>
				}
			}
<span class="nc" id="L517">			catch (Throwable ex) {</span>
				// e.g. AccessControlException on Google App Engine
<span class="nc bnc" id="L519" title="All 2 branches missed.">				if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L520">					logger.debug(&quot;Could not access system ClassLoader: &quot; + ex);</span>
				}
<span class="nc" id="L522">				return null;</span>
<span class="fc" id="L523">			}</span>
		}
<span class="fc" id="L525">		String editorName = targetType.getName() + &quot;Editor&quot;;</span>
		try {
<span class="fc" id="L527">			Class&lt;?&gt; editorClass = cl.loadClass(editorName);</span>
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">				if (logger.isInfoEnabled()) {</span>
<span class="nc" id="L530">					logger.info(&quot;Editor class [&quot; + editorName +</span>
							&quot;] does not implement [java.beans.PropertyEditor] interface&quot;);
				}
<span class="nc" id="L533">				unknownEditorTypes.add(targetType);</span>
<span class="nc" id="L534">				return null;</span>
			}
<span class="fc" id="L536">			return (PropertyEditor) instantiateClass(editorClass);</span>
		}
<span class="fc" id="L538">		catch (ClassNotFoundException ex) {</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">			if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L540">				logger.trace(&quot;No property editor [&quot; + editorName + &quot;] found for type &quot; +</span>
<span class="nc" id="L541">						targetType.getName() + &quot; according to 'Editor' suffix convention&quot;);</span>
			}
<span class="fc" id="L543">			unknownEditorTypes.add(targetType);</span>
<span class="fc" id="L544">			return null;</span>
		}
	}

	/**
	 * Determine the bean property type for the given property from the
	 * given classes/interfaces, if possible.
	 * @param propertyName the name of the bean property
	 * @param beanClasses the classes to check against
	 * @return the property type, or {@code Object.class} as fallback
	 */
	public static Class&lt;?&gt; findPropertyType(String propertyName, @Nullable Class&lt;?&gt;... beanClasses) {
<span class="nc bnc" id="L556" title="All 2 branches missed.">		if (beanClasses != null) {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">			for (Class&lt;?&gt; beanClass : beanClasses) {</span>
<span class="nc" id="L558">				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">				if (pd != null) {</span>
<span class="nc" id="L560">					return pd.getPropertyType();</span>
				}
			}
		}
<span class="nc" id="L564">		return Object.class;</span>
	}

	/**
	 * Obtain a new MethodParameter object for the write method of the
	 * specified property.
	 * @param pd the PropertyDescriptor for the property
	 * @return a corresponding MethodParameter object
	 */
	public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">		if (pd instanceof GenericTypeAwarePropertyDescriptor) {</span>
<span class="fc" id="L575">			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter());</span>
		}
		else {
<span class="nc" id="L578">			Method writeMethod = pd.getWriteMethod();</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">			Assert.state(writeMethod != null, &quot;No write method available&quot;);</span>
<span class="nc" id="L580">			return new MethodParameter(writeMethod, 0);</span>
		}
	}

	/**
	 * Check if the given type represents a &quot;simple&quot; property:
	 * a primitive, a String or other CharSequence, a Number, a Date,
	 * a URI, a URL, a Locale, a Class, or a corresponding array.
	 * &lt;p&gt;Used to determine properties to check for a &quot;simple&quot; dependency-check.
	 * @param clazz the type to check
	 * @return whether the given type represents a &quot;simple&quot; property
	 * @see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE
	 * @see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies
	 */
	public static boolean isSimpleProperty(Class&lt;?&gt; clazz) {
<span class="fc" id="L595">		Assert.notNull(clazz, &quot;Class must not be null&quot;);</span>
<span class="fc bfc" id="L596" title="All 6 branches covered.">		return isSimpleValueType(clazz) || (clazz.isArray() &amp;&amp; isSimpleValueType(clazz.getComponentType()));</span>
	}

	/**
	 * Check if the given type represents a &quot;simple&quot; value type:
	 * a primitive, an enum, a String or other CharSequence, a Number, a Date,
	 * a URI, a URL, a Locale or a Class.
	 * @param clazz the type to check
	 * @return whether the given type represents a &quot;simple&quot; value type
	 */
	public static boolean isSimpleValueType(Class&lt;?&gt; clazz) {
<span class="fc bfc" id="L607" title="All 2 branches covered.">		return (ClassUtils.isPrimitiveOrWrapper(clazz) ||</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">				Enum.class.isAssignableFrom(clazz) ||</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">				CharSequence.class.isAssignableFrom(clazz) ||</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">				Number.class.isAssignableFrom(clazz) ||</span>
<span class="pc bpc" id="L611" title="4 of 10 branches missed.">				Date.class.isAssignableFrom(clazz) ||</span>
				URI.class == clazz || URL.class == clazz ||
				Locale.class == clazz || Class.class == clazz);
	}


	/**
	 * Copy the property values of the given source bean into the target bean.
	 * &lt;p&gt;Note: The source and target classes do not have to match or even be derived
	 * from each other, as long as the properties match. Any bean properties that the
	 * source bean exposes but the target bean does not will silently be ignored.
	 * &lt;p&gt;This is just a convenience method. For more complex transfer needs,
	 * consider using a full BeanWrapper.
	 * @param source the source bean
	 * @param target the target bean
	 * @throws BeansException if the copying failed
	 * @see BeanWrapper
	 */
	public static void copyProperties(Object source, Object target) throws BeansException {
<span class="fc" id="L630">		copyProperties(source, target, null, (String[]) null);</span>
<span class="fc" id="L631">	}</span>

	/**
	 * Copy the property values of the given source bean into the given target bean,
	 * only setting properties defined in the given &quot;editable&quot; class (or interface).
	 * &lt;p&gt;Note: The source and target classes do not have to match or even be derived
	 * from each other, as long as the properties match. Any bean properties that the
	 * source bean exposes but the target bean does not will silently be ignored.
	 * &lt;p&gt;This is just a convenience method. For more complex transfer needs,
	 * consider using a full BeanWrapper.
	 * @param source the source bean
	 * @param target the target bean
	 * @param editable the class (or interface) to restrict property setting to
	 * @throws BeansException if the copying failed
	 * @see BeanWrapper
	 */
	public static void copyProperties(Object source, Object target, Class&lt;?&gt; editable) throws BeansException {
<span class="fc" id="L648">		copyProperties(source, target, editable, (String[]) null);</span>
<span class="fc" id="L649">	}</span>

	/**
	 * Copy the property values of the given source bean into the given target bean,
	 * ignoring the given &quot;ignoreProperties&quot;.
	 * &lt;p&gt;Note: The source and target classes do not have to match or even be derived
	 * from each other, as long as the properties match. Any bean properties that the
	 * source bean exposes but the target bean does not will silently be ignored.
	 * &lt;p&gt;This is just a convenience method. For more complex transfer needs,
	 * consider using a full BeanWrapper.
	 * @param source the source bean
	 * @param target the target bean
	 * @param ignoreProperties array of property names to ignore
	 * @throws BeansException if the copying failed
	 * @see BeanWrapper
	 */
	public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {
<span class="fc" id="L666">		copyProperties(source, target, null, ignoreProperties);</span>
<span class="fc" id="L667">	}</span>

	/**
	 * Copy the property values of the given source bean into the given target bean.
	 * &lt;p&gt;Note: The source and target classes do not have to match or even be derived
	 * from each other, as long as the properties match. Any bean properties that the
	 * source bean exposes but the target bean does not will silently be ignored.
	 * @param source the source bean
	 * @param target the target bean
	 * @param editable the class (or interface) to restrict property setting to
	 * @param ignoreProperties array of property names to ignore
	 * @throws BeansException if the copying failed
	 * @see BeanWrapper
	 */
	private static void copyProperties(Object source, Object target, @Nullable Class&lt;?&gt; editable,
			@Nullable String... ignoreProperties) throws BeansException {

<span class="fc" id="L684">		Assert.notNull(source, &quot;Source must not be null&quot;);</span>
<span class="fc" id="L685">		Assert.notNull(target, &quot;Target must not be null&quot;);</span>

<span class="fc" id="L687">		Class&lt;?&gt; actualEditable = target.getClass();</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">		if (editable != null) {</span>
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">			if (!editable.isInstance(target)) {</span>
<span class="nc" id="L690">				throw new IllegalArgumentException(&quot;Target class [&quot; + target.getClass().getName() +</span>
<span class="nc" id="L691">						&quot;] not assignable to Editable class [&quot; + editable.getName() + &quot;]&quot;);</span>
			}
<span class="fc" id="L693">			actualEditable = editable;</span>
		}
<span class="fc" id="L695">		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">		List&lt;String&gt; ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null);</span>

<span class="fc bfc" id="L698" title="All 2 branches covered.">		for (PropertyDescriptor targetPd : targetPds) {</span>
<span class="fc" id="L699">			Method writeMethod = targetPd.getWriteMethod();</span>
<span class="fc bfc" id="L700" title="All 6 branches covered.">			if (writeMethod != null &amp;&amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {</span>
<span class="fc" id="L701">				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">				if (sourcePd != null) {</span>
<span class="fc" id="L703">					Method readMethod = sourcePd.getReadMethod();</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">					if (readMethod != null &amp;&amp;</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {</span>
						try {
<span class="fc bfc" id="L707" title="All 2 branches covered.">							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {</span>
<span class="fc" id="L708">								readMethod.setAccessible(true);</span>
							}
<span class="fc" id="L710">							Object value = readMethod.invoke(source);</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {</span>
<span class="fc" id="L712">								writeMethod.setAccessible(true);</span>
							}
<span class="fc" id="L714">							writeMethod.invoke(target, value);</span>
						}
<span class="nc" id="L716">						catch (Throwable ex) {</span>
<span class="nc" id="L717">							throw new FatalBeanException(</span>
<span class="nc" id="L718">									&quot;Could not copy property '&quot; + targetPd.getName() + &quot;' from source to target&quot;, ex);</span>
<span class="fc" id="L719">						}</span>
					}
				}
			}
		}
<span class="fc" id="L724">	}</span>


	/**
	 * Inner class to avoid a hard dependency on Kotlin at runtime.
	 */
	private static class KotlinDelegate {

		/**
		 * Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any.
		 * @param clazz the {@link Class} of the Kotlin class
		 * @see &lt;a href=&quot;https://kotlinlang.org/docs/reference/classes.html#constructors&quot;&gt;
		 * https://kotlinlang.org/docs/reference/classes.html#constructors&lt;/a&gt;
		 */
		@Nullable
		public static &lt;T&gt; Constructor&lt;T&gt; findPrimaryConstructor(Class&lt;T&gt; clazz) {
			try {
<span class="fc" id="L741">				KFunction&lt;T&gt; primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz));</span>
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">				if (primaryCtor == null) {</span>
<span class="nc" id="L743">					return null;</span>
				}
<span class="fc" id="L745">				Constructor&lt;T&gt; constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor);</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">				if (constructor == null) {</span>
<span class="nc" id="L747">					throw new IllegalStateException(</span>
<span class="nc" id="L748">							&quot;Failed to find Java constructor for Kotlin primary constructor: &quot; + clazz.getName());</span>
				}
<span class="fc" id="L750">				return constructor;</span>
			}
<span class="nc" id="L752">			catch (UnsupportedOperationException ex) {</span>
<span class="nc" id="L753">				return null;</span>
			}
		}

		/**
		 * Instantiate a Kotlin class using the provided constructor.
		 * @param ctor the constructor of the Kotlin class to instantiate
		 * @param args the constructor arguments to apply
		 * (use {@code null} for unspecified parameter if needed)
		 */
		public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args)
				throws IllegalAccessException, InvocationTargetException, InstantiationException {

<span class="fc" id="L766">			KFunction&lt;T&gt; kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor);</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">			if (kotlinConstructor == null) {</span>
<span class="fc" id="L768">				return ctor.newInstance(args);</span>
			}
<span class="fc" id="L770">			List&lt;KParameter&gt; parameters = kotlinConstructor.getParameters();</span>
<span class="fc" id="L771">			Map&lt;KParameter, Object&gt; argParameters = new HashMap&lt;&gt;(parameters.size());</span>
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">			Assert.isTrue(args.length &lt;= parameters.size(),</span>
					&quot;Number of provided arguments should be less of equals than number of constructor parameters&quot;);
<span class="fc bfc" id="L774" title="All 2 branches covered.">			for (int i = 0 ; i &lt; args.length ; i++) {</span>
<span class="fc bfc" id="L775" title="All 4 branches covered.">				if (!(parameters.get(i).isOptional() &amp;&amp; args[i] == null)) {</span>
<span class="fc" id="L776">					argParameters.put(parameters.get(i), args[i]);</span>
				}
			}
<span class="fc" id="L779">			return kotlinConstructor.callBy(argParameters);</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>