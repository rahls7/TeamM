<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeDescriptor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-core</a> &gt; <a href="index.source.html" class="el_package">org.springframework.core.convert</a> &gt; <span class="el_source">TypeDescriptor.java</span></div><h1>TypeDescriptor.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.convert;

import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Field;
import java.lang.reflect.Type;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;

import org.springframework.core.MethodParameter;
import org.springframework.core.ResolvableType;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;

/**
 * Context about a type to convert from or to.
 *
 * @author Keith Donald
 * @author Andy Clement
 * @author Juergen Hoeller
 * @author Phillip Webb
 * @author Sam Brannen
 * @author Stephane Nicoll
 * @since 3.0
 */
@SuppressWarnings(&quot;serial&quot;)
public class TypeDescriptor implements Serializable {

<span class="fc" id="L52">	private static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];</span>

<span class="fc" id="L54">	private static final Map&lt;Class&lt;?&gt;, TypeDescriptor&gt; commonTypesCache = new HashMap&lt;&gt;(32);</span>

<span class="fc" id="L56">	private static final Class&lt;?&gt;[] CACHED_COMMON_TYPES = {</span>
			boolean.class, Boolean.class, byte.class, Byte.class, char.class, Character.class,
			double.class, Double.class, float.class, Float.class, int.class, Integer.class,
			long.class, Long.class, short.class, Short.class, String.class, Object.class};

	static {
<span class="fc bfc" id="L62" title="All 2 branches covered.">		for (Class&lt;?&gt; preCachedClass : CACHED_COMMON_TYPES) {</span>
<span class="fc" id="L63">			commonTypesCache.put(preCachedClass, valueOf(preCachedClass));</span>
		}
<span class="fc" id="L65">	}</span>


	private final Class&lt;?&gt; type;

	private final ResolvableType resolvableType;

	private final AnnotatedElementAdapter annotatedElement;


	/**
	 * Create a new type descriptor from a {@link MethodParameter}.
	 * &lt;p&gt;Use this constructor when a source or target conversion point is a
	 * constructor parameter, method parameter, or method return value.
	 * @param methodParameter the method parameter
	 */
<span class="fc" id="L81">	public TypeDescriptor(MethodParameter methodParameter) {</span>
<span class="fc" id="L82">		this.resolvableType = ResolvableType.forMethodParameter(methodParameter);</span>
<span class="fc" id="L83">		this.type = this.resolvableType.resolve(methodParameter.getNestedParameterType());</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?</span>
<span class="fc" id="L85">				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations());</span>
<span class="fc" id="L86">	}</span>

	/**
	 * Create a new type descriptor from a {@link Field}.
	 * &lt;p&gt;Use this constructor when a source or target conversion point is a field.
	 * @param field the field
	 */
<span class="fc" id="L93">	public TypeDescriptor(Field field) {</span>
<span class="fc" id="L94">		this.resolvableType = ResolvableType.forField(field);</span>
<span class="fc" id="L95">		this.type = this.resolvableType.resolve(field.getType());</span>
<span class="fc" id="L96">		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations());</span>
<span class="fc" id="L97">	}</span>

	/**
	 * Create a new type descriptor from a {@link Property}.
	 * &lt;p&gt;Use this constructor when a source or target conversion point is a
	 * property on a Java class.
	 * @param property the property
	 */
<span class="fc" id="L105">	public TypeDescriptor(Property property) {</span>
<span class="fc" id="L106">		Assert.notNull(property, &quot;Property must not be null&quot;);</span>
<span class="fc" id="L107">		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter());</span>
<span class="fc" id="L108">		this.type = this.resolvableType.resolve(property.getType());</span>
<span class="fc" id="L109">		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations());</span>
<span class="fc" id="L110">	}</span>

	/**
	 * Create a new type descriptor from a {@link ResolvableType}.
	 * &lt;p&gt;This constructor is used internally and may also be used by subclasses
	 * that support non-Java languages with extended type systems. It is public
	 * as of 5.1.4 whereas it was protected before.
	 * @param resolvableType the resolvable type
	 * @param type the backing type (or {@code null} if it should get resolved)
	 * @param annotations the type annotations
	 * @since 4.0
	 */
<span class="fc" id="L122">	public TypeDescriptor(ResolvableType resolvableType, @Nullable Class&lt;?&gt; type, @Nullable Annotation[] annotations) {</span>
<span class="fc" id="L123">		this.resolvableType = resolvableType;</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">		this.type = (type != null ? type : resolvableType.toClass());</span>
<span class="fc" id="L125">		this.annotatedElement = new AnnotatedElementAdapter(annotations);</span>
<span class="fc" id="L126">	}</span>


	/**
	 * Variation of {@link #getType()} that accounts for a primitive type by
	 * returning its object wrapper type.
	 * &lt;p&gt;This is useful for conversion service implementations that wish to
	 * normalize to object-based types and not work with primitive types directly.
	 */
	public Class&lt;?&gt; getObjectType() {
<span class="fc" id="L136">		return ClassUtils.resolvePrimitiveIfNecessary(getType());</span>
	}

	/**
	 * The type of the backing class, method parameter, field, or property
	 * described by this TypeDescriptor.
	 * &lt;p&gt;Returns primitive types as-is. See {@link #getObjectType()} for a
	 * variation of this operation that resolves primitive types to their
	 * corresponding Object types if necessary.
	 * @see #getObjectType()
	 */
	public Class&lt;?&gt; getType() {
<span class="fc" id="L148">		return this.type;</span>
	}

	/**
	 * Return the underlying {@link ResolvableType}.
	 * @since 4.0
	 */
	public ResolvableType getResolvableType() {
<span class="fc" id="L156">		return this.resolvableType;</span>
	}

	/**
	 * Return the underlying source of the descriptor. Will return a {@link Field},
	 * {@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}
	 * was constructed. This method is primarily to provide access to additional
	 * type information or meta-data that alternative JVM languages may provide.
	 * @since 4.0
	 */
	public Object getSource() {
<span class="fc" id="L167">		return this.resolvableType.getSource();</span>
	}

	/**
	 * Narrows this {@link TypeDescriptor} by setting its type to the class of the
	 * provided value.
	 * &lt;p&gt;If the value is {@code null}, no narrowing is performed and this TypeDescriptor
	 * is returned unchanged.
	 * &lt;p&gt;Designed to be called by binding frameworks when they read property, field,
	 * or method return values. Allows such frameworks to narrow a TypeDescriptor built
	 * from a declared property, field, or method return value type. For example, a field
	 * declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}
	 * if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor
	 * can then be used to convert the HashMap to some other type. Annotation and nested
	 * type context is preserved by the narrowed copy.
	 * @param value the value to use for narrowing this type descriptor
	 * @return this TypeDescriptor narrowed (returns a copy with its type updated to the
	 * class of the provided value)
	 */
	public TypeDescriptor narrow(@Nullable Object value) {
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">		if (value == null) {</span>
<span class="nc" id="L188">			return this;</span>
		}
<span class="fc" id="L190">		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType());</span>
<span class="fc" id="L191">		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations());</span>
	}

	/**
	 * Cast this {@link TypeDescriptor} to a superclass or implemented interface
	 * preserving annotations and nested type context.
	 * @param superType the super type to cast to (can be {@code null})
	 * @return a new TypeDescriptor for the up-cast type
	 * @throws IllegalArgumentException if this type is not assignable to the super-type
	 * @since 3.2
	 */
	@Nullable
	public TypeDescriptor upcast(@Nullable Class&lt;?&gt; superType) {
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">		if (superType == null) {</span>
<span class="nc" id="L205">			return null;</span>
		}
<span class="fc" id="L207">		Assert.isAssignable(superType, getType());</span>
<span class="fc" id="L208">		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations());</span>
	}

	/**
	 * Return the name of this type: the fully qualified class name.
	 */
	public String getName() {
<span class="fc" id="L215">		return ClassUtils.getQualifiedName(getType());</span>
	}

	/**
	 * Is this type a primitive type?
	 */
	public boolean isPrimitive() {
<span class="fc" id="L222">		return getType().isPrimitive();</span>
	}

	/**
	 * Return the annotations associated with this type descriptor, if any.
	 * @return the annotations, or an empty array if none
	 */
	public Annotation[] getAnnotations() {
<span class="fc" id="L230">		return this.annotatedElement.getAnnotations();</span>
	}

	/**
	 * Determine if this type descriptor has the specified annotation.
	 * &lt;p&gt;As of Spring Framework 4.2, this method supports arbitrary levels
	 * of meta-annotations.
	 * @param annotationType the annotation type
	 * @return &lt;tt&gt;true&lt;/tt&gt; if the annotation is present
	 */
	public boolean hasAnnotation(Class&lt;? extends Annotation&gt; annotationType) {
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">		if (this.annotatedElement.isEmpty()) {</span>
			// Shortcut: AnnotatedElementUtils would have to expect AnnotatedElement.getAnnotations()
			// to return a copy of the array, whereas we can do it more efficiently here.
<span class="nc" id="L244">			return false;</span>
		}
<span class="fc" id="L246">		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType);</span>
	}

	/**
	 * Obtain the annotation of the specified {@code annotationType} that is on this type descriptor.
	 * &lt;p&gt;As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations.
	 * @param annotationType the annotation type
	 * @return the annotation, or {@code null} if no such annotation exists on this type descriptor
	 */
	@Nullable
	public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationType) {
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">		if (this.annotatedElement.isEmpty()) {</span>
			// Shortcut: AnnotatedElementUtils would have to expect AnnotatedElement.getAnnotations()
			// to return a copy of the array, whereas we can do it more efficiently here.
<span class="nc" id="L260">			return null;</span>
		}
<span class="fc" id="L262">		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType);</span>
	}

	/**
	 * Returns true if an object of this type descriptor can be assigned to the location
	 * described by the given type descriptor.
	 * &lt;p&gt;For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}
	 * returns {@code true} because a String value can be assigned to a CharSequence variable.
	 * On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}
	 * returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers.
	 * &lt;p&gt;For arrays, collections, and maps, element and key/value types are checked if declared.
	 * For example, a List&amp;lt;String&amp;gt; field value is assignable to a Collection&amp;lt;CharSequence&amp;gt;
	 * field, but List&amp;lt;Number&amp;gt; is not assignable to List&amp;lt;Integer&amp;gt;.
	 * @return {@code true} if this type is assignable to the type represented by the provided
	 * type descriptor
	 * @see #getObjectType()
	 */
	public boolean isAssignableTo(TypeDescriptor typeDescriptor) {
<span class="fc" id="L280">		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType());</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">		if (!typesAssignable) {</span>
<span class="fc" id="L282">			return false;</span>
		}
<span class="fc bfc" id="L284" title="All 4 branches covered.">		if (isArray() &amp;&amp; typeDescriptor.isArray()) {</span>
<span class="fc" id="L285">			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor());</span>
		}
<span class="fc bfc" id="L287" title="All 4 branches covered.">		else if (isCollection() &amp;&amp; typeDescriptor.isCollection()) {</span>
<span class="fc" id="L288">			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor());</span>
		}
<span class="fc bfc" id="L290" title="All 4 branches covered.">		else if (isMap() &amp;&amp; typeDescriptor.isMap()) {</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &amp;&amp;</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor());</span>
		}
		else {
<span class="fc" id="L295">			return true;</span>
		}
	}

	private boolean isNestedAssignable(@Nullable TypeDescriptor nestedTypeDescriptor,
			@Nullable TypeDescriptor otherNestedTypeDescriptor) {

<span class="fc bfc" id="L302" title="All 4 branches covered.">		return (nestedTypeDescriptor == null || otherNestedTypeDescriptor == null ||</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">				nestedTypeDescriptor.isAssignableTo(otherNestedTypeDescriptor));</span>
	}

	/**
	 * Is this type a {@link Collection} type?
	 */
	public boolean isCollection() {
<span class="fc" id="L310">		return Collection.class.isAssignableFrom(getType());</span>
	}

	/**
	 * Is this type an array type?
	 */
	public boolean isArray() {
<span class="fc" id="L317">		return getType().isArray();</span>
	}

	/**
	 * If this type is an array, returns the array's component type.
	 * If this type is a {@code Stream}, returns the stream's component type.
	 * If this type is a {@link Collection} and it is parameterized, returns the Collection's element type.
	 * If the Collection is not parameterized, returns {@code null} indicating the element type is not declared.
	 * @return the array component type or Collection element type, or {@code null} if this type is a
	 * Collection but its element type is not parameterized
	 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
	 */
	@Nullable
	public TypeDescriptor getElementTypeDescriptor() {
<span class="fc bfc" id="L331" title="All 2 branches covered.">		if (getResolvableType().isArray()) {</span>
<span class="fc" id="L332">			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations());</span>
		}
<span class="fc bfc" id="L334" title="All 2 branches covered.">		if (Stream.class.isAssignableFrom(getType())) {</span>
<span class="fc" id="L335">			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0));</span>
		}
<span class="fc" id="L337">		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0));</span>
	}

	/**
	 * If this type is a {@link Collection} or an array, creates a element TypeDescriptor
	 * from the provided collection or array element.
	 * &lt;p&gt;Narrows the {@link #getElementTypeDescriptor() elementType} property to the class
	 * of the provided collection or array element. For example, if this describes a
	 * {@code java.util.List&amp;lt;java.lang.Number&amp;lt;} and the element argument is an
	 * {@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}.
	 * If this describes a {@code java.util.List&amp;lt;?&amp;gt;} and the element argument is an
	 * {@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}
	 * as well.
	 * &lt;p&gt;Annotation and nested type context will be preserved in the narrowed
	 * TypeDescriptor that is returned.
	 * @param element the collection or array element
	 * @return a element type descriptor, narrowed to the type of the provided element
	 * @throws IllegalStateException if this type is not a {@code java.util.Collection}
	 * or array type
	 * @see #narrow(Object)
	 */
	@Nullable
	public TypeDescriptor elementTypeDescriptor(Object element) {
<span class="fc" id="L360">		return narrow(element, getElementTypeDescriptor());</span>
	}

	/**
	 * Is this type a {@link Map} type?
	 */
	public boolean isMap() {
<span class="fc" id="L367">		return Map.class.isAssignableFrom(getType());</span>
	}

	/**
	 * If this type is a {@link Map} and its key type is parameterized,
	 * returns the map's key type. If the Map's key type is not parameterized,
	 * returns {@code null} indicating the key type is not declared.
	 * @return the Map key type, or {@code null} if this type is a Map
	 * but its key type is not parameterized
	 * @throws IllegalStateException if this type is not a {@code java.util.Map}
	 */
	@Nullable
	public TypeDescriptor getMapKeyTypeDescriptor() {
<span class="fc" id="L380">		Assert.state(isMap(), &quot;Not a [java.util.Map]&quot;);</span>
<span class="fc" id="L381">		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0));</span>
	}

	/**
	 * If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}
	 * from the provided map key.
	 * &lt;p&gt;Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property
	 * to the class of the provided map key. For example, if this describes a
	 * {@code java.util.Map&amp;lt;java.lang.Number, java.lang.String&amp;lt;} and the key
	 * argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be
	 * {@code java.lang.Integer}. If this describes a {@code java.util.Map&amp;lt;?, ?&amp;gt;}
	 * and the key argument is a {@code java.lang.Integer}, the returned
	 * TypeDescriptor will be {@code java.lang.Integer} as well.
	 * &lt;p&gt;Annotation and nested type context will be preserved in the narrowed
	 * TypeDescriptor that is returned.
	 * @param mapKey the map key
	 * @return the map key type descriptor
	 * @throws IllegalStateException if this type is not a {@code java.util.Map}
	 * @see #narrow(Object)
	 */
	@Nullable
	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {
<span class="fc" id="L403">		return narrow(mapKey, getMapKeyTypeDescriptor());</span>
	}

	/**
	 * If this type is a {@link Map} and its value type is parameterized,
	 * returns the map's value type.
	 * &lt;p&gt;If the Map's value type is not parameterized, returns {@code null}
	 * indicating the value type is not declared.
	 * @return the Map value type, or {@code null} if this type is a Map
	 * but its value type is not parameterized
	 * @throws IllegalStateException if this type is not a {@code java.util.Map}
	 */
	@Nullable
	public TypeDescriptor getMapValueTypeDescriptor() {
<span class="fc" id="L417">		Assert.state(isMap(), &quot;Not a [java.util.Map]&quot;);</span>
<span class="fc" id="L418">		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1));</span>
	}

	/**
	 * If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}
	 * from the provided map value.
	 * &lt;p&gt;Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property
	 * to the class of the provided map value. For example, if this describes a
	 * {@code java.util.Map&amp;lt;java.lang.String, java.lang.Number&amp;lt;} and the value
	 * argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be
	 * {@code java.lang.Integer}. If this describes a {@code java.util.Map&amp;lt;?, ?&amp;gt;}
	 * and the value argument is a {@code java.lang.Integer}, the returned
	 * TypeDescriptor will be {@code java.lang.Integer} as well.
	 * &lt;p&gt;Annotation and nested type context will be preserved in the narrowed
	 * TypeDescriptor that is returned.
	 * @param mapValue the map value
	 * @return the map value type descriptor
	 * @throws IllegalStateException if this type is not a {@code java.util.Map}
	 * @see #narrow(Object)
	 */
	@Nullable
	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {
<span class="fc" id="L440">		return narrow(mapValue, getMapValueTypeDescriptor());</span>
	}

	@Nullable
	private TypeDescriptor narrow(@Nullable Object value, @Nullable TypeDescriptor typeDescriptor) {
<span class="fc bfc" id="L445" title="All 2 branches covered.">		if (typeDescriptor != null) {</span>
<span class="fc" id="L446">			return typeDescriptor.narrow(value);</span>
		}
<span class="fc bfc" id="L448" title="All 2 branches covered.">		if (value != null) {</span>
<span class="fc" id="L449">			return narrow(value);</span>
		}
<span class="fc" id="L451">		return null;</span>
	}

	@Override
	public boolean equals(Object other) {
<span class="fc bfc" id="L456" title="All 2 branches covered.">		if (this == other) {</span>
<span class="fc" id="L457">			return true;</span>
		}
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">		if (!(other instanceof TypeDescriptor)) {</span>
<span class="nc" id="L460">			return false;</span>
		}
<span class="fc" id="L462">		TypeDescriptor otherDesc = (TypeDescriptor) other;</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">		if (getType() != otherDesc.getType()) {</span>
<span class="fc" id="L464">			return false;</span>
		}
<span class="fc bfc" id="L466" title="All 2 branches covered.">		if (!annotationsMatch(otherDesc)) {</span>
<span class="fc" id="L467">			return false;</span>
		}
<span class="fc bfc" id="L469" title="All 4 branches covered.">		if (isCollection() || isArray()) {</span>
<span class="fc" id="L470">			return ObjectUtils.nullSafeEquals(getElementTypeDescriptor(), otherDesc.getElementTypeDescriptor());</span>
		}
<span class="fc bfc" id="L472" title="All 2 branches covered.">		else if (isMap()) {</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">			return (ObjectUtils.nullSafeEquals(getMapKeyTypeDescriptor(), otherDesc.getMapKeyTypeDescriptor()) &amp;&amp;</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">					ObjectUtils.nullSafeEquals(getMapValueTypeDescriptor(), otherDesc.getMapValueTypeDescriptor()));</span>
		}
		else {
<span class="fc" id="L477">			return true;</span>
		}
	}

	private boolean annotationsMatch(TypeDescriptor otherDesc) {
<span class="fc" id="L482">		Annotation[] anns = getAnnotations();</span>
<span class="fc" id="L483">		Annotation[] otherAnns = otherDesc.getAnnotations();</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">		if (anns == otherAnns) {</span>
<span class="fc" id="L485">			return true;</span>
		}
<span class="fc bfc" id="L487" title="All 2 branches covered.">		if (anns.length != otherAnns.length) {</span>
<span class="fc" id="L488">			return false;</span>
		}
<span class="fc bfc" id="L490" title="All 2 branches covered.">		if (anns.length &gt; 0) {</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">			for (int i = 0; i &lt; anns.length; i++) {</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">				if (!annotationEquals(anns[i], otherAnns[i])) {</span>
<span class="fc" id="L493">					return false;</span>
				}
			}
		}
<span class="fc" id="L497">		return true;</span>
	}

	private boolean annotationEquals(Annotation ann, Annotation otherAnn) {
		// Annotation.equals is reflective and pretty slow, so let's check identity and proxy type first.
<span class="pc bpc" id="L502" title="2 of 6 branches missed.">		return (ann == otherAnn || (ann.getClass() == otherAnn.getClass() &amp;&amp; ann.equals(otherAnn)));</span>
	}

	@Override
	public int hashCode() {
<span class="fc" id="L507">		return getType().hashCode();</span>
	}

	@Override
	public String toString() {
<span class="fc" id="L512">		StringBuilder builder = new StringBuilder();</span>
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">		for (Annotation ann : getAnnotations()) {</span>
<span class="nc" id="L514">			builder.append(&quot;@&quot;).append(ann.annotationType().getName()).append(' ');</span>
		}
<span class="fc" id="L516">		builder.append(getResolvableType().toString());</span>
<span class="fc" id="L517">		return builder.toString();</span>
	}


	/**
	 * Create a new type descriptor for an object.
	 * &lt;p&gt;Use this factory method to introspect a source object before asking the
	 * conversion system to convert it to some another type.
	 * &lt;p&gt;If the provided object is {@code null}, returns {@code null}, else calls
	 * {@link #valueOf(Class)} to build a TypeDescriptor from the object's class.
	 * @param source the source object
	 * @return the type descriptor
	 */
	@Nullable
	public static TypeDescriptor forObject(@Nullable Object source) {
<span class="fc bfc" id="L532" title="All 2 branches covered.">		return (source != null ? valueOf(source.getClass()) : null);</span>
	}

	/**
	 * Create a new type descriptor from the given type.
	 * &lt;p&gt;Use this to instruct the conversion system to convert an object to a
	 * specific target type, when no type location such as a method parameter or
	 * field is available to provide additional conversion context.
	 * &lt;p&gt;Generally prefer use of {@link #forObject(Object)} for constructing type
	 * descriptors from source objects, as it handles the {@code null} object case.
	 * @param type the class (may be {@code null} to indicate {@code Object.class})
	 * @return the corresponding type descriptor
	 */
	public static TypeDescriptor valueOf(@Nullable Class&lt;?&gt; type) {
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">		if (type == null) {</span>
<span class="nc" id="L547">			type = Object.class;</span>
		}
<span class="fc" id="L549">		TypeDescriptor desc = commonTypesCache.get(type);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null));</span>
	}

	/**
	 * Create a new type descriptor from a {@link java.util.Collection} type.
	 * &lt;p&gt;Useful for converting to typed Collections.
	 * &lt;p&gt;For example, a {@code List&lt;String&gt;} could be converted to a
	 * {@code List&lt;EmailAddress&gt;} by converting to a targetType built with this method.
	 * The method call to construct such a {@code TypeDescriptor} would look something
	 * like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class));}
	 * @param collectionType the collection type, which must implement {@link Collection}.
	 * @param elementTypeDescriptor a descriptor for the collection's element type,
	 * used to convert collection elements
	 * @return the collection type descriptor
	 */
	public static TypeDescriptor collection(Class&lt;?&gt; collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {
<span class="fc" id="L566">		Assert.notNull(collectionType, &quot;Collection type must not be null&quot;);</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">		if (!Collection.class.isAssignableFrom(collectionType)) {</span>
<span class="nc" id="L568">			throw new IllegalArgumentException(&quot;Collection type must be a [java.util.Collection]&quot;);</span>
		}
<span class="fc bfc" id="L570" title="All 2 branches covered.">		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null);</span>
<span class="fc" id="L571">		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null);</span>
	}

	/**
	 * Create a new type descriptor from a {@link java.util.Map} type.
	 * &lt;p&gt;Useful for converting to typed Maps.
	 * &lt;p&gt;For example, a Map&amp;lt;String, String&amp;gt; could be converted to a Map&amp;lt;Id, EmailAddress&amp;gt;
	 * by converting to a targetType built with this method:
	 * The method call to construct such a TypeDescriptor would look something like:
	 * &lt;pre class=&quot;code&quot;&gt;
	 * map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class));
	 * &lt;/pre&gt;
	 * @param mapType the map type, which must implement {@link Map}
	 * @param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys
	 * @param valueTypeDescriptor the map's value type, used to convert map values
	 * @return the map type descriptor
	 */
	public static TypeDescriptor map(Class&lt;?&gt; mapType, @Nullable TypeDescriptor keyTypeDescriptor,
			@Nullable TypeDescriptor valueTypeDescriptor) {

<span class="fc" id="L591">		Assert.notNull(mapType, &quot;Map type must not be null&quot;);</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">		if (!Map.class.isAssignableFrom(mapType)) {</span>
<span class="nc" id="L593">			throw new IllegalArgumentException(&quot;Map type must be a [java.util.Map]&quot;);</span>
		}
<span class="fc bfc" id="L595" title="All 2 branches covered.">		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null);</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null);</span>
<span class="fc" id="L597">		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null);</span>
	}

	/**
	 * Create a new type descriptor as an array of the specified type.
	 * &lt;p&gt;For example to create a {@code Map&lt;String,String&gt;[]} use:
	 * &lt;pre class=&quot;code&quot;&gt;
	 * TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)));
	 * &lt;/pre&gt;
	 * @param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}
	 * @return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}
	 * @since 3.2.1
	 */
	@Nullable
	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {
<span class="fc bfc" id="L612" title="All 2 branches covered.">		if (elementTypeDescriptor == null) {</span>
<span class="fc" id="L613">			return null;</span>
		}
<span class="fc" id="L615">		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),</span>
<span class="fc" id="L616">				null, elementTypeDescriptor.getAnnotations());</span>
	}

	/**
	 * Create a type descriptor for a nested type declared within the method parameter.
	 * &lt;p&gt;For example, if the methodParameter is a {@code List&lt;String&gt;} and the
	 * nesting level is 1, the nested type descriptor will be String.class.
	 * &lt;p&gt;If the methodParameter is a {@code List&lt;List&lt;String&gt;&gt;} and the nesting
	 * level is 2, the nested type descriptor will also be a String.class.
	 * &lt;p&gt;If the methodParameter is a {@code Map&lt;Integer, String&gt;} and the nesting
	 * level is 1, the nested type descriptor will be String, derived from the map value.
	 * &lt;p&gt;If the methodParameter is a {@code List&lt;Map&lt;Integer, String&gt;&gt;} and the
	 * nesting level is 2, the nested type descriptor will be String, derived from the map value.
	 * &lt;p&gt;Returns {@code null} if a nested type cannot be obtained because it was not declared.
	 * For example, if the method parameter is a {@code List&lt;?&gt;}, the nested type
	 * descriptor returned will be {@code null}.
	 * @param methodParameter the method parameter with a nestingLevel of 1
	 * @param nestingLevel the nesting level of the collection/array element or
	 * map key/value declaration within the method parameter
	 * @return the nested type descriptor at the specified nesting level,
	 * or {@code null} if it could not be obtained
	 * @throws IllegalArgumentException if the nesting level of the input
	 * {@link MethodParameter} argument is not 1, or if the types up to the
	 * specified nesting level are not of collection, array, or map types
	 */
	@Nullable
	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {
<span class="fc bfc" id="L643" title="All 2 branches covered.">		if (methodParameter.getNestingLevel() != 1) {</span>
<span class="fc" id="L644">			throw new IllegalArgumentException(&quot;MethodParameter nesting level must be 1: &quot; +</span>
					&quot;use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal&quot;);
		}
<span class="fc" id="L647">		return nested(new TypeDescriptor(methodParameter), nestingLevel);</span>
	}

	/**
	 * Create a type descriptor for a nested type declared within the field.
	 * &lt;p&gt;For example, if the field is a {@code List&lt;String&gt;} and the nesting
	 * level is 1, the nested type descriptor will be {@code String.class}.
	 * &lt;p&gt;If the field is a {@code List&lt;List&lt;String&gt;&gt;} and the nesting level is
	 * 2, the nested type descriptor will also be a {@code String.class}.
	 * &lt;p&gt;If the field is a {@code Map&lt;Integer, String&gt;} and the nesting level
	 * is 1, the nested type descriptor will be String, derived from the map value.
	 * &lt;p&gt;If the field is a {@code List&lt;Map&lt;Integer, String&gt;&gt;} and the nesting
	 * level is 2, the nested type descriptor will be String, derived from the map value.
	 * &lt;p&gt;Returns {@code null} if a nested type cannot be obtained because it was not
	 * declared. For example, if the field is a {@code List&lt;?&gt;}, the nested type
	 * descriptor returned will be {@code null}.
	 * @param field the field
	 * @param nestingLevel the nesting level of the collection/array element or
	 * map key/value declaration within the field
	 * @return the nested type descriptor at the specified nesting level,
	 * or {@code null} if it could not be obtained
	 * @throws IllegalArgumentException if the types up to the specified nesting
	 * level are not of collection, array, or map types
	 */
	@Nullable
	public static TypeDescriptor nested(Field field, int nestingLevel) {
<span class="fc" id="L673">		return nested(new TypeDescriptor(field), nestingLevel);</span>
	}

	/**
	 * Create a type descriptor for a nested type declared within the property.
	 * &lt;p&gt;For example, if the property is a {@code List&lt;String&gt;} and the nesting
	 * level is 1, the nested type descriptor will be {@code String.class}.
	 * &lt;p&gt;If the property is a {@code List&lt;List&lt;String&gt;&gt;} and the nesting level
	 * is 2, the nested type descriptor will also be a {@code String.class}.
	 * &lt;p&gt;If the property is a {@code Map&lt;Integer, String&gt;} and the nesting level
	 * is 1, the nested type descriptor will be String, derived from the map value.
	 * &lt;p&gt;If the property is a {@code List&lt;Map&lt;Integer, String&gt;&gt;} and the nesting
	 * level is 2, the nested type descriptor will be String, derived from the map value.
	 * &lt;p&gt;Returns {@code null} if a nested type cannot be obtained because it was not
	 * declared. For example, if the property is a {@code List&lt;?&gt;}, the nested type
	 * descriptor returned will be {@code null}.
	 * @param property the property
	 * @param nestingLevel the nesting level of the collection/array element or
	 * map key/value declaration within the property
	 * @return the nested type descriptor at the specified nesting level, or
	 * {@code null} if it could not be obtained
	 * @throws IllegalArgumentException if the types up to the specified nesting
	 * level are not of collection, array, or map types
	 */
	@Nullable
	public static TypeDescriptor nested(Property property, int nestingLevel) {
<span class="fc" id="L699">		return nested(new TypeDescriptor(property), nestingLevel);</span>
	}

	@Nullable
	private static TypeDescriptor nested(TypeDescriptor typeDescriptor, int nestingLevel) {
<span class="fc" id="L704">		ResolvableType nested = typeDescriptor.resolvableType;</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">		for (int i = 0; i &lt; nestingLevel; i++) {</span>
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">			if (Object.class == nested.getType()) {</span>
				// Could be a collection type but we don't know about its element type,
				// so let's just assume there is an element type of type Object...
			}
			else {
<span class="fc" id="L711">				nested = nested.getNested(2);</span>
			}
		}
<span class="fc bfc" id="L714" title="All 2 branches covered.">		if (nested == ResolvableType.NONE) {</span>
<span class="fc" id="L715">			return null;</span>
		}
<span class="fc" id="L717">		return getRelatedIfResolvable(typeDescriptor, nested);</span>
	}

	@Nullable
	private static TypeDescriptor getRelatedIfResolvable(TypeDescriptor source, ResolvableType type) {
<span class="fc bfc" id="L722" title="All 2 branches covered.">		if (type.resolve() == null) {</span>
<span class="fc" id="L723">			return null;</span>
		}
<span class="fc" id="L725">		return new TypeDescriptor(type, null, source.getAnnotations());</span>
	}


	/**
	 * Adapter class for exposing a {@code TypeDescriptor}'s annotations as an
	 * {@link AnnotatedElement}, in particular to {@link AnnotatedElementUtils}.
	 * @see AnnotatedElementUtils#isAnnotated(AnnotatedElement, Class)
	 * @see AnnotatedElementUtils#getMergedAnnotation(AnnotatedElement, Class)
	 */
	private class AnnotatedElementAdapter implements AnnotatedElement, Serializable {

		@Nullable
		private final Annotation[] annotations;

<span class="fc" id="L740">		public AnnotatedElementAdapter(@Nullable Annotation[] annotations) {</span>
<span class="fc" id="L741">			this.annotations = annotations;</span>
<span class="fc" id="L742">		}</span>

		@Override
		public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
<span class="nc bnc" id="L746" title="All 2 branches missed.">			for (Annotation annotation : getAnnotations()) {</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">				if (annotation.annotationType() == annotationClass) {</span>
<span class="nc" id="L748">					return true;</span>
				}
			}
<span class="nc" id="L751">			return false;</span>
		}

		@Override
		@Nullable
		@SuppressWarnings(&quot;unchecked&quot;)
		public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="nc bnc" id="L758" title="All 2 branches missed.">			for (Annotation annotation : getAnnotations()) {</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">				if (annotation.annotationType() == annotationClass) {</span>
<span class="nc" id="L760">					return (T) annotation;</span>
				}
			}
<span class="nc" id="L763">			return null;</span>
		}

		@Override
		public Annotation[] getAnnotations() {
<span class="fc bfc" id="L768" title="All 2 branches covered.">			return (this.annotations != null ? this.annotations : EMPTY_ANNOTATION_ARRAY);</span>
		}

		@Override
		public Annotation[] getDeclaredAnnotations() {
<span class="fc" id="L773">			return getAnnotations();</span>
		}

		public boolean isEmpty() {
<span class="fc" id="L777">			return ObjectUtils.isEmpty(this.annotations);</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L782" title="All 4 branches missed.">			return (this == other || (other instanceof AnnotatedElementAdapter &amp;&amp;</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">					Arrays.equals(this.annotations, ((AnnotatedElementAdapter) other).annotations)));</span>
		}

		@Override
		public int hashCode() {
<span class="fc" id="L788">			return Arrays.hashCode(this.annotations);</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L793">			return TypeDescriptor.this.toString();</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>