<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Type.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-core</a> &gt; <a href="index.source.html" class="el_package">org.springframework.asm</a> &gt; <span class="el_source">Type.java</span></div><h1>Type.java</h1><pre class="source lang-java linenums">// ASM: a very small and fast Java bytecode manipulation framework
// Copyright (c) 2000-2011 INRIA, France Telecom
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.
package org.springframework.asm;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

/**
 * A Java field or method type. This class can be used to make it easier to manipulate type and
 * method descriptors.
 *
 * @author Eric Bruneton
 * @author Chris Nokleberg
 */
public final class Type {

  /** The sort of the {@code void} type. See {@link #getSort}. */
  public static final int VOID = 0;

  /** The sort of the {@code boolean} type. See {@link #getSort}. */
  public static final int BOOLEAN = 1;

  /** The sort of the {@code char} type. See {@link #getSort}. */
  public static final int CHAR = 2;

  /** The sort of the {@code byte} type. See {@link #getSort}. */
  public static final int BYTE = 3;

  /** The sort of the {@code short} type. See {@link #getSort}. */
  public static final int SHORT = 4;

  /** The sort of the {@code int} type. See {@link #getSort}. */
  public static final int INT = 5;

  /** The sort of the {@code float} type. See {@link #getSort}. */
  public static final int FLOAT = 6;

  /** The sort of the {@code long} type. See {@link #getSort}. */
  public static final int LONG = 7;

  /** The sort of the {@code double} type. See {@link #getSort}. */
  public static final int DOUBLE = 8;

  /** The sort of array reference types. See {@link #getSort}. */
  public static final int ARRAY = 9;

  /** The sort of object reference types. See {@link #getSort}. */
  public static final int OBJECT = 10;

  /** The sort of method types. See {@link #getSort}. */
  public static final int METHOD = 11;

  /** The (private) sort of object reference types represented with an internal name. */
  private static final int INTERNAL = 12;

  /** The descriptors of the primitive types. */
  private static final String PRIMITIVE_DESCRIPTORS = &quot;VZCBSIFJD&quot;;

  /** The {@code void} type. */
<span class="fc" id="L85">  public static final Type VOID_TYPE = new Type(VOID, PRIMITIVE_DESCRIPTORS, VOID, VOID + 1);</span>

  /** The {@code boolean} type. */
<span class="fc" id="L88">  public static final Type BOOLEAN_TYPE =</span>
      new Type(BOOLEAN, PRIMITIVE_DESCRIPTORS, BOOLEAN, BOOLEAN + 1);

  /** The {@code char} type. */
<span class="fc" id="L92">  public static final Type CHAR_TYPE = new Type(CHAR, PRIMITIVE_DESCRIPTORS, CHAR, CHAR + 1);</span>

  /** The {@code byte} type. */
<span class="fc" id="L95">  public static final Type BYTE_TYPE = new Type(BYTE, PRIMITIVE_DESCRIPTORS, BYTE, BYTE + 1);</span>

  /** The {@code short} type. */
<span class="fc" id="L98">  public static final Type SHORT_TYPE = new Type(SHORT, PRIMITIVE_DESCRIPTORS, SHORT, SHORT + 1);</span>

  /** The {@code int} type. */
<span class="fc" id="L101">  public static final Type INT_TYPE = new Type(INT, PRIMITIVE_DESCRIPTORS, INT, INT + 1);</span>

  /** The {@code float} type. */
<span class="fc" id="L104">  public static final Type FLOAT_TYPE = new Type(FLOAT, PRIMITIVE_DESCRIPTORS, FLOAT, FLOAT + 1);</span>

  /** The {@code long} type. */
<span class="fc" id="L107">  public static final Type LONG_TYPE = new Type(LONG, PRIMITIVE_DESCRIPTORS, LONG, LONG + 1);</span>

  /** The {@code double} type. */
<span class="fc" id="L110">  public static final Type DOUBLE_TYPE =</span>
      new Type(DOUBLE, PRIMITIVE_DESCRIPTORS, DOUBLE, DOUBLE + 1);

  // -----------------------------------------------------------------------------------------------
  // Fields
  // -----------------------------------------------------------------------------------------------

  /**
   * The sort of this type. Either {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE},
   * {@link #SHORT}, {@link #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY},
   * {@link #OBJECT}, {@link #METHOD} or {@link #INTERNAL}.
   */
  private final int sort;

  /**
   * A buffer containing the value of this field or method type. This value is an internal name for
   * {@link #OBJECT} and {@link #INTERNAL} types, and a field or method descriptor in the other
   * cases.
   *
   * &lt;p&gt;For {@link #OBJECT} types, this field also contains the descriptor: the characters in
   * [{@link #valueBegin},{@link #valueEnd}) contain the internal name, and those in [{@link
   * #valueBegin} - 1, {@link #valueEnd} + 1) contain the descriptor.
   */
  private final String valueBuffer;

  /**
   * The beginning index, inclusive, of the value of this Java field or method type in {@link
   * #valueBuffer}. This value is an internal name for {@link #OBJECT} and {@link #INTERNAL} types,
   * and a field or method descriptor in the other cases.
   */
  private final int valueBegin;

  /**
   * The end index, exclusive, of the value of this Java field or method type in {@link
   * #valueBuffer}. This value is an internal name for {@link #OBJECT} and {@link #INTERNAL} types,
   * and a field or method descriptor in the other cases.
   */
  private final int valueEnd;

  /**
   * Constructs a reference type.
   *
   * @param sort the sort of this type, see {@link #sort}.
   * @param valueBuffer a buffer containing the value of this field or method type.
   * @param valueBegin the beginning index, inclusive, of the value of this field or method type in
   *     valueBuffer.
   * @param valueEnd the end index, exclusive, of the value of this field or method type in
   *     valueBuffer.
   */
<span class="fc" id="L159">  private Type(final int sort, final String valueBuffer, final int valueBegin, final int valueEnd) {</span>
<span class="fc" id="L160">    this.sort = sort;</span>
<span class="fc" id="L161">    this.valueBuffer = valueBuffer;</span>
<span class="fc" id="L162">    this.valueBegin = valueBegin;</span>
<span class="fc" id="L163">    this.valueEnd = valueEnd;</span>
<span class="fc" id="L164">  }</span>

  // -----------------------------------------------------------------------------------------------
  // Methods to get Type(s) from a descriptor, a reflected Method or Constructor, other types, etc.
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the {@link Type} corresponding to the given type descriptor.
   *
   * @param typeDescriptor a field or method type descriptor.
   * @return the {@link Type} corresponding to the given type descriptor.
   */
  public static Type getType(final String typeDescriptor) {
<span class="fc" id="L177">    return getTypeInternal(typeDescriptor, 0, typeDescriptor.length());</span>
  }

  /**
   * Returns the {@link Type} corresponding to the given class.
   *
   * @param clazz a class.
   * @return the {@link Type} corresponding to the given class.
   */
  public static Type getType(final Class&lt;?&gt; clazz) {
<span class="nc bnc" id="L187" title="All 2 branches missed.">    if (clazz.isPrimitive()) {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">      if (clazz == Integer.TYPE) {</span>
<span class="nc" id="L189">        return INT_TYPE;</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">      } else if (clazz == Void.TYPE) {</span>
<span class="nc" id="L191">        return VOID_TYPE;</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">      } else if (clazz == Boolean.TYPE) {</span>
<span class="nc" id="L193">        return BOOLEAN_TYPE;</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">      } else if (clazz == Byte.TYPE) {</span>
<span class="nc" id="L195">        return BYTE_TYPE;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">      } else if (clazz == Character.TYPE) {</span>
<span class="nc" id="L197">        return CHAR_TYPE;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">      } else if (clazz == Short.TYPE) {</span>
<span class="nc" id="L199">        return SHORT_TYPE;</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">      } else if (clazz == Double.TYPE) {</span>
<span class="nc" id="L201">        return DOUBLE_TYPE;</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">      } else if (clazz == Float.TYPE) {</span>
<span class="nc" id="L203">        return FLOAT_TYPE;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">      } else if (clazz == Long.TYPE) {</span>
<span class="nc" id="L205">        return LONG_TYPE;</span>
      } else {
<span class="nc" id="L207">        throw new AssertionError();</span>
      }
    } else {
<span class="nc" id="L210">      return getType(getDescriptor(clazz));</span>
    }
  }

  /**
   * Returns the method {@link Type} corresponding to the given constructor.
   *
   * @param constructor a {@link Constructor} object.
   * @return the method {@link Type} corresponding to the given constructor.
   */
  public static Type getType(final Constructor&lt;?&gt; constructor) {
<span class="nc" id="L221">    return getType(getConstructorDescriptor(constructor));</span>
  }

  /**
   * Returns the method {@link Type} corresponding to the given method.
   *
   * @param method a {@link Method} object.
   * @return the method {@link Type} corresponding to the given method.
   */
  public static Type getType(final Method method) {
<span class="nc" id="L231">    return getType(getMethodDescriptor(method));</span>
  }

  /**
   * Returns the type of the elements of this array type. This method should only be used for an
   * array type.
   *
   * @return Returns the type of the elements of this array type.
   */
  public Type getElementType() {
<span class="nc" id="L241">    final int numDimensions = getDimensions();</span>
<span class="nc" id="L242">    return getTypeInternal(valueBuffer, valueBegin + numDimensions, valueEnd);</span>
  }

  /**
   * Returns the {@link Type} corresponding to the given internal name.
   *
   * @param internalName an internal name.
   * @return the {@link Type} corresponding to the given internal name.
   */
  public static Type getObjectType(final String internalName) {
<span class="fc" id="L252">    return new Type(</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        internalName.charAt(0) == '[' ? ARRAY : INTERNAL, internalName, 0, internalName.length());</span>
  }

  /**
   * Returns the {@link Type} corresponding to the given method descriptor. Equivalent to &lt;code&gt;
   * Type.getType(methodDescriptor)&lt;/code&gt;.
   *
   * @param methodDescriptor a method descriptor.
   * @return the {@link Type} corresponding to the given method descriptor.
   */
  public static Type getMethodType(final String methodDescriptor) {
<span class="nc" id="L264">    return new Type(METHOD, methodDescriptor, 0, methodDescriptor.length());</span>
  }

  /**
   * Returns the method {@link Type} corresponding to the given argument and return types.
   *
   * @param returnType the return type of the method.
   * @param argumentTypes the argument types of the method.
   * @return the method {@link Type} corresponding to the given argument and return types.
   */
  public static Type getMethodType(final Type returnType, final Type... argumentTypes) {
<span class="nc" id="L275">    return getType(getMethodDescriptor(returnType, argumentTypes));</span>
  }

  /**
   * Returns the argument types of methods of this type. This method should only be used for method
   * types.
   *
   * @return the argument types of methods of this type.
   */
  public Type[] getArgumentTypes() {
<span class="nc" id="L285">    return getArgumentTypes(getDescriptor());</span>
  }

  /**
   * Returns the {@link Type} values corresponding to the argument types of the given method
   * descriptor.
   *
   * @param methodDescriptor a method descriptor.
   * @return the {@link Type} values corresponding to the argument types of the given method
   *     descriptor.
   */
  public static Type[] getArgumentTypes(final String methodDescriptor) {
    // First step: compute the number of argument types in methodDescriptor.
<span class="fc" id="L298">    int numArgumentTypes = 0;</span>
    // Skip the first character, which is always a '('.
<span class="fc" id="L300">    int currentOffset = 1;</span>
    // Parse the argument types, one at a each loop iteration.
<span class="fc bfc" id="L302" title="All 2 branches covered.">    while (methodDescriptor.charAt(currentOffset) != ')') {</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">      while (methodDescriptor.charAt(currentOffset) == '[') {</span>
<span class="nc" id="L304">        currentOffset++;</span>
      }
<span class="fc bfc" id="L306" title="All 2 branches covered.">      if (methodDescriptor.charAt(currentOffset++) == 'L') {</span>
        // Skip the argument descriptor content.
<span class="fc" id="L308">        currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;</span>
      }
<span class="fc" id="L310">      ++numArgumentTypes;</span>
    }

    // Second step: create a Type instance for each argument type.
<span class="fc" id="L314">    Type[] argumentTypes = new Type[numArgumentTypes];</span>
    // Skip the first character, which is always a '('.
<span class="fc" id="L316">    currentOffset = 1;</span>
    // Parse and create the argument types, one at each loop iteration.
<span class="fc" id="L318">    int currentArgumentTypeIndex = 0;</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">    while (methodDescriptor.charAt(currentOffset) != ')') {</span>
<span class="fc" id="L320">      final int currentArgumentTypeOffset = currentOffset;</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">      while (methodDescriptor.charAt(currentOffset) == '[') {</span>
<span class="nc" id="L322">        currentOffset++;</span>
      }
<span class="fc bfc" id="L324" title="All 2 branches covered.">      if (methodDescriptor.charAt(currentOffset++) == 'L') {</span>
        // Skip the argument descriptor content.
<span class="fc" id="L326">        currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;</span>
      }
<span class="fc" id="L328">      argumentTypes[currentArgumentTypeIndex++] =</span>
<span class="fc" id="L329">          getTypeInternal(methodDescriptor, currentArgumentTypeOffset, currentOffset);</span>
<span class="fc" id="L330">    }</span>
<span class="fc" id="L331">    return argumentTypes;</span>
  }

  /**
   * Returns the {@link Type} values corresponding to the argument types of the given method.
   *
   * @param method a method.
   * @return the {@link Type} values corresponding to the argument types of the given method.
   */
  public static Type[] getArgumentTypes(final Method method) {
<span class="nc" id="L341">    Class&lt;?&gt;[] classes = method.getParameterTypes();</span>
<span class="nc" id="L342">    Type[] types = new Type[classes.length];</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">    for (int i = classes.length - 1; i &gt;= 0; --i) {</span>
<span class="nc" id="L344">      types[i] = getType(classes[i]);</span>
    }
<span class="nc" id="L346">    return types;</span>
  }

  /**
   * Returns the return type of methods of this type. This method should only be used for method
   * types.
   *
   * @return the return type of methods of this type.
   */
  public Type getReturnType() {
<span class="nc" id="L356">    return getReturnType(getDescriptor());</span>
  }

  /**
   * Returns the {@link Type} corresponding to the return type of the given method descriptor.
   *
   * @param methodDescriptor a method descriptor.
   * @return the {@link Type} corresponding to the return type of the given method descriptor.
   */
  public static Type getReturnType(final String methodDescriptor) {
<span class="fc" id="L366">    return getTypeInternal(</span>
<span class="fc" id="L367">        methodDescriptor, getReturnTypeOffset(methodDescriptor), methodDescriptor.length());</span>
  }

  /**
   * Returns the {@link Type} corresponding to the return type of the given method.
   *
   * @param method a method.
   * @return the {@link Type} corresponding to the return type of the given method.
   */
  public static Type getReturnType(final Method method) {
<span class="nc" id="L377">    return getType(method.getReturnType());</span>
  }

  /**
   * Returns the start index of the return type of the given method descriptor.
   *
   * @param methodDescriptor a method descriptor.
   * @return the start index of the return type of the given method descriptor.
   */
  static int getReturnTypeOffset(final String methodDescriptor) {
    // Skip the first character, which is always a '('.
<span class="fc" id="L388">    int currentOffset = 1;</span>
    // Skip the argument types, one at a each loop iteration.
<span class="fc bfc" id="L390" title="All 2 branches covered.">    while (methodDescriptor.charAt(currentOffset) != ')') {</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">      while (methodDescriptor.charAt(currentOffset) == '[') {</span>
<span class="nc" id="L392">        currentOffset++;</span>
      }
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">      if (methodDescriptor.charAt(currentOffset++) == 'L') {</span>
        // Skip the argument descriptor content.
<span class="fc" id="L396">        currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;</span>
      }
    }
<span class="fc" id="L399">    return currentOffset + 1;</span>
  }

  /**
   * Returns the {@link Type} corresponding to the given field or method descriptor.
   *
   * @param descriptorBuffer a buffer containing the field or method descriptor.
   * @param descriptorBegin the beginning index, inclusive, of the field or method descriptor in
   *     descriptorBuffer.
   * @param descriptorEnd the end index, exclusive, of the field or method descriptor in
   *     descriptorBuffer.
   * @return the {@link Type} corresponding to the given type descriptor.
   */
  private static Type getTypeInternal(
      final String descriptorBuffer, final int descriptorBegin, final int descriptorEnd) {
<span class="pc bpc" id="L414" title="7 of 13 branches missed.">    switch (descriptorBuffer.charAt(descriptorBegin)) {</span>
      case 'V':
<span class="fc" id="L416">        return VOID_TYPE;</span>
      case 'Z':
<span class="fc" id="L418">        return BOOLEAN_TYPE;</span>
      case 'C':
<span class="nc" id="L420">        return CHAR_TYPE;</span>
      case 'B':
<span class="nc" id="L422">        return BYTE_TYPE;</span>
      case 'S':
<span class="nc" id="L424">        return SHORT_TYPE;</span>
      case 'I':
<span class="fc" id="L426">        return INT_TYPE;</span>
      case 'F':
<span class="nc" id="L428">        return FLOAT_TYPE;</span>
      case 'J':
<span class="fc" id="L430">        return LONG_TYPE;</span>
      case 'D':
<span class="fc" id="L432">        return DOUBLE_TYPE;</span>
      case '[':
<span class="nc" id="L434">        return new Type(ARRAY, descriptorBuffer, descriptorBegin, descriptorEnd);</span>
      case 'L':
<span class="fc" id="L436">        return new Type(OBJECT, descriptorBuffer, descriptorBegin + 1, descriptorEnd - 1);</span>
      case '(':
<span class="nc" id="L438">        return new Type(METHOD, descriptorBuffer, descriptorBegin, descriptorEnd);</span>
      default:
<span class="nc" id="L440">        throw new IllegalArgumentException();</span>
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Methods to get class names, internal names or descriptors.
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the binary name of the class corresponding to this type. This method must not be used
   * on method types.
   *
   * @return the binary name of the class corresponding to this type.
   */
  public String getClassName() {
<span class="pc bpc" id="L455" title="6 of 12 branches missed.">    switch (sort) {</span>
      case VOID:
<span class="fc" id="L457">        return &quot;void&quot;;</span>
      case BOOLEAN:
<span class="fc" id="L459">        return &quot;boolean&quot;;</span>
      case CHAR:
<span class="nc" id="L461">        return &quot;char&quot;;</span>
      case BYTE:
<span class="nc" id="L463">        return &quot;byte&quot;;</span>
      case SHORT:
<span class="nc" id="L465">        return &quot;short&quot;;</span>
      case INT:
<span class="fc" id="L467">        return &quot;int&quot;;</span>
      case FLOAT:
<span class="nc" id="L469">        return &quot;float&quot;;</span>
      case LONG:
<span class="fc" id="L471">        return &quot;long&quot;;</span>
      case DOUBLE:
<span class="fc" id="L473">        return &quot;double&quot;;</span>
      case ARRAY:
<span class="nc" id="L475">        StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName());</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">        for (int i = getDimensions(); i &gt; 0; --i) {</span>
<span class="nc" id="L477">          stringBuilder.append(&quot;[]&quot;);</span>
        }
<span class="nc" id="L479">        return stringBuilder.toString();</span>
      case OBJECT:
      case INTERNAL:
<span class="fc" id="L482">        return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.');</span>
      default:
<span class="nc" id="L484">        throw new AssertionError();</span>
    }
  }

  /**
   * Returns the internal name of the class corresponding to this object or array type. The internal
   * name of a class is its fully qualified name (as returned by Class.getName(), where '.' are
   * replaced by '/'). This method should only be used for an object or array type.
   *
   * @return the internal name of the class corresponding to this object type.
   */
  public String getInternalName() {
<span class="nc" id="L496">    return valueBuffer.substring(valueBegin, valueEnd);</span>
  }

  /**
   * Returns the internal name of the given class. The internal name of a class is its fully
   * qualified name, as returned by Class.getName(), where '.' are replaced by '/'.
   *
   * @param clazz an object or array class.
   * @return the internal name of the given class.
   */
  public static String getInternalName(final Class&lt;?&gt; clazz) {
<span class="nc" id="L507">    return clazz.getName().replace('.', '/');</span>
  }

  /**
   * Returns the descriptor corresponding to this type.
   *
   * @return the descriptor corresponding to this type.
   */
  public String getDescriptor() {
<span class="nc bnc" id="L516" title="All 2 branches missed.">    if (sort == OBJECT) {</span>
<span class="nc" id="L517">      return valueBuffer.substring(valueBegin - 1, valueEnd + 1);</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">    } else if (sort == INTERNAL) {</span>
<span class="nc" id="L519">      return 'L' + valueBuffer.substring(valueBegin, valueEnd) + ';';</span>
    } else {
<span class="nc" id="L521">      return valueBuffer.substring(valueBegin, valueEnd);</span>
    }
  }

  /**
   * Returns the descriptor corresponding to the given class.
   *
   * @param clazz an object class, a primitive class or an array class.
   * @return the descriptor corresponding to the given class.
   */
  public static String getDescriptor(final Class&lt;?&gt; clazz) {
<span class="nc" id="L532">    StringBuilder stringBuilder = new StringBuilder();</span>
<span class="nc" id="L533">    appendDescriptor(clazz, stringBuilder);</span>
<span class="nc" id="L534">    return stringBuilder.toString();</span>
  }

  /**
   * Returns the descriptor corresponding to the given constructor.
   *
   * @param constructor a {@link Constructor} object.
   * @return the descriptor of the given constructor.
   */
  public static String getConstructorDescriptor(final Constructor&lt;?&gt; constructor) {
<span class="nc" id="L544">    StringBuilder stringBuilder = new StringBuilder();</span>
<span class="nc" id="L545">    stringBuilder.append('(');</span>
<span class="nc" id="L546">    Class&lt;?&gt;[] parameters = constructor.getParameterTypes();</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">    for (Class&lt;?&gt; parameter : parameters) {</span>
<span class="nc" id="L548">      appendDescriptor(parameter, stringBuilder);</span>
    }
<span class="nc" id="L550">    return stringBuilder.append(&quot;)V&quot;).toString();</span>
  }

  /**
   * Returns the descriptor corresponding to the given argument and return types.
   *
   * @param returnType the return type of the method.
   * @param argumentTypes the argument types of the method.
   * @return the descriptor corresponding to the given argument and return types.
   */
  public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) {
<span class="nc" id="L561">    StringBuilder stringBuilder = new StringBuilder();</span>
<span class="nc" id="L562">    stringBuilder.append('(');</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">    for (Type argumentType : argumentTypes) {</span>
<span class="nc" id="L564">      argumentType.appendDescriptor(stringBuilder);</span>
    }
<span class="nc" id="L566">    stringBuilder.append(')');</span>
<span class="nc" id="L567">    returnType.appendDescriptor(stringBuilder);</span>
<span class="nc" id="L568">    return stringBuilder.toString();</span>
  }

  /**
   * Returns the descriptor corresponding to the given method.
   *
   * @param method a {@link Method} object.
   * @return the descriptor of the given method.
   */
  public static String getMethodDescriptor(final Method method) {
<span class="nc" id="L578">    StringBuilder stringBuilder = new StringBuilder();</span>
<span class="nc" id="L579">    stringBuilder.append('(');</span>
<span class="nc" id="L580">    Class&lt;?&gt;[] parameters = method.getParameterTypes();</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">    for (Class&lt;?&gt; parameter : parameters) {</span>
<span class="nc" id="L582">      appendDescriptor(parameter, stringBuilder);</span>
    }
<span class="nc" id="L584">    stringBuilder.append(')');</span>
<span class="nc" id="L585">    appendDescriptor(method.getReturnType(), stringBuilder);</span>
<span class="nc" id="L586">    return stringBuilder.toString();</span>
  }

  /**
   * Appends the descriptor corresponding to this type to the given string buffer.
   *
   * @param stringBuilder the string builder to which the descriptor must be appended.
   */
  private void appendDescriptor(final StringBuilder stringBuilder) {
<span class="nc bnc" id="L595" title="All 2 branches missed.">    if (sort == OBJECT) {</span>
<span class="nc" id="L596">      stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1);</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">    } else if (sort == INTERNAL) {</span>
<span class="nc" id="L598">      stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append(';');</span>
    } else {
<span class="nc" id="L600">      stringBuilder.append(valueBuffer, valueBegin, valueEnd);</span>
    }
<span class="nc" id="L602">  }</span>

  /**
   * Appends the descriptor of the given class to the given string builder.
   *
   * @param clazz the class whose descriptor must be computed.
   * @param stringBuilder the string builder to which the descriptor must be appended.
   */
  private static void appendDescriptor(final Class&lt;?&gt; clazz, final StringBuilder stringBuilder) {
<span class="nc" id="L611">    Class&lt;?&gt; currentClass = clazz;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">    while (currentClass.isArray()) {</span>
<span class="nc" id="L613">      stringBuilder.append('[');</span>
<span class="nc" id="L614">      currentClass = currentClass.getComponentType();</span>
    }
<span class="nc bnc" id="L616" title="All 2 branches missed.">    if (currentClass.isPrimitive()) {</span>
      char descriptor;
<span class="nc bnc" id="L618" title="All 2 branches missed.">      if (currentClass == Integer.TYPE) {</span>
<span class="nc" id="L619">        descriptor = 'I';</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">      } else if (currentClass == Void.TYPE) {</span>
<span class="nc" id="L621">        descriptor = 'V';</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">      } else if (currentClass == Boolean.TYPE) {</span>
<span class="nc" id="L623">        descriptor = 'Z';</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">      } else if (currentClass == Byte.TYPE) {</span>
<span class="nc" id="L625">        descriptor = 'B';</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">      } else if (currentClass == Character.TYPE) {</span>
<span class="nc" id="L627">        descriptor = 'C';</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">      } else if (currentClass == Short.TYPE) {</span>
<span class="nc" id="L629">        descriptor = 'S';</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">      } else if (currentClass == Double.TYPE) {</span>
<span class="nc" id="L631">        descriptor = 'D';</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">      } else if (currentClass == Float.TYPE) {</span>
<span class="nc" id="L633">        descriptor = 'F';</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">      } else if (currentClass == Long.TYPE) {</span>
<span class="nc" id="L635">        descriptor = 'J';</span>
      } else {
<span class="nc" id="L637">        throw new AssertionError();</span>
      }
<span class="nc" id="L639">      stringBuilder.append(descriptor);</span>
<span class="nc" id="L640">    } else {</span>
<span class="nc" id="L641">      stringBuilder.append('L').append(getInternalName(currentClass)).append(';');</span>
    }
<span class="nc" id="L643">  }</span>

  // -----------------------------------------------------------------------------------------------
  // Methods to get the sort, dimension, size, and opcodes corresponding to a Type or descriptor.
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the sort of this type.
   *
   * @return {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE}, {@link #SHORT}, {@link
   *     #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY}, {@link #OBJECT} or
   *     {@link #METHOD}.
   */
  public int getSort() {
<span class="nc bnc" id="L657" title="All 2 branches missed.">    return sort == INTERNAL ? OBJECT : sort;</span>
  }

  /**
   * Returns the number of dimensions of this array type. This method should only be used for an
   * array type.
   *
   * @return the number of dimensions of this array type.
   */
  public int getDimensions() {
<span class="nc" id="L667">    int numDimensions = 1;</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">    while (valueBuffer.charAt(valueBegin + numDimensions) == '[') {</span>
<span class="nc" id="L669">      numDimensions++;</span>
    }
<span class="nc" id="L671">    return numDimensions;</span>
  }

  /**
   * Returns the size of values of this type. This method must not be used for method types.
   *
   * @return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for
   *     {@code void} and 1 otherwise.
   */
  public int getSize() {
<span class="nc bnc" id="L681" title="All 4 branches missed.">    switch (sort) {</span>
      case VOID:
<span class="nc" id="L683">        return 0;</span>
      case BOOLEAN:
      case CHAR:
      case BYTE:
      case SHORT:
      case INT:
      case FLOAT:
      case ARRAY:
      case OBJECT:
      case INTERNAL:
<span class="nc" id="L693">        return 1;</span>
      case LONG:
      case DOUBLE:
<span class="nc" id="L696">        return 2;</span>
      default:
<span class="nc" id="L698">        throw new AssertionError();</span>
    }
  }

  /**
   * Returns the size of the arguments and of the return value of methods of this type. This method
   * should only be used for method types.
   *
   * @return the size of the arguments of the method (plus one for the implicit this argument),
   *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =
   *     {@code (argumentsSize &amp;lt;&amp;lt; 2) | returnSize} (argumentsSize is therefore equal to {@code
   *     i &amp;gt;&amp;gt; 2}, and returnSize to {@code i &amp;amp; 0x03}).
   */
  public int getArgumentsAndReturnSizes() {
<span class="nc" id="L712">    return getArgumentsAndReturnSizes(getDescriptor());</span>
  }

  /**
   * Computes the size of the arguments and of the return value of a method.
   *
   * @param methodDescriptor a method descriptor.
   * @return the size of the arguments of the method (plus one for the implicit this argument),
   *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =
   *     {@code (argumentsSize &amp;lt;&amp;lt; 2) | returnSize} (argumentsSize is therefore equal to {@code
   *     i &amp;gt;&amp;gt; 2}, and returnSize to {@code i &amp;amp; 0x03}).
   */
  public static int getArgumentsAndReturnSizes(final String methodDescriptor) {
<span class="nc" id="L725">    int argumentsSize = 1;</span>
    // Skip the first character, which is always a '('.
<span class="nc" id="L727">    int currentOffset = 1;</span>
<span class="nc" id="L728">    int currentChar = methodDescriptor.charAt(currentOffset);</span>
    // Parse the argument types and compute their size, one at a each loop iteration.
<span class="nc bnc" id="L730" title="All 2 branches missed.">    while (currentChar != ')') {</span>
<span class="nc bnc" id="L731" title="All 4 branches missed.">      if (currentChar == 'J' || currentChar == 'D') {</span>
<span class="nc" id="L732">        currentOffset++;</span>
<span class="nc" id="L733">        argumentsSize += 2;</span>
      } else {
<span class="nc bnc" id="L735" title="All 2 branches missed.">        while (methodDescriptor.charAt(currentOffset) == '[') {</span>
<span class="nc" id="L736">          currentOffset++;</span>
        }
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if (methodDescriptor.charAt(currentOffset++) == 'L') {</span>
          // Skip the argument descriptor content.
<span class="nc" id="L740">          currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;</span>
        }
<span class="nc" id="L742">        argumentsSize += 1;</span>
      }
<span class="nc" id="L744">      currentChar = methodDescriptor.charAt(currentOffset);</span>
    }
<span class="nc" id="L746">    currentChar = methodDescriptor.charAt(currentOffset + 1);</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">    if (currentChar == 'V') {</span>
<span class="nc" id="L748">      return argumentsSize &lt;&lt; 2;</span>
    } else {
<span class="nc bnc" id="L750" title="All 4 branches missed.">      int returnSize = (currentChar == 'J' || currentChar == 'D') ? 2 : 1;</span>
<span class="nc" id="L751">      return argumentsSize &lt;&lt; 2 | returnSize;</span>
    }
  }

  /**
   * Returns a JVM instruction opcode adapted to this {@link Type}. This method must not be used for
   * method types.
   *
   * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD, ISTORE, IALOAD,
   *     IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL, ISHR, IUSHR, IAND, IOR, IXOR and
   *     IRETURN.
   * @return an opcode that is similar to the given opcode, but adapted to this {@link Type}. For
   *     example, if this type is {@code float} and {@code opcode} is IRETURN, this method returns
   *     FRETURN.
   */
  public int getOpcode(final int opcode) {
<span class="nc bnc" id="L767" title="All 4 branches missed.">    if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {</span>
<span class="nc bnc" id="L768" title="All 10 branches missed.">      switch (sort) {</span>
        case BOOLEAN:
        case BYTE:
<span class="nc" id="L771">          return opcode + (Opcodes.BALOAD - Opcodes.IALOAD);</span>
        case CHAR:
<span class="nc" id="L773">          return opcode + (Opcodes.CALOAD - Opcodes.IALOAD);</span>
        case SHORT:
<span class="nc" id="L775">          return opcode + (Opcodes.SALOAD - Opcodes.IALOAD);</span>
        case INT:
<span class="nc" id="L777">          return opcode;</span>
        case FLOAT:
<span class="nc" id="L779">          return opcode + (Opcodes.FALOAD - Opcodes.IALOAD);</span>
        case LONG:
<span class="nc" id="L781">          return opcode + (Opcodes.LALOAD - Opcodes.IALOAD);</span>
        case DOUBLE:
<span class="nc" id="L783">          return opcode + (Opcodes.DALOAD - Opcodes.IALOAD);</span>
        case ARRAY:
        case OBJECT:
        case INTERNAL:
<span class="nc" id="L787">          return opcode + (Opcodes.AALOAD - Opcodes.IALOAD);</span>
        case METHOD:
        case VOID:
<span class="nc" id="L790">          throw new UnsupportedOperationException();</span>
        default:
<span class="nc" id="L792">          throw new AssertionError();</span>
      }
    } else {
<span class="nc bnc" id="L795" title="All 8 branches missed.">      switch (sort) {</span>
        case VOID:
<span class="nc bnc" id="L797" title="All 2 branches missed.">          if (opcode != Opcodes.IRETURN) {</span>
<span class="nc" id="L798">            throw new UnsupportedOperationException();</span>
          }
<span class="nc" id="L800">          return Opcodes.RETURN;</span>
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case SHORT:
        case INT:
<span class="nc" id="L806">          return opcode;</span>
        case FLOAT:
<span class="nc" id="L808">          return opcode + (Opcodes.FRETURN - Opcodes.IRETURN);</span>
        case LONG:
<span class="nc" id="L810">          return opcode + (Opcodes.LRETURN - Opcodes.IRETURN);</span>
        case DOUBLE:
<span class="nc" id="L812">          return opcode + (Opcodes.DRETURN - Opcodes.IRETURN);</span>
        case ARRAY:
        case OBJECT:
        case INTERNAL:
<span class="nc bnc" id="L816" title="All 6 branches missed.">          if (opcode != Opcodes.ILOAD &amp;&amp; opcode != Opcodes.ISTORE &amp;&amp; opcode != Opcodes.IRETURN) {</span>
<span class="nc" id="L817">            throw new UnsupportedOperationException();</span>
          }
<span class="nc" id="L819">          return opcode + (Opcodes.ARETURN - Opcodes.IRETURN);</span>
        case METHOD:
<span class="nc" id="L821">          throw new UnsupportedOperationException();</span>
        default:
<span class="nc" id="L823">          throw new AssertionError();</span>
      }
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Equals, hashCode and toString.
  // -----------------------------------------------------------------------------------------------

  /**
   * Tests if the given object is equal to this type.
   *
   * @param object the object to be compared to this type.
   * @return {@literal true} if the given object is equal to this type.
   */
  @Override
  public boolean equals(final Object object) {
<span class="nc bnc" id="L840" title="All 2 branches missed.">    if (this == object) {</span>
<span class="nc" id="L841">      return true;</span>
    }
<span class="nc bnc" id="L843" title="All 2 branches missed.">    if (!(object instanceof Type)) {</span>
<span class="nc" id="L844">      return false;</span>
    }
<span class="nc" id="L846">    Type other = (Type) object;</span>
<span class="nc bnc" id="L847" title="All 6 branches missed.">    if ((sort == INTERNAL ? OBJECT : sort) != (other.sort == INTERNAL ? OBJECT : other.sort)) {</span>
<span class="nc" id="L848">      return false;</span>
    }
<span class="nc" id="L850">    int begin = valueBegin;</span>
<span class="nc" id="L851">    int end = valueEnd;</span>
<span class="nc" id="L852">    int otherBegin = other.valueBegin;</span>
<span class="nc" id="L853">    int otherEnd = other.valueEnd;</span>
    // Compare the values.
<span class="nc bnc" id="L855" title="All 2 branches missed.">    if (end - begin != otherEnd - otherBegin) {</span>
<span class="nc" id="L856">      return false;</span>
    }
<span class="nc bnc" id="L858" title="All 2 branches missed.">    for (int i = begin, j = otherBegin; i &lt; end; i++, j++) {</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">      if (valueBuffer.charAt(i) != other.valueBuffer.charAt(j)) {</span>
<span class="nc" id="L860">        return false;</span>
      }
    }
<span class="nc" id="L863">    return true;</span>
  }

  /**
   * Returns a hash code value for this type.
   *
   * @return a hash code value for this type.
   */
  @Override
  public int hashCode() {
<span class="nc bnc" id="L873" title="All 2 branches missed.">    int hashCode = 13 * (sort == INTERNAL ? OBJECT : sort);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">    if (sort &gt;= ARRAY) {</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">      for (int i = valueBegin, end = valueEnd; i &lt; end; i++) {</span>
<span class="nc" id="L876">        hashCode = 17 * (hashCode + valueBuffer.charAt(i));</span>
      }
    }
<span class="nc" id="L879">    return hashCode;</span>
  }

  /**
   * Returns a string representation of this type.
   *
   * @return the descriptor of this type.
   */
  @Override
  public String toString() {
<span class="nc" id="L889">    return getDescriptor();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>