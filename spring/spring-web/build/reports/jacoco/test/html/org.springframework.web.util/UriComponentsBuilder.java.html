<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UriComponentsBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-web</a> &gt; <a href="index.source.html" class="el_package">org.springframework.web.util</a> &gt; <span class="el_source">UriComponentsBuilder.java</span></div><h1>UriComponentsBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.util;

import java.net.URI;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpRequest;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.util.HierarchicalUriComponents.PathComponent;
import org.springframework.web.util.UriComponents.UriTemplateVariables;

/**
 * Builder for {@link UriComponents}.
 *
 * &lt;p&gt;Typical usage involves:
 * &lt;ol&gt;
 * &lt;li&gt;Create a {@code UriComponentsBuilder} with one of the static factory methods
 * (such as {@link #fromPath(String)} or {@link #fromUri(URI)})&lt;/li&gt;
 * &lt;li&gt;Set the various URI components through the respective methods ({@link #scheme(String)},
 * {@link #userInfo(String)}, {@link #host(String)}, {@link #port(int)}, {@link #path(String)},
 * {@link #pathSegment(String...)}, {@link #queryParam(String, Object...)}, and
 * {@link #fragment(String)}.&lt;/li&gt;
 * &lt;li&gt;Build the {@link UriComponents} instance with the {@link #build()} method.&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * @author Arjen Poutsma
 * @author Rossen Stoyanchev
 * @author Phillip Webb
 * @author Oliver Gierke
 * @author Brian Clozel
 * @author Sebastien Deleuze
 * @since 3.1
 * @see #newInstance()
 * @see #fromPath(String)
 * @see #fromUri(URI)
 */
public class UriComponentsBuilder implements UriBuilder, Cloneable {

<span class="fc" id="L68">	private static final Pattern QUERY_PARAM_PATTERN = Pattern.compile(&quot;([^&amp;=]+)(=?)([^&amp;]+)?&quot;);</span>

	private static final String SCHEME_PATTERN = &quot;([^:/?#]+):&quot;;

	private static final String HTTP_PATTERN = &quot;(?i)(http|https):&quot;;

	private static final String USERINFO_PATTERN = &quot;([^@\\[/?#]*)&quot;;

	private static final String HOST_IPV4_PATTERN = &quot;[^\\[/?#:]*&quot;;

	private static final String HOST_IPV6_PATTERN = &quot;\\[[\\p{XDigit}\\:\\.]*[%\\p{Alnum}]*\\]&quot;;

	private static final String HOST_PATTERN = &quot;(&quot; + HOST_IPV6_PATTERN + &quot;|&quot; + HOST_IPV4_PATTERN + &quot;)&quot;;

	private static final String PORT_PATTERN = &quot;(\\d*(?:\\{[^/]+?\\})?)&quot;;

	private static final String PATH_PATTERN = &quot;([^?#]*)&quot;;

	private static final String QUERY_PATTERN = &quot;([^#]*)&quot;;

	private static final String LAST_PATTERN = &quot;(.*)&quot;;

	// Regex patterns that matches URIs. See RFC 3986, appendix B
<span class="fc" id="L91">	private static final Pattern URI_PATTERN = Pattern.compile(</span>
			&quot;^(&quot; + SCHEME_PATTERN + &quot;)?&quot; + &quot;(//(&quot; + USERINFO_PATTERN + &quot;@)?&quot; + HOST_PATTERN + &quot;(:&quot; + PORT_PATTERN +
					&quot;)?&quot; + &quot;)?&quot; + PATH_PATTERN + &quot;(\\?&quot; + QUERY_PATTERN + &quot;)?&quot; + &quot;(#&quot; + LAST_PATTERN + &quot;)?&quot;);

<span class="fc" id="L95">	private static final Pattern HTTP_URL_PATTERN = Pattern.compile(</span>
			&quot;^&quot; + HTTP_PATTERN + &quot;(//(&quot; + USERINFO_PATTERN + &quot;@)?&quot; + HOST_PATTERN + &quot;(:&quot; + PORT_PATTERN + &quot;)?&quot; + &quot;)?&quot; +
					PATH_PATTERN + &quot;(\\?&quot; + LAST_PATTERN + &quot;)?&quot;);

<span class="fc" id="L99">	private static final Pattern FORWARDED_HOST_PATTERN = Pattern.compile(&quot;host=\&quot;?([^;,\&quot;]+)\&quot;?&quot;);</span>

<span class="fc" id="L101">	private static final Pattern FORWARDED_PROTO_PATTERN = Pattern.compile(&quot;proto=\&quot;?([^;,\&quot;]+)\&quot;?&quot;);</span>


	@Nullable
	private String scheme;

	@Nullable
	private String ssp;

	@Nullable
	private String userInfo;

	@Nullable
	private String host;

	@Nullable
	private String port;

	private CompositePathComponentBuilder pathBuilder;

<span class="fc" id="L121">	private final MultiValueMap&lt;String, String&gt; queryParams = new LinkedMultiValueMap&lt;&gt;();</span>

	@Nullable
	private String fragment;

<span class="fc" id="L126">	private final Map&lt;String, Object&gt; uriVariables = new HashMap&lt;&gt;(4);</span>

	private boolean encodeTemplate;

<span class="fc" id="L130">	private Charset charset = StandardCharsets.UTF_8;</span>


	/**
	 * Default constructor. Protected to prevent direct instantiation.
	 * @see #newInstance()
	 * @see #fromPath(String)
	 * @see #fromUri(URI)
	 */
<span class="fc" id="L139">	protected UriComponentsBuilder() {</span>
<span class="fc" id="L140">		this.pathBuilder = new CompositePathComponentBuilder();</span>
<span class="fc" id="L141">	}</span>

	/**
	 * Create a deep copy of the given UriComponentsBuilder.
	 * @param other the other builder to copy from
	 * @since 4.1.3
	 */
<span class="fc" id="L148">	protected UriComponentsBuilder(UriComponentsBuilder other) {</span>
<span class="fc" id="L149">		this.scheme = other.scheme;</span>
<span class="fc" id="L150">		this.ssp = other.ssp;</span>
<span class="fc" id="L151">		this.userInfo = other.userInfo;</span>
<span class="fc" id="L152">		this.host = other.host;</span>
<span class="fc" id="L153">		this.port = other.port;</span>
<span class="fc" id="L154">		this.pathBuilder = other.pathBuilder.cloneBuilder();</span>
<span class="fc" id="L155">		this.queryParams.putAll(other.queryParams);</span>
<span class="fc" id="L156">		this.fragment = other.fragment;</span>
<span class="fc" id="L157">		this.encodeTemplate = other.encodeTemplate;</span>
<span class="fc" id="L158">		this.charset = other.charset;</span>
<span class="fc" id="L159">	}</span>


	// Factory methods

	/**
	 * Create a new, empty builder.
	 * @return the new {@code UriComponentsBuilder}
	 */
	public static UriComponentsBuilder newInstance() {
<span class="fc" id="L169">		return new UriComponentsBuilder();</span>
	}

	/**
	 * Create a builder that is initialized with the given path.
	 * @param path the path to initialize with
	 * @return the new {@code UriComponentsBuilder}
	 */
	public static UriComponentsBuilder fromPath(String path) {
<span class="fc" id="L178">		UriComponentsBuilder builder = new UriComponentsBuilder();</span>
<span class="fc" id="L179">		builder.path(path);</span>
<span class="fc" id="L180">		return builder;</span>
	}

	/**
	 * Create a builder that is initialized with the given {@code URI}.
	 * @param uri the URI to initialize with
	 * @return the new {@code UriComponentsBuilder}
	 */
	public static UriComponentsBuilder fromUri(URI uri) {
<span class="fc" id="L189">		UriComponentsBuilder builder = new UriComponentsBuilder();</span>
<span class="fc" id="L190">		builder.uri(uri);</span>
<span class="fc" id="L191">		return builder;</span>
	}

	/**
	 * Create a builder that is initialized with the given URI string.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The presence of reserved characters can prevent
	 * correct parsing of the URI string. For example if a query parameter
	 * contains {@code '='} or {@code '&amp;'} characters, the query string cannot
	 * be parsed unambiguously. Such values should be substituted for URI
	 * variables to enable correct parsing:
	 * &lt;pre class=&quot;code&quot;&gt;
	 * String uriString = &amp;quot;/hotels/42?filter={value}&amp;quot;;
	 * UriComponentsBuilder.fromUriString(uriString).buildAndExpand(&amp;quot;hot&amp;amp;cold&amp;quot;);
	 * &lt;/pre&gt;
	 * @param uri the URI string to initialize with
	 * @return the new {@code UriComponentsBuilder}
	 */
	public static UriComponentsBuilder fromUriString(String uri) {
<span class="fc" id="L209">		Assert.notNull(uri, &quot;URI must not be null&quot;);</span>
<span class="fc" id="L210">		Matcher matcher = URI_PATTERN.matcher(uri);</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">		if (matcher.matches()) {</span>
<span class="fc" id="L212">			UriComponentsBuilder builder = new UriComponentsBuilder();</span>
<span class="fc" id="L213">			String scheme = matcher.group(2);</span>
<span class="fc" id="L214">			String userInfo = matcher.group(5);</span>
<span class="fc" id="L215">			String host = matcher.group(6);</span>
<span class="fc" id="L216">			String port = matcher.group(8);</span>
<span class="fc" id="L217">			String path = matcher.group(9);</span>
<span class="fc" id="L218">			String query = matcher.group(11);</span>
<span class="fc" id="L219">			String fragment = matcher.group(13);</span>
<span class="fc" id="L220">			boolean opaque = false;</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">			if (StringUtils.hasLength(scheme)) {</span>
<span class="fc" id="L222">				String rest = uri.substring(scheme.length());</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">				if (!rest.startsWith(&quot;:/&quot;)) {</span>
<span class="fc" id="L224">					opaque = true;</span>
				}
			}
<span class="fc" id="L227">			builder.scheme(scheme);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">			if (opaque) {</span>
<span class="fc" id="L229">				String ssp = uri.substring(scheme.length()).substring(1);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">				if (StringUtils.hasLength(fragment)) {</span>
<span class="fc" id="L231">					ssp = ssp.substring(0, ssp.length() - (fragment.length() + 1));</span>
				}
<span class="fc" id="L233">				builder.schemeSpecificPart(ssp);</span>
<span class="fc" id="L234">			}</span>
			else {
<span class="fc" id="L236">				builder.userInfo(userInfo);</span>
<span class="fc" id="L237">				builder.host(host);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">				if (StringUtils.hasLength(port)) {</span>
<span class="fc" id="L239">					builder.port(port);</span>
				}
<span class="fc" id="L241">				builder.path(path);</span>
<span class="fc" id="L242">				builder.query(query);</span>
			}
<span class="fc bfc" id="L244" title="All 2 branches covered.">			if (StringUtils.hasText(fragment)) {</span>
<span class="fc" id="L245">				builder.fragment(fragment);</span>
			}
<span class="fc" id="L247">			return builder;</span>
		}
		else {
<span class="nc" id="L250">			throw new IllegalArgumentException(&quot;[&quot; + uri + &quot;] is not a valid URI&quot;);</span>
		}
	}

	/**
	 * Create a URI components builder from the given HTTP URL String.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The presence of reserved characters can prevent
	 * correct parsing of the URI string. For example if a query parameter
	 * contains {@code '='} or {@code '&amp;'} characters, the query string cannot
	 * be parsed unambiguously. Such values should be substituted for URI
	 * variables to enable correct parsing:
	 * &lt;pre class=&quot;code&quot;&gt;
	 * String urlString = &amp;quot;https://example.com/hotels/42?filter={value}&amp;quot;;
	 * UriComponentsBuilder.fromHttpUrl(urlString).buildAndExpand(&amp;quot;hot&amp;amp;cold&amp;quot;);
	 * &lt;/pre&gt;
	 * @param httpUrl the source URI
	 * @return the URI components of the URI
	 */
	public static UriComponentsBuilder fromHttpUrl(String httpUrl) {
<span class="fc" id="L269">		Assert.notNull(httpUrl, &quot;HTTP URL must not be null&quot;);</span>
<span class="fc" id="L270">		Matcher matcher = HTTP_URL_PATTERN.matcher(httpUrl);</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">		if (matcher.matches()) {</span>
<span class="fc" id="L272">			UriComponentsBuilder builder = new UriComponentsBuilder();</span>
<span class="fc" id="L273">			String scheme = matcher.group(1);</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">			builder.scheme(scheme != null ? scheme.toLowerCase() : null);</span>
<span class="fc" id="L275">			builder.userInfo(matcher.group(4));</span>
<span class="fc" id="L276">			String host = matcher.group(5);</span>
<span class="pc bpc" id="L277" title="1 of 4 branches missed.">			if (StringUtils.hasLength(scheme) &amp;&amp; !StringUtils.hasLength(host)) {</span>
<span class="fc" id="L278">				throw new IllegalArgumentException(&quot;[&quot; + httpUrl + &quot;] is not a valid HTTP URL&quot;);</span>
			}
<span class="fc" id="L280">			builder.host(host);</span>
<span class="fc" id="L281">			String port = matcher.group(7);</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">			if (StringUtils.hasLength(port)) {</span>
<span class="fc" id="L283">				builder.port(port);</span>
			}
<span class="fc" id="L285">			builder.path(matcher.group(8));</span>
<span class="fc" id="L286">			builder.query(matcher.group(10));</span>
<span class="fc" id="L287">			return builder;</span>
		}
		else {
<span class="nc" id="L290">			throw new IllegalArgumentException(&quot;[&quot; + httpUrl + &quot;] is not a valid HTTP URL&quot;);</span>
		}
	}

	/**
	 * Create a new {@code UriComponents} object from the URI associated with
	 * the given HttpRequest while also overlaying with values from the headers
	 * &quot;Forwarded&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc7239&quot;&gt;RFC 7239&lt;/a&gt;),
	 * or &quot;X-Forwarded-Host&quot;, &quot;X-Forwarded-Port&quot;, and &quot;X-Forwarded-Proto&quot; if
	 * &quot;Forwarded&quot; is not found.
	 * @param request the source request
	 * @return the URI components of the URI
	 * @since 4.1.5
	 */
	public static UriComponentsBuilder fromHttpRequest(HttpRequest request) {
<span class="fc" id="L305">		return fromUri(request.getURI()).adaptFromForwardedHeaders(request.getHeaders());</span>
	}

	/**
	 * Create an instance by parsing the &quot;Origin&quot; header of an HTTP request.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc6454&quot;&gt;RFC 6454&lt;/a&gt;
	 */
	public static UriComponentsBuilder fromOriginHeader(String origin) {
<span class="fc" id="L313">		Matcher matcher = URI_PATTERN.matcher(origin);</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">		if (matcher.matches()) {</span>
<span class="fc" id="L315">			UriComponentsBuilder builder = new UriComponentsBuilder();</span>
<span class="fc" id="L316">			String scheme = matcher.group(2);</span>
<span class="fc" id="L317">			String host = matcher.group(6);</span>
<span class="fc" id="L318">			String port = matcher.group(8);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">			if (StringUtils.hasLength(scheme)) {</span>
<span class="fc" id="L320">				builder.scheme(scheme);</span>
			}
<span class="fc" id="L322">			builder.host(host);</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">			if (StringUtils.hasLength(port)) {</span>
<span class="fc" id="L324">				builder.port(port);</span>
			}
<span class="fc" id="L326">			return builder;</span>
		}
		else {
<span class="nc" id="L329">			throw new IllegalArgumentException(&quot;[&quot; + origin + &quot;] is not a valid \&quot;Origin\&quot; header value&quot;);</span>
		}
	}


	// Encode methods

	/**
	 * Request to have the URI template pre-encoded at build time, and
	 * URI variables encoded separately when expanded.
	 * &lt;p&gt;In comparison to {@link UriComponents#encode()}, this method has the
	 * same effect on the URI template, i.e. each URI component is encoded by
	 * replacing non-ASCII and illegal (within the URI component type) characters
	 * with escaped octets. However URI variables are encoded more strictly, by
	 * also escaping characters with reserved meaning.
	 * &lt;p&gt;For most cases, this method is more likely to give the expected result
	 * because in treats URI variables as opaque data to be fully encoded, while
	 * {@link UriComponents#encode()} is useful only if intentionally expanding
	 * URI variables that contain reserved characters.
	 * &lt;p&gt;For example ';' is legal in a path but has reserved meaning. This
	 * method replaces &quot;;&quot; with &quot;%3B&quot; in URI variables but not in the URI
	 * template. By contrast, {@link UriComponents#encode()} never replaces &quot;;&quot;
	 * since it is a legal character in a path.
	 * @since 5.0.8
	 */
	public final UriComponentsBuilder encode() {
<span class="fc" id="L355">		return encode(StandardCharsets.UTF_8);</span>
	}

	/**
	 * A variant of {@link #encode()} with a charset other than &quot;UTF-8&quot;.
	 * @param charset the charset to use for encoding
	 * @since 5.0.8
	 */
	public UriComponentsBuilder encode(Charset charset) {
<span class="fc" id="L364">		this.encodeTemplate = true;</span>
<span class="fc" id="L365">		this.charset = charset;</span>
<span class="fc" id="L366">		return this;</span>
	}


	// Build methods

	/**
	 * Build a {@code UriComponents} instance from the various components contained in this builder.
	 * @return the URI components
	 */
	public UriComponents build() {
<span class="fc" id="L377">		return build(false);</span>
	}

	/**
	 * Build a {@code UriComponents} instance from the various components
	 * contained in this builder.
	 * @param encoded whether all the components set in this builder are
	 * encoded ({@code true}) or not ({@code false})
	 * @return the URI components
	 */
	public UriComponents build(boolean encoded) {
<span class="fc bfc" id="L388" title="All 4 branches covered.">		return buildInternal(encoded ?</span>
				EncodingHint.FULLY_ENCODED :
				this.encodeTemplate ? EncodingHint.ENCODE_TEMPLATE : EncodingHint.NONE);
	}

	private UriComponents buildInternal(EncodingHint hint) {
		UriComponents result;
<span class="fc bfc" id="L395" title="All 2 branches covered.">		if (this.ssp != null) {</span>
<span class="fc" id="L396">			result = new OpaqueUriComponents(this.scheme, this.ssp, this.fragment);</span>
		}
		else {
<span class="fc" id="L399">			HierarchicalUriComponents uric = new HierarchicalUriComponents(this.scheme, this.fragment,</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">					this.userInfo, this.host, this.port, this.pathBuilder.build(), this.queryParams,</span>
					hint == EncodingHint.FULLY_ENCODED);

<span class="fc bfc" id="L403" title="All 2 branches covered.">			result = hint == EncodingHint.ENCODE_TEMPLATE ? uric.encodeTemplate(this.charset) : uric;</span>
		}
<span class="fc bfc" id="L405" title="All 2 branches covered.">		if (!this.uriVariables.isEmpty()) {</span>
<span class="fc" id="L406">			result = result.expand(name -&gt; this.uriVariables.getOrDefault(name, UriTemplateVariables.SKIP_VALUE));</span>
		}
<span class="fc" id="L408">		return result;</span>
	}

	/**
	 * Build a {@code UriComponents} instance and replaces URI template variables
	 * with the values from a map. This is a shortcut method which combines
	 * calls to {@link #build()} and then {@link UriComponents#expand(Map)}.
	 * @param uriVariables the map of URI variables
	 * @return the URI components with expanded values
	 */
	public UriComponents buildAndExpand(Map&lt;String, ?&gt; uriVariables) {
<span class="fc" id="L419">		return build().expand(uriVariables);</span>
	}

	/**
	 * Build a {@code UriComponents} instance and replaces URI template variables
	 * with the values from an array. This is a shortcut method which combines
	 * calls to {@link #build()} and then {@link UriComponents#expand(Object...)}.
	 * @param uriVariableValues the URI variable values
	 * @return the URI components with expanded values
	 */
	public UriComponents buildAndExpand(Object... uriVariableValues) {
<span class="fc" id="L430">		return build().expand(uriVariableValues);</span>
	}

	@Override
	public URI build(Object... uriVariables) {
<span class="nc" id="L435">		return buildInternal(EncodingHint.ENCODE_TEMPLATE).expand(uriVariables).toUri();</span>
	}

	@Override
	public URI build(Map&lt;String, ?&gt; uriVariables) {
<span class="nc" id="L440">		return buildInternal(EncodingHint.ENCODE_TEMPLATE).expand(uriVariables).toUri();</span>
	}

	/**
	 * Build a URI String.
	 * &lt;p&gt;Effectively, a shortcut for building, encoding, and returning the
	 * String representation:
	 * &lt;pre class=&quot;code&quot;&gt;
	 * String uri = builder.build().encode().toUriString()
	 * &lt;/pre&gt;
	 * &lt;p&gt;However if {@link #uriVariables(Map) URI variables} have been provided
	 * then the URI template is pre-encoded separately from URI variables (see
	 * {@link #encode()} for details), i.e. equivalent to:
	 * &lt;pre&gt;
	 * String uri = builder.encode().build().toUriString()
	 * &lt;/pre&gt;
	 * @since 4.1
	 * @see UriComponents#toUriString()
	 */
	public String toUriString() {
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">		return this.uriVariables.isEmpty() ?</span>
<span class="pc" id="L461">				build().encode().toUriString() :</span>
<span class="nc" id="L462">				buildInternal(EncodingHint.ENCODE_TEMPLATE).toUriString();</span>
	}


	// Instance methods

	/**
	 * Initialize components of this builder from components of the given URI.
	 * @param uri the URI
	 * @return this UriComponentsBuilder
	 */
	public UriComponentsBuilder uri(URI uri) {
<span class="fc" id="L474">		Assert.notNull(uri, &quot;URI must not be null&quot;);</span>
<span class="fc" id="L475">		this.scheme = uri.getScheme();</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">		if (uri.isOpaque()) {</span>
<span class="fc" id="L477">			this.ssp = uri.getRawSchemeSpecificPart();</span>
<span class="fc" id="L478">			resetHierarchicalComponents();</span>
		}
		else {
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">			if (uri.getRawUserInfo() != null) {</span>
<span class="nc" id="L482">				this.userInfo = uri.getRawUserInfo();</span>
			}
<span class="fc bfc" id="L484" title="All 2 branches covered.">			if (uri.getHost() != null) {</span>
<span class="fc" id="L485">				this.host = uri.getHost();</span>
			}
<span class="fc bfc" id="L487" title="All 2 branches covered.">			if (uri.getPort() != -1) {</span>
<span class="fc" id="L488">				this.port = String.valueOf(uri.getPort());</span>
			}
<span class="fc bfc" id="L490" title="All 2 branches covered.">			if (StringUtils.hasLength(uri.getRawPath())) {</span>
<span class="fc" id="L491">				this.pathBuilder = new CompositePathComponentBuilder();</span>
<span class="fc" id="L492">				this.pathBuilder.addPath(uri.getRawPath());</span>
			}
<span class="fc bfc" id="L494" title="All 2 branches covered.">			if (StringUtils.hasLength(uri.getRawQuery())) {</span>
<span class="fc" id="L495">				this.queryParams.clear();</span>
<span class="fc" id="L496">				query(uri.getRawQuery());</span>
			}
<span class="fc" id="L498">			resetSchemeSpecificPart();</span>
		}
<span class="fc bfc" id="L500" title="All 2 branches covered.">		if (uri.getRawFragment() != null) {</span>
<span class="fc" id="L501">			this.fragment = uri.getRawFragment();</span>
		}
<span class="fc" id="L503">		return this;</span>
	}

	/**
	 * Set or append individual URI components of this builder from the values
	 * of the given {@link UriComponents} instance.
	 * &lt;p&gt;For the semantics of each component (i.e. set vs append) check the
	 * builder methods on this class. For example {@link #host(String)} sets
	 * while {@link #path(String)} appends.
	 * @param uriComponents the UriComponents to copy from
	 * @return this UriComponentsBuilder
	 */
	public UriComponentsBuilder uriComponents(UriComponents uriComponents) {
<span class="fc" id="L516">		Assert.notNull(uriComponents, &quot;UriComponents must not be null&quot;);</span>
<span class="fc" id="L517">		uriComponents.copyToUriComponentsBuilder(this);</span>
<span class="fc" id="L518">		return this;</span>
	}

	/**
	 * Set the URI scheme. The given scheme may contain URI template variables,
	 * and may also be {@code null} to clear the scheme of this builder.
	 * @param scheme the URI scheme
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder scheme(@Nullable String scheme) {
<span class="fc" id="L529">		this.scheme = scheme;</span>
<span class="fc" id="L530">		return this;</span>
	}

	/**
	 * Set the URI scheme-specific-part. When invoked, this method overwrites
	 * {@linkplain #userInfo(String) user-info}, {@linkplain #host(String) host},
	 * {@linkplain #port(int) port}, {@linkplain #path(String) path}, and
	 * {@link #query(String) query}.
	 * @param ssp the URI scheme-specific-part, may contain URI template parameters
	 * @return this UriComponentsBuilder
	 */
	public UriComponentsBuilder schemeSpecificPart(String ssp) {
<span class="fc" id="L542">		this.ssp = ssp;</span>
<span class="fc" id="L543">		resetHierarchicalComponents();</span>
<span class="fc" id="L544">		return this;</span>
	}

	/**
	 * Set the URI user info. The given user info may contain URI template variables,
	 * and may also be {@code null} to clear the user info of this builder.
	 * @param userInfo the URI user info
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder userInfo(@Nullable String userInfo) {
<span class="fc" id="L555">		this.userInfo = userInfo;</span>
<span class="fc" id="L556">		resetSchemeSpecificPart();</span>
<span class="fc" id="L557">		return this;</span>
	}

	/**
	 * Set the URI host. The given host may contain URI template variables,
	 * and may also be {@code null} to clear the host of this builder.
	 * @param host the URI host
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder host(@Nullable String host) {
<span class="fc" id="L568">		this.host = host;</span>
<span class="fc" id="L569">		resetSchemeSpecificPart();</span>
<span class="fc" id="L570">		return this;</span>
	}

	/**
	 * Set the URI port. Passing {@code -1} will clear the port of this builder.
	 * @param port the URI port
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder port(int port) {
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">		Assert.isTrue(port &gt;= -1, &quot;Port must be &gt;= -1&quot;);</span>
<span class="fc" id="L581">		this.port = String.valueOf(port);</span>
<span class="fc" id="L582">		resetSchemeSpecificPart();</span>
<span class="fc" id="L583">		return this;</span>
	}

	/**
	 * Set the URI port. Use this method only when the port needs to be
	 * parameterized with a URI variable. Otherwise use {@link #port(int)}.
	 * Passing {@code null} will clear the port of this builder.
	 * @param port the URI port
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder port(@Nullable String port) {
<span class="fc" id="L595">		this.port = port;</span>
<span class="fc" id="L596">		resetSchemeSpecificPart();</span>
<span class="fc" id="L597">		return this;</span>
	}

	/**
	 * Append the given path to the existing path of this builder.
	 * The given path may contain URI template variables.
	 * @param path the URI path
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder path(String path) {
<span class="fc" id="L608">		this.pathBuilder.addPath(path);</span>
<span class="fc" id="L609">		resetSchemeSpecificPart();</span>
<span class="fc" id="L610">		return this;</span>
	}

	/**
	 * Append path segments to the existing path. Each path segment may contain
	 * URI template variables and should not contain any slashes.
	 * Use {@code path(&quot;/&quot;)} subsequently to ensure a trailing slash.
	 * @param pathSegments the URI path segments
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder pathSegment(String... pathSegments) throws IllegalArgumentException {
<span class="fc" id="L622">		this.pathBuilder.addPathSegments(pathSegments);</span>
<span class="fc" id="L623">		resetSchemeSpecificPart();</span>
<span class="fc" id="L624">		return this;</span>
	}

	/**
	 * Set the path of this builder overriding all existing path and path segment values.
	 * @param path the URI path (a {@code null} value results in an empty path)
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder replacePath(@Nullable String path) {
<span class="fc" id="L634">		this.pathBuilder = new CompositePathComponentBuilder();</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">		if (path != null) {</span>
<span class="fc" id="L636">			this.pathBuilder.addPath(path);</span>
		}
<span class="fc" id="L638">		resetSchemeSpecificPart();</span>
<span class="fc" id="L639">		return this;</span>
	}

	/**
	 * Append the given query to the existing query of this builder.
	 * The given query may contain URI template variables.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The presence of reserved characters can prevent
	 * correct parsing of the URI string. For example if a query parameter
	 * contains {@code '='} or {@code '&amp;'} characters, the query string cannot
	 * be parsed unambiguously. Such values should be substituted for URI
	 * variables to enable correct parsing:
	 * &lt;pre class=&quot;code&quot;&gt;
	 * UriComponentsBuilder.fromUriString(&amp;quot;/hotels/42&amp;quot;)
	 * 	.query(&amp;quot;filter={value}&amp;quot;)
	 * 	.buildAndExpand(&amp;quot;hot&amp;amp;cold&amp;quot;);
	 * &lt;/pre&gt;
	 * @param query the query string
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder query(@Nullable String query) {
<span class="fc bfc" id="L660" title="All 2 branches covered.">		if (query != null) {</span>
<span class="fc" id="L661">			Matcher matcher = QUERY_PARAM_PATTERN.matcher(query);</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">			while (matcher.find()) {</span>
<span class="fc" id="L663">				String name = matcher.group(1);</span>
<span class="fc" id="L664">				String eq = matcher.group(2);</span>
<span class="fc" id="L665">				String value = matcher.group(3);</span>
<span class="fc bfc" id="L666" title="All 4 branches covered.">				queryParam(name, (value != null ? value : (StringUtils.hasLength(eq) ? &quot;&quot; : null)));</span>
<span class="fc" id="L667">			}</span>
<span class="fc" id="L668">		}</span>
		else {
<span class="fc" id="L670">			this.queryParams.clear();</span>
		}
<span class="fc" id="L672">		resetSchemeSpecificPart();</span>
<span class="fc" id="L673">		return this;</span>
	}

	/**
	 * Set the query of this builder overriding all existing query parameters.
	 * @param query the query string; a {@code null} value removes all query parameters.
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder replaceQuery(@Nullable String query) {
<span class="fc" id="L683">		this.queryParams.clear();</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">		if (query != null) {</span>
<span class="fc" id="L685">			query(query);</span>
		}
<span class="fc" id="L687">		resetSchemeSpecificPart();</span>
<span class="fc" id="L688">		return this;</span>
	}

	/**
	 * Append the given query parameter to the existing query parameters. The
	 * given name or any of the values may contain URI template variables. If no
	 * values are given, the resulting URI will contain the query parameter name
	 * only (i.e. {@code ?foo} instead of {@code ?foo=bar}).
	 * @param name the query parameter name
	 * @param values the query parameter values
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder queryParam(String name, Object... values) {
<span class="fc" id="L702">		Assert.notNull(name, &quot;Name must not be null&quot;);</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">		if (!ObjectUtils.isEmpty(values)) {</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">			for (Object value : values) {</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">				String valueAsString = (value != null ? value.toString() : null);</span>
<span class="fc" id="L706">				this.queryParams.add(name, valueAsString);</span>
			}
		}
		else {
<span class="fc" id="L710">			this.queryParams.add(name, null);</span>
		}
<span class="fc" id="L712">		resetSchemeSpecificPart();</span>
<span class="fc" id="L713">		return this;</span>
	}

	/**
	 * Add the given query parameters.
	 * @param params the params
	 * @return this UriComponentsBuilder
	 * @since 4.0
	 */
	@Override
	public UriComponentsBuilder queryParams(@Nullable MultiValueMap&lt;String, String&gt; params) {
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">		if (params != null) {</span>
<span class="fc" id="L725">			this.queryParams.addAll(params);</span>
		}
<span class="fc" id="L727">		return this;</span>
	}

	/**
	 * Set the query parameter values overriding all existing query values for
	 * the same parameter. If no values are given, the query parameter is removed.
	 * @param name the query parameter name
	 * @param values the query parameter values
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder replaceQueryParam(String name, Object... values) {
<span class="fc" id="L739">		Assert.notNull(name, &quot;Name must not be null&quot;);</span>
<span class="fc" id="L740">		this.queryParams.remove(name);</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">		if (!ObjectUtils.isEmpty(values)) {</span>
<span class="fc" id="L742">			queryParam(name, values);</span>
		}
<span class="fc" id="L744">		resetSchemeSpecificPart();</span>
<span class="fc" id="L745">		return this;</span>
	}

	/**
	 * Set the query parameter values overriding all existing query values.
	 * @param params the query parameter name
	 * @return this UriComponentsBuilder
	 * @since 4.2
	 */
	@Override
	public UriComponentsBuilder replaceQueryParams(@Nullable MultiValueMap&lt;String, String&gt; params) {
<span class="nc" id="L756">		this.queryParams.clear();</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">		if (params != null) {</span>
<span class="nc" id="L758">			this.queryParams.putAll(params);</span>
		}
<span class="nc" id="L760">		return this;</span>
	}

	/**
	 * Set the URI fragment. The given fragment may contain URI template variables,
	 * and may also be {@code null} to clear the fragment of this builder.
	 * @param fragment the URI fragment
	 * @return this UriComponentsBuilder
	 */
	@Override
	public UriComponentsBuilder fragment(@Nullable String fragment) {
<span class="fc bfc" id="L771" title="All 2 branches covered.">		if (fragment != null) {</span>
<span class="fc" id="L772">			Assert.hasLength(fragment, &quot;Fragment must not be empty&quot;);</span>
<span class="fc" id="L773">			this.fragment = fragment;</span>
		}
		else {
<span class="fc" id="L776">			this.fragment = null;</span>
		}
<span class="fc" id="L778">		return this;</span>
	}

	/**
	 * Configure URI variables to be expanded at build time.
	 * &lt;p&gt;The provided variables may be a subset of all required ones. At build
	 * time, the available ones are expanded, while unresolved URI placeholders
	 * are left in place and can still be expanded later.
	 * &lt;p&gt;In contrast to {@link UriComponents#expand(Map)} or
	 * {@link #buildAndExpand(Map)}, this method is useful when you need to
	 * supply URI variables without building the {@link UriComponents} instance
	 * just yet, or perhaps pre-expand some shared default values such as host
	 * and port.
	 * @param uriVariables the URI variables to use
	 * @return this UriComponentsBuilder
	 * @since 5.0.8
	 */
	public UriComponentsBuilder uriVariables(Map&lt;String, Object&gt; uriVariables) {
<span class="fc" id="L796">		this.uriVariables.putAll(uriVariables);</span>
<span class="fc" id="L797">		return this;</span>
	}

	/**
	 * Adapt this builder's scheme+host+port from the given headers, specifically
	 * &quot;Forwarded&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc7239&quot;&gt;RFC 7239&lt;/a&gt;,
	 * or &quot;X-Forwarded-Host&quot;, &quot;X-Forwarded-Port&quot;, and &quot;X-Forwarded-Proto&quot; if
	 * &quot;Forwarded&quot; is not found.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; this method uses values from forwarded headers,
	 * if present, in order to reflect the client-originated protocol and address.
	 * Consider using the {@code ForwardedHeaderFilter} in order to choose from a
	 * central place whether to extract and use, or to discard such headers.
	 * See the Spring Framework reference for more on this filter.
	 * @param headers the HTTP headers to consider
	 * @return this UriComponentsBuilder
	 * @since 4.2.7
	 */
	UriComponentsBuilder adaptFromForwardedHeaders(HttpHeaders headers) {
		try {
<span class="fc" id="L816">			String forwardedHeader = headers.getFirst(&quot;Forwarded&quot;);</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">			if (StringUtils.hasText(forwardedHeader)) {</span>
<span class="fc" id="L818">				String forwardedToUse = StringUtils.tokenizeToStringArray(forwardedHeader, &quot;,&quot;)[0];</span>
<span class="fc" id="L819">				Matcher matcher = FORWARDED_PROTO_PATTERN.matcher(forwardedToUse);</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">				if (matcher.find()) {</span>
<span class="fc" id="L821">					scheme(matcher.group(1).trim());</span>
<span class="fc" id="L822">					port(null);</span>
				}
<span class="pc bpc" id="L824" title="1 of 2 branches missed.">				else if (isForwardedSslOn(headers)) {</span>
<span class="nc" id="L825">					scheme(&quot;https&quot;);</span>
<span class="nc" id="L826">					port(null);</span>
				}
<span class="fc" id="L828">				matcher = FORWARDED_HOST_PATTERN.matcher(forwardedToUse);</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">				if (matcher.find()) {</span>
<span class="fc" id="L830">					adaptForwardedHost(matcher.group(1).trim());</span>
				}
<span class="fc" id="L832">			}</span>
			else {
<span class="fc" id="L834">				String protocolHeader = headers.getFirst(&quot;X-Forwarded-Proto&quot;);</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">				if (StringUtils.hasText(protocolHeader)) {</span>
<span class="fc" id="L836">					scheme(StringUtils.tokenizeToStringArray(protocolHeader, &quot;,&quot;)[0]);</span>
<span class="fc" id="L837">					port(null);</span>
				}
<span class="fc bfc" id="L839" title="All 2 branches covered.">				else if (isForwardedSslOn(headers)) {</span>
<span class="fc" id="L840">					scheme(&quot;https&quot;);</span>
<span class="fc" id="L841">					port(null);</span>
				}

<span class="fc" id="L844">				String hostHeader = headers.getFirst(&quot;X-Forwarded-Host&quot;);</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">				if (StringUtils.hasText(hostHeader)) {</span>
<span class="fc" id="L846">					adaptForwardedHost(StringUtils.tokenizeToStringArray(hostHeader, &quot;,&quot;)[0]);</span>
				}

<span class="fc" id="L849">				String portHeader = headers.getFirst(&quot;X-Forwarded-Port&quot;);</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">				if (StringUtils.hasText(portHeader)) {</span>
<span class="fc" id="L851">					port(Integer.parseInt(StringUtils.tokenizeToStringArray(portHeader, &quot;,&quot;)[0]));</span>
				}
			}
		}
<span class="nc" id="L855">		catch (NumberFormatException ex) {</span>
<span class="nc" id="L856">			throw new IllegalArgumentException(&quot;Failed to parse a port from \&quot;forwarded\&quot;-type headers. &quot; +</span>
					&quot;If not behind a trusted proxy, consider using ForwardedHeaderFilter &quot; +
					&quot;with the removeOnly=true. Request headers: &quot; + headers);
<span class="fc" id="L859">		}</span>

<span class="fc bfc" id="L861" title="All 6 branches covered.">		if (this.scheme != null &amp;&amp; ((this.scheme.equals(&quot;http&quot;) &amp;&amp; &quot;80&quot;.equals(this.port)) ||</span>
<span class="fc bfc" id="L862" title="All 4 branches covered.">				(this.scheme.equals(&quot;https&quot;) &amp;&amp; &quot;443&quot;.equals(this.port)))) {</span>
<span class="fc" id="L863">			port(null);</span>
		}

<span class="fc" id="L866">		return this;</span>
	}

	private boolean isForwardedSslOn(HttpHeaders headers) {
<span class="fc" id="L870">		String forwardedSsl = headers.getFirst(&quot;X-Forwarded-Ssl&quot;);</span>
<span class="pc bpc" id="L871" title="1 of 4 branches missed.">		return StringUtils.hasText(forwardedSsl) &amp;&amp; forwardedSsl.equalsIgnoreCase(&quot;on&quot;);</span>
	}

	private void adaptForwardedHost(String hostToUse) {
<span class="fc" id="L875">		int portSeparatorIdx = hostToUse.lastIndexOf(':');</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">		if (portSeparatorIdx &gt; hostToUse.lastIndexOf(']')) {</span>
<span class="fc" id="L877">			host(hostToUse.substring(0, portSeparatorIdx));</span>
<span class="fc" id="L878">			port(Integer.parseInt(hostToUse.substring(portSeparatorIdx + 1)));</span>
		}
		else {
<span class="fc" id="L881">			host(hostToUse);</span>
<span class="fc" id="L882">			port(null);</span>
		}
<span class="fc" id="L884">	}</span>

	private void resetHierarchicalComponents() {
<span class="fc" id="L887">		this.userInfo = null;</span>
<span class="fc" id="L888">		this.host = null;</span>
<span class="fc" id="L889">		this.port = null;</span>
<span class="fc" id="L890">		this.pathBuilder = new CompositePathComponentBuilder();</span>
<span class="fc" id="L891">		this.queryParams.clear();</span>
<span class="fc" id="L892">	}</span>

	private void resetSchemeSpecificPart() {
<span class="fc" id="L895">		this.ssp = null;</span>
<span class="fc" id="L896">	}</span>


	/**
	 * Public declaration of Object's {@code clone()} method.
	 * Delegates to {@link #cloneBuilder()}.
	 */
	@Override
	public Object clone() {
<span class="fc" id="L905">		return cloneBuilder();</span>
	}

	/**
	 * Clone this {@code UriComponentsBuilder}.
	 * @return the cloned {@code UriComponentsBuilder} object
	 * @since 4.2.7
	 */
	public UriComponentsBuilder cloneBuilder() {
<span class="fc" id="L914">		return new UriComponentsBuilder(this);</span>
	}


	private interface PathComponentBuilder {

		@Nullable
		PathComponent build();

		PathComponentBuilder cloneBuilder();
	}


<span class="fc" id="L927">	private static class CompositePathComponentBuilder implements PathComponentBuilder {</span>

<span class="fc" id="L929">		private final LinkedList&lt;PathComponentBuilder&gt; builders = new LinkedList&lt;&gt;();</span>

		public void addPathSegments(String... pathSegments) {
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">			if (!ObjectUtils.isEmpty(pathSegments)) {</span>
<span class="fc" id="L933">				PathSegmentComponentBuilder psBuilder = getLastBuilder(PathSegmentComponentBuilder.class);</span>
<span class="fc" id="L934">				FullPathComponentBuilder fpBuilder = getLastBuilder(FullPathComponentBuilder.class);</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">				if (psBuilder == null) {</span>
<span class="fc" id="L936">					psBuilder = new PathSegmentComponentBuilder();</span>
<span class="fc" id="L937">					this.builders.add(psBuilder);</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">					if (fpBuilder != null) {</span>
<span class="fc" id="L939">						fpBuilder.removeTrailingSlash();</span>
					}
				}
<span class="fc" id="L942">				psBuilder.append(pathSegments);</span>
			}
<span class="fc" id="L944">		}</span>

		public void addPath(String path) {
<span class="fc bfc" id="L947" title="All 2 branches covered.">			if (StringUtils.hasText(path)) {</span>
<span class="fc" id="L948">				PathSegmentComponentBuilder psBuilder = getLastBuilder(PathSegmentComponentBuilder.class);</span>
<span class="fc" id="L949">				FullPathComponentBuilder fpBuilder = getLastBuilder(FullPathComponentBuilder.class);</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">				if (psBuilder != null) {</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">					path = (path.startsWith(&quot;/&quot;) ? path : &quot;/&quot; + path);</span>
				}
<span class="fc bfc" id="L953" title="All 2 branches covered.">				if (fpBuilder == null) {</span>
<span class="fc" id="L954">					fpBuilder = new FullPathComponentBuilder();</span>
<span class="fc" id="L955">					this.builders.add(fpBuilder);</span>
				}
<span class="fc" id="L957">				fpBuilder.append(path);</span>
			}
<span class="fc" id="L959">		}</span>

		@SuppressWarnings(&quot;unchecked&quot;)
		@Nullable
		private &lt;T&gt; T getLastBuilder(Class&lt;T&gt; builderClass) {
<span class="fc bfc" id="L964" title="All 2 branches covered.">			if (!this.builders.isEmpty()) {</span>
<span class="fc" id="L965">				PathComponentBuilder last = this.builders.getLast();</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">				if (builderClass.isInstance(last)) {</span>
<span class="fc" id="L967">					return (T) last;</span>
				}
			}
<span class="fc" id="L970">			return null;</span>
		}

		@Override
		public PathComponent build() {
<span class="fc" id="L975">			int size = this.builders.size();</span>
<span class="fc" id="L976">			List&lt;PathComponent&gt; components = new ArrayList&lt;&gt;(size);</span>
<span class="fc bfc" id="L977" title="All 2 branches covered.">			for (PathComponentBuilder componentBuilder : this.builders) {</span>
<span class="fc" id="L978">				PathComponent pathComponent = componentBuilder.build();</span>
<span class="pc bpc" id="L979" title="1 of 2 branches missed.">				if (pathComponent != null) {</span>
<span class="fc" id="L980">					components.add(pathComponent);</span>
				}
<span class="fc" id="L982">			}</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">			if (components.isEmpty()) {</span>
<span class="fc" id="L984">				return HierarchicalUriComponents.NULL_PATH_COMPONENT;</span>
			}
<span class="fc bfc" id="L986" title="All 2 branches covered.">			if (components.size() == 1) {</span>
<span class="fc" id="L987">				return components.get(0);</span>
			}
<span class="fc" id="L989">			return new HierarchicalUriComponents.PathComponentComposite(components);</span>
		}

		@Override
		public CompositePathComponentBuilder cloneBuilder() {
<span class="fc" id="L994">			CompositePathComponentBuilder compositeBuilder = new CompositePathComponentBuilder();</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">			for (PathComponentBuilder builder : this.builders) {</span>
<span class="fc" id="L996">				compositeBuilder.builders.add(builder.cloneBuilder());</span>
<span class="fc" id="L997">			}</span>
<span class="fc" id="L998">			return compositeBuilder;</span>
		}
	}


<span class="fc" id="L1003">	private static class FullPathComponentBuilder implements PathComponentBuilder {</span>

<span class="fc" id="L1005">		private final StringBuilder path = new StringBuilder();</span>

		public void append(String path) {
<span class="fc" id="L1008">			this.path.append(path);</span>
<span class="fc" id="L1009">		}</span>

		@Override
		public PathComponent build() {
<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">			if (this.path.length() == 0) {</span>
<span class="nc" id="L1014">				return null;</span>
			}
<span class="fc" id="L1016">			String path = this.path.toString();</span>
			while (true) {
<span class="fc" id="L1018">				int index = path.indexOf(&quot;//&quot;);</span>
<span class="fc bfc" id="L1019" title="All 2 branches covered.">				if (index == -1) {</span>
<span class="fc" id="L1020">					break;</span>
				}
<span class="fc" id="L1022">				path = path.substring(0, index) + path.substring(index + 1);</span>
<span class="fc" id="L1023">			}</span>
<span class="fc" id="L1024">			return new HierarchicalUriComponents.FullPathComponent(path);</span>
		}

		public void removeTrailingSlash() {
<span class="fc" id="L1028">			int index = this.path.length() - 1;</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">			if (this.path.charAt(index) == '/') {</span>
<span class="fc" id="L1030">				this.path.deleteCharAt(index);</span>
			}
<span class="fc" id="L1032">		}</span>

		@Override
		public FullPathComponentBuilder cloneBuilder() {
<span class="fc" id="L1036">			FullPathComponentBuilder builder = new FullPathComponentBuilder();</span>
<span class="fc" id="L1037">			builder.append(this.path.toString());</span>
<span class="fc" id="L1038">			return builder;</span>
		}
	}


<span class="fc" id="L1043">	private static class PathSegmentComponentBuilder implements PathComponentBuilder {</span>

<span class="fc" id="L1045">		private final List&lt;String&gt; pathSegments = new LinkedList&lt;&gt;();</span>

		public void append(String... pathSegments) {
<span class="fc bfc" id="L1048" title="All 2 branches covered.">			for (String pathSegment : pathSegments) {</span>
<span class="fc bfc" id="L1049" title="All 2 branches covered.">				if (StringUtils.hasText(pathSegment)) {</span>
<span class="fc" id="L1050">					this.pathSegments.add(pathSegment);</span>
				}
			}
<span class="fc" id="L1053">		}</span>

		@Override
		public PathComponent build() {
<span class="pc bpc" id="L1057" title="1 of 2 branches missed.">			return (this.pathSegments.isEmpty() ? null :</span>
					new HierarchicalUriComponents.PathSegmentComponent(this.pathSegments));
		}

		@Override
		public PathSegmentComponentBuilder cloneBuilder() {
<span class="fc" id="L1063">			PathSegmentComponentBuilder builder = new PathSegmentComponentBuilder();</span>
<span class="fc" id="L1064">			builder.pathSegments.addAll(this.pathSegments);</span>
<span class="fc" id="L1065">			return builder;</span>
		}
	}


<span class="fc" id="L1070">	private enum EncodingHint { ENCODE_TEMPLATE, FULLY_ENCODED, NONE }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>