<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FrameworkServlet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-webmvc</a> &gt; <a href="index.source.html" class="el_package">org.springframework.web.servlet</a> &gt; <span class="el_source">FrameworkServlet.java</span></div><h1>FrameworkServlet.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.servlet;

import java.io.IOException;
import java.security.Principal;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.stream.Collectors;
import javax.servlet.DispatcherType;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

import org.springframework.beans.BeanUtils;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationContextException;
import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ApplicationListener;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.context.event.SourceFilteringListener;
import org.springframework.context.i18n.LocaleContext;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.context.i18n.SimpleLocaleContext;
import org.springframework.core.GenericTypeResolver;
import org.springframework.core.annotation.AnnotationAwareOrderComparator;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.lang.Nullable;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.context.ConfigurableWebApplicationContext;
import org.springframework.web.context.ConfigurableWebEnvironment;
import org.springframework.web.context.ContextLoader;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.context.request.async.CallableProcessingInterceptor;
import org.springframework.web.context.request.async.WebAsyncManager;
import org.springframework.web.context.request.async.WebAsyncUtils;
import org.springframework.web.context.support.ServletRequestHandledEvent;
import org.springframework.web.context.support.WebApplicationContextUtils;
import org.springframework.web.context.support.XmlWebApplicationContext;
import org.springframework.web.cors.CorsUtils;
import org.springframework.web.util.NestedServletException;
import org.springframework.web.util.WebUtils;

/**
 * Base servlet for Spring's web framework. Provides integration with
 * a Spring application context, in a JavaBean-based overall solution.
 *
 * &lt;p&gt;This class offers the following functionality:
 * &lt;ul&gt;
 * &lt;li&gt;Manages a {@link org.springframework.web.context.WebApplicationContext
 * WebApplicationContext} instance per servlet. The servlet's configuration is determined
 * by beans in the servlet's namespace.
 * &lt;li&gt;Publishes events on request processing, whether or not a request is
 * successfully handled.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Subclasses must implement {@link #doService} to handle requests. Because this extends
 * {@link HttpServletBean} rather than HttpServlet directly, bean properties are
 * automatically mapped onto it. Subclasses can override {@link #initFrameworkServlet()}
 * for custom initialization.
 *
 * &lt;p&gt;Detects a &quot;contextClass&quot; parameter at the servlet init-param level,
 * falling back to the default context class,
 * {@link org.springframework.web.context.support.XmlWebApplicationContext
 * XmlWebApplicationContext}, if not found. Note that, with the default
 * {@code FrameworkServlet}, a custom context class needs to implement the
 * {@link org.springframework.web.context.ConfigurableWebApplicationContext
 * ConfigurableWebApplicationContext} SPI.
 *
 * &lt;p&gt;Accepts an optional &quot;contextInitializerClasses&quot; servlet init-param that
 * specifies one or more {@link org.springframework.context.ApplicationContextInitializer
 * ApplicationContextInitializer} classes. The managed web application context will be
 * delegated to these initializers, allowing for additional programmatic configuration,
 * e.g. adding property sources or activating profiles against the {@linkplain
 * org.springframework.context.ConfigurableApplicationContext#getEnvironment() context's
 * environment}. See also {@link org.springframework.web.context.ContextLoader} which
 * supports a &quot;contextInitializerClasses&quot; context-param with identical semantics for
 * the &quot;root&quot; web application context.
 *
 * &lt;p&gt;Passes a &quot;contextConfigLocation&quot; servlet init-param to the context instance,
 * parsing it into potentially multiple file paths which can be separated by any
 * number of commas and spaces, like &quot;test-servlet.xml, myServlet.xml&quot;.
 * If not explicitly specified, the context implementation is supposed to build a
 * default location from the namespace of the servlet.
 *
 * &lt;p&gt;Note: In case of multiple config locations, later bean definitions will
 * override ones defined in earlier loaded files, at least when using Spring's
 * default ApplicationContext implementation. This can be leveraged to
 * deliberately override certain bean definitions via an extra XML file.
 *
 * &lt;p&gt;The default namespace is &quot;'servlet-name'-servlet&quot;, e.g. &quot;test-servlet&quot; for a
 * servlet-name &quot;test&quot; (leading to a &quot;/WEB-INF/test-servlet.xml&quot; default location
 * with XmlWebApplicationContext). The namespace can also be set explicitly via
 * the &quot;namespace&quot; servlet init-param.
 *
 * &lt;p&gt;As of Spring 3.1, {@code FrameworkServlet} may now be injected with a web
 * application context, rather than creating its own internally. This is useful in Servlet
 * 3.0+ environments, which support programmatic registration of servlet instances. See
 * {@link #FrameworkServlet(WebApplicationContext)} Javadoc for details.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @author Chris Beams
 * @author Rossen Stoyanchev
 * @author Phillip Webb
 * @see #doService
 * @see #setContextClass
 * @see #setContextConfigLocation
 * @see #setContextInitializerClasses
 * @see #setNamespace
 */
@SuppressWarnings(&quot;serial&quot;)
public abstract class FrameworkServlet extends HttpServletBean implements ApplicationContextAware {

	/**
	 * Suffix for WebApplicationContext namespaces. If a servlet of this class is
	 * given the name &quot;test&quot; in a context, the namespace used by the servlet will
	 * resolve to &quot;test-servlet&quot;.
	 */
	public static final String DEFAULT_NAMESPACE_SUFFIX = &quot;-servlet&quot;;

	/**
	 * Default context class for FrameworkServlet.
	 * @see org.springframework.web.context.support.XmlWebApplicationContext
	 */
<span class="fc" id="L155">	public static final Class&lt;?&gt; DEFAULT_CONTEXT_CLASS = XmlWebApplicationContext.class;</span>

	/**
	 * Prefix for the ServletContext attribute for the WebApplicationContext.
	 * The completion is the servlet name.
	 */
<span class="fc" id="L161">	public static final String SERVLET_CONTEXT_PREFIX = FrameworkServlet.class.getName() + &quot;.CONTEXT.&quot;;</span>

	/**
	 * Any number of these characters are considered delimiters between
	 * multiple values in a single init-param String value.
	 */
	private static final String INIT_PARAM_DELIMITERS = &quot;,; \t\n&quot;;


	/** ServletContext attribute to find the WebApplicationContext in. */
	@Nullable
	private String contextAttribute;

	/** WebApplicationContext implementation class to create. */
<span class="fc" id="L175">	private Class&lt;?&gt; contextClass = DEFAULT_CONTEXT_CLASS;</span>

	/** WebApplicationContext id to assign. */
	@Nullable
	private String contextId;

	/** Namespace for this servlet. */
	@Nullable
	private String namespace;

	/** Explicit context config location. */
	@Nullable
	private String contextConfigLocation;

	/** Actual ApplicationContextInitializer instances to apply to the context. */
<span class="fc" id="L190">	private final List&lt;ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt;&gt; contextInitializers =</span>
			new ArrayList&lt;&gt;();

	/** Comma-delimited ApplicationContextInitializer class names set through init param. */
	@Nullable
	private String contextInitializerClasses;

	/** Should we publish the context as a ServletContext attribute?. */
<span class="fc" id="L198">	private boolean publishContext = true;</span>

	/** Should we publish a ServletRequestHandledEvent at the end of each request?. */
<span class="fc" id="L201">	private boolean publishEvents = true;</span>

	/** Expose LocaleContext and RequestAttributes as inheritable for child threads?. */
<span class="fc" id="L204">	private boolean threadContextInheritable = false;</span>

	/** Should we dispatch an HTTP OPTIONS request to {@link #doService}?. */
<span class="fc" id="L207">	private boolean dispatchOptionsRequest = false;</span>

	/** Should we dispatch an HTTP TRACE request to {@link #doService}?. */
<span class="fc" id="L210">	private boolean dispatchTraceRequest = false;</span>

	/** Whether to log potentially sensitive info (request params at DEBUG + headers at TRACE). */
<span class="fc" id="L213">	private boolean enableLoggingRequestDetails = false;</span>

	/** WebApplicationContext for this servlet. */
	@Nullable
	private WebApplicationContext webApplicationContext;

	/** If the WebApplicationContext was injected via {@link #setApplicationContext}. */
<span class="fc" id="L220">	private boolean webApplicationContextInjected = false;</span>

	/** Flag used to detect whether onRefresh has already been called. */
<span class="fc" id="L223">	private volatile boolean refreshEventReceived = false;</span>

	/** Monitor for synchronized onRefresh execution. */
<span class="fc" id="L226">	private final Object onRefreshMonitor = new Object();</span>


	/**
	 * Create a new {@code FrameworkServlet} that will create its own internal web
	 * application context based on defaults and values provided through servlet
	 * init-params. Typically used in Servlet 2.5 or earlier environments, where the only
	 * option for servlet registration is through {@code web.xml} which requires the use
	 * of a no-arg constructor.
	 * &lt;p&gt;Calling {@link #setContextConfigLocation} (init-param 'contextConfigLocation')
	 * will dictate which XML files will be loaded by the
	 * {@linkplain #DEFAULT_CONTEXT_CLASS default XmlWebApplicationContext}
	 * &lt;p&gt;Calling {@link #setContextClass} (init-param 'contextClass') overrides the
	 * default {@code XmlWebApplicationContext} and allows for specifying an alternative class,
	 * such as {@code AnnotationConfigWebApplicationContext}.
	 * &lt;p&gt;Calling {@link #setContextInitializerClasses} (init-param 'contextInitializerClasses')
	 * indicates which {@link ApplicationContextInitializer} classes should be used to
	 * further configure the internal application context prior to refresh().
	 * @see #FrameworkServlet(WebApplicationContext)
	 */
<span class="fc" id="L246">	public FrameworkServlet() {</span>
<span class="fc" id="L247">	}</span>

	/**
	 * Create a new {@code FrameworkServlet} with the given web application context. This
	 * constructor is useful in Servlet 3.0+ environments where instance-based registration
	 * of servlets is possible through the {@link ServletContext#addServlet} API.
	 * &lt;p&gt;Using this constructor indicates that the following properties / init-params
	 * will be ignored:
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link #setContextClass(Class)} / 'contextClass'&lt;/li&gt;
	 * &lt;li&gt;{@link #setContextConfigLocation(String)} / 'contextConfigLocation'&lt;/li&gt;
	 * &lt;li&gt;{@link #setContextAttribute(String)} / 'contextAttribute'&lt;/li&gt;
	 * &lt;li&gt;{@link #setNamespace(String)} / 'namespace'&lt;/li&gt;
	 * &lt;/ul&gt;
	 * &lt;p&gt;The given web application context may or may not yet be {@linkplain
	 * ConfigurableApplicationContext#refresh() refreshed}. If it (a) is an implementation
	 * of {@link ConfigurableWebApplicationContext} and (b) has &lt;strong&gt;not&lt;/strong&gt;
	 * already been refreshed (the recommended approach), then the following will occur:
	 * &lt;ul&gt;
	 * &lt;li&gt;If the given context does not already have a {@linkplain
	 * ConfigurableApplicationContext#setParent parent}, the root application context
	 * will be set as the parent.&lt;/li&gt;
	 * &lt;li&gt;If the given context has not already been assigned an {@linkplain
	 * ConfigurableApplicationContext#setId id}, one will be assigned to it&lt;/li&gt;
	 * &lt;li&gt;{@code ServletContext} and {@code ServletConfig} objects will be delegated to
	 * the application context&lt;/li&gt;
	 * &lt;li&gt;{@link #postProcessWebApplicationContext} will be called&lt;/li&gt;
	 * &lt;li&gt;Any {@link ApplicationContextInitializer ApplicationContextInitializers} specified through the
	 * &quot;contextInitializerClasses&quot; init-param or through the {@link
	 * #setContextInitializers} property will be applied.&lt;/li&gt;
	 * &lt;li&gt;{@link ConfigurableApplicationContext#refresh refresh()} will be called&lt;/li&gt;
	 * &lt;/ul&gt;
	 * If the context has already been refreshed or does not implement
	 * {@code ConfigurableWebApplicationContext}, none of the above will occur under the
	 * assumption that the user has performed these actions (or not) per his or her
	 * specific needs.
	 * &lt;p&gt;See {@link org.springframework.web.WebApplicationInitializer} for usage examples.
	 * @param webApplicationContext the context to use
	 * @see #initWebApplicationContext
	 * @see #configureAndRefreshWebApplicationContext
	 * @see org.springframework.web.WebApplicationInitializer
	 */
<span class="fc" id="L289">	public FrameworkServlet(WebApplicationContext webApplicationContext) {</span>
<span class="fc" id="L290">		this.webApplicationContext = webApplicationContext;</span>
<span class="fc" id="L291">	}</span>


	/**
	 * Set the name of the ServletContext attribute which should be used to retrieve the
	 * {@link WebApplicationContext} that this servlet is supposed to use.
	 */
	public void setContextAttribute(@Nullable String contextAttribute) {
<span class="nc" id="L299">		this.contextAttribute = contextAttribute;</span>
<span class="nc" id="L300">	}</span>

	/**
	 * Return the name of the ServletContext attribute which should be used to retrieve the
	 * {@link WebApplicationContext} that this servlet is supposed to use.
	 */
	@Nullable
	public String getContextAttribute() {
<span class="fc" id="L308">		return this.contextAttribute;</span>
	}

	/**
	 * Set a custom context class. This class must be of type
	 * {@link org.springframework.web.context.WebApplicationContext}.
	 * &lt;p&gt;When using the default FrameworkServlet implementation,
	 * the context class must also implement the
	 * {@link org.springframework.web.context.ConfigurableWebApplicationContext}
	 * interface.
	 * @see #createWebApplicationContext
	 */
	public void setContextClass(Class&lt;?&gt; contextClass) {
<span class="fc" id="L321">		this.contextClass = contextClass;</span>
<span class="fc" id="L322">	}</span>

	/**
	 * Return the custom context class.
	 */
	public Class&lt;?&gt; getContextClass() {
<span class="fc" id="L328">		return this.contextClass;</span>
	}

	/**
	 * Specify a custom WebApplicationContext id,
	 * to be used as serialization id for the underlying BeanFactory.
	 */
	public void setContextId(@Nullable String contextId) {
<span class="nc" id="L336">		this.contextId = contextId;</span>
<span class="nc" id="L337">	}</span>

	/**
	 * Return the custom WebApplicationContext id, if any.
	 */
	@Nullable
	public String getContextId() {
<span class="nc" id="L344">		return this.contextId;</span>
	}

	/**
	 * Set a custom namespace for this servlet,
	 * to be used for building a default context config location.
	 */
	public void setNamespace(String namespace) {
<span class="fc" id="L352">		this.namespace = namespace;</span>
<span class="fc" id="L353">	}</span>

	/**
	 * Return the namespace for this servlet, falling back to default scheme if
	 * no custom namespace was set: e.g. &quot;test-servlet&quot; for a servlet named &quot;test&quot;.
	 */
	public String getNamespace() {
<span class="fc bfc" id="L360" title="All 2 branches covered.">		return (this.namespace != null ? this.namespace : getServletName() + DEFAULT_NAMESPACE_SUFFIX);</span>
	}

	/**
	 * Set the context config location explicitly, instead of relying on the default
	 * location built from the namespace. This location string can consist of
	 * multiple locations separated by any number of commas and spaces.
	 */
	public void setContextConfigLocation(@Nullable String contextConfigLocation) {
<span class="fc" id="L369">		this.contextConfigLocation = contextConfigLocation;</span>
<span class="fc" id="L370">	}</span>

	/**
	 * Return the explicit context config location, if any.
	 */
	@Nullable
	public String getContextConfigLocation() {
<span class="fc" id="L377">		return this.contextConfigLocation;</span>
	}

	/**
	 * Specify which {@link ApplicationContextInitializer} instances should be used
	 * to initialize the application context used by this {@code FrameworkServlet}.
	 * @see #configureAndRefreshWebApplicationContext
	 * @see #applyInitializers
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public void setContextInitializers(@Nullable ApplicationContextInitializer&lt;?&gt;... initializers) {
<span class="fc bfc" id="L388" title="All 2 branches covered.">		if (initializers != null) {</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">			for (ApplicationContextInitializer&lt;?&gt; initializer : initializers) {</span>
<span class="fc" id="L390">				this.contextInitializers.add((ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt;) initializer);</span>
			}
		}
<span class="fc" id="L393">	}</span>

	/**
	 * Specify the set of fully-qualified {@link ApplicationContextInitializer} class
	 * names, per the optional &quot;contextInitializerClasses&quot; servlet init-param.
	 * @see #configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext)
	 * @see #applyInitializers(ConfigurableApplicationContext)
	 */
	public void setContextInitializerClasses(String contextInitializerClasses) {
<span class="fc" id="L402">		this.contextInitializerClasses = contextInitializerClasses;</span>
<span class="fc" id="L403">	}</span>

	/**
	 * Set whether to publish this servlet's context as a ServletContext attribute,
	 * available to all objects in the web container. Default is &quot;true&quot;.
	 * &lt;p&gt;This is especially handy during testing, although it is debatable whether
	 * it's good practice to let other application objects access the context this way.
	 */
	public void setPublishContext(boolean publishContext) {
<span class="fc" id="L412">		this.publishContext = publishContext;</span>
<span class="fc" id="L413">	}</span>

	/**
	 * Set whether this servlet should publish a ServletRequestHandledEvent at the end
	 * of each request. Default is &quot;true&quot;; can be turned off for a slight performance
	 * improvement, provided that no ApplicationListeners rely on such events.
	 * @see org.springframework.web.context.support.ServletRequestHandledEvent
	 */
	public void setPublishEvents(boolean publishEvents) {
<span class="fc" id="L422">		this.publishEvents = publishEvents;</span>
<span class="fc" id="L423">	}</span>

	/**
	 * Set whether to expose the LocaleContext and RequestAttributes as inheritable
	 * for child threads (using an {@link java.lang.InheritableThreadLocal}).
	 * &lt;p&gt;Default is &quot;false&quot;, to avoid side effects on spawned background threads.
	 * Switch this to &quot;true&quot; to enable inheritance for custom child threads which
	 * are spawned during request processing and only used for this request
	 * (that is, ending after their initial task, without reuse of the thread).
	 * &lt;p&gt;&lt;b&gt;WARNING:&lt;/b&gt; Do not use inheritance for child threads if you are
	 * accessing a thread pool which is configured to potentially add new threads
	 * on demand (e.g. a JDK {@link java.util.concurrent.ThreadPoolExecutor}),
	 * since this will expose the inherited context to such a pooled thread.
	 */
	public void setThreadContextInheritable(boolean threadContextInheritable) {
<span class="nc" id="L438">		this.threadContextInheritable = threadContextInheritable;</span>
<span class="nc" id="L439">	}</span>

	/**
	 * Set whether this servlet should dispatch an HTTP OPTIONS request to
	 * the {@link #doService} method.
	 * &lt;p&gt;Default in the {@code FrameworkServlet} is &quot;false&quot;, applying
	 * {@link javax.servlet.http.HttpServlet}'s default behavior (i.e.enumerating
	 * all standard HTTP request methods as a response to the OPTIONS request).
	 * Note however that as of 4.3 the {@code DispatcherServlet} sets this
	 * property to &quot;true&quot; by default due to its built-in support for OPTIONS.
	 * &lt;p&gt;Turn this flag on if you prefer OPTIONS requests to go through the
	 * regular dispatching chain, just like other HTTP requests. This usually
	 * means that your controllers will receive those requests; make sure
	 * that those endpoints are actually able to handle an OPTIONS request.
	 * &lt;p&gt;Note that HttpServlet's default OPTIONS processing will be applied
	 * in any case if your controllers happen to not set the 'Allow' header
	 * (as required for an OPTIONS response).
	 */
	public void setDispatchOptionsRequest(boolean dispatchOptionsRequest) {
<span class="fc" id="L458">		this.dispatchOptionsRequest = dispatchOptionsRequest;</span>
<span class="fc" id="L459">	}</span>

	/**
	 * Set whether this servlet should dispatch an HTTP TRACE request to
	 * the {@link #doService} method.
	 * &lt;p&gt;Default is &quot;false&quot;, applying {@link javax.servlet.http.HttpServlet}'s
	 * default behavior (i.e. reflecting the message received back to the client).
	 * &lt;p&gt;Turn this flag on if you prefer TRACE requests to go through the
	 * regular dispatching chain, just like other HTTP requests. This usually
	 * means that your controllers will receive those requests; make sure
	 * that those endpoints are actually able to handle a TRACE request.
	 * &lt;p&gt;Note that HttpServlet's default TRACE processing will be applied
	 * in any case if your controllers happen to not generate a response
	 * of content type 'message/http' (as required for a TRACE response).
	 */
	public void setDispatchTraceRequest(boolean dispatchTraceRequest) {
<span class="nc" id="L475">		this.dispatchTraceRequest = dispatchTraceRequest;</span>
<span class="nc" id="L476">	}</span>

	/**
	 * Whether to log request params at DEBUG level, and headers at TRACE level.
	 * Both may contain sensitive information.
	 * &lt;p&gt;By default set to {@code false} so that request details are not shown.
	 * @param enable whether to enable or not
	 * @since 5.1
	 */
	public void setEnableLoggingRequestDetails(boolean enable) {
<span class="nc" id="L486">		this.enableLoggingRequestDetails = enable;</span>
<span class="nc" id="L487">	}</span>

	/**
	 * Whether logging of potentially sensitive, request details at DEBUG and
	 * TRACE level is allowed.
	 * @since 5.1
	 */
	public boolean isEnableLoggingRequestDetails() {
<span class="nc" id="L495">		return this.enableLoggingRequestDetails;</span>
	}

	/**
	 * Called by Spring via {@link ApplicationContextAware} to inject the current
	 * application context. This method allows FrameworkServlets to be registered as
	 * Spring beans inside an existing {@link WebApplicationContext} rather than
	 * {@link #findWebApplicationContext() finding} a
	 * {@link org.springframework.web.context.ContextLoaderListener bootstrapped} context.
	 * &lt;p&gt;Primarily added to support use in embedded servlet containers.
	 * @since 4.0
	 */
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) {
<span class="nc bnc" id="L509" title="All 4 branches missed.">		if (this.webApplicationContext == null &amp;&amp; applicationContext instanceof WebApplicationContext) {</span>
<span class="nc" id="L510">			this.webApplicationContext = (WebApplicationContext) applicationContext;</span>
<span class="nc" id="L511">			this.webApplicationContextInjected = true;</span>
		}
<span class="nc" id="L513">	}</span>


	/**
	 * Overridden method of {@link HttpServletBean}, invoked after any bean properties
	 * have been set. Creates this servlet's WebApplicationContext.
	 */
	@Override
	protected final void initServletBean() throws ServletException {
<span class="fc" id="L522">		getServletContext().log(&quot;Initializing Spring &quot; + getClass().getSimpleName() + &quot; '&quot; + getServletName() + &quot;'&quot;);</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">		if (logger.isInfoEnabled()) {</span>
<span class="nc" id="L524">			logger.info(&quot;Initializing Servlet '&quot; + getServletName() + &quot;'&quot;);</span>
		}
<span class="fc" id="L526">		long startTime = System.currentTimeMillis();</span>

		try {
<span class="fc" id="L529">			this.webApplicationContext = initWebApplicationContext();</span>
<span class="fc" id="L530">			initFrameworkServlet();</span>
		}
<span class="fc" id="L532">		catch (ServletException | RuntimeException ex) {</span>
<span class="fc" id="L533">			logger.error(&quot;Context initialization failed&quot;, ex);</span>
<span class="fc" id="L534">			throw ex;</span>
<span class="fc" id="L535">		}</span>

<span class="pc bpc" id="L537" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">			String value = this.enableLoggingRequestDetails ?</span>
					&quot;shown which may lead to unsafe logging of potentially sensitive data&quot; :
					&quot;masked to prevent unsafe logging of potentially sensitive data&quot;;
<span class="nc" id="L541">			logger.debug(&quot;enableLoggingRequestDetails='&quot; + this.enableLoggingRequestDetails +</span>
					&quot;': request parameters and headers will be &quot; + value);
		}

<span class="pc bpc" id="L545" title="1 of 2 branches missed.">		if (logger.isInfoEnabled()) {</span>
<span class="nc" id="L546">			logger.info(&quot;Completed initialization in &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;);</span>
		}
<span class="fc" id="L548">	}</span>

	/**
	 * Initialize and publish the WebApplicationContext for this servlet.
	 * &lt;p&gt;Delegates to {@link #createWebApplicationContext} for actual creation
	 * of the context. Can be overridden in subclasses.
	 * @return the WebApplicationContext instance
	 * @see #FrameworkServlet(WebApplicationContext)
	 * @see #setContextClass
	 * @see #setContextConfigLocation
	 */
	protected WebApplicationContext initWebApplicationContext() {
<span class="fc" id="L560">		WebApplicationContext rootContext =</span>
<span class="fc" id="L561">				WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span>
<span class="fc" id="L562">		WebApplicationContext wac = null;</span>

<span class="fc bfc" id="L564" title="All 2 branches covered.">		if (this.webApplicationContext != null) {</span>
			// A context instance was injected at construction time -&gt; use it
<span class="fc" id="L566">			wac = this.webApplicationContext;</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">			if (wac instanceof ConfigurableWebApplicationContext) {</span>
<span class="fc" id="L568">				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">				if (!cwac.isActive()) {</span>
					// The context has not yet been refreshed -&gt; provide services such as
					// setting the parent context, setting the application context id, etc
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">					if (cwac.getParent() == null) {</span>
						// The context instance was injected without an explicit parent -&gt; set
						// the root application context (if any; may be null) as the parent
<span class="fc" id="L575">						cwac.setParent(rootContext);</span>
					}
<span class="fc" id="L577">					configureAndRefreshWebApplicationContext(cwac);</span>
				}
			}
		}
<span class="fc bfc" id="L581" title="All 2 branches covered.">		if (wac == null) {</span>
			// No context instance was injected at construction time -&gt; see if one
			// has been registered in the servlet context. If one exists, it is assumed
			// that the parent context (if any) has already been set and that the
			// user has performed any initialization such as setting the context id
<span class="fc" id="L586">			wac = findWebApplicationContext();</span>
		}
<span class="fc bfc" id="L588" title="All 2 branches covered.">		if (wac == null) {</span>
			// No context instance is defined for this servlet -&gt; create a local one
<span class="fc" id="L590">			wac = createWebApplicationContext(rootContext);</span>
		}

<span class="fc bfc" id="L593" title="All 2 branches covered.">		if (!this.refreshEventReceived) {</span>
			// Either the context is not a ConfigurableApplicationContext with refresh
			// support or the context injected at construction time had already been
			// refreshed -&gt; trigger initial onRefresh manually here.
<span class="fc" id="L597">			synchronized (this.onRefreshMonitor) {</span>
<span class="fc" id="L598">				onRefresh(wac);</span>
<span class="fc" id="L599">			}</span>
		}

<span class="fc bfc" id="L602" title="All 2 branches covered.">		if (this.publishContext) {</span>
			// Publish the context as a servlet context attribute.
<span class="fc" id="L604">			String attrName = getServletContextAttributeName();</span>
<span class="fc" id="L605">			getServletContext().setAttribute(attrName, wac);</span>
		}

<span class="fc" id="L608">		return wac;</span>
	}

	/**
	 * Retrieve a {@code WebApplicationContext} from the {@code ServletContext}
	 * attribute with the {@link #setContextAttribute configured name}. The
	 * {@code WebApplicationContext} must have already been loaded and stored in the
	 * {@code ServletContext} before this servlet gets initialized (or invoked).
	 * &lt;p&gt;Subclasses may override this method to provide a different
	 * {@code WebApplicationContext} retrieval strategy.
	 * @return the WebApplicationContext for this servlet, or {@code null} if not found
	 * @see #getContextAttribute()
	 */
	@Nullable
	protected WebApplicationContext findWebApplicationContext() {
<span class="fc" id="L623">		String attrName = getContextAttribute();</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">		if (attrName == null) {</span>
<span class="fc" id="L625">			return null;</span>
		}
<span class="nc" id="L627">		WebApplicationContext wac =</span>
<span class="nc" id="L628">				WebApplicationContextUtils.getWebApplicationContext(getServletContext(), attrName);</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">		if (wac == null) {</span>
<span class="nc" id="L630">			throw new IllegalStateException(&quot;No WebApplicationContext found: initializer not registered?&quot;);</span>
		}
<span class="nc" id="L632">		return wac;</span>
	}

	/**
	 * Instantiate the WebApplicationContext for this servlet, either a default
	 * {@link org.springframework.web.context.support.XmlWebApplicationContext}
	 * or a {@link #setContextClass custom context class}, if set.
	 * &lt;p&gt;This implementation expects custom contexts to implement the
	 * {@link org.springframework.web.context.ConfigurableWebApplicationContext}
	 * interface. Can be overridden in subclasses.
	 * &lt;p&gt;Do not forget to register this servlet instance as application listener on the
	 * created context (for triggering its {@link #onRefresh callback}, and to call
	 * {@link org.springframework.context.ConfigurableApplicationContext#refresh()}
	 * before returning the context instance.
	 * @param parent the parent ApplicationContext to use, or {@code null} if none
	 * @return the WebApplicationContext for this servlet
	 * @see org.springframework.web.context.support.XmlWebApplicationContext
	 */
	protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) {
<span class="fc" id="L651">		Class&lt;?&gt; contextClass = getContextClass();</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">		if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {</span>
<span class="nc" id="L653">			throw new ApplicationContextException(</span>
<span class="nc" id="L654">					&quot;Fatal initialization error in servlet with name '&quot; + getServletName() +</span>
<span class="nc" id="L655">					&quot;': custom WebApplicationContext class [&quot; + contextClass.getName() +</span>
					&quot;] is not of type ConfigurableWebApplicationContext&quot;);
		}
<span class="fc" id="L658">		ConfigurableWebApplicationContext wac =</span>
<span class="fc" id="L659">				(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span>

<span class="fc" id="L661">		wac.setEnvironment(getEnvironment());</span>
<span class="fc" id="L662">		wac.setParent(parent);</span>
<span class="fc" id="L663">		String configLocation = getContextConfigLocation();</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">		if (configLocation != null) {</span>
<span class="fc" id="L665">			wac.setConfigLocation(configLocation);</span>
		}
<span class="fc" id="L667">		configureAndRefreshWebApplicationContext(wac);</span>

<span class="fc" id="L669">		return wac;</span>
	}

	protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">		if (ObjectUtils.identityToString(wac).equals(wac.getId())) {</span>
			// The application context id is still set to its original default value
			// -&gt; assign a more useful id based on available information
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">			if (this.contextId != null) {</span>
<span class="nc" id="L677">				wac.setId(this.contextId);</span>
			}
			else {
				// Generate default id...
<span class="fc" id="L681">				wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span>
<span class="fc" id="L682">						ObjectUtils.getDisplayString(getServletContext().getContextPath()) + '/' + getServletName());</span>
			}
		}

<span class="fc" id="L686">		wac.setServletContext(getServletContext());</span>
<span class="fc" id="L687">		wac.setServletConfig(getServletConfig());</span>
<span class="fc" id="L688">		wac.setNamespace(getNamespace());</span>
<span class="fc" id="L689">		wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));</span>

		// The wac environment's #initPropertySources will be called in any case when the context
		// is refreshed; do it eagerly here to ensure servlet property sources are in place for
		// use in any post-processing or initialization that occurs below prior to #refresh
<span class="fc" id="L694">		ConfigurableEnvironment env = wac.getEnvironment();</span>
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">		if (env instanceof ConfigurableWebEnvironment) {</span>
<span class="fc" id="L696">			((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span>
		}

<span class="fc" id="L699">		postProcessWebApplicationContext(wac);</span>
<span class="fc" id="L700">		applyInitializers(wac);</span>
<span class="fc" id="L701">		wac.refresh();</span>
<span class="fc" id="L702">	}</span>

	/**
	 * Instantiate the WebApplicationContext for this servlet, either a default
	 * {@link org.springframework.web.context.support.XmlWebApplicationContext}
	 * or a {@link #setContextClass custom context class}, if set.
	 * Delegates to #createWebApplicationContext(ApplicationContext).
	 * @param parent the parent WebApplicationContext to use, or {@code null} if none
	 * @return the WebApplicationContext for this servlet
	 * @see org.springframework.web.context.support.XmlWebApplicationContext
	 * @see #createWebApplicationContext(ApplicationContext)
	 */
	protected WebApplicationContext createWebApplicationContext(@Nullable WebApplicationContext parent) {
<span class="fc" id="L715">		return createWebApplicationContext((ApplicationContext) parent);</span>
	}

	/**
	 * Post-process the given WebApplicationContext before it is refreshed
	 * and activated as context for this servlet.
	 * &lt;p&gt;The default implementation is empty. {@code refresh()} will
	 * be called automatically after this method returns.
	 * &lt;p&gt;Note that this method is designed to allow subclasses to modify the application
	 * context, while {@link #initWebApplicationContext} is designed to allow
	 * end-users to modify the context through the use of
	 * {@link ApplicationContextInitializer ApplicationContextInitializers}.
	 * @param wac the configured WebApplicationContext (not refreshed yet)
	 * @see #createWebApplicationContext
	 * @see #initWebApplicationContext
	 * @see ConfigurableWebApplicationContext#refresh()
	 */
	protected void postProcessWebApplicationContext(ConfigurableWebApplicationContext wac) {
<span class="fc" id="L733">	}</span>

	/**
	 * Delegate the WebApplicationContext before it is refreshed to any
	 * {@link ApplicationContextInitializer} instances specified by the
	 * &quot;contextInitializerClasses&quot; servlet init-param.
	 * &lt;p&gt;See also {@link #postProcessWebApplicationContext}, which is designed to allow
	 * subclasses (as opposed to end-users) to modify the application context, and is
	 * called immediately before this method.
	 * @param wac the configured WebApplicationContext (not refreshed yet)
	 * @see #createWebApplicationContext
	 * @see #postProcessWebApplicationContext
	 * @see ConfigurableApplicationContext#refresh()
	 */
	protected void applyInitializers(ConfigurableApplicationContext wac) {
<span class="fc" id="L748">		String globalClassNames = getServletContext().getInitParameter(ContextLoader.GLOBAL_INITIALIZER_CLASSES_PARAM);</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">		if (globalClassNames != null) {</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">			for (String className : StringUtils.tokenizeToStringArray(globalClassNames, INIT_PARAM_DELIMITERS)) {</span>
<span class="fc" id="L751">				this.contextInitializers.add(loadInitializer(className, wac));</span>
			}
		}

<span class="fc bfc" id="L755" title="All 2 branches covered.">		if (this.contextInitializerClasses != null) {</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">			for (String className : StringUtils.tokenizeToStringArray(this.contextInitializerClasses, INIT_PARAM_DELIMITERS)) {</span>
<span class="fc" id="L757">				this.contextInitializers.add(loadInitializer(className, wac));</span>
			}
		}

<span class="fc" id="L761">		AnnotationAwareOrderComparator.sort(this.contextInitializers);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">		for (ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; initializer : this.contextInitializers) {</span>
<span class="fc" id="L763">			initializer.initialize(wac);</span>
<span class="fc" id="L764">		}</span>
<span class="fc" id="L765">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; loadInitializer(
			String className, ConfigurableApplicationContext wac) {
		try {
<span class="fc" id="L771">			Class&lt;?&gt; initializerClass = ClassUtils.forName(className, wac.getClassLoader());</span>
<span class="fc" id="L772">			Class&lt;?&gt; initializerContextClass =</span>
<span class="fc" id="L773">					GenericTypeResolver.resolveTypeArgument(initializerClass, ApplicationContextInitializer.class);</span>
<span class="pc bpc" id="L774" title="2 of 4 branches missed.">			if (initializerContextClass != null &amp;&amp; !initializerContextClass.isInstance(wac)) {</span>
<span class="nc" id="L775">				throw new ApplicationContextException(String.format(</span>
						&quot;Could not apply context initializer [%s] since its generic parameter [%s] &quot; +
						&quot;is not assignable from the type of application context used by this &quot; +
<span class="nc" id="L778">						&quot;framework servlet: [%s]&quot;, initializerClass.getName(), initializerContextClass.getName(),</span>
<span class="nc" id="L779">						wac.getClass().getName()));</span>
			}
<span class="fc" id="L781">			return BeanUtils.instantiateClass(initializerClass, ApplicationContextInitializer.class);</span>
		}
<span class="nc" id="L783">		catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L784">			throw new ApplicationContextException(String.format(&quot;Could not load class [%s] specified &quot; +</span>
					&quot;via 'contextInitializerClasses' init-param&quot;, className), ex);
		}
	}

	/**
	 * Return the ServletContext attribute name for this servlet's WebApplicationContext.
	 * &lt;p&gt;The default implementation returns
	 * {@code SERVLET_CONTEXT_PREFIX + servlet name}.
	 * @see #SERVLET_CONTEXT_PREFIX
	 * @see #getServletName
	 */
	public String getServletContextAttributeName() {
<span class="fc" id="L797">		return SERVLET_CONTEXT_PREFIX + getServletName();</span>
	}

	/**
	 * Return this servlet's WebApplicationContext.
	 */
	@Nullable
	public final WebApplicationContext getWebApplicationContext() {
<span class="fc" id="L805">		return this.webApplicationContext;</span>
	}


	/**
	 * This method will be invoked after any bean properties have been set and
	 * the WebApplicationContext has been loaded. The default implementation is empty;
	 * subclasses may override this method to perform any initialization they require.
	 * @throws ServletException in case of an initialization exception
	 */
	protected void initFrameworkServlet() throws ServletException {
<span class="fc" id="L816">	}</span>

	/**
	 * Refresh this servlet's application context, as well as the
	 * dependent state of the servlet.
	 * @see #getWebApplicationContext()
	 * @see org.springframework.context.ConfigurableApplicationContext#refresh()
	 */
	public void refresh() {
<span class="fc" id="L825">		WebApplicationContext wac = getWebApplicationContext();</span>
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">		if (!(wac instanceof ConfigurableApplicationContext)) {</span>
<span class="nc" id="L827">			throw new IllegalStateException(&quot;WebApplicationContext does not support refresh: &quot; + wac);</span>
		}
<span class="fc" id="L829">		((ConfigurableApplicationContext) wac).refresh();</span>
<span class="fc" id="L830">	}</span>

	/**
	 * Callback that receives refresh events from this servlet's WebApplicationContext.
	 * &lt;p&gt;The default implementation calls {@link #onRefresh},
	 * triggering a refresh of this servlet's context-dependent state.
	 * @param event the incoming ApplicationContext event
	 */
	public void onApplicationEvent(ContextRefreshedEvent event) {
<span class="fc" id="L839">		this.refreshEventReceived = true;</span>
<span class="fc" id="L840">		synchronized (this.onRefreshMonitor) {</span>
<span class="fc" id="L841">			onRefresh(event.getApplicationContext());</span>
<span class="fc" id="L842">		}</span>
<span class="fc" id="L843">	}</span>

	/**
	 * Template method which can be overridden to add servlet-specific refresh work.
	 * Called after successful context refresh.
	 * &lt;p&gt;This implementation is empty.
	 * @param context the current WebApplicationContext
	 * @see #refresh()
	 */
	protected void onRefresh(ApplicationContext context) {
		// For subclasses: do nothing by default.
<span class="nc" id="L854">	}</span>

	/**
	 * Close the WebApplicationContext of this servlet.
	 * @see org.springframework.context.ConfigurableApplicationContext#close()
	 */
	@Override
	public void destroy() {
<span class="fc" id="L862">		getServletContext().log(&quot;Destroying Spring FrameworkServlet '&quot; + getServletName() + &quot;'&quot;);</span>
		// Only call close() on WebApplicationContext if locally managed...
<span class="pc bpc" id="L864" title="2 of 4 branches missed.">		if (this.webApplicationContext instanceof ConfigurableApplicationContext &amp;&amp; !this.webApplicationContextInjected) {</span>
<span class="fc" id="L865">			((ConfigurableApplicationContext) this.webApplicationContext).close();</span>
		}
<span class="fc" id="L867">	}</span>


	/**
	 * Override the parent class implementation in order to intercept PATCH requests.
	 */
	@Override
	protected void service(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

<span class="fc" id="L877">		HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span>
<span class="pc bpc" id="L878" title="1 of 4 branches missed.">		if (httpMethod == HttpMethod.PATCH || httpMethod == null) {</span>
<span class="fc" id="L879">			processRequest(request, response);</span>
		}
		else {
<span class="fc" id="L882">			super.service(request, response);</span>
		}
<span class="fc" id="L884">	}</span>

	/**
	 * Delegate GET requests to processRequest/doService.
	 * &lt;p&gt;Will also be invoked by HttpServlet's default implementation of {@code doHead},
	 * with a {@code NoBodyResponse} that just captures the content length.
	 * @see #doService
	 * @see #doHead
	 */
	@Override
	protected final void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

<span class="fc" id="L897">		processRequest(request, response);</span>
<span class="fc" id="L898">	}</span>

	/**
	 * Delegate POST requests to {@link #processRequest}.
	 * @see #doService
	 */
	@Override
	protected final void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

<span class="fc" id="L908">		processRequest(request, response);</span>
<span class="fc" id="L909">	}</span>

	/**
	 * Delegate PUT requests to {@link #processRequest}.
	 * @see #doService
	 */
	@Override
	protected final void doPut(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

<span class="fc" id="L919">		processRequest(request, response);</span>
<span class="fc" id="L920">	}</span>

	/**
	 * Delegate DELETE requests to {@link #processRequest}.
	 * @see #doService
	 */
	@Override
	protected final void doDelete(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

<span class="fc" id="L930">		processRequest(request, response);</span>
<span class="fc" id="L931">	}</span>

	/**
	 * Delegate OPTIONS requests to {@link #processRequest}, if desired.
	 * &lt;p&gt;Applies HttpServlet's standard OPTIONS processing otherwise,
	 * and also if there is still no 'Allow' header set after dispatching.
	 * @see #doService
	 */
	@Override
	protected void doOptions(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

<span class="pc bpc" id="L943" title="1 of 4 branches missed.">		if (this.dispatchOptionsRequest || CorsUtils.isPreFlightRequest(request)) {</span>
<span class="fc" id="L944">			processRequest(request, response);</span>
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">			if (response.containsHeader(&quot;Allow&quot;)) {</span>
				// Proper OPTIONS response coming from a handler - we're done.
<span class="fc" id="L947">				return;</span>
			}
		}

		// Use response wrapper in order to always add PATCH to the allowed methods
<span class="fc" id="L952">		super.doOptions(request, new HttpServletResponseWrapper(response) {</span>
			@Override
			public void setHeader(String name, String value) {
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">				if (&quot;Allow&quot;.equals(name)) {</span>
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">					value = (StringUtils.hasLength(value) ? value + &quot;, &quot; : &quot;&quot;) + HttpMethod.PATCH.name();</span>
				}
<span class="fc" id="L958">				super.setHeader(name, value);</span>
<span class="fc" id="L959">			}</span>
		});
<span class="fc" id="L961">	}</span>

	/**
	 * Delegate TRACE requests to {@link #processRequest}, if desired.
	 * &lt;p&gt;Applies HttpServlet's standard TRACE processing otherwise.
	 * @see #doService
	 */
	@Override
	protected void doTrace(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

<span class="nc bnc" id="L972" title="All 2 branches missed.">		if (this.dispatchTraceRequest) {</span>
<span class="nc" id="L973">			processRequest(request, response);</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">			if (&quot;message/http&quot;.equals(response.getContentType())) {</span>
				// Proper TRACE response coming from a handler - we're done.
<span class="nc" id="L976">				return;</span>
			}
		}
<span class="nc" id="L979">		super.doTrace(request, response);</span>
<span class="nc" id="L980">	}</span>

	/**
	 * Process this request, publishing an event regardless of the outcome.
	 * &lt;p&gt;The actual event handling is performed by the abstract
	 * {@link #doService} template method.
	 */
	protected final void processRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

<span class="fc" id="L990">		long startTime = System.currentTimeMillis();</span>
<span class="fc" id="L991">		Throwable failureCause = null;</span>

<span class="fc" id="L993">		LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span>
<span class="fc" id="L994">		LocaleContext localeContext = buildLocaleContext(request);</span>

<span class="fc" id="L996">		RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span>
<span class="fc" id="L997">		ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span>

<span class="fc" id="L999">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span>
<span class="fc" id="L1000">		asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());</span>

<span class="fc" id="L1002">		initContextHolders(request, localeContext, requestAttributes);</span>

		try {
<span class="fc" id="L1005">			doService(request, response);</span>
		}
<span class="fc" id="L1007">		catch (ServletException | IOException ex) {</span>
<span class="fc" id="L1008">			failureCause = ex;</span>
<span class="fc" id="L1009">			throw ex;</span>
		}
<span class="fc" id="L1011">		catch (Throwable ex) {</span>
<span class="fc" id="L1012">			failureCause = ex;</span>
<span class="fc" id="L1013">			throw new NestedServletException(&quot;Request processing failed&quot;, ex);</span>
		}

		finally {
<span class="fc" id="L1017">			resetContextHolders(request, previousLocaleContext, previousAttributes);</span>
<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">			if (requestAttributes != null) {</span>
<span class="fc" id="L1019">				requestAttributes.requestCompleted();</span>
			}
<span class="fc" id="L1021">			logResult(request, response, failureCause, asyncManager);</span>
<span class="fc" id="L1022">			publishRequestHandledEvent(request, response, startTime, failureCause);</span>
		}
<span class="fc" id="L1024">	}</span>

	/**
	 * Build a LocaleContext for the given request, exposing the request's
	 * primary locale as current locale.
	 * @param request current HTTP request
	 * @return the corresponding LocaleContext, or {@code null} if none to bind
	 * @see LocaleContextHolder#setLocaleContext
	 */
	@Nullable
	protected LocaleContext buildLocaleContext(HttpServletRequest request) {
<span class="nc" id="L1035">		return new SimpleLocaleContext(request.getLocale());</span>
	}

	/**
	 * Build ServletRequestAttributes for the given request (potentially also
	 * holding a reference to the response), taking pre-bound attributes
	 * (and their type) into consideration.
	 * @param request current HTTP request
	 * @param response current HTTP response
	 * @param previousAttributes pre-bound RequestAttributes instance, if any
	 * @return the ServletRequestAttributes to bind, or {@code null} to preserve
	 * the previously bound instance (or not binding any, if none bound before)
	 * @see RequestContextHolder#setRequestAttributes
	 */
	@Nullable
	protected ServletRequestAttributes buildRequestAttributes(HttpServletRequest request,
			@Nullable HttpServletResponse response, @Nullable RequestAttributes previousAttributes) {

<span class="pc bpc" id="L1053" title="3 of 4 branches missed.">		if (previousAttributes == null || previousAttributes instanceof ServletRequestAttributes) {</span>
<span class="fc" id="L1054">			return new ServletRequestAttributes(request, response);</span>
		}
		else {
<span class="nc" id="L1057">			return null;  // preserve the pre-bound RequestAttributes instance</span>
		}
	}

	private void initContextHolders(HttpServletRequest request,
			@Nullable LocaleContext localeContext, @Nullable RequestAttributes requestAttributes) {

<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">		if (localeContext != null) {</span>
<span class="fc" id="L1065">			LocaleContextHolder.setLocaleContext(localeContext, this.threadContextInheritable);</span>
		}
<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">		if (requestAttributes != null) {</span>
<span class="fc" id="L1068">			RequestContextHolder.setRequestAttributes(requestAttributes, this.threadContextInheritable);</span>
		}
<span class="fc" id="L1070">	}</span>

	private void resetContextHolders(HttpServletRequest request,
			@Nullable LocaleContext prevLocaleContext, @Nullable RequestAttributes previousAttributes) {

<span class="fc" id="L1075">		LocaleContextHolder.setLocaleContext(prevLocaleContext, this.threadContextInheritable);</span>
<span class="fc" id="L1076">		RequestContextHolder.setRequestAttributes(previousAttributes, this.threadContextInheritable);</span>
<span class="fc" id="L1077">	}</span>

	private void logResult(HttpServletRequest request, HttpServletResponse response,
			@Nullable Throwable failureCause, WebAsyncManager asyncManager) {

<span class="pc bpc" id="L1082" title="1 of 2 branches missed.">		if (!logger.isDebugEnabled()) {</span>
<span class="fc" id="L1083">			return;</span>
		}

<span class="nc" id="L1086">		String dispatchType = request.getDispatcherType().name();</span>
<span class="nc" id="L1087">		boolean initialDispatch = request.getDispatcherType().equals(DispatcherType.REQUEST);</span>

<span class="nc bnc" id="L1089" title="All 2 branches missed.">		if (failureCause != null) {</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">			if (!initialDispatch) {</span>
				// FORWARD/ERROR/ASYNC: minimal message (there should be enough context already)
<span class="nc bnc" id="L1092" title="All 2 branches missed.">				if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L1093">					logger.debug(&quot;Unresolved failure from \&quot;&quot; + dispatchType + &quot;\&quot; dispatch: &quot; + failureCause);</span>
				}
			}
<span class="nc bnc" id="L1096" title="All 2 branches missed.">			else if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L1097">				logger.trace(&quot;Failed to complete request&quot;, failureCause);</span>
			}
			else {
<span class="nc" id="L1100">				logger.debug(&quot;Failed to complete request: &quot; + failureCause);</span>
			}
<span class="nc" id="L1102">			return;</span>
		}

<span class="nc bnc" id="L1105" title="All 2 branches missed.">		if (asyncManager.isConcurrentHandlingStarted()) {</span>
<span class="nc" id="L1106">			logger.debug(&quot;Exiting but response remains open for further handling&quot;);</span>
<span class="nc" id="L1107">			return;</span>
		}

<span class="nc" id="L1110">		int status = response.getStatus();</span>
<span class="nc" id="L1111">		String headers = &quot;&quot;; // nothing below trace</span>

<span class="nc bnc" id="L1113" title="All 2 branches missed.">		if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L1114">			Collection&lt;String&gt; names = response.getHeaderNames();</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">			if (this.enableLoggingRequestDetails) {</span>
<span class="nc" id="L1116">				headers = names.stream().map(name -&gt; name + &quot;:&quot; + response.getHeaders(name))</span>
<span class="nc" id="L1117">						.collect(Collectors.joining(&quot;, &quot;));</span>
			}
			else {
<span class="nc bnc" id="L1120" title="All 2 branches missed.">				headers = names.isEmpty() ? &quot;&quot; : &quot;masked&quot;;</span>
			}
<span class="nc" id="L1122">			headers = &quot;, headers={&quot; + headers + &quot;}&quot;;</span>
		}

<span class="nc bnc" id="L1125" title="All 2 branches missed.">		if (!initialDispatch) {</span>
<span class="nc" id="L1126">			logger.debug(&quot;Exiting from \&quot;&quot; + dispatchType + &quot;\&quot; dispatch, status &quot; + status + headers);</span>
		}
		else {
<span class="nc" id="L1129">			HttpStatus httpStatus = HttpStatus.resolve(status);</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">			logger.debug(&quot;Completed &quot; + (httpStatus != null ? httpStatus : status) + headers);</span>
		}
<span class="nc" id="L1132">	}</span>

	private void publishRequestHandledEvent(HttpServletRequest request, HttpServletResponse response,
			long startTime, @Nullable Throwable failureCause) {

<span class="pc bpc" id="L1137" title="1 of 4 branches missed.">		if (this.publishEvents &amp;&amp; this.webApplicationContext != null) {</span>
			// Whether or not we succeeded, publish an event.
<span class="fc" id="L1139">			long processingTime = System.currentTimeMillis() - startTime;</span>
<span class="fc" id="L1140">			this.webApplicationContext.publishEvent(</span>
					new ServletRequestHandledEvent(this,
<span class="fc" id="L1142">							request.getRequestURI(), request.getRemoteAddr(),</span>
<span class="fc" id="L1143">							request.getMethod(), getServletConfig().getServletName(),</span>
<span class="fc" id="L1144">							WebUtils.getSessionId(request), getUsernameForRequest(request),</span>
<span class="fc" id="L1145">							processingTime, failureCause, response.getStatus()));</span>
		}
<span class="fc" id="L1147">	}</span>

	/**
	 * Determine the username for the given request.
	 * &lt;p&gt;The default implementation takes the name of the UserPrincipal, if any.
	 * Can be overridden in subclasses.
	 * @param request current HTTP request
	 * @return the username, or {@code null} if none found
	 * @see javax.servlet.http.HttpServletRequest#getUserPrincipal()
	 */
	@Nullable
	protected String getUsernameForRequest(HttpServletRequest request) {
<span class="fc" id="L1159">		Principal userPrincipal = request.getUserPrincipal();</span>
<span class="fc bfc" id="L1160" title="All 2 branches covered.">		return (userPrincipal != null ? userPrincipal.getName() : null);</span>
	}


	/**
	 * Subclasses must implement this method to do the work of request handling,
	 * receiving a centralized callback for GET, POST, PUT and DELETE.
	 * &lt;p&gt;The contract is essentially the same as that for the commonly overridden
	 * {@code doGet} or {@code doPost} methods of HttpServlet.
	 * &lt;p&gt;This class intercepts calls to ensure that exception handling and
	 * event publication takes place.
	 * @param request current HTTP request
	 * @param response current HTTP response
	 * @throws Exception in case of any kind of processing failure
	 * @see javax.servlet.http.HttpServlet#doGet
	 * @see javax.servlet.http.HttpServlet#doPost
	 */
	protected abstract void doService(HttpServletRequest request, HttpServletResponse response)
			throws Exception;


	/**
	 * ApplicationListener endpoint that receives events from this servlet's WebApplicationContext
	 * only, delegating to {@code onApplicationEvent} on the FrameworkServlet instance.
	 */
<span class="fc" id="L1185">	private class ContextRefreshListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {</span>

		@Override
		public void onApplicationEvent(ContextRefreshedEvent event) {
<span class="fc" id="L1189">			FrameworkServlet.this.onApplicationEvent(event);</span>
<span class="fc" id="L1190">		}</span>
	}


	/**
	 * CallableProcessingInterceptor implementation that initializes and resets
	 * FrameworkServlet's context holders, i.e. LocaleContextHolder and RequestContextHolder.
	 */
<span class="fc" id="L1198">	private class RequestBindingInterceptor implements CallableProcessingInterceptor {</span>

		@Override
		public &lt;T&gt; void preProcess(NativeWebRequest webRequest, Callable&lt;T&gt; task) {
<span class="nc" id="L1202">			HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">			if (request != null) {</span>
<span class="nc" id="L1204">				HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);</span>
<span class="nc" id="L1205">				initContextHolders(request, buildLocaleContext(request),</span>
<span class="nc" id="L1206">						buildRequestAttributes(request, response, null));</span>
			}
<span class="nc" id="L1208">		}</span>
		@Override
		public &lt;T&gt; void postProcess(NativeWebRequest webRequest, Callable&lt;T&gt; task, Object concurrentResult) {
<span class="nc" id="L1211">			HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">			if (request != null) {</span>
<span class="nc" id="L1213">				resetContextHolders(request, null, null);</span>
			}
<span class="nc" id="L1215">		}</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>