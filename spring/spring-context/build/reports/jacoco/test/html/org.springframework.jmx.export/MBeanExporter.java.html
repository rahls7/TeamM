<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MBeanExporter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-context</a> &gt; <a href="index.source.html" class="el_package">org.springframework.jmx.export</a> &gt; <span class="el_source">MBeanExporter.java</span></div><h1>MBeanExporter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.jmx.export;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.management.DynamicMBean;
import javax.management.JMException;
import javax.management.MBeanException;
import javax.management.MBeanServer;
import javax.management.MalformedObjectNameException;
import javax.management.NotCompliantMBeanException;
import javax.management.NotificationListener;
import javax.management.ObjectName;
import javax.management.StandardMBean;
import javax.management.modelmbean.ModelMBean;
import javax.management.modelmbean.ModelMBeanInfo;
import javax.management.modelmbean.RequiredModelMBean;

import org.springframework.aop.framework.ProxyFactory;
import org.springframework.aop.scope.ScopedProxyUtils;
import org.springframework.aop.support.AopUtils;
import org.springframework.aop.target.LazyInitTargetSource;
import org.springframework.beans.factory.BeanClassLoaderAware;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.CannotLoadBeanClassException;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.ListableBeanFactory;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.core.Constants;
import org.springframework.jmx.export.assembler.AutodetectCapableMBeanInfoAssembler;
import org.springframework.jmx.export.assembler.MBeanInfoAssembler;
import org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler;
import org.springframework.jmx.export.naming.KeyNamingStrategy;
import org.springframework.jmx.export.naming.ObjectNamingStrategy;
import org.springframework.jmx.export.naming.SelfNaming;
import org.springframework.jmx.export.notification.ModelMBeanNotificationPublisher;
import org.springframework.jmx.export.notification.NotificationPublisherAware;
import org.springframework.jmx.support.JmxUtils;
import org.springframework.jmx.support.MBeanRegistrationSupport;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.CollectionUtils;
import org.springframework.util.ObjectUtils;

/**
 * JMX exporter that allows for exposing any &lt;i&gt;Spring-managed bean&lt;/i&gt; to a
 * JMX {@link javax.management.MBeanServer}, without the need to define any
 * JMX-specific information in the bean classes.
 *
 * &lt;p&gt;If a bean implements one of the JMX management interfaces, MBeanExporter can
 * simply register the MBean with the server through its autodetection process.
 *
 * &lt;p&gt;If a bean does not implement one of the JMX management interfaces, MBeanExporter
 * will create the management information using the supplied {@link MBeanInfoAssembler}.
 *
 * &lt;p&gt;A list of {@link MBeanExporterListener MBeanExporterListeners} can be registered
 * via the {@link #setListeners(MBeanExporterListener[]) listeners} property, allowing
 * application code to be notified of MBean registration and unregistration events.
 *
 * &lt;p&gt;This exporter is compatible with MBeans as well as MXBeans.
 *
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @author Rick Evans
 * @author Mark Fisher
 * @author Stephane Nicoll
 * @since 1.2
 * @see #setBeans
 * @see #setAutodetect
 * @see #setAssembler
 * @see #setListeners
 * @see org.springframework.jmx.export.assembler.MBeanInfoAssembler
 * @see MBeanExporterListener
 */
<span class="fc" id="L102">public class MBeanExporter extends MBeanRegistrationSupport implements MBeanExportOperations,</span>
		BeanClassLoaderAware, BeanFactoryAware, InitializingBean, SmartInitializingSingleton, DisposableBean {

	/**
	 * Autodetection mode indicating that no autodetection should be used.
	 */
	public static final int AUTODETECT_NONE = 0;

	/**
	 * Autodetection mode indicating that only valid MBeans should be autodetected.
	 */
	public static final int AUTODETECT_MBEAN = 1;

	/**
	 * Autodetection mode indicating that only the {@link MBeanInfoAssembler} should be able
	 * to autodetect beans.
	 */
	public static final int AUTODETECT_ASSEMBLER = 2;

	/**
	 * Autodetection mode indicating that all autodetection mechanisms should be used.
	 */
	public static final int AUTODETECT_ALL = AUTODETECT_MBEAN | AUTODETECT_ASSEMBLER;


	/**
	 * Wildcard used to map a {@link javax.management.NotificationListener}
	 * to all MBeans registered by the {@code MBeanExporter}.
	 */
	private static final String WILDCARD = &quot;*&quot;;

	/** Constant for the JMX {@code mr_type} &quot;ObjectReference&quot;. */
	private static final String MR_TYPE_OBJECT_REFERENCE = &quot;ObjectReference&quot;;

	/** Prefix for the autodetect constants defined in this class. */
	private static final String CONSTANT_PREFIX_AUTODETECT = &quot;AUTODETECT_&quot;;


	/** Constants instance for this class. */
<span class="fc" id="L141">	private static final Constants constants = new Constants(MBeanExporter.class);</span>

	/** The beans to be exposed as JMX managed resources, with JMX names as keys. */
	@Nullable
	private Map&lt;String, Object&gt; beans;

	/** The autodetect mode to use for this MBeanExporter. */
	@Nullable
	private Integer autodetectMode;

	/** Whether to eagerly initialize candidate beans when autodetecting MBeans. */
<span class="fc" id="L152">	private boolean allowEagerInit = false;</span>

	/** Stores the MBeanInfoAssembler to use for this exporter. */
<span class="fc" id="L155">	private MBeanInfoAssembler assembler = new SimpleReflectiveMBeanInfoAssembler();</span>

	/** The strategy to use for creating ObjectNames for an object. */
<span class="fc" id="L158">	private ObjectNamingStrategy namingStrategy = new KeyNamingStrategy();</span>

	/** Indicates whether Spring should modify generated ObjectNames. */
<span class="fc" id="L161">	private boolean ensureUniqueRuntimeObjectNames = true;</span>

	/** Indicates whether Spring should expose the managed resource ClassLoader in the MBean. */
<span class="fc" id="L164">	private boolean exposeManagedResourceClassLoader = true;</span>

	/** A set of bean names that should be excluded from autodetection. */
<span class="fc" id="L167">	private Set&lt;String&gt; excludedBeans = new HashSet&lt;&gt;();</span>

	/** The MBeanExporterListeners registered with this exporter. */
	@Nullable
	private MBeanExporterListener[] listeners;

	/** The NotificationListeners to register for the MBeans registered by this exporter. */
	@Nullable
	private NotificationListenerBean[] notificationListeners;

	/** Map of actually registered NotificationListeners. */
<span class="fc" id="L178">	private final Map&lt;NotificationListenerBean, ObjectName[]&gt; registeredNotificationListeners = new LinkedHashMap&lt;&gt;();</span>

	/** Stores the ClassLoader to use for generating lazy-init proxies. */
<span class="fc" id="L181">	@Nullable</span>
<span class="fc" id="L182">	private ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();</span>

	/** Stores the BeanFactory for use in autodetection process. */
	@Nullable
	private ListableBeanFactory beanFactory;


	/**
	 * Supply a {@code Map} of beans to be registered with the JMX
	 * {@code MBeanServer}.
	 * &lt;p&gt;The String keys are the basis for the creation of JMX object names.
	 * By default, a JMX {@code ObjectName} will be created straight
	 * from the given key. This can be customized through specifying a
	 * custom {@code NamingStrategy}.
	 * &lt;p&gt;Both bean instances and bean names are allowed as values.
	 * Bean instances are typically linked in through bean references.
	 * Bean names will be resolved as beans in the current factory, respecting
	 * lazy-init markers (that is, not triggering initialization of such beans).
	 * @param beans a Map with JMX names as keys and bean instances or bean names
	 * as values
	 * @see #setNamingStrategy
	 * @see org.springframework.jmx.export.naming.KeyNamingStrategy
	 * @see javax.management.ObjectName#ObjectName(String)
	 */
	public void setBeans(Map&lt;String, Object&gt; beans) {
<span class="fc" id="L207">		this.beans = beans;</span>
<span class="fc" id="L208">	}</span>

	/**
	 * Set whether to autodetect MBeans in the bean factory that this exporter
	 * runs in. Will also ask an {@code AutodetectCapableMBeanInfoAssembler}
	 * if available.
	 * &lt;p&gt;This feature is turned off by default. Explicitly specify
	 * {@code true} here to enable autodetection.
	 * @see #setAssembler
	 * @see AutodetectCapableMBeanInfoAssembler
	 * @see #isMBean
	 */
	public void setAutodetect(boolean autodetect) {
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">		this.autodetectMode = (autodetect ? AUTODETECT_ALL : AUTODETECT_NONE);</span>
<span class="fc" id="L222">	}</span>

	/**
	 * Set the autodetection mode to use.
	 * @throws IllegalArgumentException if the supplied value is not
	 * one of the {@code AUTODETECT_} constants
	 * @see #setAutodetectModeName(String)
	 * @see #AUTODETECT_ALL
	 * @see #AUTODETECT_ASSEMBLER
	 * @see #AUTODETECT_MBEAN
	 * @see #AUTODETECT_NONE
	 */
	public void setAutodetectMode(int autodetectMode) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">		if (!constants.getValues(CONSTANT_PREFIX_AUTODETECT).contains(autodetectMode)) {</span>
<span class="fc" id="L236">			throw new IllegalArgumentException(&quot;Only values of autodetect constants allowed&quot;);</span>
		}
<span class="fc" id="L238">		this.autodetectMode = autodetectMode;</span>
<span class="fc" id="L239">	}</span>

	/**
	 * Set the autodetection mode to use by name.
	 * @throws IllegalArgumentException if the supplied value is not resolvable
	 * to one of the {@code AUTODETECT_} constants or is {@code null}
	 * @see #setAutodetectMode(int)
	 * @see #AUTODETECT_ALL
	 * @see #AUTODETECT_ASSEMBLER
	 * @see #AUTODETECT_MBEAN
	 * @see #AUTODETECT_NONE
	 */
	public void setAutodetectModeName(String constantName) {
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">		if (!constantName.startsWith(CONSTANT_PREFIX_AUTODETECT)) {</span>
<span class="fc" id="L253">			throw new IllegalArgumentException(&quot;Only autodetect constants allowed&quot;);</span>
		}
<span class="nc" id="L255">		this.autodetectMode = (Integer) constants.asNumber(constantName);</span>
<span class="nc" id="L256">	}</span>

	/**
	 * Specify whether to allow eager initialization of candidate beans
	 * when autodetecting MBeans in the Spring application context.
	 * &lt;p&gt;Default is &quot;false&quot;, respecting lazy-init flags on bean definitions.
	 * Switch this to &quot;true&quot; in order to search lazy-init beans as well,
	 * including FactoryBean-produced objects that haven't been initialized yet.
	 */
	public void setAllowEagerInit(boolean allowEagerInit) {
<span class="nc" id="L266">		this.allowEagerInit = allowEagerInit;</span>
<span class="nc" id="L267">	}</span>

	/**
	 * Set the implementation of the {@code MBeanInfoAssembler} interface to use
	 * for this exporter. Default is a {@code SimpleReflectiveMBeanInfoAssembler}.
	 * &lt;p&gt;The passed-in assembler can optionally implement the
	 * {@code AutodetectCapableMBeanInfoAssembler} interface, which enables it
	 * to participate in the exporter's MBean autodetection process.
	 * @see org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler
	 * @see org.springframework.jmx.export.assembler.AutodetectCapableMBeanInfoAssembler
	 * @see org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler
	 * @see #setAutodetect
	 */
	public void setAssembler(MBeanInfoAssembler assembler) {
<span class="fc" id="L281">		this.assembler = assembler;</span>
<span class="fc" id="L282">	}</span>

	/**
	 * Set the implementation of the {@code ObjectNamingStrategy} interface
	 * to use for this exporter. Default is a {@code KeyNamingStrategy}.
	 * @see org.springframework.jmx.export.naming.KeyNamingStrategy
	 * @see org.springframework.jmx.export.naming.MetadataNamingStrategy
	 */
	public void setNamingStrategy(ObjectNamingStrategy namingStrategy) {
<span class="fc" id="L291">		this.namingStrategy = namingStrategy;</span>
<span class="fc" id="L292">	}</span>

	/**
	 * Indicates whether Spring should ensure that {@link ObjectName ObjectNames}
	 * generated by the configured {@link ObjectNamingStrategy} for
	 * runtime-registered MBeans ({@link #registerManagedResource}) should get
	 * modified: to ensure uniqueness for every instance of a managed {@code Class}.
	 * &lt;p&gt;The default value is {@code true}.
	 * @see #registerManagedResource
	 * @see JmxUtils#appendIdentityToObjectName(javax.management.ObjectName, Object)
	 */
	public void setEnsureUniqueRuntimeObjectNames(boolean ensureUniqueRuntimeObjectNames) {
<span class="fc" id="L304">		this.ensureUniqueRuntimeObjectNames = ensureUniqueRuntimeObjectNames;</span>
<span class="fc" id="L305">	}</span>

	/**
	 * Indicates whether or not the managed resource should be exposed on the
	 * {@link Thread#getContextClassLoader() thread context ClassLoader} before
	 * allowing any invocations on the MBean to occur.
	 * &lt;p&gt;The default value is {@code true}, exposing a {@link SpringModelMBean}
	 * which performs thread context ClassLoader management. Switch this flag off to
	 * expose a standard JMX {@link javax.management.modelmbean.RequiredModelMBean}.
	 */
	public void setExposeManagedResourceClassLoader(boolean exposeManagedResourceClassLoader) {
<span class="fc" id="L316">		this.exposeManagedResourceClassLoader = exposeManagedResourceClassLoader;</span>
<span class="fc" id="L317">	}</span>

	/**
	 * Set the list of names for beans that should be excluded from autodetection.
	 */
	public void setExcludedBeans(String... excludedBeans) {
<span class="fc" id="L323">		this.excludedBeans.clear();</span>
<span class="fc" id="L324">		Collections.addAll(this.excludedBeans, excludedBeans);</span>
<span class="fc" id="L325">	}</span>

	/**
	 * Add the name of bean that should be excluded from autodetection.
	 */
	public void addExcludedBean(String excludedBean) {
<span class="fc" id="L331">		Assert.notNull(excludedBean, &quot;ExcludedBean must not be null&quot;);</span>
<span class="fc" id="L332">		this.excludedBeans.add(excludedBean);</span>
<span class="fc" id="L333">	}</span>

	/**
	 * Set the {@code MBeanExporterListener}s that should be notified
	 * of MBean registration and unregistration events.
	 * @see MBeanExporterListener
	 */
	public void setListeners(MBeanExporterListener... listeners) {
<span class="fc" id="L341">		this.listeners = listeners;</span>
<span class="fc" id="L342">	}</span>

	/**
	 * Set the {@link NotificationListenerBean NotificationListenerBeans}
	 * containing the
	 * {@link javax.management.NotificationListener NotificationListeners}
	 * that will be registered with the {@link MBeanServer}.
	 * @see #setNotificationListenerMappings(java.util.Map)
	 * @see NotificationListenerBean
	 */
	public void setNotificationListeners(NotificationListenerBean... notificationListeners) {
<span class="fc" id="L353">		this.notificationListeners = notificationListeners;</span>
<span class="fc" id="L354">	}</span>

	/**
	 * Set the {@link NotificationListener NotificationListeners} to register
	 * with the {@link javax.management.MBeanServer}.
	 * &lt;P&gt;The key of each entry in the {@code Map} is a {@link String}
	 * representation of the {@link javax.management.ObjectName} or the bean
	 * name of the MBean the listener should be registered for. Specifying an
	 * asterisk ({@code *}) for a key will cause the listener to be
	 * associated with all MBeans registered by this class at startup time.
	 * &lt;p&gt;The value of each entry is the
	 * {@link javax.management.NotificationListener} to register. For more
	 * advanced options such as registering
	 * {@link javax.management.NotificationFilter NotificationFilters} and
	 * handback objects see {@link #setNotificationListeners(NotificationListenerBean[])}.
	 */
	public void setNotificationListenerMappings(Map&lt;?, ? extends NotificationListener&gt; listeners) {
<span class="fc" id="L371">		Assert.notNull(listeners, &quot;'listeners' must not be null&quot;);</span>
<span class="fc" id="L372">		List&lt;NotificationListenerBean&gt; notificationListeners =</span>
<span class="fc" id="L373">				new ArrayList&lt;&gt;(listeners.size());</span>

<span class="fc" id="L375">		listeners.forEach((key, listener) -&gt; {</span>
			// Get the listener from the map value.
<span class="fc" id="L377">			NotificationListenerBean bean = new NotificationListenerBean(listener);</span>
			// Get the ObjectName from the map key.
<span class="pc bpc" id="L379" title="1 of 4 branches missed.">			if (key != null &amp;&amp; !WILDCARD.equals(key)) {</span>
				// This listener is mapped to a specific ObjectName.
<span class="fc" id="L381">				bean.setMappedObjectName(key);</span>
			}
<span class="fc" id="L383">			notificationListeners.add(bean);</span>
<span class="fc" id="L384">		});</span>

<span class="fc" id="L386">		this.notificationListeners = notificationListeners.toArray(new NotificationListenerBean[0]);</span>
<span class="fc" id="L387">	}</span>

	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
<span class="fc" id="L391">		this.beanClassLoader = classLoader;</span>
<span class="fc" id="L392">	}</span>

	/**
	 * This callback is only required for resolution of bean names in the
	 * {@link #setBeans(java.util.Map) &quot;beans&quot;} {@link Map} and for
	 * autodetection of MBeans (in the latter case, a
	 * {@code ListableBeanFactory} is required).
	 * @see #setBeans
	 * @see #setAutodetect
	 */
	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">		if (beanFactory instanceof ListableBeanFactory) {</span>
<span class="fc" id="L405">			this.beanFactory = (ListableBeanFactory) beanFactory;</span>
		}
		else {
<span class="nc" id="L408">			logger.debug(&quot;MBeanExporter not running in a ListableBeanFactory: autodetection of MBeans not available.&quot;);</span>
		}
<span class="fc" id="L410">	}</span>


	//---------------------------------------------------------------------
	// Lifecycle in bean factory: automatically register/unregister beans
	//---------------------------------------------------------------------

	@Override
	public void afterPropertiesSet() {
		// If no server was provided then try to find one. This is useful in an environment
		// where there is already an MBeanServer loaded.
<span class="fc bfc" id="L421" title="All 2 branches covered.">		if (this.server == null) {</span>
<span class="fc" id="L422">			this.server = JmxUtils.locateMBeanServer();</span>
		}
<span class="fc" id="L424">	}</span>

	/**
	 * Kick off bean registration automatically after the regular singleton instantiation phase.
	 * @see #registerBeans()
	 */
	@Override
	public void afterSingletonsInstantiated() {
		try {
<span class="fc" id="L433">			logger.debug(&quot;Registering beans for JMX exposure on startup&quot;);</span>
<span class="fc" id="L434">			registerBeans();</span>
<span class="fc" id="L435">			registerNotificationListeners();</span>
		}
<span class="fc" id="L437">		catch (RuntimeException ex) {</span>
			// Unregister beans already registered by this exporter.
<span class="fc" id="L439">			unregisterNotificationListeners();</span>
<span class="fc" id="L440">			unregisterBeans();</span>
<span class="fc" id="L441">			throw ex;</span>
<span class="fc" id="L442">		}</span>
<span class="fc" id="L443">	}</span>

	/**
	 * Unregisters all beans that this exported has exposed via JMX
	 * when the enclosing {@code ApplicationContext} is destroyed.
	 */
	@Override
	public void destroy() {
<span class="fc" id="L451">		logger.debug(&quot;Unregistering JMX-exposed beans on shutdown&quot;);</span>
<span class="fc" id="L452">		unregisterNotificationListeners();</span>
<span class="fc" id="L453">		unregisterBeans();</span>
<span class="fc" id="L454">	}</span>


	//---------------------------------------------------------------------
	// Implementation of MBeanExportOperations interface
	//---------------------------------------------------------------------

	@Override
	public ObjectName registerManagedResource(Object managedResource) throws MBeanExportException {
<span class="fc" id="L463">		Assert.notNull(managedResource, &quot;Managed resource must not be null&quot;);</span>
		ObjectName objectName;
		try {
<span class="fc" id="L466">			objectName = getObjectName(managedResource, null);</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">			if (this.ensureUniqueRuntimeObjectNames) {</span>
<span class="fc" id="L468">				objectName = JmxUtils.appendIdentityToObjectName(objectName, managedResource);</span>
			}
		}
<span class="nc" id="L471">		catch (Throwable ex) {</span>
<span class="nc" id="L472">			throw new MBeanExportException(&quot;Unable to generate ObjectName for MBean [&quot; + managedResource + &quot;]&quot;, ex);</span>
<span class="fc" id="L473">		}</span>
<span class="fc" id="L474">		registerManagedResource(managedResource, objectName);</span>
<span class="fc" id="L475">		return objectName;</span>
	}

	@Override
	public void registerManagedResource(Object managedResource, ObjectName objectName) throws MBeanExportException {
<span class="fc" id="L480">		Assert.notNull(managedResource, &quot;Managed resource must not be null&quot;);</span>
<span class="fc" id="L481">		Assert.notNull(objectName, &quot;ObjectName must not be null&quot;);</span>
		try {
<span class="fc bfc" id="L483" title="All 2 branches covered.">			if (isMBean(managedResource.getClass())) {</span>
<span class="fc" id="L484">				doRegister(managedResource, objectName);</span>
			}
			else {
<span class="fc" id="L487">				ModelMBean mbean = createAndConfigureMBean(managedResource, managedResource.getClass().getName());</span>
<span class="fc" id="L488">				doRegister(mbean, objectName);</span>
<span class="fc" id="L489">				injectNotificationPublisherIfNecessary(managedResource, mbean, objectName);</span>
			}
		}
<span class="fc" id="L492">		catch (JMException ex) {</span>
<span class="fc" id="L493">			throw new UnableToRegisterMBeanException(</span>
					&quot;Unable to register MBean [&quot; + managedResource + &quot;] with object name [&quot; + objectName + &quot;]&quot;, ex);
<span class="fc" id="L495">		}</span>
<span class="fc" id="L496">	}</span>

	@Override
	public void unregisterManagedResource(ObjectName objectName) {
<span class="nc" id="L500">		Assert.notNull(objectName, &quot;ObjectName must not be null&quot;);</span>
<span class="nc" id="L501">		doUnregister(objectName);</span>
<span class="nc" id="L502">	}</span>


	//---------------------------------------------------------------------
	// Exporter implementation
	//---------------------------------------------------------------------

	/**
	 * Register the defined beans with the {@link MBeanServer}.
	 * &lt;p&gt;Each bean is exposed to the {@code MBeanServer} via a
	 * {@code ModelMBean}. The actual implementation of the
	 * {@code ModelMBean} interface used depends on the implementation of
	 * the {@code ModelMBeanProvider} interface that is configured. By
	 * default the {@code RequiredModelMBean} class that is supplied with
	 * all JMX implementations is used.
	 * &lt;p&gt;The management interface produced for each bean is dependent on the
	 * {@code MBeanInfoAssembler} implementation being used. The
	 * {@code ObjectName} given to each bean is dependent on the
	 * implementation of the {@code ObjectNamingStrategy} interface being used.
	 */
	protected void registerBeans() {
		// The beans property may be null, for example if we are relying solely on autodetection.
<span class="fc bfc" id="L524" title="All 2 branches covered.">		if (this.beans == null) {</span>
<span class="fc" id="L525">			this.beans = new HashMap&lt;&gt;();</span>
			// Use AUTODETECT_ALL as default in no beans specified explicitly.
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">			if (this.autodetectMode == null) {</span>
<span class="nc" id="L528">				this.autodetectMode = AUTODETECT_ALL;</span>
			}
		}

		// Perform autodetection, if desired.
<span class="fc bfc" id="L533" title="All 2 branches covered.">		int mode = (this.autodetectMode != null ? this.autodetectMode : AUTODETECT_NONE);</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">		if (mode != AUTODETECT_NONE) {</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">			if (this.beanFactory == null) {</span>
<span class="fc" id="L536">				throw new MBeanExportException(&quot;Cannot autodetect MBeans if not running in a BeanFactory&quot;);</span>
			}
<span class="fc bfc" id="L538" title="All 4 branches covered.">			if (mode == AUTODETECT_MBEAN || mode == AUTODETECT_ALL) {</span>
				// Autodetect any beans that are already MBeans.
<span class="fc" id="L540">				logger.debug(&quot;Autodetecting user-defined JMX MBeans&quot;);</span>
<span class="fc" id="L541">				autodetect(this.beans, (beanClass, beanName) -&gt; isMBean(beanClass));</span>
			}
			// Allow the assembler a chance to vote for bean inclusion.
<span class="fc bfc" id="L544" title="All 6 branches covered.">			if ((mode == AUTODETECT_ASSEMBLER || mode == AUTODETECT_ALL) &amp;&amp;</span>
					this.assembler instanceof AutodetectCapableMBeanInfoAssembler) {
<span class="fc" id="L546">				autodetect(this.beans, ((AutodetectCapableMBeanInfoAssembler) this.assembler)::includeBean);</span>
			}
		}

<span class="fc bfc" id="L550" title="All 2 branches covered.">		if (!this.beans.isEmpty()) {</span>
<span class="fc" id="L551">			this.beans.forEach((beanName, instance) -&gt; registerBeanNameOrInstance(instance, beanName));</span>
		}
<span class="fc" id="L553">	}</span>

	/**
	 * Return whether the specified bean definition should be considered as lazy-init.
	 * @param beanFactory the bean factory that is supposed to contain the bean definition
	 * @param beanName the name of the bean to check
	 * @see org.springframework.beans.factory.config.ConfigurableListableBeanFactory#getBeanDefinition
	 * @see org.springframework.beans.factory.config.BeanDefinition#isLazyInit
	 */
	protected boolean isBeanDefinitionLazyInit(ListableBeanFactory beanFactory, String beanName) {
<span class="pc bpc" id="L563" title="1 of 4 branches missed.">		return (beanFactory instanceof ConfigurableListableBeanFactory &amp;&amp; beanFactory.containsBeanDefinition(beanName) &amp;&amp;</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">				((ConfigurableListableBeanFactory) beanFactory).getBeanDefinition(beanName).isLazyInit());</span>
	}

	/**
	 * Register an individual bean with the {@link #setServer MBeanServer}.
	 * &lt;p&gt;This method is responsible for deciding &lt;strong&gt;how&lt;/strong&gt; a bean
	 * should be exposed to the {@code MBeanServer}. Specifically, if the
	 * supplied {@code mapValue} is the name of a bean that is configured
	 * for lazy initialization, then a proxy to the resource is registered with
	 * the {@code MBeanServer} so that the lazy load behavior is
	 * honored. If the bean is already an MBean then it will be registered
	 * directly with the {@code MBeanServer} without any intervention. For
	 * all other beans or bean names, the resource itself is registered with
	 * the {@code MBeanServer} directly.
	 * @param mapValue the value configured for this bean in the beans map;
	 * may be either the {@code String} name of a bean, or the bean itself
	 * @param beanKey the key associated with this bean in the beans map
	 * @return the {@code ObjectName} under which the resource was registered
	 * @throws MBeanExportException if the export failed
	 * @see #setBeans
	 * @see #registerBeanInstance
	 * @see #registerLazyInit
	 */
	protected ObjectName registerBeanNameOrInstance(Object mapValue, String beanKey) throws MBeanExportException {
		try {
<span class="fc bfc" id="L589" title="All 2 branches covered.">			if (mapValue instanceof String) {</span>
				// Bean name pointing to a potentially lazy-init bean in the factory.
<span class="fc bfc" id="L591" title="All 2 branches covered.">				if (this.beanFactory == null) {</span>
<span class="fc" id="L592">					throw new MBeanExportException(&quot;Cannot resolve bean names if not running in a BeanFactory&quot;);</span>
				}
<span class="fc" id="L594">				String beanName = (String) mapValue;</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">				if (isBeanDefinitionLazyInit(this.beanFactory, beanName)) {</span>
<span class="fc" id="L596">					ObjectName objectName = registerLazyInit(beanName, beanKey);</span>
<span class="fc" id="L597">					replaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);</span>
<span class="fc" id="L598">					return objectName;</span>
				}
				else {
<span class="fc" id="L601">					Object bean = this.beanFactory.getBean(beanName);</span>
<span class="fc" id="L602">					ObjectName objectName = registerBeanInstance(bean, beanKey);</span>
<span class="fc" id="L603">					replaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);</span>
<span class="fc" id="L604">					return objectName;</span>
				}
			}
			else {
				// Plain bean instance -&gt; register it directly.
<span class="fc bfc" id="L609" title="All 2 branches covered.">				if (this.beanFactory != null) {</span>
<span class="fc" id="L610">					Map&lt;String, ?&gt; beansOfSameType =</span>
<span class="fc" id="L611">							this.beanFactory.getBeansOfType(mapValue.getClass(), false, this.allowEagerInit);</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">					for (Map.Entry&lt;String, ?&gt; entry : beansOfSameType.entrySet()) {</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">						if (entry.getValue() == mapValue) {</span>
<span class="fc" id="L614">							String beanName = entry.getKey();</span>
<span class="fc" id="L615">							ObjectName objectName = registerBeanInstance(mapValue, beanKey);</span>
<span class="fc" id="L616">							replaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);</span>
<span class="fc" id="L617">							return objectName;</span>
						}
<span class="fc" id="L619">					}</span>
				}
<span class="fc" id="L621">				return registerBeanInstance(mapValue, beanKey);</span>
			}
		}
<span class="fc" id="L624">		catch (Throwable ex) {</span>
<span class="fc" id="L625">			throw new UnableToRegisterMBeanException(</span>
					&quot;Unable to register MBean [&quot; + mapValue + &quot;] with key '&quot; + beanKey + &quot;'&quot;, ex);
		}
	}

	/**
	 * Replace any bean names used as keys in the {@code NotificationListener}
	 * mappings with their corresponding {@code ObjectName} values.
	 * @param beanName the name of the bean to be registered
	 * @param objectName the {@code ObjectName} under which the bean will be registered
	 * with the {@code MBeanServer}
	 */
	private void replaceNotificationListenerBeanNameKeysIfNecessary(String beanName, ObjectName objectName) {
<span class="fc bfc" id="L638" title="All 2 branches covered.">		if (this.notificationListeners != null) {</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">			for (NotificationListenerBean notificationListener : this.notificationListeners) {</span>
<span class="fc" id="L640">				notificationListener.replaceObjectName(beanName, objectName);</span>
			}
		}
<span class="fc" id="L643">	}</span>

	/**
	 * Registers an existing MBean or an MBean adapter for a plain bean
	 * with the {@code MBeanServer}.
	 * @param bean the bean to register, either an MBean or a plain bean
	 * @param beanKey the key associated with this bean in the beans map
	 * @return the {@code ObjectName} under which the bean was registered
	 * with the {@code MBeanServer}
	 */
	private ObjectName registerBeanInstance(Object bean, String beanKey) throws JMException {
<span class="fc" id="L654">		ObjectName objectName = getObjectName(bean, beanKey);</span>
<span class="fc" id="L655">		Object mbeanToExpose = null;</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">		if (isMBean(bean.getClass())) {</span>
<span class="fc" id="L657">			mbeanToExpose = bean;</span>
		}
		else {
<span class="fc" id="L660">			DynamicMBean adaptedBean = adaptMBeanIfPossible(bean);</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">			if (adaptedBean != null) {</span>
<span class="nc" id="L662">				mbeanToExpose = adaptedBean;</span>
			}
		}

<span class="fc bfc" id="L666" title="All 2 branches covered.">		if (mbeanToExpose != null) {</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L668">				logger.debug(&quot;Located MBean '&quot; + beanKey + &quot;': registering with JMX server as MBean [&quot; +</span>
						objectName + &quot;]&quot;);
			}
<span class="fc" id="L671">			doRegister(mbeanToExpose, objectName);</span>
		}
		else {
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L675">				logger.debug(&quot;Located managed bean '&quot; + beanKey + &quot;': registering with JMX server as MBean [&quot; +</span>
						objectName + &quot;]&quot;);
			}
<span class="fc" id="L678">			ModelMBean mbean = createAndConfigureMBean(bean, beanKey);</span>
<span class="fc" id="L679">			doRegister(mbean, objectName);</span>
<span class="fc" id="L680">			injectNotificationPublisherIfNecessary(bean, mbean, objectName);</span>
		}

<span class="fc" id="L683">		return objectName;</span>
	}

	/**
	 * Register beans that are configured for lazy initialization with the
	 * {@code MBeanServer} indirectly through a proxy.
	 * @param beanName the name of the bean in the {@code BeanFactory}
	 * @param beanKey the key associated with this bean in the beans map
	 * @return the {@code ObjectName} under which the bean was registered
	 * with the {@code MBeanServer}
	 */
	private ObjectName registerLazyInit(String beanName, String beanKey) throws JMException {
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">		Assert.state(this.beanFactory != null, &quot;No BeanFactory set&quot;);</span>

<span class="fc" id="L697">		ProxyFactory proxyFactory = new ProxyFactory();</span>
<span class="fc" id="L698">		proxyFactory.setProxyTargetClass(true);</span>
<span class="fc" id="L699">		proxyFactory.setFrozen(true);</span>

<span class="fc bfc" id="L701" title="All 2 branches covered.">		if (isMBean(this.beanFactory.getType(beanName))) {</span>
			// A straight MBean... Let's create a simple lazy-init CGLIB proxy for it.
<span class="fc" id="L703">			LazyInitTargetSource targetSource = new LazyInitTargetSource();</span>
<span class="fc" id="L704">			targetSource.setTargetBeanName(beanName);</span>
<span class="fc" id="L705">			targetSource.setBeanFactory(this.beanFactory);</span>
<span class="fc" id="L706">			proxyFactory.setTargetSource(targetSource);</span>

<span class="fc" id="L708">			Object proxy = proxyFactory.getProxy(this.beanClassLoader);</span>
<span class="fc" id="L709">			ObjectName objectName = getObjectName(proxy, beanKey);</span>
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L711">				logger.debug(&quot;Located MBean '&quot; + beanKey + &quot;': registering with JMX server as lazy-init MBean [&quot; +</span>
						objectName + &quot;]&quot;);
			}
<span class="fc" id="L714">			doRegister(proxy, objectName);</span>
<span class="fc" id="L715">			return objectName;</span>
		}

		else {
			// A simple bean... Let's create a lazy-init ModelMBean proxy with notification support.
<span class="fc" id="L720">			NotificationPublisherAwareLazyTargetSource targetSource = new NotificationPublisherAwareLazyTargetSource();</span>
<span class="fc" id="L721">			targetSource.setTargetBeanName(beanName);</span>
<span class="fc" id="L722">			targetSource.setBeanFactory(this.beanFactory);</span>
<span class="fc" id="L723">			proxyFactory.setTargetSource(targetSource);</span>

<span class="fc" id="L725">			Object proxy = proxyFactory.getProxy(this.beanClassLoader);</span>
<span class="fc" id="L726">			ObjectName objectName = getObjectName(proxy, beanKey);</span>
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L728">				logger.debug(&quot;Located simple bean '&quot; + beanKey + &quot;': registering with JMX server as lazy-init MBean [&quot; +</span>
						objectName + &quot;]&quot;);
			}
<span class="fc" id="L731">			ModelMBean mbean = createAndConfigureMBean(proxy, beanKey);</span>
<span class="fc" id="L732">			targetSource.setModelMBean(mbean);</span>
<span class="fc" id="L733">			targetSource.setObjectName(objectName);</span>
<span class="fc" id="L734">			doRegister(mbean, objectName);</span>
<span class="fc" id="L735">			return objectName;</span>
		}
	}

	/**
	 * Retrieve the {@code ObjectName} for a bean.
	 * &lt;p&gt;If the bean implements the {@code SelfNaming} interface, then the
	 * {@code ObjectName} will be retrieved using {@code SelfNaming.getObjectName()}.
	 * Otherwise, the configured {@code ObjectNamingStrategy} is used.
	 * @param bean the name of the bean in the {@code BeanFactory}
	 * @param beanKey the key associated with the bean in the beans map
	 * @return the {@code ObjectName} for the supplied bean
	 * @throws javax.management.MalformedObjectNameException
	 * if the retrieved {@code ObjectName} is malformed
	 */
	protected ObjectName getObjectName(Object bean, @Nullable String beanKey) throws MalformedObjectNameException {
<span class="fc bfc" id="L751" title="All 2 branches covered.">		if (bean instanceof SelfNaming) {</span>
<span class="fc" id="L752">			return ((SelfNaming) bean).getObjectName();</span>
		}
		else {
<span class="fc" id="L755">			return this.namingStrategy.getObjectName(bean, beanKey);</span>
		}
	}

	/**
	 * Determine whether the given bean class qualifies as an MBean as-is.
	 * &lt;p&gt;The default implementation delegates to {@link JmxUtils#isMBean},
	 * which checks for {@link javax.management.DynamicMBean} classes as well
	 * as classes with corresponding &quot;*MBean&quot; interface (Standard MBeans)
	 * or corresponding &quot;*MXBean&quot; interface (Java 6 MXBeans).
	 * @param beanClass the bean class to analyze
	 * @return whether the class qualifies as an MBean
	 * @see org.springframework.jmx.support.JmxUtils#isMBean(Class)
	 */
	protected boolean isMBean(@Nullable Class&lt;?&gt; beanClass) {
<span class="fc" id="L770">		return JmxUtils.isMBean(beanClass);</span>
	}

	/**
	 * Build an adapted MBean for the given bean instance, if possible.
	 * &lt;p&gt;The default implementation builds a JMX 1.2 StandardMBean
	 * for the target's MBean/MXBean interface in case of an AOP proxy,
	 * delegating the interface's management operations to the proxy.
	 * @param bean the original bean instance
	 * @return the adapted MBean, or {@code null} if not possible
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	@Nullable
	protected DynamicMBean adaptMBeanIfPossible(Object bean) throws JMException {
<span class="fc" id="L784">		Class&lt;?&gt; targetClass = AopUtils.getTargetClass(bean);</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">		if (targetClass != bean.getClass()) {</span>
<span class="fc" id="L786">			Class&lt;?&gt; ifc = JmxUtils.getMXBeanInterface(targetClass);</span>
<span class="pc bpc" id="L787" title="1 of 2 branches missed.">			if (ifc != null) {</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">				if (!ifc.isInstance(bean)) {</span>
<span class="nc" id="L789">					throw new NotCompliantMBeanException(&quot;Managed bean [&quot; + bean +</span>
							&quot;] has a target class with an MXBean interface but does not expose it in the proxy&quot;);
				}
<span class="nc" id="L792">				return new StandardMBean(bean, ((Class&lt;Object&gt;) ifc), true);</span>
			}
			else {
<span class="fc" id="L795">				ifc = JmxUtils.getMBeanInterface(targetClass);</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">				if (ifc != null) {</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">					if (!ifc.isInstance(bean)) {</span>
<span class="nc" id="L798">						throw new NotCompliantMBeanException(&quot;Managed bean [&quot; + bean +</span>
								&quot;] has a target class with an MBean interface but does not expose it in the proxy&quot;);
					}
<span class="nc" id="L801">					return new StandardMBean(bean, ((Class&lt;Object&gt;) ifc));</span>
				}
			}
		}
<span class="fc" id="L805">		return null;</span>
	}

	/**
	 * Creates an MBean that is configured with the appropriate management
	 * interface for the supplied managed resource.
	 * @param managedResource the resource that is to be exported as an MBean
	 * @param beanKey the key associated with the managed bean
	 * @see #createModelMBean()
	 * @see #getMBeanInfo(Object, String)
	 */
	protected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)
			throws MBeanExportException {
		try {
<span class="fc" id="L819">			ModelMBean mbean = createModelMBean();</span>
<span class="fc" id="L820">			mbean.setModelMBeanInfo(getMBeanInfo(managedResource, beanKey));</span>
<span class="fc" id="L821">			mbean.setManagedResource(managedResource, MR_TYPE_OBJECT_REFERENCE);</span>
<span class="fc" id="L822">			return mbean;</span>
		}
<span class="nc" id="L824">		catch (Throwable ex) {</span>
<span class="nc" id="L825">			throw new MBeanExportException(&quot;Could not create ModelMBean for managed resource [&quot; +</span>
					managedResource + &quot;] with key '&quot; + beanKey + &quot;'&quot;, ex);
		}
	}

	/**
	 * Create an instance of a class that implements {@code ModelMBean}.
	 * &lt;p&gt;This method is called to obtain a {@code ModelMBean} instance to
	 * use when registering a bean. This method is called once per bean during the
	 * registration phase and must return a new instance of {@code ModelMBean}
	 * @return a new instance of a class that implements {@code ModelMBean}
	 * @throws javax.management.MBeanException if creation of the ModelMBean failed
	 */
	protected ModelMBean createModelMBean() throws MBeanException {
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">		return (this.exposeManagedResourceClassLoader ? new SpringModelMBean() : new RequiredModelMBean());</span>
	}

	/**
	 * Gets the {@code ModelMBeanInfo} for the bean with the supplied key
	 * and of the supplied type.
	 */
	private ModelMBeanInfo getMBeanInfo(Object managedBean, String beanKey) throws JMException {
<span class="fc" id="L847">		ModelMBeanInfo info = this.assembler.getMBeanInfo(managedBean, beanKey);</span>
<span class="pc bpc" id="L848" title="3 of 4 branches missed.">		if (logger.isInfoEnabled() &amp;&amp; ObjectUtils.isEmpty(info.getAttributes()) &amp;&amp;</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">				ObjectUtils.isEmpty(info.getOperations())) {</span>
<span class="nc" id="L850">			logger.info(&quot;Bean with key '&quot; + beanKey +</span>
					&quot;' has been registered as an MBean but has no exposed attributes or operations&quot;);
		}
<span class="fc" id="L853">		return info;</span>
	}


	//---------------------------------------------------------------------
	// Autodetection process
	//---------------------------------------------------------------------

	/**
	 * Performs the actual autodetection process, delegating to an
	 * {@code AutodetectCallback} instance to vote on the inclusion of a
	 * given bean.
	 * @param callback the {@code AutodetectCallback} to use when deciding
	 * whether to include a bean or not
	 */
	private void autodetect(Map&lt;String, Object&gt; beans, AutodetectCallback callback) {
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">		Assert.state(this.beanFactory != null, &quot;No BeanFactory set&quot;);</span>
<span class="fc" id="L870">		Set&lt;String&gt; beanNames = new LinkedHashSet&lt;&gt;(this.beanFactory.getBeanDefinitionCount());</span>
<span class="fc" id="L871">		Collections.addAll(beanNames, this.beanFactory.getBeanDefinitionNames());</span>
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">		if (this.beanFactory instanceof ConfigurableBeanFactory) {</span>
<span class="fc" id="L873">			Collections.addAll(beanNames, ((ConfigurableBeanFactory) this.beanFactory).getSingletonNames());</span>
		}

<span class="fc bfc" id="L876" title="All 2 branches covered.">		for (String beanName : beanNames) {</span>
<span class="fc bfc" id="L877" title="All 4 branches covered.">			if (!isExcluded(beanName) &amp;&amp; !isBeanDefinitionAbstract(this.beanFactory, beanName)) {</span>
				try {
<span class="fc" id="L879">					Class&lt;?&gt; beanClass = this.beanFactory.getType(beanName);</span>
<span class="pc bpc" id="L880" title="1 of 4 branches missed.">					if (beanClass != null &amp;&amp; callback.include(beanClass, beanName)) {</span>
<span class="fc" id="L881">						boolean lazyInit = isBeanDefinitionLazyInit(this.beanFactory, beanName);</span>
<span class="fc" id="L882">						Object beanInstance = null;</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">						if (!lazyInit) {</span>
<span class="fc" id="L884">							beanInstance = this.beanFactory.getBean(beanName);</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">							if (!beanClass.isInstance(beanInstance)) {</span>
<span class="fc" id="L886">								continue;</span>
							}
						}
<span class="fc bfc" id="L889" title="All 6 branches covered.">						if (!ScopedProxyUtils.isScopedTarget(beanName) &amp;&amp; !beans.containsValue(beanName) &amp;&amp;</span>
								(beanInstance == null ||
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">										!CollectionUtils.containsInstance(beans.values(), beanInstance))) {</span>
							// Not already registered for JMX exposure.
<span class="fc bfc" id="L893" title="All 2 branches covered.">							beans.put(beanName, (beanInstance != null ? beanInstance : beanName));</span>
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">							if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L895">								logger.debug(&quot;Bean with name '&quot; + beanName + &quot;' has been autodetected for JMX exposure&quot;);</span>
							}
						}
						else {
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">							if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L900">								logger.trace(&quot;Bean with name '&quot; + beanName + &quot;' is already registered for JMX exposure&quot;);</span>
							}
						}
					}
				}
<span class="fc" id="L905">				catch (CannotLoadBeanClassException ex) {</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">					if (this.allowEagerInit) {</span>
<span class="nc" id="L907">						throw ex;</span>
					}
					// otherwise ignore beans where the class is not resolvable
<span class="fc" id="L910">				}</span>
			}
<span class="fc" id="L912">		}</span>
<span class="fc" id="L913">	}</span>

	/**
	 * Indicates whether or not a particular bean name is present in the excluded beans list.
	 */
	private boolean isExcluded(String beanName) {
<span class="fc bfc" id="L919" title="All 2 branches covered.">		return (this.excludedBeans.contains(beanName) ||</span>
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">					(beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX) &amp;&amp;</span>
<span class="pc bnc" id="L921" title="All 2 branches missed.">							this.excludedBeans.contains(beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length()))));</span>
	}

	/**
	 * Return whether the specified bean definition should be considered as abstract.
	 */
	private boolean isBeanDefinitionAbstract(ListableBeanFactory beanFactory, String beanName) {
<span class="pc bpc" id="L928" title="1 of 4 branches missed.">		return (beanFactory instanceof ConfigurableListableBeanFactory &amp;&amp; beanFactory.containsBeanDefinition(beanName) &amp;&amp;</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">				((ConfigurableListableBeanFactory) beanFactory).getBeanDefinition(beanName).isAbstract());</span>
	}


	//---------------------------------------------------------------------
	// Notification and listener management
	//---------------------------------------------------------------------

	/**
	 * If the supplied managed resource implements the {@link NotificationPublisherAware} an instance of
	 * {@link org.springframework.jmx.export.notification.NotificationPublisher} is injected.
	 */
	private void injectNotificationPublisherIfNecessary(
			Object managedResource, @Nullable ModelMBean modelMBean, @Nullable ObjectName objectName) {

<span class="pc bpc" id="L944" title="2 of 6 branches missed.">		if (managedResource instanceof NotificationPublisherAware &amp;&amp; modelMBean != null &amp;&amp; objectName != null) {</span>
<span class="fc" id="L945">			((NotificationPublisherAware) managedResource).setNotificationPublisher(</span>
					new ModelMBeanNotificationPublisher(modelMBean, objectName, managedResource));
		}
<span class="fc" id="L948">	}</span>

	/**
	 * Register the configured {@link NotificationListener NotificationListeners}
	 * with the {@link MBeanServer}.
	 */
	private void registerNotificationListeners() throws MBeanExportException {
<span class="fc bfc" id="L955" title="All 2 branches covered.">		if (this.notificationListeners != null) {</span>
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">			Assert.state(this.server != null, &quot;No MBeanServer available&quot;);</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">			for (NotificationListenerBean bean : this.notificationListeners) {</span>
				try {
<span class="fc" id="L959">					ObjectName[] mappedObjectNames = bean.getResolvedObjectNames();</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">					if (mappedObjectNames == null) {</span>
						// Mapped to all MBeans registered by the MBeanExporter.
<span class="fc" id="L962">						mappedObjectNames = getRegisteredObjectNames();</span>
					}
<span class="fc bfc" id="L964" title="All 2 branches covered.">					if (this.registeredNotificationListeners.put(bean, mappedObjectNames) == null) {</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">						for (ObjectName mappedObjectName : mappedObjectNames) {</span>
<span class="fc" id="L966">							this.server.addNotificationListener(mappedObjectName, bean.getNotificationListener(),</span>
<span class="fc" id="L967">									bean.getNotificationFilter(), bean.getHandback());</span>
						}
					}
				}
<span class="fc" id="L971">				catch (Throwable ex) {</span>
<span class="fc" id="L972">					throw new MBeanExportException(&quot;Unable to register NotificationListener&quot;, ex);</span>
<span class="fc" id="L973">				}</span>
			}
		}
<span class="fc" id="L976">	}</span>

	/**
	 * Unregister the configured {@link NotificationListener NotificationListeners}
	 * from the {@link MBeanServer}.
	 */
	private void unregisterNotificationListeners() {
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">		if (this.server != null) {</span>
<span class="fc" id="L984">			this.registeredNotificationListeners.forEach((bean, mappedObjectNames) -&gt; {</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">				for (ObjectName mappedObjectName : mappedObjectNames) {</span>
					try {
<span class="pc" id="L987">						this.server.removeNotificationListener(mappedObjectName, bean.getNotificationListener(),</span>
<span class="fc" id="L988">								bean.getNotificationFilter(), bean.getHandback());</span>
					}
<span class="fc" id="L990">					catch (Throwable ex) {</span>
<span class="pc bpc" id="L991" title="1 of 2 branches missed.">						if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L992">							logger.debug(&quot;Unable to unregister NotificationListener&quot;, ex);</span>
						}
<span class="nc" id="L994">					}</span>
				}
<span class="fc" id="L996">			});</span>
		}
<span class="fc" id="L998">		this.registeredNotificationListeners.clear();</span>
<span class="fc" id="L999">	}</span>

	/**
	 * Called when an MBean is registered. Notifies all registered
	 * {@link MBeanExporterListener MBeanExporterListeners} of the registration event.
	 * &lt;p&gt;Please note that if an {@link MBeanExporterListener} throws a (runtime)
	 * exception when notified, this will essentially interrupt the notification process
	 * and any remaining listeners that have yet to be notified will not (obviously)
	 * receive the {@link MBeanExporterListener#mbeanRegistered(javax.management.ObjectName)}
	 * callback.
	 * @param objectName the {@code ObjectName} of the registered MBean
	 */
	@Override
	protected void onRegister(ObjectName objectName) {
<span class="fc" id="L1013">		notifyListenersOfRegistration(objectName);</span>
<span class="fc" id="L1014">	}</span>

	/**
	 * Called when an MBean is unregistered. Notifies all registered
	 * {@link MBeanExporterListener MBeanExporterListeners} of the unregistration event.
	 * &lt;p&gt;Please note that if an {@link MBeanExporterListener} throws a (runtime)
	 * exception when notified, this will essentially interrupt the notification process
	 * and any remaining listeners that have yet to be notified will not (obviously)
	 * receive the {@link MBeanExporterListener#mbeanUnregistered(javax.management.ObjectName)}
	 * callback.
	 * @param objectName the {@code ObjectName} of the unregistered MBean
	 */
	@Override
	protected void onUnregister(ObjectName objectName) {
<span class="fc" id="L1028">		notifyListenersOfUnregistration(objectName);</span>
<span class="fc" id="L1029">	}</span>


	/**
	 * Notifies all registered {@link MBeanExporterListener MBeanExporterListeners} of the
	 * registration of the MBean identified by the supplied {@link ObjectName}.
	 */
	private void notifyListenersOfRegistration(ObjectName objectName) {
<span class="fc bfc" id="L1037" title="All 2 branches covered.">		if (this.listeners != null) {</span>
<span class="fc bfc" id="L1038" title="All 2 branches covered.">			for (MBeanExporterListener listener : this.listeners) {</span>
<span class="fc" id="L1039">				listener.mbeanRegistered(objectName);</span>
			}
		}
<span class="fc" id="L1042">	}</span>

	/**
	 * Notifies all registered {@link MBeanExporterListener MBeanExporterListeners} of the
	 * unregistration of the MBean identified by the supplied {@link ObjectName}.
	 */
	private void notifyListenersOfUnregistration(ObjectName objectName) {
<span class="fc bfc" id="L1049" title="All 2 branches covered.">		if (this.listeners != null) {</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">			for (MBeanExporterListener listener : this.listeners) {</span>
<span class="fc" id="L1051">				listener.mbeanUnregistered(objectName);</span>
			}
		}
<span class="fc" id="L1054">	}</span>


	//---------------------------------------------------------------------
	// Inner classes for internal use
	//---------------------------------------------------------------------

	/**
	 * Internal callback interface for the autodetection process.
	 */
	@FunctionalInterface
	private interface AutodetectCallback {

		/**
		 * Called during the autodetection process to decide whether
		 * or not a bean should be included.
		 * @param beanClass the class of the bean
		 * @param beanName the name of the bean
		 */
		boolean include(Class&lt;?&gt; beanClass, String beanName);
	}


	/**
	 * Extension of {@link LazyInitTargetSource} that will inject a
	 * {@link org.springframework.jmx.export.notification.NotificationPublisher}
	 * into the lazy resource as it is created if required.
	 */
	@SuppressWarnings(&quot;serial&quot;)
<span class="fc" id="L1083">	private class NotificationPublisherAwareLazyTargetSource extends LazyInitTargetSource {</span>

		@Nullable
		private ModelMBean modelMBean;

		@Nullable
		private ObjectName objectName;

		public void setModelMBean(ModelMBean modelMBean) {
<span class="fc" id="L1092">			this.modelMBean = modelMBean;</span>
<span class="fc" id="L1093">		}</span>

		public void setObjectName(ObjectName objectName) {
<span class="fc" id="L1096">			this.objectName = objectName;</span>
<span class="fc" id="L1097">		}</span>

		@Override
		@Nullable
		public Object getTarget() {
			try {
<span class="fc" id="L1103">				return super.getTarget();</span>
			}
<span class="nc" id="L1105">			catch (RuntimeException ex) {</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">				if (logger.isInfoEnabled()) {</span>
<span class="nc" id="L1107">					logger.info(&quot;Failed to retrieve target for JMX-exposed bean [&quot; + this.objectName + &quot;]: &quot; + ex);</span>
				}
<span class="nc" id="L1109">				throw ex;</span>
			}
		}

		@Override
		protected void postProcessTargetObject(Object targetObject) {
<span class="fc" id="L1115">			injectNotificationPublisherIfNecessary(targetObject, this.modelMBean, this.objectName);</span>
<span class="fc" id="L1116">		}</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>