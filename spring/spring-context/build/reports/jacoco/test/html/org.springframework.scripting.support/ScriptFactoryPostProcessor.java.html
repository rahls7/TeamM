<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ScriptFactoryPostProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-context</a> &gt; <a href="index.source.html" class="el_package">org.springframework.scripting.support</a> &gt; <span class="el_source">ScriptFactoryPostProcessor.java</span></div><h1>ScriptFactoryPostProcessor.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.scripting.support;

import java.util.HashMap;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.aop.TargetSource;
import org.springframework.aop.framework.AopInfrastructureBean;
import org.springframework.aop.framework.ProxyFactory;
import org.springframework.aop.support.DelegatingIntroductionInterceptor;
import org.springframework.asm.Type;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.PropertyValue;
import org.springframework.beans.PropertyValues;
import org.springframework.beans.factory.BeanClassLoaderAware;
import org.springframework.beans.factory.BeanCreationException;
import org.springframework.beans.factory.BeanCurrentlyInCreationException;
import org.springframework.beans.factory.BeanDefinitionStoreException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;
import org.springframework.beans.factory.support.BeanDefinitionValidationException;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.beans.factory.support.GenericBeanDefinition;
import org.springframework.cglib.core.Signature;
import org.springframework.cglib.proxy.InterfaceMaker;
import org.springframework.context.ResourceLoaderAware;
import org.springframework.core.Conventions;
import org.springframework.core.Ordered;
import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.ResourceLoader;
import org.springframework.lang.Nullable;
import org.springframework.scripting.ScriptFactory;
import org.springframework.scripting.ScriptSource;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;

/**
 * {@link org.springframework.beans.factory.config.BeanPostProcessor} that
 * handles {@link org.springframework.scripting.ScriptFactory} definitions,
 * replacing each factory with the actual scripted Java object generated by it.
 *
 * &lt;p&gt;This is similar to the
 * {@link org.springframework.beans.factory.FactoryBean} mechanism, but is
 * specifically tailored for scripts and not built into Spring's core
 * container itself but rather implemented as an extension.
 *
 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; The most important characteristic of this post-processor
 * is that constructor arguments are applied to the
 * {@link org.springframework.scripting.ScriptFactory} instance
 * while bean property values are applied to the generated scripted object.
 * Typically, constructor arguments include a script source locator and
 * potentially script interfaces, while bean property values include
 * references and config values to inject into the scripted object itself.
 *
 * &lt;p&gt;The following {@link ScriptFactoryPostProcessor} will automatically
 * be applied to the two
 * {@link org.springframework.scripting.ScriptFactory} definitions below.
 * At runtime, the actual scripted objects will be exposed for
 * &quot;bshMessenger&quot; and &quot;groovyMessenger&quot;, rather than the
 * {@link org.springframework.scripting.ScriptFactory} instances. Both of
 * those are supposed to be castable to the example's {@code Messenger}
 * interfaces here.
 *
 * &lt;pre class=&quot;code&quot;&gt;&amp;lt;bean class=&quot;org.springframework.scripting.support.ScriptFactoryPostProcessor&quot;/&amp;gt;
 *
 * &amp;lt;bean id=&quot;bshMessenger&quot; class=&quot;org.springframework.scripting.bsh.BshScriptFactory&quot;&amp;gt;
 *   &amp;lt;constructor-arg value=&quot;classpath:mypackage/Messenger.bsh&quot;/&amp;gt;
 *   &amp;lt;constructor-arg value=&quot;mypackage.Messenger&quot;/&amp;gt;
 *   &amp;lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&amp;gt;
 * &amp;lt;/bean&amp;gt;
 *
 * &amp;lt;bean id=&quot;groovyMessenger&quot; class=&quot;org.springframework.scripting.groovy.GroovyScriptFactory&quot;&amp;gt;
 *   &amp;lt;constructor-arg value=&quot;classpath:mypackage/Messenger.groovy&quot;/&amp;gt;
 *   &amp;lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&amp;gt;
 * &amp;lt;/bean&amp;gt;&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Please note that the above excerpt from a Spring
 * XML bean definition file uses just the &amp;lt;bean/&amp;gt;-style syntax
 * (in an effort to illustrate using the {@link ScriptFactoryPostProcessor} itself).
 * In reality, you would never create a &amp;lt;bean/&amp;gt; definition for a
 * {@link ScriptFactoryPostProcessor} explicitly; rather you would import the
 * tags from the {@code 'lang'} namespace and simply create scripted
 * beans using the tags in that namespace... as part of doing so, a
 * {@link ScriptFactoryPostProcessor} will implicitly be created for you.
 *
 * &lt;p&gt;The Spring reference documentation contains numerous examples of using
 * tags in the {@code 'lang'} namespace; by way of an example, find below
 * a Groovy-backed bean defined using the {@code 'lang:groovy'} tag.
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
 * &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
 *     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
 *     xmlns:lang=&quot;http://www.springframework.org/schema/lang&quot;&amp;gt;
 *
 *   &amp;lt;!-- this is the bean definition for the Groovy-backed Messenger implementation --&amp;gt;
 *   &amp;lt;lang:groovy id=&quot;messenger&quot; script-source=&quot;classpath:Messenger.groovy&quot;&amp;gt;
 *     &amp;lt;lang:property name=&quot;message&quot; value=&quot;I Can Do The Frug&quot; /&amp;gt;
 *   &amp;lt;/lang:groovy&amp;gt;
 *
 *   &amp;lt;!-- an otherwise normal bean that will be injected by the Groovy-backed Messenger --&amp;gt;
 *   &amp;lt;bean id=&quot;bookingService&quot; class=&quot;x.y.DefaultBookingService&quot;&amp;gt;
 *     &amp;lt;property name=&quot;messenger&quot; ref=&quot;messenger&quot; /&amp;gt;
 *   &amp;lt;/bean&amp;gt;
 *
 * &amp;lt;/beans&amp;gt;&lt;/pre&gt;
 *
 * @author Juergen Hoeller
 * @author Rob Harrop
 * @author Rick Evans
 * @author Mark Fisher
 * @since 2.0
 */
<span class="fc" id="L139">public class ScriptFactoryPostProcessor extends InstantiationAwareBeanPostProcessorAdapter</span>
		implements BeanClassLoaderAware, BeanFactoryAware, ResourceLoaderAware, DisposableBean, Ordered {

	/**
	 * The {@link org.springframework.core.io.Resource}-style prefix that denotes
	 * an inline script.
	 * &lt;p&gt;An inline script is a script that is defined right there in the (typically XML)
	 * configuration, as opposed to being defined in an external file.
	 */
	public static final String INLINE_SCRIPT_PREFIX = &quot;inline:&quot;;

	/**
	 * The {@code refreshCheckDelay} attribute.
	 */
<span class="fc" id="L153">	public static final String REFRESH_CHECK_DELAY_ATTRIBUTE = Conventions.getQualifiedAttributeName(</span>
			ScriptFactoryPostProcessor.class, &quot;refreshCheckDelay&quot;);

	/**
	 * The {@code proxyTargetClass} attribute.
	 */
<span class="fc" id="L159">	public static final String PROXY_TARGET_CLASS_ATTRIBUTE = Conventions.getQualifiedAttributeName(</span>
			ScriptFactoryPostProcessor.class, &quot;proxyTargetClass&quot;);

	/**
	 * The {@code language} attribute.
	 */
<span class="fc" id="L165">	public static final String LANGUAGE_ATTRIBUTE = Conventions.getQualifiedAttributeName(</span>
			ScriptFactoryPostProcessor.class, &quot;language&quot;);

	private static final String SCRIPT_FACTORY_NAME_PREFIX = &quot;scriptFactory.&quot;;

	private static final String SCRIPTED_OBJECT_NAME_PREFIX = &quot;scriptedObject.&quot;;


	/** Logger available to subclasses. */
<span class="fc" id="L174">	protected final Log logger = LogFactory.getLog(getClass());</span>

<span class="fc" id="L176">	private long defaultRefreshCheckDelay = -1;</span>

<span class="fc" id="L178">	private boolean defaultProxyTargetClass = false;</span>

<span class="fc" id="L180">	@Nullable</span>
<span class="fc" id="L181">	private ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();</span>

	@Nullable
	private ConfigurableBeanFactory beanFactory;

<span class="fc" id="L186">	private ResourceLoader resourceLoader = new DefaultResourceLoader();</span>

<span class="fc" id="L188">	final DefaultListableBeanFactory scriptBeanFactory = new DefaultListableBeanFactory();</span>

	/** Map from bean name String to ScriptSource object. */
<span class="fc" id="L191">	private final Map&lt;String, ScriptSource&gt; scriptSourceCache = new HashMap&lt;&gt;();</span>


	/**
	 * Set the delay between refresh checks, in milliseconds.
	 * Default is -1, indicating no refresh checks at all.
	 * &lt;p&gt;Note that an actual refresh will only happen when
	 * the {@link org.springframework.scripting.ScriptSource} indicates
	 * that it has been modified.
	 * @see org.springframework.scripting.ScriptSource#isModified()
	 */
	public void setDefaultRefreshCheckDelay(long defaultRefreshCheckDelay) {
<span class="fc" id="L203">		this.defaultRefreshCheckDelay = defaultRefreshCheckDelay;</span>
<span class="fc" id="L204">	}</span>

	/**
	 * Flag to signal that refreshable proxies should be created to proxy the target class not its interfaces.
	 * @param defaultProxyTargetClass the flag value to set
	 */
	public void setDefaultProxyTargetClass(boolean defaultProxyTargetClass) {
<span class="fc" id="L211">		this.defaultProxyTargetClass = defaultProxyTargetClass;</span>
<span class="fc" id="L212">	}</span>

	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
<span class="fc" id="L216">		this.beanClassLoader = classLoader;</span>
<span class="fc" id="L217">	}</span>

	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">		if (!(beanFactory instanceof ConfigurableBeanFactory)) {</span>
<span class="nc" id="L222">			throw new IllegalStateException(&quot;ScriptFactoryPostProcessor doesn't work with &quot; +</span>
<span class="nc" id="L223">					&quot;non-ConfigurableBeanFactory: &quot; + beanFactory.getClass());</span>
		}
<span class="fc" id="L225">		this.beanFactory = (ConfigurableBeanFactory) beanFactory;</span>

		// Required so that references (up container hierarchies) are correctly resolved.
<span class="fc" id="L228">		this.scriptBeanFactory.setParentBeanFactory(this.beanFactory);</span>

		// Required so that all BeanPostProcessors, Scopes, etc become available.
<span class="fc" id="L231">		this.scriptBeanFactory.copyConfigurationFrom(this.beanFactory);</span>

		// Filter out BeanPostProcessors that are part of the AOP infrastructure,
		// since those are only meant to apply to beans defined in the original factory.
<span class="fc" id="L235">		this.scriptBeanFactory.getBeanPostProcessors().removeIf(beanPostProcessor -&gt;</span>
<span class="fc" id="L236">				beanPostProcessor instanceof AopInfrastructureBean);</span>
<span class="fc" id="L237">	}</span>

	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
<span class="fc" id="L241">		this.resourceLoader = resourceLoader;</span>
<span class="fc" id="L242">	}</span>

	@Override
	public int getOrder() {
<span class="fc" id="L246">		return Integer.MIN_VALUE;</span>
	}


	@Override
	@Nullable
	public Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) {
		// We only apply special treatment to ScriptFactory implementations here.
<span class="fc bfc" id="L254" title="All 2 branches covered.">		if (!ScriptFactory.class.isAssignableFrom(beanClass)) {</span>
<span class="fc" id="L255">			return null;</span>
		}

<span class="pc bpc" id="L258" title="1 of 2 branches missed.">		Assert.state(this.beanFactory != null, &quot;No BeanFactory set&quot;);</span>
<span class="fc" id="L259">		BeanDefinition bd = this.beanFactory.getMergedBeanDefinition(beanName);</span>

		try {
<span class="fc" id="L262">			String scriptFactoryBeanName = SCRIPT_FACTORY_NAME_PREFIX + beanName;</span>
<span class="fc" id="L263">			String scriptedObjectBeanName = SCRIPTED_OBJECT_NAME_PREFIX + beanName;</span>
<span class="fc" id="L264">			prepareScriptBeans(bd, scriptFactoryBeanName, scriptedObjectBeanName);</span>

<span class="fc" id="L266">			ScriptFactory scriptFactory = this.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class);</span>
<span class="fc" id="L267">			ScriptSource scriptSource = getScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator());</span>
<span class="fc" id="L268">			Class&lt;?&gt;[] interfaces = scriptFactory.getScriptInterfaces();</span>

<span class="fc" id="L270">			Class&lt;?&gt; scriptedType = scriptFactory.getScriptedObjectType(scriptSource);</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">			if (scriptedType != null) {</span>
<span class="fc" id="L272">				return scriptedType;</span>
			}
<span class="fc bfc" id="L274" title="All 2 branches covered.">			else if (!ObjectUtils.isEmpty(interfaces)) {</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">				return (interfaces.length == 1 ? interfaces[0] : createCompositeInterface(interfaces));</span>
			}
			else {
<span class="fc bfc" id="L278" title="All 2 branches covered.">				if (bd.isSingleton()) {</span>
<span class="fc" id="L279">					return this.scriptBeanFactory.getBean(scriptedObjectBeanName).getClass();</span>
				}
			}
		}
<span class="fc" id="L283">		catch (Exception ex) {</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">			if (ex instanceof BeanCreationException &amp;&amp;</span>
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">					((BeanCreationException) ex).getMostSpecificCause() instanceof BeanCurrentlyInCreationException) {</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">				if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L287">					logger.trace(&quot;Could not determine scripted object type for bean '&quot; + beanName + &quot;': &quot; +</span>
<span class="nc" id="L288">							ex.getMessage());</span>
				}
			}
			else {
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">				if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L293">					logger.debug(&quot;Could not determine scripted object type for bean '&quot; + beanName + &quot;'&quot;, ex);</span>
				}
			}
<span class="fc" id="L296">		}</span>

<span class="fc" id="L298">		return null;</span>
	}

	@Override
	public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
<span class="fc" id="L303">		return pvs;</span>
	}

	@Override
	public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {
		// We only apply special treatment to ScriptFactory implementations here.
<span class="fc bfc" id="L309" title="All 2 branches covered.">		if (!ScriptFactory.class.isAssignableFrom(beanClass)) {</span>
<span class="fc" id="L310">			return null;</span>
		}

<span class="pc bpc" id="L313" title="1 of 2 branches missed.">		Assert.state(this.beanFactory != null, &quot;No BeanFactory set&quot;);</span>
<span class="fc" id="L314">		BeanDefinition bd = this.beanFactory.getMergedBeanDefinition(beanName);</span>
<span class="fc" id="L315">		String scriptFactoryBeanName = SCRIPT_FACTORY_NAME_PREFIX + beanName;</span>
<span class="fc" id="L316">		String scriptedObjectBeanName = SCRIPTED_OBJECT_NAME_PREFIX + beanName;</span>
<span class="fc" id="L317">		prepareScriptBeans(bd, scriptFactoryBeanName, scriptedObjectBeanName);</span>

<span class="fc" id="L319">		ScriptFactory scriptFactory = this.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class);</span>
<span class="fc" id="L320">		ScriptSource scriptSource = getScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator());</span>
<span class="fc" id="L321">		boolean isFactoryBean = false;</span>
		try {
<span class="fc" id="L323">			Class&lt;?&gt; scriptedObjectType = scriptFactory.getScriptedObjectType(scriptSource);</span>
			// Returned type may be null if the factory is unable to determine the type.
<span class="fc bfc" id="L325" title="All 2 branches covered.">			if (scriptedObjectType != null) {</span>
<span class="fc" id="L326">				isFactoryBean = FactoryBean.class.isAssignableFrom(scriptedObjectType);</span>
			}
		}
<span class="fc" id="L329">		catch (Exception ex) {</span>
<span class="fc" id="L330">			throw new BeanCreationException(beanName,</span>
					&quot;Could not determine scripted object type for &quot; + scriptFactory, ex);
<span class="fc" id="L332">		}</span>

<span class="fc" id="L334">		long refreshCheckDelay = resolveRefreshCheckDelay(bd);</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">		if (refreshCheckDelay &gt;= 0) {</span>
<span class="fc" id="L336">			Class&lt;?&gt;[] interfaces = scriptFactory.getScriptInterfaces();</span>
<span class="fc" id="L337">			RefreshableScriptTargetSource ts = new RefreshableScriptTargetSource(this.scriptBeanFactory,</span>
					scriptedObjectBeanName, scriptFactory, scriptSource, isFactoryBean);
<span class="fc" id="L339">			boolean proxyTargetClass = resolveProxyTargetClass(bd);</span>
<span class="fc" id="L340">			String language = (String) bd.getAttribute(LANGUAGE_ATTRIBUTE);</span>
<span class="pc bpc" id="L341" title="2 of 6 branches missed.">			if (proxyTargetClass &amp;&amp; (language == null || !language.equals(&quot;groovy&quot;))) {</span>
<span class="nc" id="L342">				throw new BeanDefinitionValidationException(</span>
						&quot;Cannot use proxyTargetClass=true with script beans where language is not 'groovy': '&quot; +
						language + &quot;'&quot;);
			}
<span class="fc" id="L346">			ts.setRefreshCheckDelay(refreshCheckDelay);</span>
<span class="fc" id="L347">			return createRefreshableProxy(ts, interfaces, proxyTargetClass);</span>
		}

<span class="fc bfc" id="L350" title="All 2 branches covered.">		if (isFactoryBean) {</span>
<span class="fc" id="L351">			scriptedObjectBeanName = BeanFactory.FACTORY_BEAN_PREFIX + scriptedObjectBeanName;</span>
		}
<span class="fc" id="L353">		return this.scriptBeanFactory.getBean(scriptedObjectBeanName);</span>
	}

	/**
	 * Prepare the script beans in the internal BeanFactory that this
	 * post-processor uses. Each original bean definition will be split
	 * into a ScriptFactory definition and a scripted object definition.
	 * @param bd the original bean definition in the main BeanFactory
	 * @param scriptFactoryBeanName the name of the internal ScriptFactory bean
	 * @param scriptedObjectBeanName the name of the internal scripted object bean
	 */
	protected void prepareScriptBeans(BeanDefinition bd, String scriptFactoryBeanName, String scriptedObjectBeanName) {
		// Avoid recreation of the script bean definition in case of a prototype.
<span class="fc" id="L366">		synchronized (this.scriptBeanFactory) {</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">			if (!this.scriptBeanFactory.containsBeanDefinition(scriptedObjectBeanName)) {</span>

<span class="fc" id="L369">				this.scriptBeanFactory.registerBeanDefinition(</span>
<span class="fc" id="L370">						scriptFactoryBeanName, createScriptFactoryBeanDefinition(bd));</span>
<span class="fc" id="L371">				ScriptFactory scriptFactory =</span>
<span class="fc" id="L372">						this.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class);</span>
<span class="fc" id="L373">				ScriptSource scriptSource =</span>
<span class="fc" id="L374">						getScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator());</span>
<span class="fc" id="L375">				Class&lt;?&gt;[] interfaces = scriptFactory.getScriptInterfaces();</span>

<span class="fc" id="L377">				Class&lt;?&gt;[] scriptedInterfaces = interfaces;</span>
<span class="fc bfc" id="L378" title="All 4 branches covered.">				if (scriptFactory.requiresConfigInterface() &amp;&amp; !bd.getPropertyValues().isEmpty()) {</span>
<span class="fc" id="L379">					Class&lt;?&gt; configInterface = createConfigInterface(bd, interfaces);</span>
<span class="fc" id="L380">					scriptedInterfaces = ObjectUtils.addObjectToArray(interfaces, configInterface);</span>
				}

<span class="fc" id="L383">				BeanDefinition objectBd = createScriptedObjectBeanDefinition(</span>
						bd, scriptFactoryBeanName, scriptSource, scriptedInterfaces);
<span class="fc" id="L385">				long refreshCheckDelay = resolveRefreshCheckDelay(bd);</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">				if (refreshCheckDelay &gt;= 0) {</span>
<span class="fc" id="L387">					objectBd.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span>
				}

<span class="fc" id="L390">				this.scriptBeanFactory.registerBeanDefinition(scriptedObjectBeanName, objectBd);</span>
			}
<span class="fc" id="L392">		}</span>
<span class="fc" id="L393">	}</span>

	/**
	 * Get the refresh check delay for the given {@link ScriptFactory} {@link BeanDefinition}.
	 * If the {@link BeanDefinition} has a
	 * {@link org.springframework.core.AttributeAccessor metadata attribute}
	 * under the key {@link #REFRESH_CHECK_DELAY_ATTRIBUTE} which is a valid {@link Number}
	 * type, then this value is used. Otherwise, the {@link #defaultRefreshCheckDelay}
	 * value is used.
	 * @param beanDefinition the BeanDefinition to check
	 * @return the refresh check delay
	 */
	protected long resolveRefreshCheckDelay(BeanDefinition beanDefinition) {
<span class="fc" id="L406">		long refreshCheckDelay = this.defaultRefreshCheckDelay;</span>
<span class="fc" id="L407">		Object attributeValue = beanDefinition.getAttribute(REFRESH_CHECK_DELAY_ATTRIBUTE);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">		if (attributeValue instanceof Number) {</span>
<span class="fc" id="L409">			refreshCheckDelay = ((Number) attributeValue).longValue();</span>
		}
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">		else if (attributeValue instanceof String) {</span>
<span class="nc" id="L412">			refreshCheckDelay = Long.parseLong((String) attributeValue);</span>
		}
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">		else if (attributeValue != null) {</span>
<span class="nc" id="L415">			throw new BeanDefinitionStoreException(&quot;Invalid refresh check delay attribute [&quot; +</span>
					REFRESH_CHECK_DELAY_ATTRIBUTE + &quot;] with value '&quot; + attributeValue +
					&quot;': needs to be of type Number or String&quot;);
		}
<span class="fc" id="L419">		return refreshCheckDelay;</span>
	}

	protected boolean resolveProxyTargetClass(BeanDefinition beanDefinition) {
<span class="fc" id="L423">		boolean proxyTargetClass = this.defaultProxyTargetClass;</span>
<span class="fc" id="L424">		Object attributeValue = beanDefinition.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">		if (attributeValue instanceof Boolean) {</span>
<span class="fc" id="L426">			proxyTargetClass = (Boolean) attributeValue;</span>
		}
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">		else if (attributeValue instanceof String) {</span>
<span class="nc" id="L429">			proxyTargetClass = Boolean.valueOf((String) attributeValue);</span>
		}
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">		else if (attributeValue != null) {</span>
<span class="nc" id="L432">			throw new BeanDefinitionStoreException(&quot;Invalid proxy target class attribute [&quot; +</span>
					PROXY_TARGET_CLASS_ATTRIBUTE + &quot;] with value '&quot; + attributeValue +
					&quot;': needs to be of type Boolean or String&quot;);
		}
<span class="fc" id="L436">		return proxyTargetClass;</span>
	}

	/**
	 * Create a ScriptFactory bean definition based on the given script definition,
	 * extracting only the definition data that is relevant for the ScriptFactory
	 * (that is, only bean class and constructor arguments).
	 * @param bd the full script bean definition
	 * @return the extracted ScriptFactory bean definition
	 * @see org.springframework.scripting.ScriptFactory
	 */
	protected BeanDefinition createScriptFactoryBeanDefinition(BeanDefinition bd) {
<span class="fc" id="L448">		GenericBeanDefinition scriptBd = new GenericBeanDefinition();</span>
<span class="fc" id="L449">		scriptBd.setBeanClassName(bd.getBeanClassName());</span>
<span class="fc" id="L450">		scriptBd.getConstructorArgumentValues().addArgumentValues(bd.getConstructorArgumentValues());</span>
<span class="fc" id="L451">		return scriptBd;</span>
	}

	/**
	 * Obtain a ScriptSource for the given bean, lazily creating it
	 * if not cached already.
	 * @param beanName the name of the scripted bean
	 * @param scriptSourceLocator the script source locator associated with the bean
	 * @return the corresponding ScriptSource instance
	 * @see #convertToScriptSource
	 */
	protected ScriptSource getScriptSource(String beanName, String scriptSourceLocator) {
<span class="fc" id="L463">		synchronized (this.scriptSourceCache) {</span>
<span class="fc" id="L464">			ScriptSource scriptSource = this.scriptSourceCache.get(beanName);</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">			if (scriptSource == null) {</span>
<span class="fc" id="L466">				scriptSource = convertToScriptSource(beanName, scriptSourceLocator, this.resourceLoader);</span>
<span class="fc" id="L467">				this.scriptSourceCache.put(beanName, scriptSource);</span>
			}
<span class="fc" id="L469">			return scriptSource;</span>
		}
	}

	/**
	 * Convert the given script source locator to a ScriptSource instance.
	 * &lt;p&gt;By default, supported locators are Spring resource locations
	 * (such as &quot;file:C:/myScript.bsh&quot; or &quot;classpath:myPackage/myScript.bsh&quot;)
	 * and inline scripts (&quot;inline:myScriptText...&quot;).
	 * @param beanName the name of the scripted bean
	 * @param scriptSourceLocator the script source locator
	 * @param resourceLoader the ResourceLoader to use (if necessary)
	 * @return the ScriptSource instance
	 */
	protected ScriptSource convertToScriptSource(String beanName, String scriptSourceLocator,
			ResourceLoader resourceLoader) {

<span class="fc bfc" id="L486" title="All 2 branches covered.">		if (scriptSourceLocator.startsWith(INLINE_SCRIPT_PREFIX)) {</span>
<span class="fc" id="L487">			return new StaticScriptSource(scriptSourceLocator.substring(INLINE_SCRIPT_PREFIX.length()), beanName);</span>
		}
		else {
<span class="fc" id="L490">			return new ResourceScriptSource(resourceLoader.getResource(scriptSourceLocator));</span>
		}
	}

	/**
	 * Create a config interface for the given bean definition, defining setter
	 * methods for the defined property values as well as an init method and
	 * a destroy method (if defined).
	 * &lt;p&gt;This implementation creates the interface via CGLIB's InterfaceMaker,
	 * determining the property types from the given interfaces (as far as possible).
	 * @param bd the bean definition (property values etc) to create a
	 * config interface for
	 * @param interfaces the interfaces to check against (might define
	 * getters corresponding to the setters we're supposed to generate)
	 * @return the config interface
	 * @see org.springframework.cglib.proxy.InterfaceMaker
	 * @see org.springframework.beans.BeanUtils#findPropertyType
	 */
	protected Class&lt;?&gt; createConfigInterface(BeanDefinition bd, @Nullable Class&lt;?&gt;[] interfaces) {
<span class="fc" id="L509">		InterfaceMaker maker = new InterfaceMaker();</span>
<span class="fc" id="L510">		PropertyValue[] pvs = bd.getPropertyValues().getPropertyValues();</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">		for (PropertyValue pv : pvs) {</span>
<span class="fc" id="L512">			String propertyName = pv.getName();</span>
<span class="fc" id="L513">			Class&lt;?&gt; propertyType = BeanUtils.findPropertyType(propertyName, interfaces);</span>
<span class="fc" id="L514">			String setterName = &quot;set&quot; + StringUtils.capitalize(propertyName);</span>
<span class="fc" id="L515">			Signature signature = new Signature(setterName, Type.VOID_TYPE, new Type[] {Type.getType(propertyType)});</span>
<span class="fc" id="L516">			maker.add(signature, new Type[0]);</span>
		}
<span class="fc bfc" id="L518" title="All 2 branches covered.">		if (bd.getInitMethodName() != null) {</span>
<span class="fc" id="L519">			Signature signature = new Signature(bd.getInitMethodName(), Type.VOID_TYPE, new Type[0]);</span>
<span class="fc" id="L520">			maker.add(signature, new Type[0]);</span>
		}
<span class="fc bfc" id="L522" title="All 2 branches covered.">		if (StringUtils.hasText(bd.getDestroyMethodName())) {</span>
<span class="fc" id="L523">			Signature signature = new Signature(bd.getDestroyMethodName(), Type.VOID_TYPE, new Type[0]);</span>
<span class="fc" id="L524">			maker.add(signature, new Type[0]);</span>
		}
<span class="fc" id="L526">		return maker.create();</span>
	}

	/**
	 * Create a composite interface Class for the given interfaces,
	 * implementing the given interfaces in one single Class.
	 * &lt;p&gt;The default implementation builds a JDK proxy class
	 * for the given interfaces.
	 * @param interfaces the interfaces to merge
	 * @return the merged interface as Class
	 * @see java.lang.reflect.Proxy#getProxyClass
	 */
	protected Class&lt;?&gt; createCompositeInterface(Class&lt;?&gt;[] interfaces) {
<span class="fc" id="L539">		return ClassUtils.createCompositeInterface(interfaces, this.beanClassLoader);</span>
	}

	/**
	 * Create a bean definition for the scripted object, based on the given script
	 * definition, extracting the definition data that is relevant for the scripted
	 * object (that is, everything but bean class and constructor arguments).
	 * @param bd the full script bean definition
	 * @param scriptFactoryBeanName the name of the internal ScriptFactory bean
	 * @param scriptSource the ScriptSource for the scripted bean
	 * @param interfaces the interfaces that the scripted bean is supposed to implement
	 * @return the extracted ScriptFactory bean definition
	 * @see org.springframework.scripting.ScriptFactory#getScriptedObject
	 */
	protected BeanDefinition createScriptedObjectBeanDefinition(BeanDefinition bd, String scriptFactoryBeanName,
			ScriptSource scriptSource, @Nullable Class&lt;?&gt;[] interfaces) {

<span class="fc" id="L556">		GenericBeanDefinition objectBd = new GenericBeanDefinition(bd);</span>
<span class="fc" id="L557">		objectBd.setFactoryBeanName(scriptFactoryBeanName);</span>
<span class="fc" id="L558">		objectBd.setFactoryMethodName(&quot;getScriptedObject&quot;);</span>
<span class="fc" id="L559">		objectBd.getConstructorArgumentValues().clear();</span>
<span class="fc" id="L560">		objectBd.getConstructorArgumentValues().addIndexedArgumentValue(0, scriptSource);</span>
<span class="fc" id="L561">		objectBd.getConstructorArgumentValues().addIndexedArgumentValue(1, interfaces);</span>
<span class="fc" id="L562">		return objectBd;</span>
	}

	/**
	 * Create a refreshable proxy for the given AOP TargetSource.
	 * @param ts the refreshable TargetSource
	 * @param interfaces the proxy interfaces (may be {@code null} to
	 * indicate proxying of all interfaces implemented by the target class)
	 * @return the generated proxy
	 * @see RefreshableScriptTargetSource
	 */
	protected Object createRefreshableProxy(TargetSource ts, @Nullable Class&lt;?&gt;[] interfaces, boolean proxyTargetClass) {
<span class="fc" id="L574">		ProxyFactory proxyFactory = new ProxyFactory();</span>
<span class="fc" id="L575">		proxyFactory.setTargetSource(ts);</span>
<span class="fc" id="L576">		ClassLoader classLoader = this.beanClassLoader;</span>

<span class="fc bfc" id="L578" title="All 2 branches covered.">		if (interfaces != null) {</span>
<span class="fc" id="L579">			proxyFactory.setInterfaces(interfaces);</span>
		}
		else {
<span class="fc" id="L582">			Class&lt;?&gt; targetClass = ts.getTargetClass();</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">			if (targetClass != null) {</span>
<span class="fc" id="L584">				proxyFactory.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.beanClassLoader));</span>
			}
		}

<span class="fc bfc" id="L588" title="All 2 branches covered.">		if (proxyTargetClass) {</span>
<span class="fc" id="L589">			classLoader = null;  // force use of Class.getClassLoader()</span>
<span class="fc" id="L590">			proxyFactory.setProxyTargetClass(true);</span>
		}

<span class="fc" id="L593">		DelegatingIntroductionInterceptor introduction = new DelegatingIntroductionInterceptor(ts);</span>
<span class="fc" id="L594">		introduction.suppressInterface(TargetSource.class);</span>
<span class="fc" id="L595">		proxyFactory.addAdvice(introduction);</span>

<span class="fc" id="L597">		return proxyFactory.getProxy(classLoader);</span>
	}

	/**
	 * Destroy the inner bean factory (used for scripts) on shutdown.
	 */
	@Override
	public void destroy() {
<span class="fc" id="L605">		this.scriptBeanFactory.destroySingletons();</span>
<span class="fc" id="L606">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>