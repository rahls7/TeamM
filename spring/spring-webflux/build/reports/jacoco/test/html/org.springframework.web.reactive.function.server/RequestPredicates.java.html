<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RequestPredicates.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-webflux</a> &gt; <a href="index.source.html" class="el_package">org.springframework.web.reactive.function.server</a> &gt; <span class="el_source">RequestPredicates.java</span></div><h1>RequestPredicates.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.reactive.function.server;

import java.net.InetSocketAddress;
import java.net.URI;
import java.security.Principal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.function.Predicate;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpCookie;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.codec.HttpMessageReader;
import org.springframework.http.codec.multipart.Part;
import org.springframework.http.server.PathContainer;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.lang.NonNull;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyExtractor;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebSession;
import org.springframework.web.util.UriBuilder;
import org.springframework.web.util.UriUtils;
import org.springframework.web.util.pattern.PathPattern;
import org.springframework.web.util.pattern.PathPatternParser;

/**
 * Implementations of {@link RequestPredicate} that implement various useful
 * request matching operations, such as matching based on path, HTTP method, etc.
 *
 * @author Arjen Poutsma
 * @since 5.0
 */
<span class="nc" id="L70">public abstract class RequestPredicates {</span>

<span class="fc" id="L72">	private static final Log logger = LogFactory.getLog(RequestPredicates.class);</span>

<span class="fc" id="L74">	private static final PathPatternParser DEFAULT_PATTERN_PARSER = new PathPatternParser();</span>


	/**
	 * Return a {@code RequestPredicate} that always matches.
	 * @return a predicate that always matches
	 */
	public static RequestPredicate all() {
<span class="fc" id="L82">		return request -&gt; true;</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if the request's
	 * HTTP method is equal to the given method.
	 * @param httpMethod the HTTP method to match against
	 * @return a predicate that tests against the given HTTP method
	 */
	public static RequestPredicate method(HttpMethod httpMethod) {
<span class="fc" id="L92">		return new HttpMethodPredicate(httpMethod);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if the request's
	 * HTTP method is equal to one the of the given methods.
	 * @param httpMethods the HTTP methods to match against
	 * @return a predicate that tests against the given HTTP methods
	 * @since 5.1
	 */
	public static RequestPredicate methods(HttpMethod... httpMethods) {
<span class="fc" id="L103">		return new HttpMethodPredicate(httpMethods);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that tests the request path
	 * against the given path pattern.
	 * @param pattern the pattern to match to
	 * @return a predicate that tests against the given path pattern
	 */
	public static RequestPredicate path(String pattern) {
<span class="fc" id="L113">		Assert.notNull(pattern, &quot;'pattern' must not be null&quot;);</span>
<span class="fc" id="L114">		return pathPredicates(DEFAULT_PATTERN_PARSER).apply(pattern);</span>
	}

	/**
	 * Return a function that creates new path-matching {@code RequestPredicates}
	 * from pattern Strings using the given {@link PathPatternParser}.
	 * &lt;p&gt;This method can be used to specify a non-default, customized
	 * {@code PathPatternParser} when resolving path patterns.
	 * @param patternParser the parser used to parse patterns given to the returned function
	 * @return a function that resolves a pattern String into a path-matching
	 * {@code RequestPredicates} instance
	 */
	public static Function&lt;String, RequestPredicate&gt; pathPredicates(PathPatternParser patternParser) {
<span class="fc" id="L127">		Assert.notNull(patternParser, &quot;PathPatternParser must not be null&quot;);</span>
<span class="fc" id="L128">		return pattern -&gt; new PathPatternPredicate(patternParser.parse(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that tests the request's headers
	 * against the given headers predicate.
	 * @param headersPredicate a predicate that tests against the request headers
	 * @return a predicate that tests against the given header predicate
	 */
	public static RequestPredicate headers(Predicate&lt;ServerRequest.Headers&gt; headersPredicate) {
<span class="fc" id="L138">		return new HeadersPredicate(headersPredicate);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that tests if the request's
	 * {@linkplain ServerRequest.Headers#contentType() content type} is
	 * {@linkplain MediaType#includes(MediaType) included} by any of the given media types.
	 * @param mediaTypes the media types to match the request's content type against
	 * @return a predicate that tests the request's content type against the given media types
	 */
	public static RequestPredicate contentType(MediaType... mediaTypes) {
<span class="fc" id="L149">		Assert.notEmpty(mediaTypes, &quot;'mediaTypes' must not be empty&quot;);</span>
<span class="fc" id="L150">		return new ContentTypePredicate(mediaTypes);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that tests if the request's
	 * {@linkplain ServerRequest.Headers#accept() accept} header is
	 * {@linkplain MediaType#isCompatibleWith(MediaType) compatible} with any of the given media types.
	 * @param mediaTypes the media types to match the request's accept header against
	 * @return a predicate that tests the request's accept header against the given media types
	 */
	public static RequestPredicate accept(MediaType... mediaTypes) {
<span class="fc" id="L161">		Assert.notEmpty(mediaTypes, &quot;'mediaTypes' must not be empty&quot;);</span>
<span class="fc" id="L162">		return new AcceptPredicate(mediaTypes);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code GET}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is GET and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate GET(String pattern) {
<span class="fc" id="L173">		return method(HttpMethod.GET).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code HEAD}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is HEAD and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate HEAD(String pattern) {
<span class="fc" id="L184">		return method(HttpMethod.HEAD).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code POST}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is POST and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate POST(String pattern) {
<span class="fc" id="L195">		return method(HttpMethod.POST).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PUT}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is PUT and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate PUT(String pattern) {
<span class="fc" id="L206">		return method(HttpMethod.PUT).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PATCH}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is PATCH and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate PATCH(String pattern) {
<span class="fc" id="L217">		return method(HttpMethod.PATCH).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code DELETE}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is DELETE and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate DELETE(String pattern) {
<span class="fc" id="L228">		return method(HttpMethod.DELETE).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code OPTIONS}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is OPTIONS and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate OPTIONS(String pattern) {
<span class="fc" id="L239">		return method(HttpMethod.OPTIONS).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if the request's path has the given extension.
	 * @param extension the path extension to match against, ignoring case
	 * @return a predicate that matches if the request's path has the given file extension
	 */
	public static RequestPredicate pathExtension(String extension) {
<span class="fc" id="L248">		Assert.notNull(extension, &quot;'extension' must not be null&quot;);</span>
<span class="fc" id="L249">		return new PathExtensionPredicate(extension);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if the request's path matches the given
	 * predicate.
	 * @param extensionPredicate the predicate to test against the request path extension
	 * @return a predicate that matches if the given predicate matches against the request's path
	 * file extension
	 */
	public static RequestPredicate pathExtension(Predicate&lt;String&gt; extensionPredicate) {
<span class="nc" id="L260">		return new PathExtensionPredicate(extensionPredicate);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if the request's query parameter of the given name
	 * has the given value.
	 * @param name the name of the query parameter to test against
	 * @param value the value of the query parameter to test against
	 * @return a predicate that matches if the query parameter has the given value
	 * @since 5.0.7
	 * @see ServerRequest#queryParam(String)
	 */
	public static RequestPredicate queryParam(String name, String value) {
<span class="fc" id="L273">		return new QueryParamPredicate(name, value);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that tests the request's query parameter of the given name
	 * against the given predicate.
	 * @param name the name of the query parameter to test against
	 * @param predicate predicate to test against the query parameter value
	 * @return a predicate that matches the given predicate against the query parameter of the given name
	 * @see ServerRequest#queryParam(String)
	 */
	public static RequestPredicate queryParam(String name, Predicate&lt;String&gt; predicate) {
<span class="fc" id="L285">		return new QueryParamPredicate(name, predicate);</span>
	}


	private static void traceMatch(String prefix, Object desired, @Nullable Object actual, boolean match) {
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">		if (logger.isTraceEnabled()) {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">			logger.trace(String.format(&quot;%s \&quot;%s\&quot; %s against value \&quot;%s\&quot;&quot;,</span>
					prefix, desired, match ? &quot;matches&quot; : &quot;does not match&quot;, actual));
		}
<span class="fc" id="L294">	}</span>

	private static void restoreAttributes(ServerRequest request, Map&lt;String, Object&gt; attributes) {
<span class="fc" id="L297">		request.attributes().clear();</span>
<span class="fc" id="L298">		request.attributes().putAll(attributes);</span>
<span class="fc" id="L299">	}</span>

	private static Map&lt;String, String&gt; mergePathVariables(Map&lt;String, String&gt; oldVariables,
			Map&lt;String, String&gt; newVariables) {

<span class="fc bfc" id="L304" title="All 2 branches covered.">		if (!newVariables.isEmpty()) {</span>
<span class="fc" id="L305">			Map&lt;String, String&gt; mergedVariables = new LinkedHashMap&lt;&gt;(oldVariables);</span>
<span class="fc" id="L306">			mergedVariables.putAll(newVariables);</span>
<span class="fc" id="L307">			return mergedVariables;</span>
		}
		else {
<span class="fc" id="L310">			return oldVariables;</span>
		}
	}

	private static PathPattern mergePatterns(@Nullable PathPattern oldPattern, PathPattern newPattern) {
<span class="fc bfc" id="L315" title="All 2 branches covered.">		if (oldPattern != null) {</span>
<span class="fc" id="L316">			return oldPattern.combine(newPattern);</span>
		}
		else {
<span class="fc" id="L319">			return newPattern;</span>
		}

	}


	/**
	 * Receives notifications from the logical structure of request predicates.
	 */
	public interface Visitor {

		/**
		 * Receive notification of an HTTP method predicate.
		 * @param methods the HTTP methods that make up the predicate
		 * @see RequestPredicates#method(HttpMethod)
		 */
		void method(Set&lt;HttpMethod&gt; methods);

		/**
		 * Receive notification of an path predicate.
		 * @param pattern the path pattern that makes up the predicate
		 * @see RequestPredicates#path(String)
		 */
		void path(String pattern);

		/**
		 * Receive notification of an path extension predicate.
		 * @param extension the path extension that makes up the predicate
		 * @see RequestPredicates#pathExtension(String)
		 */
		void pathExtension(String extension);

		/**
		 * Receive notification of a HTTP header predicate.
		 * @param name the name of the HTTP header to check
		 * @param value the desired value of the HTTP header
		 * @see RequestPredicates#headers(Predicate)
		 * @see RequestPredicates#contentType(MediaType...)
		 * @see RequestPredicates#accept(MediaType...)
		 */
		void header(String name, String value);

		/**
		 * Receive notification of a query parameter predicate.
		 * @param name the name of the query parameter
		 * @param value the desired value of the parameter
		 * @see RequestPredicates#queryParam(String, String)
		 */
		void queryParam(String name, String value);

		/**
		 * Receive first notification of a logical AND predicate.
		 * The first subsequent notification will contain the left-hand side of the AND-predicate;
		 * followed by {@link #and()}, followed by the right-hand side, followed by {@link #endAnd()}.
		 * @see RequestPredicate#and(RequestPredicate)
		 */
		void startAnd();

		/**
		 * Receive &quot;middle&quot; notification of a logical AND predicate.
		 * The following notification contains the right-hand side, followed by {@link #endAnd()}.
		 * @see RequestPredicate#and(RequestPredicate)
		 */
		void and();

		/**
		 * Receive last notification of a logical AND predicate.
		 * @see RequestPredicate#and(RequestPredicate)
		 */
		void endAnd();

		/**
		 * Receive first notification of a logical OR predicate.
		 * The first subsequent notification will contain the left-hand side of the OR-predicate;
		 * the second notification contains the right-hand side, followed by {@link #endOr()}.
		 * @see RequestPredicate#or(RequestPredicate)
		 */
		void startOr();

		/**
		 * Receive &quot;middle&quot; notification of a logical OR predicate.
		 * The following notification contains the right-hand side, followed by {@link #endOr()}.
		 * @see RequestPredicate#or(RequestPredicate)
		 */
		void or();

		/**
		 * Receive last notification of a logical OR predicate.
		 * @see RequestPredicate#or(RequestPredicate)
		 */
		void endOr();

		/**
		 * Receive first notification of a negated predicate.
		 * The first subsequent notification will contain the negated predicated, followed
		 * by {@link #endNegate()}.
		 * @see RequestPredicate#negate()
		 */
		void startNegate();

		/**
		 * Receive last notification of a negated predicate.
		 * @see RequestPredicate#negate()
		 */
		void endNegate();

		/**
		 * Receive first notification of an unknown predicate.
		 */
		void unknown(RequestPredicate predicate);
	}


	private static class HttpMethodPredicate implements RequestPredicate {

		private final Set&lt;HttpMethod&gt; httpMethods;

<span class="fc" id="L436">		public HttpMethodPredicate(HttpMethod httpMethod) {</span>
<span class="fc" id="L437">			Assert.notNull(httpMethod, &quot;HttpMethod must not be null&quot;);</span>
<span class="fc" id="L438">			this.httpMethods = EnumSet.of(httpMethod);</span>
<span class="fc" id="L439">		}</span>

<span class="fc" id="L441">		public HttpMethodPredicate(HttpMethod... httpMethods) {</span>
<span class="fc" id="L442">			Assert.notEmpty(httpMethods, &quot;HttpMethods must not be empty&quot;);</span>

<span class="fc" id="L444">			this.httpMethods = EnumSet.copyOf(Arrays.asList(httpMethods));</span>
<span class="fc" id="L445">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L449">			boolean match = this.httpMethods.contains(request.method());</span>
<span class="fc" id="L450">			traceMatch(&quot;Method&quot;, this.httpMethods, request.method(), match);</span>
<span class="fc" id="L451">			return match;</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L456">			visitor.method(Collections.unmodifiableSet(this.httpMethods));</span>
<span class="fc" id="L457">		}</span>

		@Override
		public String toString() {
<span class="nc bnc" id="L461" title="All 2 branches missed.">			if (this.httpMethods.size() == 1) {</span>
<span class="nc" id="L462">				return this.httpMethods.iterator().next().toString();</span>
			}
			else {
<span class="nc" id="L465">				return this.httpMethods.toString();</span>
			}
		}
	}


	private static class PathPatternPredicate implements RequestPredicate {

		private final PathPattern pattern;

<span class="fc" id="L475">		public PathPatternPredicate(PathPattern pattern) {</span>
<span class="fc" id="L476">			Assert.notNull(pattern, &quot;'pattern' must not be null&quot;);</span>
<span class="fc" id="L477">			this.pattern = pattern;</span>
<span class="fc" id="L478">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L482">			PathContainer pathContainer = request.pathContainer();</span>
<span class="fc" id="L483">			PathPattern.PathMatchInfo info = this.pattern.matchAndExtract(pathContainer);</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">			traceMatch(&quot;Pattern&quot;, this.pattern.getPatternString(), request.path(), info != null);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">			if (info != null) {</span>
<span class="fc" id="L486">				mergeAttributes(request, info.getUriVariables(), this.pattern);</span>
<span class="fc" id="L487">				return true;</span>
			}
			else {
<span class="fc" id="L490">				return false;</span>
			}
		}

		private static void mergeAttributes(ServerRequest request, Map&lt;String, String&gt; variables,
				PathPattern pattern) {
<span class="fc" id="L496">			Map&lt;String, String&gt; pathVariables = mergePathVariables(request.pathVariables(), variables);</span>
<span class="fc" id="L497">			request.attributes().put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE,</span>
<span class="fc" id="L498">						Collections.unmodifiableMap(pathVariables));</span>

<span class="fc" id="L500">			pattern = mergePatterns(</span>
<span class="fc" id="L501">					(PathPattern) request.attributes().get(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE),</span>
					pattern);
<span class="fc" id="L503">			request.attributes().put(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE, pattern);</span>
<span class="fc" id="L504">		}</span>

		@Override
		public Optional&lt;ServerRequest&gt; nest(ServerRequest request) {
<span class="fc" id="L508">			return Optional.ofNullable(this.pattern.matchStartOfPath(request.pathContainer()))</span>
<span class="fc" id="L509">					.map(info -&gt; new SubPathServerRequestWrapper(request, info, this.pattern));</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L514">			visitor.path(this.pattern.getPatternString());</span>
<span class="fc" id="L515">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L519">			return this.pattern.getPatternString();</span>
		}
	}


	private static class HeadersPredicate implements RequestPredicate {

		private final Predicate&lt;ServerRequest.Headers&gt; headersPredicate;

<span class="fc" id="L528">		public HeadersPredicate(Predicate&lt;ServerRequest.Headers&gt; headersPredicate) {</span>
<span class="fc" id="L529">			Assert.notNull(headersPredicate, &quot;Predicate must not be null&quot;);</span>
<span class="fc" id="L530">			this.headersPredicate = headersPredicate;</span>
<span class="fc" id="L531">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L535">			return this.headersPredicate.test(request.headers());</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L540">			return this.headersPredicate.toString();</span>
		}
	}

	private static class ContentTypePredicate extends HeadersPredicate {

		private final Set&lt;MediaType&gt; mediaTypes;

		public ContentTypePredicate(MediaType... mediaTypes) {
<span class="fc" id="L549">			this(new HashSet&lt;&gt;(Arrays.asList(mediaTypes)));</span>
<span class="fc" id="L550">		}</span>

		private ContentTypePredicate(Set&lt;MediaType&gt; mediaTypes) {
<span class="fc" id="L553">			super(headers -&gt; {</span>
<span class="fc" id="L554">				MediaType contentType =</span>
<span class="fc" id="L555">						headers.contentType().orElse(MediaType.APPLICATION_OCTET_STREAM);</span>
<span class="fc" id="L556">				boolean match = mediaTypes.stream()</span>
<span class="fc" id="L557">						.anyMatch(mediaType -&gt; mediaType.includes(contentType));</span>
<span class="fc" id="L558">				traceMatch(&quot;Content-Type&quot;, mediaTypes, contentType, match);</span>
<span class="fc" id="L559">				return match;</span>
			});
<span class="fc" id="L561">			this.mediaTypes = mediaTypes;</span>
<span class="fc" id="L562">		}</span>

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L566">			visitor.header(HttpHeaders.CONTENT_TYPE,</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">					(this.mediaTypes.size() == 1) ?</span>
<span class="fc" id="L568">							this.mediaTypes.iterator().next().toString() :</span>
<span class="fc" id="L569">							this.mediaTypes.toString());</span>
<span class="fc" id="L570">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L574">			return String.format(&quot;Content-Type: %s&quot;,</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">					(this.mediaTypes.size() == 1) ?</span>
<span class="nc" id="L576">							this.mediaTypes.iterator().next().toString() :</span>
<span class="nc" id="L577">							this.mediaTypes.toString());</span>
		}
	}

	private static class AcceptPredicate extends HeadersPredicate {

		private final Set&lt;MediaType&gt; mediaTypes;

		public AcceptPredicate(MediaType... mediaTypes) {
<span class="fc" id="L586">			this(new HashSet&lt;&gt;(Arrays.asList(mediaTypes)));</span>
<span class="fc" id="L587">		}</span>

		private AcceptPredicate(Set&lt;MediaType&gt; mediaTypes) {
<span class="fc" id="L590">			super(headers -&gt; {</span>
<span class="fc" id="L591">				List&lt;MediaType&gt; acceptedMediaTypes = acceptedMediaTypes(headers);</span>
<span class="fc" id="L592">				boolean match = acceptedMediaTypes.stream()</span>
<span class="fc" id="L593">						.anyMatch(acceptedMediaType -&gt; mediaTypes.stream()</span>
<span class="fc" id="L594">								.anyMatch(acceptedMediaType::isCompatibleWith));</span>
<span class="fc" id="L595">				traceMatch(&quot;Accept&quot;, mediaTypes, acceptedMediaTypes, match);</span>
<span class="fc" id="L596">				return match;</span>
			});
<span class="fc" id="L598">			this.mediaTypes = mediaTypes;</span>
<span class="fc" id="L599">		}</span>

		@NonNull
		private static List&lt;MediaType&gt; acceptedMediaTypes(ServerRequest.Headers headers) {
<span class="fc" id="L603">			List&lt;MediaType&gt; acceptedMediaTypes = headers.accept();</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">			if (acceptedMediaTypes.isEmpty()) {</span>
<span class="fc" id="L605">				acceptedMediaTypes = Collections.singletonList(MediaType.ALL);</span>
			}
			else {
<span class="fc" id="L608">				MediaType.sortBySpecificityAndQuality(acceptedMediaTypes);</span>
			}
<span class="fc" id="L610">			return acceptedMediaTypes;</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L615">			visitor.header(HttpHeaders.ACCEPT,</span>
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">					(this.mediaTypes.size() == 1) ?</span>
<span class="pc" id="L617">							this.mediaTypes.iterator().next().toString() :</span>
<span class="nc" id="L618">							this.mediaTypes.toString());</span>
<span class="fc" id="L619">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L623">			return String.format(&quot;Accept: %s&quot;,</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">					(this.mediaTypes.size() == 1) ?</span>
<span class="nc" id="L625">							this.mediaTypes.iterator().next().toString() :</span>
<span class="nc" id="L626">							this.mediaTypes.toString());</span>
		}
	}


	private static class PathExtensionPredicate implements RequestPredicate {

		private final Predicate&lt;String&gt; extensionPredicate;

		@Nullable
		private final String extension;

<span class="nc" id="L638">		public PathExtensionPredicate(Predicate&lt;String&gt; extensionPredicate) {</span>
<span class="nc" id="L639">			Assert.notNull(extensionPredicate, &quot;Predicate must not be null&quot;);</span>
<span class="nc" id="L640">			this.extensionPredicate = extensionPredicate;</span>
<span class="nc" id="L641">			this.extension = null;</span>
<span class="nc" id="L642">		}</span>

<span class="fc" id="L644">		public PathExtensionPredicate(String extension) {</span>
<span class="fc" id="L645">			Assert.notNull(extension, &quot;Extension must not be null&quot;);</span>

<span class="fc" id="L647">			this.extensionPredicate = s -&gt; {</span>
<span class="fc" id="L648">				boolean match = extension.equalsIgnoreCase(s);</span>
<span class="fc" id="L649">				traceMatch(&quot;Extension&quot;, extension, s, match);</span>
<span class="fc" id="L650">				return match;</span>
			};
<span class="fc" id="L652">			this.extension = extension;</span>
<span class="fc" id="L653">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L657">			String pathExtension = UriUtils.extractFileExtension(request.path());</span>
<span class="fc" id="L658">			return this.extensionPredicate.test(pathExtension);</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">			visitor.pathExtension(</span>
					(this.extension != null) ?
							this.extension :
<span class="nc" id="L666">							this.extensionPredicate.toString());</span>
<span class="fc" id="L667">		}</span>

		@Override
		public String toString() {
<span class="nc bnc" id="L671" title="All 2 branches missed.">			return String.format(&quot;*.%s&quot;,</span>
					(this.extension != null) ?
							this.extension :
							this.extensionPredicate);
		}

	}


	private static class QueryParamPredicate implements RequestPredicate {

		private final String name;

		private final Predicate&lt;String&gt; valuePredicate;

		@Nullable
		private final String value;

<span class="fc" id="L689">		public QueryParamPredicate(String name, Predicate&lt;String&gt; valuePredicate) {</span>
<span class="fc" id="L690">			Assert.notNull(name, &quot;Name must not be null&quot;);</span>
<span class="fc" id="L691">			Assert.notNull(valuePredicate, &quot;Predicate must not be null&quot;);</span>
<span class="fc" id="L692">			this.name = name;</span>
<span class="fc" id="L693">			this.valuePredicate = valuePredicate;</span>
<span class="fc" id="L694">			this.value = null;</span>
<span class="fc" id="L695">		}</span>

<span class="fc" id="L697">		public QueryParamPredicate(String name, String value) {</span>
<span class="fc" id="L698">			Assert.notNull(name, &quot;Name must not be null&quot;);</span>
<span class="fc" id="L699">			Assert.notNull(value, &quot;Value must not be null&quot;);</span>
<span class="fc" id="L700">			this.name = name;</span>
<span class="fc" id="L701">			this.valuePredicate = value::equals;</span>
<span class="fc" id="L702">			this.value = value;</span>
<span class="fc" id="L703">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L707">			Optional&lt;String&gt; s = request.queryParam(this.name);</span>
<span class="fc" id="L708">			return s.filter(this.valuePredicate).isPresent();</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">			visitor.queryParam(this.name,</span>
					(this.value != null) ?
							this.value :
<span class="nc" id="L716">							this.valuePredicate.toString());</span>
<span class="fc" id="L717">		}</span>

		@Override
		public String toString() {
<span class="nc bnc" id="L721" title="All 2 branches missed.">			return String.format(&quot;?%s %s&quot;, this.name,</span>
					(this.value != null) ?
							this.value :
							this.valuePredicate);
		}
	}


	/**
	 * {@link RequestPredicate} for where both {@code left} and {@code right} predicates
	 * must match.
	 */
	static class AndRequestPredicate implements RequestPredicate {

		private final RequestPredicate left;

		private final RequestPredicate right;

<span class="fc" id="L739">		public AndRequestPredicate(RequestPredicate left, RequestPredicate right) {</span>
<span class="fc" id="L740">			Assert.notNull(left, &quot;Left RequestPredicate must not be null&quot;);</span>
<span class="fc" id="L741">			Assert.notNull(right, &quot;Right RequestPredicate must not be null&quot;);</span>
<span class="fc" id="L742">			this.left = left;</span>
<span class="fc" id="L743">			this.right = right;</span>
<span class="fc" id="L744">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L748">			Map&lt;String, Object&gt; oldAttributes = new HashMap&lt;&gt;(request.attributes());</span>

<span class="fc bfc" id="L750" title="All 4 branches covered.">			if (this.left.test(request) &amp;&amp; this.right.test(request)) {</span>
<span class="fc" id="L751">				return true;</span>
			}
<span class="fc" id="L753">			restoreAttributes(request, oldAttributes);</span>
<span class="fc" id="L754">			return false;</span>
		}

		@Override
		public Optional&lt;ServerRequest&gt; nest(ServerRequest request) {
<span class="fc" id="L759">			return this.left.nest(request).flatMap(this.right::nest);</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L764">			visitor.startAnd();</span>
<span class="fc" id="L765">			this.left.accept(visitor);</span>
<span class="fc" id="L766">			visitor.and();</span>
<span class="fc" id="L767">			this.right.accept(visitor);</span>
<span class="fc" id="L768">			visitor.endAnd();</span>
<span class="fc" id="L769">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L773">			return String.format(&quot;(%s &amp;&amp; %s)&quot;, this.left, this.right);</span>
		}
	}

	/**
	 * {@link RequestPredicate} that negates a delegate predicate.
	 */
	static class NegateRequestPredicate implements RequestPredicate {
		private final RequestPredicate delegate;

<span class="fc" id="L783">		public NegateRequestPredicate(RequestPredicate delegate) {</span>
<span class="fc" id="L784">			Assert.notNull(delegate, &quot;Delegate must not be null&quot;);</span>
<span class="fc" id="L785">			this.delegate = delegate;</span>
<span class="fc" id="L786">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L790">			Map&lt;String, Object&gt; oldAttributes = new HashMap&lt;&gt;(request.attributes());</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">			boolean result = !this.delegate.test(request);</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">			if (!result) {</span>
<span class="fc" id="L793">				restoreAttributes(request, oldAttributes);</span>
			}
<span class="fc" id="L795">			return result;</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L800">			visitor.startNegate();</span>
<span class="fc" id="L801">			this.delegate.accept(visitor);</span>
<span class="fc" id="L802">			visitor.endNegate();</span>
<span class="fc" id="L803">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L807">			return &quot;!&quot; + this.delegate.toString();</span>
		}
	}

	/**
	 * {@link RequestPredicate} where either {@code left} or {@code right} predicates
	 * may match.
	 */
	static class OrRequestPredicate implements RequestPredicate {

		private final RequestPredicate left;

		private final RequestPredicate right;

<span class="fc" id="L821">		public OrRequestPredicate(RequestPredicate left, RequestPredicate right) {</span>
<span class="fc" id="L822">			Assert.notNull(left, &quot;Left RequestPredicate must not be null&quot;);</span>
<span class="fc" id="L823">			Assert.notNull(right, &quot;Right RequestPredicate must not be null&quot;);</span>
<span class="fc" id="L824">			this.left = left;</span>
<span class="fc" id="L825">			this.right = right;</span>
<span class="fc" id="L826">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L830">			Map&lt;String, Object&gt; oldAttributes = new HashMap&lt;&gt;(request.attributes());</span>

<span class="fc bfc" id="L832" title="All 2 branches covered.">			if (this.left.test(request)) {</span>
<span class="fc" id="L833">				return true;</span>
			}
			else {
<span class="fc" id="L836">				restoreAttributes(request, oldAttributes);</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">				if (this.right.test(request)) {</span>
<span class="fc" id="L838">					return true;</span>
				}
			}
<span class="fc" id="L841">			restoreAttributes(request, oldAttributes);</span>
<span class="fc" id="L842">			return false;</span>
		}

		@Override
		public Optional&lt;ServerRequest&gt; nest(ServerRequest request) {
<span class="nc" id="L847">			Optional&lt;ServerRequest&gt; leftResult = this.left.nest(request);</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">			if (leftResult.isPresent()) {</span>
<span class="nc" id="L849">				return leftResult;</span>
			}
			else {
<span class="nc" id="L852">				return this.right.nest(request);</span>
			}
		}

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L858">			visitor.startOr();</span>
<span class="fc" id="L859">			this.left.accept(visitor);</span>
<span class="fc" id="L860">			visitor.or();</span>
<span class="fc" id="L861">			this.right.accept(visitor);</span>
<span class="fc" id="L862">			visitor.endOr();</span>
<span class="fc" id="L863">		}</span>


		@Override
		public String toString() {
<span class="nc" id="L868">			return String.format(&quot;(%s || %s)&quot;, this.left, this.right);</span>
		}
	}


	private static class SubPathServerRequestWrapper implements ServerRequest {

		private final ServerRequest request;

		private final PathContainer pathContainer;

		private final Map&lt;String, Object&gt; attributes;

		public SubPathServerRequestWrapper(ServerRequest request,
<span class="fc" id="L882">				PathPattern.PathRemainingMatchInfo info, PathPattern pattern) {</span>
<span class="fc" id="L883">			this.request = request;</span>
<span class="fc" id="L884">			this.pathContainer = new SubPathContainer(info.getPathRemaining());</span>
<span class="fc" id="L885">			this.attributes = mergeAttributes(request, info.getUriVariables(), pattern);</span>
<span class="fc" id="L886">		}</span>

		private static Map&lt;String, Object&gt; mergeAttributes(ServerRequest request,
		Map&lt;String, String&gt; pathVariables, PathPattern pattern) {
<span class="fc" id="L890">			Map&lt;String, Object&gt; result = new ConcurrentHashMap&lt;&gt;(request.attributes());</span>

<span class="fc" id="L892">			result.put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE,</span>
<span class="fc" id="L893">					mergePathVariables(request.pathVariables(), pathVariables));</span>

<span class="fc" id="L895">			pattern = mergePatterns(</span>
<span class="fc" id="L896">					(PathPattern) request.attributes().get(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE),</span>
					pattern);
<span class="fc" id="L898">			result.put(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE, pattern);</span>
<span class="fc" id="L899">			return result;</span>
		}

		@Override
		public HttpMethod method() {
<span class="fc" id="L904">			return this.request.method();</span>
		}

		@Override
		public String methodName() {
<span class="nc" id="L909">			return this.request.methodName();</span>
		}

		@Override
		public URI uri() {
<span class="nc" id="L914">			return this.request.uri();</span>
		}

		@Override
		public UriBuilder uriBuilder() {
<span class="nc" id="L919">			return this.request.uriBuilder();</span>
		}

		@Override
		public String path() {
<span class="fc" id="L924">			return this.pathContainer.value();</span>
		}

		@Override
		public PathContainer pathContainer() {
<span class="fc" id="L929">			return this.pathContainer;</span>
		}

		@Override
		public Headers headers() {
<span class="fc" id="L934">			return this.request.headers();</span>
		}

		@Override
		public MultiValueMap&lt;String, HttpCookie&gt; cookies() {
<span class="nc" id="L939">			return this.request.cookies();</span>
		}

		@Override
		public Optional&lt;InetSocketAddress&gt; remoteAddress() {
<span class="nc" id="L944">			return this.request.remoteAddress();</span>
		}

		@Override
		public List&lt;HttpMessageReader&lt;?&gt;&gt; messageReaders() {
<span class="nc" id="L949">			return this.request.messageReaders();</span>
		}

		@Override
		public &lt;T&gt; T body(BodyExtractor&lt;T, ? super ServerHttpRequest&gt; extractor) {
<span class="nc" id="L954">			return this.request.body(extractor);</span>
		}

		@Override
		public &lt;T&gt; T body(BodyExtractor&lt;T, ? super ServerHttpRequest&gt; extractor, Map&lt;String, Object&gt; hints) {
<span class="nc" id="L959">			return this.request.body(extractor, hints);</span>
		}

		@Override
		public &lt;T&gt; Mono&lt;T&gt; bodyToMono(Class&lt;? extends T&gt; elementClass) {
<span class="nc" id="L964">			return this.request.bodyToMono(elementClass);</span>
		}

		@Override
		public &lt;T&gt; Mono&lt;T&gt; bodyToMono(ParameterizedTypeReference&lt;T&gt; typeReference) {
<span class="nc" id="L969">			return this.request.bodyToMono(typeReference);</span>
		}

		@Override
		public &lt;T&gt; Flux&lt;T&gt; bodyToFlux(Class&lt;? extends T&gt; elementClass) {
<span class="nc" id="L974">			return this.request.bodyToFlux(elementClass);</span>
		}

		@Override
		public &lt;T&gt; Flux&lt;T&gt; bodyToFlux(ParameterizedTypeReference&lt;T&gt; typeReference) {
<span class="nc" id="L979">			return this.request.bodyToFlux(typeReference);</span>
		}

		@Override
		public Map&lt;String, Object&gt; attributes() {
<span class="fc" id="L984">			return this.attributes;</span>
		}

		@Override
		public Optional&lt;String&gt; queryParam(String name) {
<span class="nc" id="L989">			return this.request.queryParam(name);</span>
		}

		@Override
		public MultiValueMap&lt;String, String&gt; queryParams() {
<span class="nc" id="L994">			return this.request.queryParams();</span>
		}

		@Override
		@SuppressWarnings(&quot;unchecked&quot;)
		public Map&lt;String, String&gt; pathVariables() {
<span class="fc" id="L1000">			return (Map&lt;String, String&gt;) this.attributes.getOrDefault(</span>
<span class="fc" id="L1001">					RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap());</span>

		}

		@Override
		public Mono&lt;WebSession&gt; session() {
<span class="nc" id="L1007">			return this.request.session();</span>
		}

		@Override
		public Mono&lt;? extends Principal&gt; principal() {
<span class="nc" id="L1012">			return this.request.principal();</span>
		}

		@Override
		public Mono&lt;MultiValueMap&lt;String, String&gt;&gt; formData() {
<span class="nc" id="L1017">			return this.request.formData();</span>
		}

		@Override
		public Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; multipartData() {
<span class="nc" id="L1022">			return this.request.multipartData();</span>
		}

		@Override
		public ServerWebExchange exchange() {
<span class="nc" id="L1027">			return this.request.exchange();</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L1032">			return method() + &quot; &quot; +  path();</span>
		}

		private static class SubPathContainer implements PathContainer {

<span class="pc" id="L1037">			private static final PathContainer.Separator SEPARATOR = () -&gt; &quot;/&quot;;</span>


			private final String value;

			private final List&lt;Element&gt; elements;

<span class="fc" id="L1044">			public SubPathContainer(PathContainer original) {</span>
<span class="fc" id="L1045">				this.value = prefixWithSlash(original.value());</span>
<span class="fc" id="L1046">				this.elements = prependWithSeparator(original.elements());</span>
<span class="fc" id="L1047">			}</span>

			private static String prefixWithSlash(String path) {
<span class="fc bfc" id="L1050" title="All 2 branches covered.">				if (!path.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L1051">					path = &quot;/&quot; + path;</span>
				}
<span class="fc" id="L1053">				return path;</span>
			}

			private static List&lt;Element&gt; prependWithSeparator(List&lt;Element&gt; elements) {
<span class="fc" id="L1057">				List&lt;Element&gt; result = new ArrayList&lt;&gt;(elements);</span>
<span class="fc bfc" id="L1058" title="All 4 branches covered.">				if (result.isEmpty() || !(result.get(0) instanceof Separator)) {</span>
<span class="fc" id="L1059">					result.add(0, SEPARATOR);</span>
				}
<span class="fc" id="L1061">				return Collections.unmodifiableList(result);</span>
			}


			@Override
			public String value() {
<span class="fc" id="L1067">				return this.value;</span>
			}

			@Override
			public List&lt;Element&gt; elements() {
<span class="fc" id="L1072">				return this.elements;</span>
			}
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>