<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Jaxb2Marshaller.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-oxm</a> &gt; <a href="index.source.html" class="el_package">org.springframework.oxm.jaxb</a> &gt; <span class="el_source">Jaxb2Marshaller.java</span></div><h1>Jaxb2Marshaller.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.oxm.jaxb;

import java.awt.Image;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.Map;
import java.util.UUID;
import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.xml.XMLConstants;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.MarshalException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.UnmarshalException;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.ValidationEventHandler;
import javax.xml.bind.ValidationException;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.adapters.XmlAdapter;
import javax.xml.bind.attachment.AttachmentMarshaller;
import javax.xml.bind.attachment.AttachmentUnmarshaller;
import javax.xml.datatype.Duration;
import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.namespace.QName;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLEventWriter;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stax.StAXSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.w3c.dom.ls.LSResourceResolver;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;

import org.springframework.beans.factory.BeanClassLoaderAware;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.core.io.Resource;
import org.springframework.lang.Nullable;
import org.springframework.oxm.GenericMarshaller;
import org.springframework.oxm.GenericUnmarshaller;
import org.springframework.oxm.MarshallingFailureException;
import org.springframework.oxm.UncategorizedMappingException;
import org.springframework.oxm.UnmarshallingFailureException;
import org.springframework.oxm.ValidationFailureException;
import org.springframework.oxm.XmlMappingException;
import org.springframework.oxm.mime.MimeContainer;
import org.springframework.oxm.mime.MimeMarshaller;
import org.springframework.oxm.mime.MimeUnmarshaller;
import org.springframework.oxm.support.SaxResourceUtils;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.FileCopyUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;
import org.springframework.util.xml.StaxUtils;

/**
 * Implementation of the {@code GenericMarshaller} interface for JAXB 2.2.
 *
 * &lt;p&gt;The typical usage will be to set either the &quot;contextPath&quot; or the &quot;classesToBeBound&quot;
 * property on this bean, possibly customize the marshaller and unmarshaller by setting
 * properties, schemas, adapters, and listeners, and to refer to it.
 *
 * @author Arjen Poutsma
 * @author Juergen Hoeller
 * @author Rossen Stoyanchev
 * @since 3.0
 * @see #setContextPath(String)
 * @see #setClassesToBeBound(Class[])
 * @see #setJaxbContextProperties(Map)
 * @see #setMarshallerProperties(Map)
 * @see #setUnmarshallerProperties(Map)
 * @see #setSchema(Resource)
 * @see #setSchemas(Resource[])
 * @see #setMarshallerListener(javax.xml.bind.Marshaller.Listener)
 * @see #setUnmarshallerListener(javax.xml.bind.Unmarshaller.Listener)
 * @see #setAdapters(XmlAdapter[])
 */
<span class="fc" id="L125">public class Jaxb2Marshaller implements MimeMarshaller, MimeUnmarshaller, GenericMarshaller, GenericUnmarshaller,</span>
		BeanClassLoaderAware, InitializingBean {

	private static final String CID = &quot;cid:&quot;;

<span class="fc" id="L130">	private static final EntityResolver NO_OP_ENTITY_RESOLVER =</span>
<span class="nc" id="L131">			(publicId, systemId) -&gt; new InputSource(new StringReader(&quot;&quot;));</span>


	/** Logger available to subclasses. */
<span class="fc" id="L135">	protected final Log logger = LogFactory.getLog(getClass());</span>

	@Nullable
	private String contextPath;

	@Nullable
	private Class&lt;?&gt;[] classesToBeBound;

	@Nullable
	private String[] packagesToScan;

	@Nullable
	private Map&lt;String, ?&gt; jaxbContextProperties;

	@Nullable
	private Map&lt;String, ?&gt; marshallerProperties;

	@Nullable
	private Map&lt;String, ?&gt; unmarshallerProperties;

	@Nullable
	private Marshaller.Listener marshallerListener;

	@Nullable
	private Unmarshaller.Listener unmarshallerListener;

	@Nullable
	private ValidationEventHandler validationEventHandler;

	@Nullable
	private XmlAdapter&lt;?, ?&gt;[] adapters;

	@Nullable
	private Resource[] schemaResources;

<span class="fc" id="L170">	private String schemaLanguage = XMLConstants.W3C_XML_SCHEMA_NS_URI;</span>

	@Nullable
	private LSResourceResolver schemaResourceResolver;

<span class="fc" id="L175">	private boolean lazyInit = false;</span>

<span class="fc" id="L177">	private boolean mtomEnabled = false;</span>

<span class="fc" id="L179">	private boolean supportJaxbElementClass = false;</span>

<span class="fc" id="L181">	private boolean checkForXmlRootElement = true;</span>

	@Nullable
	private Class&lt;?&gt; mappedClass;

	@Nullable
	private ClassLoader beanClassLoader;

<span class="fc" id="L189">	private final Object jaxbContextMonitor = new Object();</span>

	@Nullable
	private volatile JAXBContext jaxbContext;

	@Nullable
	private Schema schema;

<span class="fc" id="L197">	private boolean supportDtd = false;</span>

<span class="fc" id="L199">	private boolean processExternalEntities = false;</span>


	/**
	 * Set multiple JAXB context paths. The given array of context paths gets
	 * converted to a colon-delimited string, as supported by JAXB.
	 */
	public void setContextPaths(String... contextPaths) {
<span class="nc" id="L207">		Assert.notEmpty(contextPaths, &quot;'contextPaths' must not be empty&quot;);</span>
<span class="nc" id="L208">		this.contextPath = StringUtils.arrayToDelimitedString(contextPaths, &quot;:&quot;);</span>
<span class="nc" id="L209">	}</span>

	/**
	 * Set a JAXB context path.
	 * &lt;p&gt;Setting either this property, {@link #setClassesToBeBound &quot;classesToBeBound&quot;}
	 * or {@link #setPackagesToScan &quot;packagesToScan&quot;} is required.
	 */
	public void setContextPath(@Nullable String contextPath) {
<span class="fc" id="L217">		this.contextPath = contextPath;</span>
<span class="fc" id="L218">	}</span>

	/**
	 * Return the JAXB context path.
	 */
	@Nullable
	public String getContextPath() {
<span class="nc" id="L225">		return this.contextPath;</span>
	}

	/**
	 * Set the list of Java classes to be recognized by a newly created JAXBContext.
	 * &lt;p&gt;Setting either this property, {@link #setContextPath &quot;contextPath&quot;}
	 * or {@link #setPackagesToScan &quot;packagesToScan&quot;} is required.
	 */
	public void setClassesToBeBound(@Nullable Class&lt;?&gt;... classesToBeBound) {
<span class="fc" id="L234">		this.classesToBeBound = classesToBeBound;</span>
<span class="fc" id="L235">	}</span>

	/**
	 * Return the list of Java classes to be recognized by a newly created JAXBContext.
	 */
	@Nullable
	public Class&lt;?&gt;[] getClassesToBeBound() {
<span class="nc" id="L242">		return this.classesToBeBound;</span>
	}

	/**
	 * Set the packages to search for classes with JAXB2 annotations in the classpath.
	 * This is using a Spring-bases search and therefore analogous to Spring's component-scan
	 * feature ({@link org.springframework.context.annotation.ClassPathBeanDefinitionScanner}).
	 * &lt;p&gt;Setting either this property, {@link #setContextPath &quot;contextPath&quot;}
	 * or {@link #setClassesToBeBound &quot;classesToBeBound&quot;} is required.
	 */
	public void setPackagesToScan(@Nullable String... packagesToScan) {
<span class="fc" id="L253">		this.packagesToScan = packagesToScan;</span>
<span class="fc" id="L254">	}</span>

	/**
	 * Return the packages to search for JAXB2 annotations.
	 */
	@Nullable
	public String[] getPackagesToScan() {
<span class="nc" id="L261">		return this.packagesToScan;</span>
	}

	/**
	 * Set the {@code JAXBContext} properties. These implementation-specific
	 * properties will be set on the underlying {@code JAXBContext}.
	 */
	public void setJaxbContextProperties(Map&lt;String, ?&gt; jaxbContextProperties) {
<span class="nc" id="L269">		this.jaxbContextProperties = jaxbContextProperties;</span>
<span class="nc" id="L270">	}</span>

	/**
	 * Set the JAXB {@code Marshaller} properties. These properties will be set on the
	 * underlying JAXB {@code Marshaller}, and allow for features such as indentation.
	 * @param properties the properties
	 * @see javax.xml.bind.Marshaller#setProperty(String, Object)
	 * @see javax.xml.bind.Marshaller#JAXB_ENCODING
	 * @see javax.xml.bind.Marshaller#JAXB_FORMATTED_OUTPUT
	 * @see javax.xml.bind.Marshaller#JAXB_NO_NAMESPACE_SCHEMA_LOCATION
	 * @see javax.xml.bind.Marshaller#JAXB_SCHEMA_LOCATION
	 */
	public void setMarshallerProperties(Map&lt;String, ?&gt; properties) {
<span class="fc" id="L283">		this.marshallerProperties = properties;</span>
<span class="fc" id="L284">	}</span>

	/**
	 * Set the JAXB {@code Unmarshaller} properties. These properties will be set on the
	 * underlying JAXB {@code Unmarshaller}.
	 * @param properties the properties
	 * @see javax.xml.bind.Unmarshaller#setProperty(String, Object)
	 */
	public void setUnmarshallerProperties(Map&lt;String, ?&gt; properties) {
<span class="nc" id="L293">		this.unmarshallerProperties = properties;</span>
<span class="nc" id="L294">	}</span>

	/**
	 * Specify the {@code Marshaller.Listener} to be registered with the JAXB {@code Marshaller}.
	 */
	public void setMarshallerListener(Marshaller.Listener marshallerListener) {
<span class="nc" id="L300">		this.marshallerListener = marshallerListener;</span>
<span class="nc" id="L301">	}</span>

	/**
	 * Set the {@code Unmarshaller.Listener} to be registered with the JAXB {@code Unmarshaller}.
	 */
	public void setUnmarshallerListener(Unmarshaller.Listener unmarshallerListener) {
<span class="nc" id="L307">		this.unmarshallerListener = unmarshallerListener;</span>
<span class="nc" id="L308">	}</span>

	/**
	 * Set the JAXB validation event handler. This event handler will be called by JAXB
	 * if any validation errors are encountered during calls to any of the marshal APIs.
	 */
	public void setValidationEventHandler(ValidationEventHandler validationEventHandler) {
<span class="nc" id="L315">		this.validationEventHandler = validationEventHandler;</span>
<span class="nc" id="L316">	}</span>

	/**
	 * Specify the {@code XmlAdapter}s to be registered with the JAXB {@code Marshaller}
	 * and {@code Unmarshaller}.
	 */
	public void setAdapters(XmlAdapter&lt;?, ?&gt;... adapters) {
<span class="nc" id="L323">		this.adapters = adapters;</span>
<span class="nc" id="L324">	}</span>

	/**
	 * Set the schema resource to use for validation.
	 */
	public void setSchema(Resource schemaResource) {
<span class="fc" id="L330">		this.schemaResources = new Resource[] {schemaResource};</span>
<span class="fc" id="L331">	}</span>

	/**
	 * Set the schema resources to use for validation.
	 */
	public void setSchemas(Resource... schemaResources) {
<span class="nc" id="L337">		this.schemaResources = schemaResources;</span>
<span class="nc" id="L338">	}</span>

	/**
	 * Set the schema language. Default is the W3C XML Schema: {@code http://www.w3.org/2001/XMLSchema&quot;}.
	 * @see XMLConstants#W3C_XML_SCHEMA_NS_URI
	 * @see XMLConstants#RELAXNG_NS_URI
	 */
	public void setSchemaLanguage(String schemaLanguage) {
<span class="nc" id="L346">		this.schemaLanguage = schemaLanguage;</span>
<span class="nc" id="L347">	}</span>

	/**
	 * Set the resource resolver, as used to load the schema resources.
	 * @see SchemaFactory#setResourceResolver(org.w3c.dom.ls.LSResourceResolver)
	 * @see #setSchema(Resource)
	 * @see #setSchemas(Resource[])
	 */
	public void setSchemaResourceResolver(LSResourceResolver schemaResourceResolver) {
<span class="nc" id="L356">		this.schemaResourceResolver = schemaResourceResolver;</span>
<span class="nc" id="L357">	}</span>

	/**
	 * Set whether to lazily initialize the {@link JAXBContext} for this marshaller.
	 * Default is {@code false} to initialize on startup; can be switched to {@code true}.
	 * &lt;p&gt;Early initialization just applies if {@link #afterPropertiesSet()} is called.
	 */
	public void setLazyInit(boolean lazyInit) {
<span class="fc" id="L365">		this.lazyInit = lazyInit;</span>
<span class="fc" id="L366">	}</span>

	/**
	 * Specify whether MTOM support should be enabled or not.
	 * Default is {@code false}: marshalling using XOP/MTOM not being enabled.
	 */
	public void setMtomEnabled(boolean mtomEnabled) {
<span class="fc" id="L373">		this.mtomEnabled = mtomEnabled;</span>
<span class="fc" id="L374">	}</span>

	/**
	 * Specify whether the {@link #supports(Class)} returns {@code true} for the {@link JAXBElement} class.
	 * &lt;p&gt;Default is {@code false}, meaning that {@code supports(Class)} always returns {@code false} for
	 * {@code JAXBElement} classes (though {@link #supports(Type)} can return {@code true}, since it can
	 * obtain the type parameters of {@code JAXBElement}).
	 * &lt;p&gt;This property is typically enabled in combination with usage of classes like
	 * {@link org.springframework.web.servlet.view.xml.MarshallingView MarshallingView},
	 * since the {@code ModelAndView} does not offer type parameter information at runtime.
	 * @see #supports(Class)
	 * @see #supports(Type)
	 */
	public void setSupportJaxbElementClass(boolean supportJaxbElementClass) {
<span class="fc" id="L388">		this.supportJaxbElementClass = supportJaxbElementClass;</span>
<span class="fc" id="L389">	}</span>

	/**
	 * Specify whether the {@link #supports(Class)} should check for
	 * {@link XmlRootElement @XmlRootElement} annotations.
	 * &lt;p&gt;Default is {@code true}, meaning that {@code supports(Class)} will check for
	 * this annotation. However, some JAXB implementations (i.e. EclipseLink MOXy) allow
	 * for defining the bindings in an external definition file, thus keeping the classes
	 * annotations free. Setting this property to {@code false} supports these
	 * JAXB implementations.
	 * @see #supports(Class)
	 * @see #supports(Type)
	 */
	public void setCheckForXmlRootElement(boolean checkForXmlRootElement) {
<span class="nc" id="L403">		this.checkForXmlRootElement = checkForXmlRootElement;</span>
<span class="nc" id="L404">	}</span>

	/**
	 * Specify a JAXB mapped class for partial unmarshalling.
	 * @see javax.xml.bind.Unmarshaller#unmarshal(javax.xml.transform.Source, Class)
	 */
	public void setMappedClass(Class&lt;?&gt; mappedClass) {
<span class="nc" id="L411">		this.mappedClass = mappedClass;</span>
<span class="nc" id="L412">	}</span>

	/**
	 * Indicates whether DTD parsing should be supported.
	 * &lt;p&gt;Default is {@code false} meaning that DTD is disabled.
	 */
	public void setSupportDtd(boolean supportDtd) {
<span class="fc" id="L419">		this.supportDtd = supportDtd;</span>
<span class="fc" id="L420">	}</span>

	/**
	 * Whether DTD parsing is supported.
	 */
	public boolean isSupportDtd() {
<span class="fc" id="L426">		return this.supportDtd;</span>
	}

	/**
	 * Indicates whether external XML entities are processed when unmarshalling.
	 * &lt;p&gt;Default is {@code false}, meaning that external entities are not resolved.
	 * Note that processing of external entities will only be enabled/disabled when the
	 * {@code Source} passed to {@link #unmarshal(Source)} is a {@link SAXSource} or
	 * {@link StreamSource}. It has no effect for {@link DOMSource} or {@link StAXSource}
	 * instances.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; setting this option to {@code true} also
	 * automatically sets {@link #setSupportDtd} to {@code true}.
	 */
	public void setProcessExternalEntities(boolean processExternalEntities) {
<span class="fc" id="L440">		this.processExternalEntities = processExternalEntities;</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">		if (processExternalEntities) {</span>
<span class="fc" id="L442">			setSupportDtd(true);</span>
		}
<span class="fc" id="L444">	}</span>

	/**
	 * Returns the configured value for whether XML external entities are allowed.
	 */
	public boolean isProcessExternalEntities() {
<span class="fc" id="L450">		return this.processExternalEntities;</span>
	}


	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
<span class="fc" id="L456">		this.beanClassLoader = classLoader;</span>
<span class="fc" id="L457">	}</span>


	@Override
	public void afterPropertiesSet() throws Exception {
<span class="fc" id="L462">		boolean hasContextPath = StringUtils.hasLength(this.contextPath);</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">		boolean hasClassesToBeBound = !ObjectUtils.isEmpty(this.classesToBeBound);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">		boolean hasPackagesToScan = !ObjectUtils.isEmpty(this.packagesToScan);</span>

<span class="pc bpc" id="L466" title="3 of 10 branches missed.">		if (hasContextPath &amp;&amp; (hasClassesToBeBound || hasPackagesToScan) ||</span>
				(hasClassesToBeBound &amp;&amp; hasPackagesToScan)) {
<span class="nc" id="L468">			throw new IllegalArgumentException(&quot;Specify either 'contextPath', 'classesToBeBound', &quot; +</span>
					&quot;or 'packagesToScan'&quot;);
		}
<span class="fc bfc" id="L471" title="All 6 branches covered.">		if (!hasContextPath &amp;&amp; !hasClassesToBeBound &amp;&amp; !hasPackagesToScan) {</span>
<span class="fc" id="L472">			throw new IllegalArgumentException(</span>
					&quot;Setting either 'contextPath', 'classesToBeBound', &quot; + &quot;or 'packagesToScan' is required&quot;);
		}
<span class="fc bfc" id="L475" title="All 2 branches covered.">		if (!this.lazyInit) {</span>
<span class="fc" id="L476">			getJaxbContext();</span>
		}
<span class="fc bfc" id="L478" title="All 2 branches covered.">		if (!ObjectUtils.isEmpty(this.schemaResources)) {</span>
<span class="fc" id="L479">			this.schema = loadSchema(this.schemaResources, this.schemaLanguage);</span>
		}
<span class="fc" id="L481">	}</span>

	/**
	 * Return the JAXBContext used by this marshaller, lazily building it if necessary.
	 */
	public JAXBContext getJaxbContext() {
<span class="fc" id="L487">		JAXBContext context = this.jaxbContext;</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">		if (context != null) {</span>
<span class="fc" id="L489">			return context;</span>
		}
<span class="fc" id="L491">		synchronized (this.jaxbContextMonitor) {</span>
<span class="fc" id="L492">			context = this.jaxbContext;</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">			if (context == null) {</span>
				try {
<span class="fc bfc" id="L495" title="All 2 branches covered.">					if (StringUtils.hasLength(this.contextPath)) {</span>
<span class="fc" id="L496">						context = createJaxbContextFromContextPath(this.contextPath);</span>
					}
<span class="fc bfc" id="L498" title="All 2 branches covered.">					else if (!ObjectUtils.isEmpty(this.classesToBeBound)) {</span>
<span class="fc" id="L499">						context = createJaxbContextFromClasses(this.classesToBeBound);</span>
					}
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">					else if (!ObjectUtils.isEmpty(this.packagesToScan)) {</span>
<span class="fc" id="L502">						context = createJaxbContextFromPackages(this.packagesToScan);</span>
					}
					else {
<span class="nc" id="L505">						context = JAXBContext.newInstance();</span>
					}
<span class="fc" id="L507">					this.jaxbContext = context;</span>
				}
<span class="fc" id="L509">				catch (JAXBException ex) {</span>
<span class="fc" id="L510">					throw convertJaxbException(ex);</span>
<span class="fc" id="L511">				}</span>
			}
<span class="fc" id="L513">			return context;</span>
		}
	}

	private JAXBContext createJaxbContextFromContextPath(String contextPath) throws JAXBException {
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L519">			logger.debug(&quot;Creating JAXBContext with context path [&quot; + this.contextPath + &quot;]&quot;);</span>
		}
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">		if (this.jaxbContextProperties != null) {</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">			if (this.beanClassLoader != null) {</span>
<span class="nc" id="L523">				return JAXBContext.newInstance(contextPath, this.beanClassLoader, this.jaxbContextProperties);</span>
			}
			else {
				// analogous to the JAXBContext.newInstance(String) implementation
<span class="nc" id="L527">				return JAXBContext.newInstance(contextPath, Thread.currentThread().getContextClassLoader(),</span>
						this.jaxbContextProperties);
			}
		}
		else {
<span class="fc bfc" id="L532" title="All 2 branches covered.">			if (this.beanClassLoader != null) {</span>
<span class="fc" id="L533">				return JAXBContext.newInstance(contextPath, this.beanClassLoader);</span>
			}
			else {
<span class="fc" id="L536">				return JAXBContext.newInstance(contextPath);</span>
			}
		}
	}

	private JAXBContext createJaxbContextFromClasses(Class&lt;?&gt;... classesToBeBound) throws JAXBException {
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L543">			logger.debug(&quot;Creating JAXBContext with classes to be bound [&quot; +</span>
<span class="nc" id="L544">					StringUtils.arrayToCommaDelimitedString(classesToBeBound) + &quot;]&quot;);</span>
		}
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">		if (this.jaxbContextProperties != null) {</span>
<span class="nc" id="L547">			return JAXBContext.newInstance(classesToBeBound, this.jaxbContextProperties);</span>
		}
		else {
<span class="fc" id="L550">			return JAXBContext.newInstance(classesToBeBound);</span>
		}
	}

	private JAXBContext createJaxbContextFromPackages(String... packagesToScan) throws JAXBException {
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L556">			logger.debug(&quot;Creating JAXBContext by scanning packages [&quot; +</span>
<span class="nc" id="L557">					StringUtils.arrayToCommaDelimitedString(packagesToScan) + &quot;]&quot;);</span>
		}
<span class="fc" id="L559">		ClassPathJaxb2TypeScanner scanner = new ClassPathJaxb2TypeScanner(this.beanClassLoader, packagesToScan);</span>
<span class="fc" id="L560">		Class&lt;?&gt;[] jaxb2Classes = scanner.scanPackages();</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L562">			logger.debug(&quot;Found JAXB2 classes: [&quot; + StringUtils.arrayToCommaDelimitedString(jaxb2Classes) + &quot;]&quot;);</span>
		}
<span class="fc" id="L564">		this.classesToBeBound = jaxb2Classes;</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">		if (this.jaxbContextProperties != null) {</span>
<span class="nc" id="L566">			return JAXBContext.newInstance(jaxb2Classes, this.jaxbContextProperties);</span>
		}
		else {
<span class="fc" id="L569">			return JAXBContext.newInstance(jaxb2Classes);</span>
		}
	}

	@SuppressWarnings(&quot;deprecation&quot;)  // on JDK 9
	private Schema loadSchema(Resource[] resources, String schemaLanguage) throws IOException, SAXException {
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L576">			logger.debug(&quot;Setting validation schema to &quot; +</span>
<span class="nc" id="L577">					StringUtils.arrayToCommaDelimitedString(this.schemaResources));</span>
		}
<span class="fc" id="L579">		Assert.notEmpty(resources, &quot;No resources given&quot;);</span>
<span class="fc" id="L580">		Assert.hasLength(schemaLanguage, &quot;No schema language provided&quot;);</span>
<span class="fc" id="L581">		Source[] schemaSources = new Source[resources.length];</span>
<span class="fc" id="L582">		XMLReader xmlReader = org.xml.sax.helpers.XMLReaderFactory.createXMLReader();</span>
<span class="fc" id="L583">		xmlReader.setFeature(&quot;http://xml.org/sax/features/namespace-prefixes&quot;, true);</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">		for (int i = 0; i &lt; resources.length; i++) {</span>
<span class="fc" id="L585">			Resource resource = resources[i];</span>
<span class="pc bpc" id="L586" title="2 of 4 branches missed.">			Assert.isTrue(resource != null &amp;&amp; resource.exists(), () -&gt; &quot;Resource does not exist: &quot; + resource);</span>
<span class="fc" id="L587">			InputSource inputSource = SaxResourceUtils.createInputSource(resource);</span>
<span class="fc" id="L588">			schemaSources[i] = new SAXSource(xmlReader, inputSource);</span>
		}
<span class="fc" id="L590">		SchemaFactory schemaFactory = SchemaFactory.newInstance(schemaLanguage);</span>
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">		if (this.schemaResourceResolver != null) {</span>
<span class="nc" id="L592">			schemaFactory.setResourceResolver(this.schemaResourceResolver);</span>
		}
<span class="fc" id="L594">		return schemaFactory.newSchema(schemaSources);</span>
	}


	@Override
	public boolean supports(Class&lt;?&gt; clazz) {
<span class="fc bfc" id="L600" title="All 4 branches covered.">		return (this.supportJaxbElementClass &amp;&amp; JAXBElement.class.isAssignableFrom(clazz)) ||</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">				supportsInternal(clazz, this.checkForXmlRootElement);</span>
	}

	@Override
	public boolean supports(Type genericType) {
<span class="fc bfc" id="L606" title="All 2 branches covered.">		if (genericType instanceof ParameterizedType) {</span>
<span class="fc" id="L607">			ParameterizedType parameterizedType = (ParameterizedType) genericType;</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">			if (JAXBElement.class == parameterizedType.getRawType() &amp;&amp;</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">					parameterizedType.getActualTypeArguments().length == 1) {</span>
<span class="fc" id="L610">				Type typeArgument = parameterizedType.getActualTypeArguments()[0];</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">				if (typeArgument instanceof Class) {</span>
<span class="fc" id="L612">					Class&lt;?&gt; classArgument = (Class&lt;?&gt;) typeArgument;</span>
<span class="pc bpc" id="L613" title="1 of 4 branches missed.">					return ((classArgument.isArray() &amp;&amp; Byte.TYPE == classArgument.getComponentType()) ||</span>
<span class="fc bfc" id="L614" title="All 4 branches covered.">							isPrimitiveWrapper(classArgument) || isStandardClass(classArgument) ||</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">							supportsInternal(classArgument, false));</span>
				}
<span class="nc bnc" id="L617" title="All 2 branches missed.">				else if (typeArgument instanceof GenericArrayType) {</span>
<span class="nc" id="L618">					GenericArrayType arrayType = (GenericArrayType) typeArgument;</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">					return (Byte.TYPE == arrayType.getGenericComponentType());</span>
				}
			}
<span class="nc" id="L622">		}</span>
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">		else if (genericType instanceof Class) {</span>
<span class="fc" id="L624">			Class&lt;?&gt; clazz = (Class&lt;?&gt;) genericType;</span>
<span class="fc" id="L625">			return supportsInternal(clazz, this.checkForXmlRootElement);</span>
		}
<span class="nc" id="L627">		return false;</span>
	}

	private boolean supportsInternal(Class&lt;?&gt; clazz, boolean checkForXmlRootElement) {
<span class="fc bfc" id="L631" title="All 4 branches covered.">		if (checkForXmlRootElement &amp;&amp; AnnotationUtils.findAnnotation(clazz, XmlRootElement.class) == null) {</span>
<span class="fc" id="L632">			return false;</span>
		}
<span class="fc bfc" id="L634" title="All 2 branches covered.">		if (StringUtils.hasLength(this.contextPath)) {</span>
<span class="fc" id="L635">			String packageName = ClassUtils.getPackageName(clazz);</span>
<span class="fc" id="L636">			String[] contextPaths = StringUtils.tokenizeToStringArray(this.contextPath, &quot;:&quot;);</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">			for (String contextPath : contextPaths) {</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">				if (contextPath.equals(packageName)) {</span>
<span class="fc" id="L639">					return true;</span>
				}
			}
<span class="fc" id="L642">			return false;</span>
		}
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">		else if (!ObjectUtils.isEmpty(this.classesToBeBound)) {</span>
<span class="fc" id="L645">			return Arrays.asList(this.classesToBeBound).contains(clazz);</span>
		}
<span class="nc" id="L647">		return false;</span>
	}

	/**
	 * Checks whether the given type is a primitive wrapper type.
	 * Compare section 8.5.1 of the JAXB2 spec.
	 */
	private boolean isPrimitiveWrapper(Class&lt;?&gt; clazz) {
<span class="pc bpc" id="L655" title="1 of 14 branches missed.">		return (Boolean.class == clazz ||</span>
				Byte.class == clazz ||
				Short.class == clazz ||
				Integer.class == clazz ||
				Long.class == clazz ||
				Float.class == clazz ||
				Double.class == clazz);
	}

	/**
	 * Checks whether the given type is a standard class.
	 * Compare section 8.5.2 of the JAXB2 spec.
	 */
	private boolean isStandardClass(Class&lt;?&gt; clazz) {
<span class="fc bfc" id="L669" title="All 2 branches covered.">		return (String.class == clazz ||</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">				BigInteger.class.isAssignableFrom(clazz) ||</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">				BigDecimal.class.isAssignableFrom(clazz) ||</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">				Calendar.class.isAssignableFrom(clazz) ||</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">				Date.class.isAssignableFrom(clazz) ||</span>
<span class="fc bfc" id="L674" title="All 4 branches covered.">				QName.class.isAssignableFrom(clazz) ||</span>
				URI.class == clazz ||
<span class="fc bfc" id="L676" title="All 2 branches covered.">				XMLGregorianCalendar.class.isAssignableFrom(clazz) ||</span>
<span class="fc bfc" id="L677" title="All 8 branches covered.">				Duration.class.isAssignableFrom(clazz) ||</span>
				Image.class == clazz ||
				DataHandler.class == clazz ||
				// Source and subclasses should be supported according to the JAXB2 spec, but aren't in the RI
				// Source.class.isAssignableFrom(clazz) ||
				UUID.class == clazz);

	}


	// Marshalling

	@Override
	public void marshal(Object graph, Result result) throws XmlMappingException {
<span class="fc" id="L691">		marshal(graph, result, null);</span>
<span class="fc" id="L692">	}</span>

	@Override
	public void marshal(Object graph, Result result, @Nullable MimeContainer mimeContainer) throws XmlMappingException {
		try {
<span class="fc" id="L697">			Marshaller marshaller = createMarshaller();</span>
<span class="pc bpc" id="L698" title="1 of 4 branches missed.">			if (this.mtomEnabled &amp;&amp; mimeContainer != null) {</span>
<span class="fc" id="L699">				marshaller.setAttachmentMarshaller(new Jaxb2AttachmentMarshaller(mimeContainer));</span>
			}
<span class="fc bfc" id="L701" title="All 2 branches covered.">			if (StaxUtils.isStaxResult(result)) {</span>
<span class="fc" id="L702">				marshalStaxResult(marshaller, graph, result);</span>
			}
			else {
<span class="fc" id="L705">				marshaller.marshal(graph, result);</span>
			}
		}
<span class="fc" id="L708">		catch (JAXBException ex) {</span>
<span class="fc" id="L709">			throw convertJaxbException(ex);</span>
<span class="fc" id="L710">		}</span>
<span class="fc" id="L711">	}</span>

	private void marshalStaxResult(Marshaller jaxbMarshaller, Object graph, Result staxResult) throws JAXBException {
<span class="fc" id="L714">		XMLStreamWriter streamWriter = StaxUtils.getXMLStreamWriter(staxResult);</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">		if (streamWriter != null) {</span>
<span class="fc" id="L716">			jaxbMarshaller.marshal(graph, streamWriter);</span>
		}
		else {
<span class="fc" id="L719">			XMLEventWriter eventWriter = StaxUtils.getXMLEventWriter(staxResult);</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">			if (eventWriter != null) {</span>
<span class="fc" id="L721">				jaxbMarshaller.marshal(graph, eventWriter);</span>
			}
			else {
<span class="nc" id="L724">				throw new IllegalArgumentException(&quot;StAX Result contains neither XMLStreamWriter nor XMLEventConsumer&quot;);</span>
			}
		}
<span class="fc" id="L727">	}</span>

	/**
	 * Return a newly created JAXB marshaller. JAXB marshallers are not necessarily thread safe.
	 */
	protected Marshaller createMarshaller() {
		try {
<span class="fc" id="L734">			Marshaller marshaller = getJaxbContext().createMarshaller();</span>
<span class="fc" id="L735">			initJaxbMarshaller(marshaller);</span>
<span class="fc" id="L736">			return marshaller;</span>
		}
<span class="nc" id="L738">		catch (JAXBException ex) {</span>
<span class="nc" id="L739">			throw convertJaxbException(ex);</span>
		}
	}

	/**
	 * Template method that can be overridden by concrete JAXB marshallers for custom initialization behavior.
	 * Gets called after creation of JAXB {@code Marshaller}, and after the respective properties have been set.
	 * &lt;p&gt;The default implementation sets the {@link #setMarshallerProperties(Map) defined properties}, the {@link
	 * #setValidationEventHandler(ValidationEventHandler) validation event handler}, the {@link #setSchemas(Resource[])
	 * schemas}, {@link #setMarshallerListener(javax.xml.bind.Marshaller.Listener) listener}, and
	 * {@link #setAdapters(XmlAdapter[]) adapters}.
	 */
	protected void initJaxbMarshaller(Marshaller marshaller) throws JAXBException {
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">		if (this.marshallerProperties != null) {</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">			for (String name : this.marshallerProperties.keySet()) {</span>
<span class="nc" id="L754">				marshaller.setProperty(name, this.marshallerProperties.get(name));</span>
<span class="nc" id="L755">			}</span>
		}
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">		if (this.marshallerListener != null) {</span>
<span class="nc" id="L758">			marshaller.setListener(this.marshallerListener);</span>
		}
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">		if (this.validationEventHandler != null) {</span>
<span class="nc" id="L761">			marshaller.setEventHandler(this.validationEventHandler);</span>
		}
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">		if (this.adapters != null) {</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">			for (XmlAdapter&lt;?, ?&gt; adapter : this.adapters) {</span>
<span class="nc" id="L765">				marshaller.setAdapter(adapter);</span>
			}
		}
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">		if (this.schema != null) {</span>
<span class="nc" id="L769">			marshaller.setSchema(this.schema);</span>
		}
<span class="fc" id="L771">	}</span>


	// Unmarshalling

	@Override
	public Object unmarshal(Source source) throws XmlMappingException {
<span class="fc" id="L778">		return unmarshal(source, null);</span>
	}

	@Override
	public Object unmarshal(Source source, @Nullable MimeContainer mimeContainer) throws XmlMappingException {
<span class="fc" id="L783">		source = processSource(source);</span>

		try {
<span class="fc" id="L786">			Unmarshaller unmarshaller = createUnmarshaller();</span>
<span class="pc bpc" id="L787" title="1 of 4 branches missed.">			if (this.mtomEnabled &amp;&amp; mimeContainer != null) {</span>
<span class="fc" id="L788">				unmarshaller.setAttachmentUnmarshaller(new Jaxb2AttachmentUnmarshaller(mimeContainer));</span>
			}
<span class="fc bfc" id="L790" title="All 2 branches covered.">			if (StaxUtils.isStaxSource(source)) {</span>
<span class="fc" id="L791">				return unmarshalStaxSource(unmarshaller, source);</span>
			}
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">			else if (this.mappedClass != null) {</span>
<span class="nc" id="L794">				return unmarshaller.unmarshal(source, this.mappedClass).getValue();</span>
			}
			else {
<span class="fc" id="L797">				return unmarshaller.unmarshal(source);</span>
			}
		}
<span class="nc" id="L800">		catch (NullPointerException ex) {</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">			if (!isSupportDtd()) {</span>
<span class="nc" id="L802">				throw new UnmarshallingFailureException(&quot;NPE while unmarshalling: &quot; +</span>
						&quot;This can happen due to the presence of DTD declarations which are disabled.&quot;, ex);
			}
<span class="nc" id="L805">			throw ex;</span>
		}
<span class="nc" id="L807">		catch (JAXBException ex) {</span>
<span class="nc" id="L808">			throw convertJaxbException(ex);</span>
		}
	}

	protected Object unmarshalStaxSource(Unmarshaller jaxbUnmarshaller, Source staxSource) throws JAXBException {
<span class="fc" id="L813">		XMLStreamReader streamReader = StaxUtils.getXMLStreamReader(staxSource);</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">		if (streamReader != null) {</span>
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">			return (this.mappedClass != null ?</span>
<span class="pc" id="L816">					jaxbUnmarshaller.unmarshal(streamReader, this.mappedClass).getValue() :</span>
<span class="fc" id="L817">					jaxbUnmarshaller.unmarshal(streamReader));</span>
		}
		else {
<span class="fc" id="L820">			XMLEventReader eventReader = StaxUtils.getXMLEventReader(staxSource);</span>
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">			if (eventReader != null) {</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">				return (this.mappedClass != null ?</span>
<span class="pc" id="L823">						jaxbUnmarshaller.unmarshal(eventReader, this.mappedClass).getValue() :</span>
<span class="fc" id="L824">						jaxbUnmarshaller.unmarshal(eventReader));</span>
			}
			else {
<span class="nc" id="L827">				throw new IllegalArgumentException(&quot;StaxSource contains neither XMLStreamReader nor XMLEventReader&quot;);</span>
			}
		}
	}

	@SuppressWarnings(&quot;deprecation&quot;)  // on JDK 9
	private Source processSource(Source source) {
<span class="fc bfc" id="L834" title="All 4 branches covered.">		if (StaxUtils.isStaxSource(source) || source instanceof DOMSource) {</span>
<span class="fc" id="L835">			return source;</span>
		}

<span class="fc" id="L838">		XMLReader xmlReader = null;</span>
<span class="fc" id="L839">		InputSource inputSource = null;</span>

<span class="fc bfc" id="L841" title="All 2 branches covered.">		if (source instanceof SAXSource) {</span>
<span class="fc" id="L842">			SAXSource saxSource = (SAXSource) source;</span>
<span class="fc" id="L843">			xmlReader = saxSource.getXMLReader();</span>
<span class="fc" id="L844">			inputSource = saxSource.getInputSource();</span>
<span class="fc" id="L845">		}</span>
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">		else if (source instanceof StreamSource) {</span>
<span class="fc" id="L847">			StreamSource streamSource = (StreamSource) source;</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">			if (streamSource.getInputStream() != null) {</span>
<span class="fc" id="L849">				inputSource = new InputSource(streamSource.getInputStream());</span>
			}
<span class="fc bfc" id="L851" title="All 2 branches covered.">			else if (streamSource.getReader() != null) {</span>
<span class="fc" id="L852">				inputSource = new InputSource(streamSource.getReader());</span>
			}
			else {
<span class="fc" id="L855">				inputSource = new InputSource(streamSource.getSystemId());</span>
			}
		}

		try {
<span class="fc bfc" id="L860" title="All 2 branches covered.">			if (xmlReader == null) {</span>
<span class="fc" id="L861">				xmlReader = org.xml.sax.helpers.XMLReaderFactory.createXMLReader();</span>
			}
<span class="fc bfc" id="L863" title="All 2 branches covered.">			xmlReader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, !isSupportDtd());</span>
<span class="fc" id="L864">			String name = &quot;http://xml.org/sax/features/external-general-entities&quot;;</span>
<span class="fc" id="L865">			xmlReader.setFeature(name, isProcessExternalEntities());</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">			if (!isProcessExternalEntities()) {</span>
<span class="fc" id="L867">				xmlReader.setEntityResolver(NO_OP_ENTITY_RESOLVER);</span>
			}
<span class="fc" id="L869">			return new SAXSource(xmlReader, inputSource);</span>
		}
<span class="nc" id="L871">		catch (SAXException ex) {</span>
<span class="nc" id="L872">			logger.info(&quot;Processing of external entities could not be disabled&quot;, ex);</span>
<span class="nc" id="L873">			return source;</span>
		}
	}

	/**
	 * Return a newly created JAXB unmarshaller.
	 * Note: JAXB unmarshallers are not necessarily thread-safe.
	 */
	protected Unmarshaller createUnmarshaller() {
		try {
<span class="fc" id="L883">			Unmarshaller unmarshaller = getJaxbContext().createUnmarshaller();</span>
<span class="fc" id="L884">			initJaxbUnmarshaller(unmarshaller);</span>
<span class="fc" id="L885">			return unmarshaller;</span>
		}
<span class="nc" id="L887">		catch (JAXBException ex) {</span>
<span class="nc" id="L888">			throw convertJaxbException(ex);</span>
		}
	}

	/**
	 * Template method that can be overridden by concrete JAXB marshallers for custom initialization behavior.
	 * Gets called after creation of JAXB {@code Marshaller}, and after the respective properties have been set.
	 * &lt;p&gt;The default implementation sets the {@link #setUnmarshallerProperties(Map) defined properties}, the {@link
	 * #setValidationEventHandler(ValidationEventHandler) validation event handler}, the {@link #setSchemas(Resource[])
	 * schemas}, {@link #setUnmarshallerListener(javax.xml.bind.Unmarshaller.Listener) listener}, and
	 * {@link #setAdapters(XmlAdapter[]) adapters}.
	 */
	protected void initJaxbUnmarshaller(Unmarshaller unmarshaller) throws JAXBException {
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">		if (this.unmarshallerProperties != null) {</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">			for (String name : this.unmarshallerProperties.keySet()) {</span>
<span class="nc" id="L903">				unmarshaller.setProperty(name, this.unmarshallerProperties.get(name));</span>
<span class="nc" id="L904">			}</span>
		}
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">		if (this.unmarshallerListener != null) {</span>
<span class="nc" id="L907">			unmarshaller.setListener(this.unmarshallerListener);</span>
		}
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">		if (this.validationEventHandler != null) {</span>
<span class="nc" id="L910">			unmarshaller.setEventHandler(this.validationEventHandler);</span>
		}
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">		if (this.adapters != null) {</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">			for (XmlAdapter&lt;?, ?&gt; adapter : this.adapters) {</span>
<span class="nc" id="L914">				unmarshaller.setAdapter(adapter);</span>
			}
		}
<span class="fc bfc" id="L917" title="All 2 branches covered.">		if (this.schema != null) {</span>
<span class="fc" id="L918">			unmarshaller.setSchema(this.schema);</span>
		}
<span class="fc" id="L920">	}</span>

	/**
	 * Convert the given {@code JAXBException} to an appropriate exception from the
	 * {@code org.springframework.oxm} hierarchy.
	 * @param ex {@code JAXBException} that occurred
	 * @return the corresponding {@code XmlMappingException}
	 */
	protected XmlMappingException convertJaxbException(JAXBException ex) {
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">		if (ex instanceof ValidationException) {</span>
<span class="nc" id="L930">			return new ValidationFailureException(&quot;JAXB validation exception&quot;, ex);</span>
		}
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">		else if (ex instanceof MarshalException) {</span>
<span class="nc" id="L933">			return new MarshallingFailureException(&quot;JAXB marshalling exception&quot;, ex);</span>
		}
<span class="pc bpc" id="L935" title="1 of 2 branches missed.">		else if (ex instanceof UnmarshalException) {</span>
<span class="nc" id="L936">			return new UnmarshallingFailureException(&quot;JAXB unmarshalling exception&quot;, ex);</span>
		}
		else {
			// fallback
<span class="fc" id="L940">			return new UncategorizedMappingException(&quot;Unknown JAXB exception&quot;, ex);</span>
		}
	}


	private static class Jaxb2AttachmentMarshaller extends AttachmentMarshaller {

		private final MimeContainer mimeContainer;

<span class="fc" id="L949">		public Jaxb2AttachmentMarshaller(MimeContainer mimeContainer) {</span>
<span class="fc" id="L950">			this.mimeContainer = mimeContainer;</span>
<span class="fc" id="L951">		}</span>

		@Override
		public String addMtomAttachment(byte[] data, int offset, int length, String mimeType,
				String elementNamespace, String elementLocalName) {
<span class="fc" id="L956">			ByteArrayDataSource dataSource = new ByteArrayDataSource(mimeType, data, offset, length);</span>
<span class="fc" id="L957">			return addMtomAttachment(new DataHandler(dataSource), elementNamespace, elementLocalName);</span>
		}

		@Override
		public String addMtomAttachment(DataHandler dataHandler, String elementNamespace, String elementLocalName) {
<span class="fc" id="L962">			String host = getHost(elementNamespace, dataHandler);</span>
<span class="fc" id="L963">			String contentId = UUID.randomUUID() + &quot;@&quot; + host;</span>
<span class="fc" id="L964">			this.mimeContainer.addAttachment(&quot;&lt;&quot; + contentId + &quot;&gt;&quot;, dataHandler);</span>
			try {
<span class="fc" id="L966">				contentId = URLEncoder.encode(contentId, &quot;UTF-8&quot;);</span>
			}
<span class="nc" id="L968">			catch (UnsupportedEncodingException ex) {</span>
				// ignore
<span class="fc" id="L970">			}</span>
<span class="fc" id="L971">			return CID + contentId;</span>
		}

		private String getHost(String elementNamespace, DataHandler dataHandler) {
			try {
<span class="fc" id="L976">				URI uri = new URI(elementNamespace);</span>
<span class="fc" id="L977">				return uri.getHost();</span>
			}
<span class="nc" id="L979">			catch (URISyntaxException ex) {</span>
				// ignore
			}
<span class="nc" id="L982">			return dataHandler.getName();</span>
		}

		@Override
		public String addSwaRefAttachment(DataHandler dataHandler) {
<span class="fc" id="L987">			String contentId = UUID.randomUUID() + &quot;@&quot; + dataHandler.getName();</span>
<span class="fc" id="L988">			this.mimeContainer.addAttachment(contentId, dataHandler);</span>
<span class="fc" id="L989">			return contentId;</span>
		}

		@Override
		public boolean isXOPPackage() {
<span class="fc" id="L994">			return this.mimeContainer.convertToXopPackage();</span>
		}
	}


	private static class Jaxb2AttachmentUnmarshaller extends AttachmentUnmarshaller {

		private final MimeContainer mimeContainer;

<span class="fc" id="L1003">		public Jaxb2AttachmentUnmarshaller(MimeContainer mimeContainer) {</span>
<span class="fc" id="L1004">			this.mimeContainer = mimeContainer;</span>
<span class="fc" id="L1005">		}</span>

		@Override
		public byte[] getAttachmentAsByteArray(String cid) {
			try {
<span class="nc" id="L1010">				DataHandler dataHandler = getAttachmentAsDataHandler(cid);</span>
<span class="nc" id="L1011">				return FileCopyUtils.copyToByteArray(dataHandler.getInputStream());</span>
			}
<span class="nc" id="L1013">			catch (IOException ex) {</span>
<span class="nc" id="L1014">				throw new UnmarshallingFailureException(&quot;Couldn't read attachment&quot;, ex);</span>
			}
		}

		@Override
		public DataHandler getAttachmentAsDataHandler(String contentId) {
<span class="fc bfc" id="L1020" title="All 2 branches covered.">			if (contentId.startsWith(CID)) {</span>
<span class="fc" id="L1021">				contentId = contentId.substring(CID.length());</span>
				try {
<span class="fc" id="L1023">					contentId = URLDecoder.decode(contentId, &quot;UTF-8&quot;);</span>
				}
<span class="nc" id="L1025">				catch (UnsupportedEncodingException ex) {</span>
					// ignore
<span class="fc" id="L1027">				}</span>
<span class="fc" id="L1028">				contentId = '&lt;' + contentId + '&gt;';</span>
			}
<span class="fc" id="L1030">			DataHandler dataHandler = this.mimeContainer.getAttachment(contentId);</span>
<span class="pc bpc" id="L1031" title="1 of 2 branches missed.">			if (dataHandler == null) {</span>
<span class="nc" id="L1032">				throw new IllegalArgumentException(&quot;No attachment found for &quot; + contentId);</span>
			}
<span class="fc" id="L1034">			return dataHandler;</span>
		}

		@Override
		public boolean isXOPPackage() {
<span class="fc" id="L1039">			return this.mimeContainer.isXopPackage();</span>
		}
	}


	/**
	 * DataSource that wraps around a byte array.
	 */
	private static class ByteArrayDataSource implements DataSource {

		private final byte[] data;

		private final String contentType;

		private final int offset;

		private final int length;

<span class="fc" id="L1057">		public ByteArrayDataSource(String contentType, byte[] data, int offset, int length) {</span>
<span class="fc" id="L1058">			this.contentType = contentType;</span>
<span class="fc" id="L1059">			this.data = data;</span>
<span class="fc" id="L1060">			this.offset = offset;</span>
<span class="fc" id="L1061">			this.length = length;</span>
<span class="fc" id="L1062">		}</span>

		@Override
		public InputStream getInputStream() {
<span class="nc" id="L1066">			return new ByteArrayInputStream(this.data, this.offset, this.length);</span>
		}

		@Override
		public OutputStream getOutputStream() {
<span class="nc" id="L1071">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public String getContentType() {
<span class="nc" id="L1076">			return this.contentType;</span>
		}

		@Override
		public String getName() {
<span class="nc" id="L1081">			return &quot;ByteArrayDataSource&quot;;</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>