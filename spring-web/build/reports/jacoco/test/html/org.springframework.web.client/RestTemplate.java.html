<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RestTemplate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-web</a> &gt; <a href="index.source.html" class="el_package">org.springframework.web.client</a> &gt; <span class="el_source">RestTemplate.java</span></div><h1>RestTemplate.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.client;

import java.io.IOException;
import java.lang.reflect.Type;
import java.net.URI;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.ClientHttpRequest;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.http.client.support.InterceptingHttpAccessor;
import org.springframework.http.converter.ByteArrayHttpMessageConverter;
import org.springframework.http.converter.GenericHttpMessageConverter;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.ResourceHttpMessageConverter;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.http.converter.cbor.MappingJackson2CborHttpMessageConverter;
import org.springframework.http.converter.feed.AtomFeedHttpMessageConverter;
import org.springframework.http.converter.feed.RssChannelHttpMessageConverter;
import org.springframework.http.converter.json.GsonHttpMessageConverter;
import org.springframework.http.converter.json.JsonbHttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.http.converter.smile.MappingJackson2SmileHttpMessageConverter;
import org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter;
import org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter;
import org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;
import org.springframework.http.converter.xml.SourceHttpMessageConverter;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.web.util.DefaultUriBuilderFactory;
import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;
import org.springframework.web.util.UriTemplateHandler;

/**
 * Synchronous client to perform HTTP requests, exposing a simple, template
 * method API over underlying HTTP client libraries such as the JDK
 * {@code HttpURLConnection}, Apache HttpComponents, and others.
 *
 * &lt;p&gt;The RestTemplate offers templates for common scenarios by HTTP method, in
 * addition to the generalized {@code exchange} and {@code execute} methods that
 * support of less frequent cases.
 *
 * &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; As of 5.0, the non-blocking, reactive
 * {@code org.springframework.web.reactive.client.WebClient} offers a
 * modern alternative to the {@code RestTemplate} with efficient support for
 * both sync and async, as well as streaming scenarios. The {@code RestTemplate}
 * will be deprecated in a future version and will not have major new features
 * added going forward. See the WebClient section of the Spring Framework reference
 * documentation for more details and example code.
 *
 * @author Arjen Poutsma
 * @author Brian Clozel
 * @author Roy Clarkson
 * @author Juergen Hoeller
 * @since 3.0
 * @see HttpMessageConverter
 * @see RequestCallback
 * @see ResponseExtractor
 * @see ResponseErrorHandler
 */
public class RestTemplate extends InterceptingHttpAccessor implements RestOperations {

	private static boolean romePresent;

	private static final boolean jaxb2Present;

	private static final boolean jackson2Present;

	private static final boolean jackson2XmlPresent;

	private static final boolean jackson2SmilePresent;

	private static final boolean jackson2CborPresent;

	private static final boolean gsonPresent;

	private static final boolean jsonbPresent;

	static {
<span class="fc" id="L112">		ClassLoader classLoader = RestTemplate.class.getClassLoader();</span>
<span class="fc" id="L113">		romePresent = ClassUtils.isPresent(&quot;com.rometools.rome.feed.WireFeed&quot;, classLoader);</span>
<span class="fc" id="L114">		jaxb2Present = ClassUtils.isPresent(&quot;javax.xml.bind.Binder&quot;, classLoader);</span>
<span class="fc" id="L115">		jackson2Present =</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">				ClassUtils.isPresent(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;, classLoader) &amp;&amp;</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">						ClassUtils.isPresent(&quot;com.fasterxml.jackson.core.JsonGenerator&quot;, classLoader);</span>
<span class="fc" id="L118">		jackson2XmlPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader);</span>
<span class="fc" id="L119">		jackson2SmilePresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;, classLoader);</span>
<span class="fc" id="L120">		jackson2CborPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.cbor.CBORFactory&quot;, classLoader);</span>
<span class="fc" id="L121">		gsonPresent = ClassUtils.isPresent(&quot;com.google.gson.Gson&quot;, classLoader);</span>
<span class="fc" id="L122">		jsonbPresent = ClassUtils.isPresent(&quot;javax.json.bind.Jsonb&quot;, classLoader);</span>
<span class="fc" id="L123">	}</span>


<span class="fc" id="L126">	private final List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L128">	private ResponseErrorHandler errorHandler = new DefaultResponseErrorHandler();</span>

	private UriTemplateHandler uriTemplateHandler;

<span class="fc" id="L132">	private final ResponseExtractor&lt;HttpHeaders&gt; headersExtractor = new HeadersExtractor();</span>


	/**
	 * Create a new instance of the {@link RestTemplate} using default settings.
	 * Default {@link HttpMessageConverter HttpMessageConverters} are initialized.
	 */
<span class="fc" id="L139">	public RestTemplate() {</span>
<span class="fc" id="L140">		this.messageConverters.add(new ByteArrayHttpMessageConverter());</span>
<span class="fc" id="L141">		this.messageConverters.add(new StringHttpMessageConverter());</span>
<span class="fc" id="L142">		this.messageConverters.add(new ResourceHttpMessageConverter(false));</span>
		try {
<span class="fc" id="L144">			this.messageConverters.add(new SourceHttpMessageConverter&lt;&gt;());</span>
		}
<span class="nc" id="L146">		catch (Error err) {</span>
			// Ignore when no TransformerFactory implementation is available
<span class="fc" id="L148">		}</span>
<span class="fc" id="L149">		this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());</span>

<span class="pc bpc" id="L151" title="1 of 2 branches missed.">		if (romePresent) {</span>
<span class="fc" id="L152">			this.messageConverters.add(new AtomFeedHttpMessageConverter());</span>
<span class="fc" id="L153">			this.messageConverters.add(new RssChannelHttpMessageConverter());</span>
		}

<span class="pc bpc" id="L156" title="1 of 2 branches missed.">		if (jackson2XmlPresent) {</span>
<span class="fc" id="L157">			this.messageConverters.add(new MappingJackson2XmlHttpMessageConverter());</span>
		}
<span class="nc bnc" id="L159" title="All 2 branches missed.">		else if (jaxb2Present) {</span>
<span class="nc" id="L160">			this.messageConverters.add(new Jaxb2RootElementHttpMessageConverter());</span>
		}

<span class="pc bpc" id="L163" title="1 of 2 branches missed.">		if (jackson2Present) {</span>
<span class="fc" id="L164">			this.messageConverters.add(new MappingJackson2HttpMessageConverter());</span>
		}
<span class="nc bnc" id="L166" title="All 2 branches missed.">		else if (gsonPresent) {</span>
<span class="nc" id="L167">			this.messageConverters.add(new GsonHttpMessageConverter());</span>
		}
<span class="nc bnc" id="L169" title="All 2 branches missed.">		else if (jsonbPresent) {</span>
<span class="nc" id="L170">			this.messageConverters.add(new JsonbHttpMessageConverter());</span>
		}

<span class="pc bpc" id="L173" title="1 of 2 branches missed.">		if (jackson2SmilePresent) {</span>
<span class="fc" id="L174">			this.messageConverters.add(new MappingJackson2SmileHttpMessageConverter());</span>
		}
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">		if (jackson2CborPresent) {</span>
<span class="fc" id="L177">			this.messageConverters.add(new MappingJackson2CborHttpMessageConverter());</span>
		}

<span class="fc" id="L180">		this.uriTemplateHandler = initUriTemplateHandler();</span>
<span class="fc" id="L181">	}</span>

	/**
	 * Create a new instance of the {@link RestTemplate} based on the given {@link ClientHttpRequestFactory}.
	 * @param requestFactory the HTTP request factory to use
	 * @see org.springframework.http.client.SimpleClientHttpRequestFactory
	 * @see org.springframework.http.client.HttpComponentsClientHttpRequestFactory
	 */
	public RestTemplate(ClientHttpRequestFactory requestFactory) {
<span class="fc" id="L190">		this();</span>
<span class="fc" id="L191">		setRequestFactory(requestFactory);</span>
<span class="fc" id="L192">	}</span>

	/**
	 * Create a new instance of the {@link RestTemplate} using the given list of
	 * {@link HttpMessageConverter} to use.
	 * @param messageConverters the list of {@link HttpMessageConverter} to use
	 * @since 3.2.7
	 */
<span class="fc" id="L200">	public RestTemplate(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters) {</span>
<span class="fc" id="L201">		Assert.notEmpty(messageConverters, &quot;At least one HttpMessageConverter required&quot;);</span>
<span class="fc" id="L202">		this.messageConverters.addAll(messageConverters);</span>
<span class="fc" id="L203">		this.uriTemplateHandler = initUriTemplateHandler();</span>
<span class="fc" id="L204">	}</span>

	private static DefaultUriBuilderFactory initUriTemplateHandler() {
<span class="fc" id="L207">		DefaultUriBuilderFactory uriFactory = new DefaultUriBuilderFactory();</span>
<span class="fc" id="L208">		uriFactory.setEncodingMode(EncodingMode.URI_COMPONENT);  // for backwards compatibility..</span>
<span class="fc" id="L209">		return uriFactory;</span>
	}


	/**
	 * Set the message body converters to use.
	 * &lt;p&gt;These converters are used to convert from and to HTTP requests and responses.
	 */
	public void setMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters) {
<span class="fc" id="L218">		Assert.notEmpty(messageConverters, &quot;At least one HttpMessageConverter required&quot;);</span>
		// Take getMessageConverters() List as-is when passed in here
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">		if (this.messageConverters != messageConverters) {</span>
<span class="fc" id="L221">			this.messageConverters.clear();</span>
<span class="fc" id="L222">			this.messageConverters.addAll(messageConverters);</span>
		}
<span class="fc" id="L224">	}</span>

	/**
	 * Return the list of message body converters.
	 * &lt;p&gt;The returned {@link List} is active and may get appended to.
	 */
	public List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() {
<span class="fc" id="L231">		return this.messageConverters;</span>
	}

	/**
	 * Set the error handler.
	 * &lt;p&gt;By default, RestTemplate uses a {@link DefaultResponseErrorHandler}.
	 */
	public void setErrorHandler(ResponseErrorHandler errorHandler) {
<span class="fc" id="L239">		Assert.notNull(errorHandler, &quot;ResponseErrorHandler must not be null&quot;);</span>
<span class="fc" id="L240">		this.errorHandler = errorHandler;</span>
<span class="fc" id="L241">	}</span>

	/**
	 * Return the error handler.
	 */
	public ResponseErrorHandler getErrorHandler() {
<span class="fc" id="L247">		return this.errorHandler;</span>
	}

	/**
	 * Configure default URI variable values. This is a shortcut for:
	 * &lt;pre class=&quot;code&quot;&gt;
	 * DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory();
	 * handler.setDefaultUriVariables(...);
	 *
	 * RestTemplate restTemplate = new RestTemplate();
	 * restTemplate.setUriTemplateHandler(handler);
	 * &lt;/pre&gt;
	 * @param uriVars the default URI variable values
	 * @since 4.3
	 */
	@SuppressWarnings(&quot;deprecation&quot;)
	public void setDefaultUriVariables(Map&lt;String, ?&gt; uriVars) {
<span class="nc bnc" id="L264" title="All 2 branches missed.">		if (this.uriTemplateHandler instanceof DefaultUriBuilderFactory) {</span>
<span class="nc" id="L265">			((DefaultUriBuilderFactory) this.uriTemplateHandler).setDefaultUriVariables(uriVars);</span>
		}
<span class="nc bnc" id="L267" title="All 2 branches missed.">		else if (this.uriTemplateHandler instanceof org.springframework.web.util.AbstractUriTemplateHandler) {</span>
<span class="nc" id="L268">			((org.springframework.web.util.AbstractUriTemplateHandler) this.uriTemplateHandler)</span>
<span class="nc" id="L269">					.setDefaultUriVariables(uriVars);</span>
		}
		else {
<span class="nc" id="L272">			throw new IllegalArgumentException(</span>
					&quot;This property is not supported with the configured UriTemplateHandler.&quot;);
		}
<span class="nc" id="L275">	}</span>

	/**
	 * Configure a strategy for expanding URI templates.
	 * &lt;p&gt;By default, {@link DefaultUriBuilderFactory} is used and for
	 * backwards compatibility, the encoding mode is set to
	 * {@link EncodingMode#URI_COMPONENT URI_COMPONENT}. As of 5.0.8, prefer
	 * using {@link EncodingMode#TEMPLATE_AND_VALUES TEMPLATE_AND_VALUES}.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; in 5.0 the switch from
	 * {@link org.springframework.web.util.DefaultUriTemplateHandler
	 * DefaultUriTemplateHandler} (deprecated in 4.3), as the default to use, to
	 * {@link DefaultUriBuilderFactory} brings in a different default for the
	 * {@code parsePath} property (switching from false to true).
	 * @param handler the URI template handler to use
	 */
	public void setUriTemplateHandler(UriTemplateHandler handler) {
<span class="fc" id="L291">		Assert.notNull(handler, &quot;UriTemplateHandler must not be null&quot;);</span>
<span class="fc" id="L292">		this.uriTemplateHandler = handler;</span>
<span class="fc" id="L293">	}</span>

	/**
	 * Return the configured URI template handler.
	 */
	public UriTemplateHandler getUriTemplateHandler() {
<span class="fc" id="L299">		return this.uriTemplateHandler;</span>
	}


	// GET

	@Override
	@Nullable
	public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException {
<span class="fc" id="L308">		RequestCallback requestCallback = acceptHeaderRequestCallback(responseType);</span>
<span class="fc" id="L309">		HttpMessageConverterExtractor&lt;T&gt; responseExtractor =</span>
<span class="fc" id="L310">				new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger);</span>
<span class="fc" id="L311">		return execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);</span>
	}

	@Override
	@Nullable
	public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException {
<span class="fc" id="L317">		RequestCallback requestCallback = acceptHeaderRequestCallback(responseType);</span>
<span class="fc" id="L318">		HttpMessageConverterExtractor&lt;T&gt; responseExtractor =</span>
<span class="fc" id="L319">				new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger);</span>
<span class="fc" id="L320">		return execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);</span>
	}

	@Override
	@Nullable
	public &lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException {
<span class="fc" id="L326">		RequestCallback requestCallback = acceptHeaderRequestCallback(responseType);</span>
<span class="fc" id="L327">		HttpMessageConverterExtractor&lt;T&gt; responseExtractor =</span>
<span class="fc" id="L328">				new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger);</span>
<span class="nc" id="L329">		return execute(url, HttpMethod.GET, requestCallback, responseExtractor);</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables)
			throws RestClientException {

<span class="fc" id="L336">		RequestCallback requestCallback = acceptHeaderRequestCallback(responseType);</span>
<span class="fc" id="L337">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType);</span>
<span class="fc" id="L338">		return nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables));</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)
			throws RestClientException {

<span class="nc" id="L345">		RequestCallback requestCallback = acceptHeaderRequestCallback(responseType);</span>
<span class="nc" id="L346">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType);</span>
<span class="nc" id="L347">		return nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables));</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(URI url, Class&lt;T&gt; responseType) throws RestClientException {
<span class="fc" id="L352">		RequestCallback requestCallback = acceptHeaderRequestCallback(responseType);</span>
<span class="fc" id="L353">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType);</span>
<span class="fc" id="L354">		return nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor));</span>
	}


	// HEAD

	@Override
	public HttpHeaders headForHeaders(String url, Object... uriVariables) throws RestClientException {
<span class="fc" id="L362">		return nonNull(execute(url, HttpMethod.HEAD, null, headersExtractor(), uriVariables));</span>
	}

	@Override
	public HttpHeaders headForHeaders(String url, Map&lt;String, ?&gt; uriVariables) throws RestClientException {
<span class="nc" id="L367">		return nonNull(execute(url, HttpMethod.HEAD, null, headersExtractor(), uriVariables));</span>
	}

	@Override
	public HttpHeaders headForHeaders(URI url) throws RestClientException {
<span class="nc" id="L372">		return nonNull(execute(url, HttpMethod.HEAD, null, headersExtractor()));</span>
	}


	// POST

	@Override
	@Nullable
	public URI postForLocation(String url, @Nullable Object request, Object... uriVariables)
			throws RestClientException {

<span class="fc" id="L383">		RequestCallback requestCallback = httpEntityCallback(request);</span>
<span class="fc" id="L384">		HttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor(), uriVariables);</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">		return (headers != null ? headers.getLocation() : null);</span>
	}

	@Override
	@Nullable
	public URI postForLocation(String url, @Nullable Object request, Map&lt;String, ?&gt; uriVariables)
			throws RestClientException {

<span class="nc" id="L393">		RequestCallback requestCallback = httpEntityCallback(request);</span>
<span class="nc" id="L394">		HttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor(), uriVariables);</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">		return (headers != null ? headers.getLocation() : null);</span>
	}

	@Override
	@Nullable
	public URI postForLocation(URI url, @Nullable Object request) throws RestClientException {
<span class="nc" id="L401">		RequestCallback requestCallback = httpEntityCallback(request);</span>
<span class="nc" id="L402">		HttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor());</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">		return (headers != null ? headers.getLocation() : null);</span>
	}

	@Override
	@Nullable
	public &lt;T&gt; T postForObject(String url, @Nullable Object request, Class&lt;T&gt; responseType,
			Object... uriVariables) throws RestClientException {

<span class="fc" id="L411">		RequestCallback requestCallback = httpEntityCallback(request, responseType);</span>
<span class="fc" id="L412">		HttpMessageConverterExtractor&lt;T&gt; responseExtractor =</span>
<span class="fc" id="L413">				new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger);</span>
<span class="fc" id="L414">		return execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);</span>
	}

	@Override
	@Nullable
	public &lt;T&gt; T postForObject(String url, @Nullable Object request, Class&lt;T&gt; responseType,
			Map&lt;String, ?&gt; uriVariables) throws RestClientException {

<span class="nc" id="L422">		RequestCallback requestCallback = httpEntityCallback(request, responseType);</span>
<span class="nc" id="L423">		HttpMessageConverterExtractor&lt;T&gt; responseExtractor =</span>
<span class="nc" id="L424">				new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger);</span>
<span class="nc" id="L425">		return execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);</span>
	}

	@Override
	@Nullable
	public &lt;T&gt; T postForObject(URI url, @Nullable Object request, Class&lt;T&gt; responseType)
			throws RestClientException {

<span class="nc" id="L433">		RequestCallback requestCallback = httpEntityCallback(request, responseType);</span>
<span class="nc" id="L434">		HttpMessageConverterExtractor&lt;T&gt; responseExtractor =</span>
<span class="nc" id="L435">				new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters());</span>
<span class="nc" id="L436">		return execute(url, HttpMethod.POST, requestCallback, responseExtractor);</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, @Nullable Object request,
			Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException {

<span class="fc" id="L443">		RequestCallback requestCallback = httpEntityCallback(request, responseType);</span>
<span class="fc" id="L444">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType);</span>
<span class="fc" id="L445">		return nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables));</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, @Nullable Object request,
			Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException {

<span class="nc" id="L452">		RequestCallback requestCallback = httpEntityCallback(request, responseType);</span>
<span class="nc" id="L453">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType);</span>
<span class="nc" id="L454">		return nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables));</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(URI url, @Nullable Object request, Class&lt;T&gt; responseType)
			throws RestClientException {

<span class="nc" id="L461">		RequestCallback requestCallback = httpEntityCallback(request, responseType);</span>
<span class="nc" id="L462">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType);</span>
<span class="nc" id="L463">		return nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor));</span>
	}


	// PUT

	@Override
	public void put(String url, @Nullable Object request, Object... uriVariables)
			throws RestClientException {

<span class="fc" id="L473">		RequestCallback requestCallback = httpEntityCallback(request);</span>
<span class="fc" id="L474">		execute(url, HttpMethod.PUT, requestCallback, null, uriVariables);</span>
<span class="fc" id="L475">	}</span>

	@Override
	public void put(String url, @Nullable Object request, Map&lt;String, ?&gt; uriVariables)
			throws RestClientException {

<span class="nc" id="L481">		RequestCallback requestCallback = httpEntityCallback(request);</span>
<span class="nc" id="L482">		execute(url, HttpMethod.PUT, requestCallback, null, uriVariables);</span>
<span class="nc" id="L483">	}</span>

	@Override
	public void put(URI url, @Nullable Object request) throws RestClientException {
<span class="nc" id="L487">		RequestCallback requestCallback = httpEntityCallback(request);</span>
<span class="nc" id="L488">		execute(url, HttpMethod.PUT, requestCallback, null);</span>
<span class="nc" id="L489">	}</span>


	// PATCH

	@Override
	@Nullable
	public &lt;T&gt; T patchForObject(String url, @Nullable Object request, Class&lt;T&gt; responseType,
			Object... uriVariables) throws RestClientException {

<span class="fc" id="L499">		RequestCallback requestCallback = httpEntityCallback(request, responseType);</span>
<span class="fc" id="L500">		HttpMessageConverterExtractor&lt;T&gt; responseExtractor =</span>
<span class="fc" id="L501">				new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger);</span>
<span class="fc" id="L502">		return execute(url, HttpMethod.PATCH, requestCallback, responseExtractor, uriVariables);</span>
	}

	@Override
	@Nullable
	public &lt;T&gt; T patchForObject(String url, @Nullable Object request, Class&lt;T&gt; responseType,
			Map&lt;String, ?&gt; uriVariables) throws RestClientException {

<span class="nc" id="L510">		RequestCallback requestCallback = httpEntityCallback(request, responseType);</span>
<span class="nc" id="L511">		HttpMessageConverterExtractor&lt;T&gt; responseExtractor =</span>
<span class="nc" id="L512">				new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger);</span>
<span class="nc" id="L513">		return execute(url, HttpMethod.PATCH, requestCallback, responseExtractor, uriVariables);</span>
	}

	@Override
	@Nullable
	public &lt;T&gt; T patchForObject(URI url, @Nullable Object request, Class&lt;T&gt; responseType)
			throws RestClientException {

<span class="nc" id="L521">		RequestCallback requestCallback = httpEntityCallback(request, responseType);</span>
<span class="nc" id="L522">		HttpMessageConverterExtractor&lt;T&gt; responseExtractor =</span>
<span class="nc" id="L523">				new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters());</span>
<span class="nc" id="L524">		return execute(url, HttpMethod.PATCH, requestCallback, responseExtractor);</span>
	}


	// DELETE

	@Override
	public void delete(String url, Object... uriVariables) throws RestClientException {
<span class="fc" id="L532">		execute(url, HttpMethod.DELETE, null, null, uriVariables);</span>
<span class="fc" id="L533">	}</span>

	@Override
	public void delete(String url, Map&lt;String, ?&gt; uriVariables) throws RestClientException {
<span class="nc" id="L537">		execute(url, HttpMethod.DELETE, null, null, uriVariables);</span>
<span class="nc" id="L538">	}</span>

	@Override
	public void delete(URI url) throws RestClientException {
<span class="nc" id="L542">		execute(url, HttpMethod.DELETE, null, null);</span>
<span class="nc" id="L543">	}</span>


	// OPTIONS

	@Override
	public Set&lt;HttpMethod&gt; optionsForAllow(String url, Object... uriVariables) throws RestClientException {
<span class="fc" id="L550">		ResponseExtractor&lt;HttpHeaders&gt; headersExtractor = headersExtractor();</span>
<span class="fc" id="L551">		HttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">		return (headers != null ? headers.getAllow() : Collections.emptySet());</span>
	}

	@Override
	public Set&lt;HttpMethod&gt; optionsForAllow(String url, Map&lt;String, ?&gt; uriVariables) throws RestClientException {
<span class="nc" id="L557">		ResponseExtractor&lt;HttpHeaders&gt; headersExtractor = headersExtractor();</span>
<span class="nc" id="L558">		HttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">		return (headers != null ? headers.getAllow() : Collections.emptySet());</span>
	}

	@Override
	public Set&lt;HttpMethod&gt; optionsForAllow(URI url) throws RestClientException {
<span class="fc" id="L564">		ResponseExtractor&lt;HttpHeaders&gt; headersExtractor = headersExtractor();</span>
<span class="fc" id="L565">		HttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor);</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">		return (headers != null ? headers.getAllow() : Collections.emptySet());</span>
	}


	// exchange

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method,
			@Nullable HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Object... uriVariables)
			throws RestClientException {

<span class="fc" id="L577">		RequestCallback requestCallback = httpEntityCallback(requestEntity, responseType);</span>
<span class="fc" id="L578">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType);</span>
<span class="fc" id="L579">		return nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables));</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method,
			@Nullable HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)
			throws RestClientException {

<span class="nc" id="L587">		RequestCallback requestCallback = httpEntityCallback(requestEntity, responseType);</span>
<span class="nc" id="L588">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType);</span>
<span class="nc" id="L589">		return nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables));</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; exchange(URI url, HttpMethod method, @Nullable HttpEntity&lt;?&gt; requestEntity,
			Class&lt;T&gt; responseType) throws RestClientException {

<span class="nc" id="L596">		RequestCallback requestCallback = httpEntityCallback(requestEntity, responseType);</span>
<span class="nc" id="L597">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType);</span>
<span class="nc" id="L598">		return nonNull(execute(url, method, requestCallback, responseExtractor));</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method, @Nullable HttpEntity&lt;?&gt; requestEntity,
			ParameterizedTypeReference&lt;T&gt; responseType, Object... uriVariables) throws RestClientException {

<span class="fc" id="L605">		Type type = responseType.getType();</span>
<span class="fc" id="L606">		RequestCallback requestCallback = httpEntityCallback(requestEntity, type);</span>
<span class="fc" id="L607">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(type);</span>
<span class="fc" id="L608">		return nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables));</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method, @Nullable HttpEntity&lt;?&gt; requestEntity,
			ParameterizedTypeReference&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException {

<span class="nc" id="L615">		Type type = responseType.getType();</span>
<span class="nc" id="L616">		RequestCallback requestCallback = httpEntityCallback(requestEntity, type);</span>
<span class="nc" id="L617">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(type);</span>
<span class="nc" id="L618">		return nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables));</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; exchange(URI url, HttpMethod method, @Nullable HttpEntity&lt;?&gt; requestEntity,
			ParameterizedTypeReference&lt;T&gt; responseType) throws RestClientException {

<span class="nc" id="L625">		Type type = responseType.getType();</span>
<span class="nc" id="L626">		RequestCallback requestCallback = httpEntityCallback(requestEntity, type);</span>
<span class="nc" id="L627">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(type);</span>
<span class="nc" id="L628">		return nonNull(execute(url, method, requestCallback, responseExtractor));</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; exchange(RequestEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType)
			throws RestClientException {

<span class="fc" id="L635">		RequestCallback requestCallback = httpEntityCallback(requestEntity, responseType);</span>
<span class="fc" id="L636">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType);</span>
<span class="fc" id="L637">		return nonNull(doExecute(requestEntity.getUrl(), requestEntity.getMethod(), requestCallback, responseExtractor));</span>
	}

	@Override
	public &lt;T&gt; ResponseEntity&lt;T&gt; exchange(RequestEntity&lt;?&gt; requestEntity, ParameterizedTypeReference&lt;T&gt; responseType)
			throws RestClientException {

<span class="nc" id="L644">		Type type = responseType.getType();</span>
<span class="nc" id="L645">		RequestCallback requestCallback = httpEntityCallback(requestEntity, type);</span>
<span class="nc" id="L646">		ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(type);</span>
<span class="nc" id="L647">		return nonNull(doExecute(requestEntity.getUrl(), requestEntity.getMethod(), requestCallback, responseExtractor));</span>
	}


	// General execution

	/**
	 * {@inheritDoc}
	 * &lt;p&gt;To provide a {@code RequestCallback} or {@code ResponseExtractor} only,
	 * but not both, consider using:
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link #acceptHeaderRequestCallback(Class)}
	 * &lt;li&gt;{@link #httpEntityCallback(Object)}
	 * &lt;li&gt;{@link #httpEntityCallback(Object, Type)}
	 * &lt;li&gt;{@link #responseEntityExtractor(Type)}
	 * &lt;/ul&gt;
	 */
	@Override
	@Nullable
	public &lt;T&gt; T execute(String url, HttpMethod method, @Nullable RequestCallback requestCallback,
			@Nullable ResponseExtractor&lt;T&gt; responseExtractor, Object... uriVariables) throws RestClientException {

<span class="fc" id="L669">		URI expanded = getUriTemplateHandler().expand(url, uriVariables);</span>
<span class="fc" id="L670">		return doExecute(expanded, method, requestCallback, responseExtractor);</span>
	}

	/**
	 * {@inheritDoc}
	 * &lt;p&gt;To provide a {@code RequestCallback} or {@code ResponseExtractor} only,
	 * but not both, consider using:
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link #acceptHeaderRequestCallback(Class)}
	 * &lt;li&gt;{@link #httpEntityCallback(Object)}
	 * &lt;li&gt;{@link #httpEntityCallback(Object, Type)}
	 * &lt;li&gt;{@link #responseEntityExtractor(Type)}
	 * &lt;/ul&gt;
	 */
	@Override
	@Nullable
	public &lt;T&gt; T execute(String url, HttpMethod method, @Nullable RequestCallback requestCallback,
			@Nullable ResponseExtractor&lt;T&gt; responseExtractor, Map&lt;String, ?&gt; uriVariables)
			throws RestClientException {

<span class="fc" id="L690">		URI expanded = getUriTemplateHandler().expand(url, uriVariables);</span>
<span class="fc" id="L691">		return doExecute(expanded, method, requestCallback, responseExtractor);</span>
	}

	/**
	 * {@inheritDoc}
	 * &lt;p&gt;To provide a {@code RequestCallback} or {@code ResponseExtractor} only,
	 * but not both, consider using:
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link #acceptHeaderRequestCallback(Class)}
	 * &lt;li&gt;{@link #httpEntityCallback(Object)}
	 * &lt;li&gt;{@link #httpEntityCallback(Object, Type)}
	 * &lt;li&gt;{@link #responseEntityExtractor(Type)}
	 * &lt;/ul&gt;
	 */
	@Override
	@Nullable
	public &lt;T&gt; T execute(URI url, HttpMethod method, @Nullable RequestCallback requestCallback,
			@Nullable ResponseExtractor&lt;T&gt; responseExtractor) throws RestClientException {

<span class="fc" id="L710">		return doExecute(url, method, requestCallback, responseExtractor);</span>
	}

	/**
	 * Execute the given method on the provided URI.
	 * &lt;p&gt;The {@link ClientHttpRequest} is processed using the {@link RequestCallback};
	 * the response with the {@link ResponseExtractor}.
	 * @param url the fully-expanded URL to connect to
	 * @param method the HTTP method to execute (GET, POST, etc.)
	 * @param requestCallback object that prepares the request (can be {@code null})
	 * @param responseExtractor object that extracts the return value from the response (can be {@code null})
	 * @return an arbitrary object, as returned by the {@link ResponseExtractor}
	 */
	@Nullable
	protected &lt;T&gt; T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,
			@Nullable ResponseExtractor&lt;T&gt; responseExtractor) throws RestClientException {

<span class="fc" id="L727">		Assert.notNull(url, &quot;URI is required&quot;);</span>
<span class="fc" id="L728">		Assert.notNull(method, &quot;HttpMethod is required&quot;);</span>
<span class="fc" id="L729">		ClientHttpResponse response = null;</span>
		try {
<span class="fc" id="L731">			ClientHttpRequest request = createRequest(url, method);</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">			if (requestCallback != null) {</span>
<span class="fc" id="L733">				requestCallback.doWithRequest(request);</span>
			}
<span class="fc" id="L735">			response = request.execute();</span>
<span class="fc" id="L736">			handleResponse(url, method, response);</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">			return (responseExtractor != null ? responseExtractor.extractData(response) : null);</span>
		}
<span class="fc" id="L739">		catch (IOException ex) {</span>
<span class="fc" id="L740">			String resource = url.toString();</span>
<span class="fc" id="L741">			String query = url.getRawQuery();</span>
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">			resource = (query != null ? resource.substring(0, resource.indexOf('?')) : resource);</span>
<span class="fc" id="L743">			throw new ResourceAccessException(&quot;I/O error on &quot; + method.name() +</span>
<span class="fc" id="L744">					&quot; request for \&quot;&quot; + resource + &quot;\&quot;: &quot; + ex.getMessage(), ex);</span>
		}
		finally {
<span class="fc bfc" id="L747" title="All 2 branches covered.">			if (response != null) {</span>
<span class="fc" id="L748">				response.close();</span>
			}
		}
	}

	/**
	 * Handle the given response, performing appropriate logging and
	 * invoking the {@link ResponseErrorHandler} if necessary.
	 * &lt;p&gt;Can be overridden in subclasses.
	 * @param url the fully-expanded URL to connect to
	 * @param method the HTTP method to execute (GET, POST, etc.)
	 * @param response the resulting {@link ClientHttpResponse}
	 * @throws IOException if propagated from {@link ResponseErrorHandler}
	 * @since 4.1.6
	 * @see #setErrorHandler
	 */
	protected void handleResponse(URI url, HttpMethod method, ClientHttpResponse response) throws IOException {
<span class="fc" id="L765">		ResponseErrorHandler errorHandler = getErrorHandler();</span>
<span class="fc" id="L766">		boolean hasError = errorHandler.hasError(response);</span>
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
			try {
<span class="fc" id="L769">				int code = response.getRawStatusCode();</span>
<span class="fc" id="L770">				HttpStatus status = HttpStatus.resolve(code);</span>
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">				logger.debug(&quot;Response &quot; + (status != null ? status : code));</span>
			}
<span class="nc" id="L773">			catch (IOException ex) {</span>
				// ignore
<span class="fc" id="L775">			}</span>
		}
<span class="fc bfc" id="L777" title="All 2 branches covered.">		if (hasError) {</span>
<span class="nc" id="L778">			errorHandler.handleError(url, method, response);</span>
		}
<span class="fc" id="L780">	}</span>

	/**
	 * Return a {@code RequestCallback} that sets the request {@code Accept}
	 * header based on the given response type, cross-checked against the
	 * configured message converters.
	 */
	public &lt;T&gt; RequestCallback acceptHeaderRequestCallback(Class&lt;T&gt; responseType) {
<span class="fc" id="L788">		return new AcceptHeaderRequestCallback(responseType);</span>
	}

	/**
	 * Return a {@code RequestCallback} implementation that writes the given
	 * object to the request stream.
	 */
	public &lt;T&gt; RequestCallback httpEntityCallback(@Nullable Object requestBody) {
<span class="fc" id="L796">		return new HttpEntityRequestCallback(requestBody);</span>
	}

	/**
	 * Return a {@code RequestCallback} implementation that:
	 * &lt;ol&gt;
	 * &lt;li&gt;Sets the request {@code Accept} header based on the given response
	 * type, cross-checked against the configured message converters.
	 * &lt;li&gt;Writes the given object to the request stream.
	 * &lt;/ol&gt;
	 */
	public &lt;T&gt; RequestCallback httpEntityCallback(@Nullable Object requestBody, Type responseType) {
<span class="fc" id="L808">		return new HttpEntityRequestCallback(requestBody, responseType);</span>
	}

	/**
	 * Return a {@code ResponseExtractor} that prepares a {@link ResponseEntity}.
	 */
	public &lt;T&gt; ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseEntityExtractor(Type responseType) {
<span class="fc" id="L815">		return new ResponseEntityResponseExtractor&lt;&gt;(responseType);</span>
	}

	/**
	 * Return a response extractor for {@link HttpHeaders}.
	 */
	protected ResponseExtractor&lt;HttpHeaders&gt; headersExtractor() {
<span class="fc" id="L822">		return this.headersExtractor;</span>
	}

	private static &lt;T&gt; T nonNull(@Nullable T result) {
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">		Assert.state(result != null, &quot;No result&quot;);</span>
<span class="fc" id="L827">		return result;</span>
	}


	/**
	 * Request callback implementation that prepares the request's accept headers.
	 */
	private class AcceptHeaderRequestCallback implements RequestCallback {

		@Nullable
		private final Type responseType;

<span class="fc" id="L839">		public AcceptHeaderRequestCallback(@Nullable Type responseType) {</span>
<span class="fc" id="L840">			this.responseType = responseType;</span>
<span class="fc" id="L841">		}</span>

		@Override
		public void doWithRequest(ClientHttpRequest request) throws IOException {
<span class="fc bfc" id="L845" title="All 2 branches covered.">			if (this.responseType != null) {</span>
<span class="fc" id="L846">				List&lt;MediaType&gt; allSupportedMediaTypes = getMessageConverters().stream()</span>
<span class="fc" id="L847">						.filter(converter -&gt; canReadResponse(this.responseType, converter))</span>
<span class="fc" id="L848">						.flatMap(this::getSupportedMediaTypes)</span>
<span class="fc" id="L849">						.distinct()</span>
<span class="fc" id="L850">						.sorted(MediaType.SPECIFICITY_COMPARATOR)</span>
<span class="fc" id="L851">						.collect(Collectors.toList());</span>
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">				if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L853">					logger.debug(&quot;Accept=&quot; + allSupportedMediaTypes);</span>
				}
<span class="fc" id="L855">				request.getHeaders().setAccept(allSupportedMediaTypes);</span>
			}
<span class="fc" id="L857">		}</span>

		private boolean canReadResponse(Type responseType, HttpMessageConverter&lt;?&gt; converter) {
<span class="fc bfc" id="L860" title="All 2 branches covered.">			Class&lt;?&gt; responseClass = (responseType instanceof Class ? (Class&lt;?&gt;) responseType : null);</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">			if (responseClass != null) {</span>
<span class="fc" id="L862">				return converter.canRead(responseClass, null);</span>
			}
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">			else if (converter instanceof GenericHttpMessageConverter) {</span>
<span class="fc" id="L865">				GenericHttpMessageConverter&lt;?&gt; genericConverter = (GenericHttpMessageConverter&lt;?&gt;) converter;</span>
<span class="fc" id="L866">				return genericConverter.canRead(responseType, null, null);</span>
			}
<span class="nc" id="L868">			return false;</span>
		}

		private Stream&lt;MediaType&gt; getSupportedMediaTypes(HttpMessageConverter&lt;?&gt; messageConverter) {
<span class="fc" id="L872">			return messageConverter.getSupportedMediaTypes()</span>
<span class="fc" id="L873">					.stream()</span>
<span class="fc" id="L874">					.map(mediaType -&gt; {</span>
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">						if (mediaType.getCharset() != null) {</span>
<span class="nc" id="L876">							return new MediaType(mediaType.getType(), mediaType.getSubtype());</span>
						}
<span class="fc" id="L878">						return mediaType;</span>
					});
		}
	}


	/**
	 * Request callback implementation that writes the given object to the request stream.
	 */
	private class HttpEntityRequestCallback extends AcceptHeaderRequestCallback {

		private final HttpEntity&lt;?&gt; requestEntity;

		public HttpEntityRequestCallback(@Nullable Object requestBody) {
<span class="fc" id="L892">			this(requestBody, null);</span>
<span class="fc" id="L893">		}</span>

<span class="fc" id="L895">		public HttpEntityRequestCallback(@Nullable Object requestBody, @Nullable Type responseType) {</span>
<span class="fc" id="L896">			super(responseType);</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">			if (requestBody instanceof HttpEntity) {</span>
<span class="fc" id="L898">				this.requestEntity = (HttpEntity&lt;?&gt;) requestBody;</span>
			}
<span class="fc bfc" id="L900" title="All 2 branches covered.">			else if (requestBody != null) {</span>
<span class="fc" id="L901">				this.requestEntity = new HttpEntity&lt;&gt;(requestBody);</span>
			}
			else {
<span class="fc" id="L904">				this.requestEntity = HttpEntity.EMPTY;</span>
			}
<span class="fc" id="L906">		}</span>

		@Override
		@SuppressWarnings(&quot;unchecked&quot;)
		public void doWithRequest(ClientHttpRequest httpRequest) throws IOException {
<span class="fc" id="L911">			super.doWithRequest(httpRequest);</span>
<span class="fc" id="L912">			Object requestBody = this.requestEntity.getBody();</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">			if (requestBody == null) {</span>
<span class="fc" id="L914">				HttpHeaders httpHeaders = httpRequest.getHeaders();</span>
<span class="fc" id="L915">				HttpHeaders requestHeaders = this.requestEntity.getHeaders();</span>
<span class="fc bfc" id="L916" title="All 2 branches covered.">				if (!requestHeaders.isEmpty()) {</span>
<span class="fc" id="L917">					requestHeaders.forEach((key, values) -&gt; httpHeaders.put(key, new LinkedList&lt;&gt;(values)));</span>
				}
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">				if (httpHeaders.getContentLength() &lt; 0) {</span>
<span class="fc" id="L920">					httpHeaders.setContentLength(0L);</span>
				}
<span class="fc" id="L922">			}</span>
			else {
<span class="fc" id="L924">				Class&lt;?&gt; requestBodyClass = requestBody.getClass();</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">				Type requestBodyType = (this.requestEntity instanceof RequestEntity ?</span>
<span class="fc" id="L926">						((RequestEntity&lt;?&gt;)this.requestEntity).getType() : requestBodyClass);</span>
<span class="fc" id="L927">				HttpHeaders httpHeaders = httpRequest.getHeaders();</span>
<span class="fc" id="L928">				HttpHeaders requestHeaders = this.requestEntity.getHeaders();</span>
<span class="fc" id="L929">				MediaType requestContentType = requestHeaders.getContentType();</span>
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">				for (HttpMessageConverter&lt;?&gt; messageConverter : getMessageConverters()) {</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">					if (messageConverter instanceof GenericHttpMessageConverter) {</span>
<span class="fc" id="L932">						GenericHttpMessageConverter&lt;Object&gt; genericConverter =</span>
								(GenericHttpMessageConverter&lt;Object&gt;) messageConverter;
<span class="fc bfc" id="L934" title="All 2 branches covered.">						if (genericConverter.canWrite(requestBodyType, requestBodyClass, requestContentType)) {</span>
<span class="pc bpc" id="L935" title="1 of 2 branches missed.">							if (!requestHeaders.isEmpty()) {</span>
<span class="fc" id="L936">								requestHeaders.forEach((key, values) -&gt; httpHeaders.put(key, new LinkedList&lt;&gt;(values)));</span>
							}
<span class="fc" id="L938">							logBody(requestBody, requestContentType, genericConverter);</span>
<span class="fc" id="L939">							genericConverter.write(requestBody, requestBodyType, requestContentType, httpRequest);</span>
<span class="fc" id="L940">							return;</span>
						}
<span class="fc" id="L942">					}</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">					else if (messageConverter.canWrite(requestBodyClass, requestContentType)) {</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">						if (!requestHeaders.isEmpty()) {</span>
<span class="fc" id="L945">							requestHeaders.forEach((key, values) -&gt; httpHeaders.put(key, new LinkedList&lt;&gt;(values)));</span>
						}
<span class="fc" id="L947">						logBody(requestBody, requestContentType, messageConverter);</span>
<span class="fc" id="L948">						((HttpMessageConverter&lt;Object&gt;) messageConverter).write(</span>
								requestBody, requestContentType, httpRequest);
<span class="fc" id="L950">						return;</span>
					}
<span class="fc" id="L952">				}</span>
<span class="nc" id="L953">				String message = &quot;No HttpMessageConverter for [&quot; + requestBodyClass.getName() + &quot;]&quot;;</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">				if (requestContentType != null) {</span>
<span class="nc" id="L955">					message += &quot; and content type [&quot; + requestContentType + &quot;]&quot;;</span>
				}
<span class="nc" id="L957">				throw new RestClientException(message);</span>
			}
<span class="fc" id="L959">		}</span>

		private void logBody(Object body, @Nullable MediaType mediaType, HttpMessageConverter&lt;?&gt; converter) {
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">				if (mediaType != null) {</span>
<span class="fc" id="L964">					logger.debug(&quot;Writing [&quot; + body + &quot;] as \&quot;&quot; + mediaType + &quot;\&quot;&quot;);</span>
				}
				else {
<span class="fc" id="L967">					String classname = converter.getClass().getName();</span>
<span class="fc" id="L968">					logger.debug(&quot;Writing [&quot; + body + &quot;] with &quot; + classname);</span>
				}
			}
<span class="fc" id="L971">		}</span>
	}


	/**
	 * Response extractor for {@link HttpEntity}.
	 */
	private class ResponseEntityResponseExtractor&lt;T&gt; implements ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; {

		@Nullable
		private final HttpMessageConverterExtractor&lt;T&gt; delegate;

<span class="fc" id="L983">		public ResponseEntityResponseExtractor(@Nullable Type responseType) {</span>
<span class="pc bpc" id="L984" title="1 of 4 branches missed.">			if (responseType != null &amp;&amp; Void.class != responseType) {</span>
<span class="fc" id="L985">				this.delegate = new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger);</span>
			}
			else {
<span class="fc" id="L988">				this.delegate = null;</span>
			}
<span class="fc" id="L990">		}</span>

		@Override
		public ResponseEntity&lt;T&gt; extractData(ClientHttpResponse response) throws IOException {
<span class="fc bfc" id="L994" title="All 2 branches covered.">			if (this.delegate != null) {</span>
<span class="fc" id="L995">				T body = this.delegate.extractData(response);</span>
<span class="fc" id="L996">				return ResponseEntity.status(response.getRawStatusCode()).headers(response.getHeaders()).body(body);</span>
			}
			else {
<span class="fc" id="L999">				return ResponseEntity.status(response.getRawStatusCode()).headers(response.getHeaders()).build();</span>
			}
		}
	}


	/**
	 * Response extractor that extracts the response {@link HttpHeaders}.
	 */
	private static class HeadersExtractor implements ResponseExtractor&lt;HttpHeaders&gt; {

		@Override
		public HttpHeaders extractData(ClientHttpResponse response) {
<span class="fc" id="L1012">			return response.getHeaders();</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>