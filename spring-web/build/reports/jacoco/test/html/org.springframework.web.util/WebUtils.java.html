<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WebUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-web</a> &gt; <a href="index.source.html" class="el_package">org.springframework.web.util</a> &gt; <span class="el_source">WebUtils.java</span></div><h1>WebUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.util;

import java.io.File;
import java.io.FileNotFoundException;
import java.net.URI;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.TreeMap;
import javax.servlet.ServletContext;
import javax.servlet.ServletRequest;
import javax.servlet.ServletRequestWrapper;
import javax.servlet.ServletResponse;
import javax.servlet.ServletResponseWrapper;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpRequest;
import org.springframework.http.server.ServletServerHttpRequest;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;

/**
 * Miscellaneous utilities for web applications.
 * Used by various framework classes.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Sebastien Deleuze
 */
<span class="nc" id="L56">public abstract class WebUtils {</span>

	/**
	 * Standard Servlet 2.3+ spec request attribute for include request URI.
	 * &lt;p&gt;If included via a {@code RequestDispatcher}, the current resource will see the
	 * originating request. Its own request URI is exposed as a request attribute.
	 */
	public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = &quot;javax.servlet.include.request_uri&quot;;

	/**
	 * Standard Servlet 2.3+ spec request attribute for include context path.
	 * &lt;p&gt;If included via a {@code RequestDispatcher}, the current resource will see the
	 * originating context path. Its own context path is exposed as a request attribute.
	 */
	public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = &quot;javax.servlet.include.context_path&quot;;

	/**
	 * Standard Servlet 2.3+ spec request attribute for include servlet path.
	 * &lt;p&gt;If included via a {@code RequestDispatcher}, the current resource will see the
	 * originating servlet path. Its own servlet path is exposed as a request attribute.
	 */
	public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = &quot;javax.servlet.include.servlet_path&quot;;

	/**
	 * Standard Servlet 2.3+ spec request attribute for include path info.
	 * &lt;p&gt;If included via a {@code RequestDispatcher}, the current resource will see the
	 * originating path info. Its own path info is exposed as a request attribute.
	 */
	public static final String INCLUDE_PATH_INFO_ATTRIBUTE = &quot;javax.servlet.include.path_info&quot;;

	/**
	 * Standard Servlet 2.3+ spec request attribute for include query string.
	 * &lt;p&gt;If included via a {@code RequestDispatcher}, the current resource will see the
	 * originating query string. Its own query string is exposed as a request attribute.
	 */
	public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = &quot;javax.servlet.include.query_string&quot;;

	/**
	 * Standard Servlet 2.4+ spec request attribute for forward request URI.
	 * &lt;p&gt;If forwarded to via a RequestDispatcher, the current resource will see its
	 * own request URI. The originating request URI is exposed as a request attribute.
	 */
	public static final String FORWARD_REQUEST_URI_ATTRIBUTE = &quot;javax.servlet.forward.request_uri&quot;;

	/**
	 * Standard Servlet 2.4+ spec request attribute for forward context path.
	 * &lt;p&gt;If forwarded to via a RequestDispatcher, the current resource will see its
	 * own context path. The originating context path is exposed as a request attribute.
	 */
	public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = &quot;javax.servlet.forward.context_path&quot;;

	/**
	 * Standard Servlet 2.4+ spec request attribute for forward servlet path.
	 * &lt;p&gt;If forwarded to via a RequestDispatcher, the current resource will see its
	 * own servlet path. The originating servlet path is exposed as a request attribute.
	 */
	public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = &quot;javax.servlet.forward.servlet_path&quot;;

	/**
	 * Standard Servlet 2.4+ spec request attribute for forward path info.
	 * &lt;p&gt;If forwarded to via a RequestDispatcher, the current resource will see its
	 * own path ingo. The originating path info is exposed as a request attribute.
	 */
	public static final String FORWARD_PATH_INFO_ATTRIBUTE = &quot;javax.servlet.forward.path_info&quot;;

	/**
	 * Standard Servlet 2.4+ spec request attribute for forward query string.
	 * &lt;p&gt;If forwarded to via a RequestDispatcher, the current resource will see its
	 * own query string. The originating query string is exposed as a request attribute.
	 */
	public static final String FORWARD_QUERY_STRING_ATTRIBUTE = &quot;javax.servlet.forward.query_string&quot;;

	/**
	 * Standard Servlet 2.3+ spec request attribute for error page status code.
	 * &lt;p&gt;To be exposed to JSPs that are marked as error pages, when forwarding
	 * to them directly rather than through the servlet container's error page
	 * resolution mechanism.
	 */
	public static final String ERROR_STATUS_CODE_ATTRIBUTE = &quot;javax.servlet.error.status_code&quot;;

	/**
	 * Standard Servlet 2.3+ spec request attribute for error page exception type.
	 * &lt;p&gt;To be exposed to JSPs that are marked as error pages, when forwarding
	 * to them directly rather than through the servlet container's error page
	 * resolution mechanism.
	 */
	public static final String ERROR_EXCEPTION_TYPE_ATTRIBUTE = &quot;javax.servlet.error.exception_type&quot;;

	/**
	 * Standard Servlet 2.3+ spec request attribute for error page message.
	 * &lt;p&gt;To be exposed to JSPs that are marked as error pages, when forwarding
	 * to them directly rather than through the servlet container's error page
	 * resolution mechanism.
	 */
	public static final String ERROR_MESSAGE_ATTRIBUTE = &quot;javax.servlet.error.message&quot;;

	/**
	 * Standard Servlet 2.3+ spec request attribute for error page exception.
	 * &lt;p&gt;To be exposed to JSPs that are marked as error pages, when forwarding
	 * to them directly rather than through the servlet container's error page
	 * resolution mechanism.
	 */
	public static final String ERROR_EXCEPTION_ATTRIBUTE = &quot;javax.servlet.error.exception&quot;;

	/**
	 * Standard Servlet 2.3+ spec request attribute for error page request URI.
	 * &lt;p&gt;To be exposed to JSPs that are marked as error pages, when forwarding
	 * to them directly rather than through the servlet container's error page
	 * resolution mechanism.
	 */
	public static final String ERROR_REQUEST_URI_ATTRIBUTE = &quot;javax.servlet.error.request_uri&quot;;

	/**
	 * Standard Servlet 2.3+ spec request attribute for error page servlet name.
	 * &lt;p&gt;To be exposed to JSPs that are marked as error pages, when forwarding
	 * to them directly rather than through the servlet container's error page
	 * resolution mechanism.
	 */
	public static final String ERROR_SERVLET_NAME_ATTRIBUTE = &quot;javax.servlet.error.servlet_name&quot;;

	/**
	 * Prefix of the charset clause in a content type String: &quot;;charset=&quot;.
	 */
	public static final String CONTENT_TYPE_CHARSET_PREFIX = &quot;;charset=&quot;;

	/**
	 * Default character encoding to use when {@code request.getCharacterEncoding}
	 * returns {@code null}, according to the Servlet spec.
	 * @see ServletRequest#getCharacterEncoding
	 */
	public static final String DEFAULT_CHARACTER_ENCODING = &quot;ISO-8859-1&quot;;

	/**
	 * Standard Servlet spec context attribute that specifies a temporary
	 * directory for the current web application, of type {@code java.io.File}.
	 */
	public static final String TEMP_DIR_CONTEXT_ATTRIBUTE = &quot;javax.servlet.context.tempdir&quot;;

	/**
	 * HTML escape parameter at the servlet context level
	 * (i.e. a context-param in {@code web.xml}): &quot;defaultHtmlEscape&quot;.
	 */
	public static final String HTML_ESCAPE_CONTEXT_PARAM = &quot;defaultHtmlEscape&quot;;

	/**
	 * Use of response encoding for HTML escaping parameter at the servlet context level
	 * (i.e. a context-param in {@code web.xml}): &quot;responseEncodedHtmlEscape&quot;.
	 * @since 4.1.2
	 */
	public static final String RESPONSE_ENCODED_HTML_ESCAPE_CONTEXT_PARAM = &quot;responseEncodedHtmlEscape&quot;;

	/**
	 * Web app root key parameter at the servlet context level
	 * (i.e. a context-param in {@code web.xml}): &quot;webAppRootKey&quot;.
	 */
	public static final String WEB_APP_ROOT_KEY_PARAM = &quot;webAppRootKey&quot;;

	/** Default web app root key: &quot;webapp.root&quot;. */
	public static final String DEFAULT_WEB_APP_ROOT_KEY = &quot;webapp.root&quot;;

	/** Name suffixes in case of image buttons. */
<span class="fc" id="L217">	public static final String[] SUBMIT_IMAGE_SUFFIXES = {&quot;.x&quot;, &quot;.y&quot;};</span>

	/** Key for the mutex session attribute. */
<span class="fc" id="L220">	public static final String SESSION_MUTEX_ATTRIBUTE = WebUtils.class.getName() + &quot;.MUTEX&quot;;</span>


	/**
	 * Set a system property to the web application root directory.
	 * The key of the system property can be defined with the &quot;webAppRootKey&quot;
	 * context-param in {@code web.xml}. Default is &quot;webapp.root&quot;.
	 * &lt;p&gt;Can be used for tools that support substitution with {@code System.getProperty}
	 * values, like log4j's &quot;${key}&quot; syntax within log file locations.
	 * @param servletContext the servlet context of the web application
	 * @throws IllegalStateException if the system property is already set,
	 * or if the WAR file is not expanded
	 * @see #WEB_APP_ROOT_KEY_PARAM
	 * @see #DEFAULT_WEB_APP_ROOT_KEY
	 * @see WebAppRootListener
	 */
	public static void setWebAppRootSystemProperty(ServletContext servletContext) throws IllegalStateException {
<span class="nc" id="L237">		Assert.notNull(servletContext, &quot;ServletContext must not be null&quot;);</span>
<span class="nc" id="L238">		String root = servletContext.getRealPath(&quot;/&quot;);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">		if (root == null) {</span>
<span class="nc" id="L240">			throw new IllegalStateException(</span>
					&quot;Cannot set web app root system property when WAR file is not expanded&quot;);
		}
<span class="nc" id="L243">		String param = servletContext.getInitParameter(WEB_APP_ROOT_KEY_PARAM);</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">		String key = (param != null ? param : DEFAULT_WEB_APP_ROOT_KEY);</span>
<span class="nc" id="L245">		String oldValue = System.getProperty(key);</span>
<span class="nc bnc" id="L246" title="All 4 branches missed.">		if (oldValue != null &amp;&amp; !StringUtils.pathEquals(oldValue, root)) {</span>
<span class="nc" id="L247">			throw new IllegalStateException(&quot;Web app root system property already set to different value: '&quot; +</span>
					key + &quot;' = [&quot; + oldValue + &quot;] instead of [&quot; + root + &quot;] - &quot; +
					&quot;Choose unique values for the 'webAppRootKey' context-param in your web.xml files!&quot;);
		}
<span class="nc" id="L251">		System.setProperty(key, root);</span>
<span class="nc" id="L252">		servletContext.log(&quot;Set web app root system property: '&quot; + key + &quot;' = [&quot; + root + &quot;]&quot;);</span>
<span class="nc" id="L253">	}</span>

	/**
	 * Remove the system property that points to the web app root directory.
	 * To be called on shutdown of the web application.
	 * @param servletContext the servlet context of the web application
	 * @see #setWebAppRootSystemProperty
	 */
	public static void removeWebAppRootSystemProperty(ServletContext servletContext) {
<span class="nc" id="L262">		Assert.notNull(servletContext, &quot;ServletContext must not be null&quot;);</span>
<span class="nc" id="L263">		String param = servletContext.getInitParameter(WEB_APP_ROOT_KEY_PARAM);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">		String key = (param != null ? param : DEFAULT_WEB_APP_ROOT_KEY);</span>
<span class="nc" id="L265">		System.getProperties().remove(key);</span>
<span class="nc" id="L266">	}</span>

	/**
	 * Return whether default HTML escaping is enabled for the web application,
	 * i.e. the value of the &quot;defaultHtmlEscape&quot; context-param in {@code web.xml}
	 * (if any).
	 * &lt;p&gt;This method differentiates between no param specified at all and
	 * an actual boolean value specified, allowing to have a context-specific
	 * default in case of no setting at the global level.
	 * @param servletContext the servlet context of the web application
	 * @return whether default HTML escaping is enabled for the given application
	 * ({@code null} = no explicit default)
	 */
	@Nullable
	public static Boolean getDefaultHtmlEscape(@Nullable ServletContext servletContext) {
<span class="nc bnc" id="L281" title="All 2 branches missed.">		if (servletContext == null) {</span>
<span class="nc" id="L282">			return null;</span>
		}
<span class="nc" id="L284">		String param = servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">		return (StringUtils.hasText(param) ? Boolean.valueOf(param) : null);</span>
	}

	/**
	 * Return whether response encoding should be used when HTML escaping characters,
	 * thus only escaping XML markup significant characters with UTF-* encodings.
	 * This option is enabled for the web application with a ServletContext param,
	 * i.e. the value of the &quot;responseEncodedHtmlEscape&quot; context-param in {@code web.xml}
	 * (if any).
	 * &lt;p&gt;This method differentiates between no param specified at all and
	 * an actual boolean value specified, allowing to have a context-specific
	 * default in case of no setting at the global level.
	 * @param servletContext the servlet context of the web application
	 * @return whether response encoding is to be used for HTML escaping
	 * ({@code null} = no explicit default)
	 * @since 4.1.2
	 */
	@Nullable
	public static Boolean getResponseEncodedHtmlEscape(@Nullable ServletContext servletContext) {
<span class="nc bnc" id="L304" title="All 2 branches missed.">		if (servletContext == null) {</span>
<span class="nc" id="L305">			return null;</span>
		}
<span class="nc" id="L307">		String param = servletContext.getInitParameter(RESPONSE_ENCODED_HTML_ESCAPE_CONTEXT_PARAM);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">		return (StringUtils.hasText(param) ? Boolean.valueOf(param) : null);</span>
	}

	/**
	 * Return the temporary directory for the current web application,
	 * as provided by the servlet container.
	 * @param servletContext the servlet context of the web application
	 * @return the File representing the temporary directory
	 */
	public static File getTempDir(ServletContext servletContext) {
<span class="fc" id="L318">		Assert.notNull(servletContext, &quot;ServletContext must not be null&quot;);</span>
<span class="fc" id="L319">		return (File) servletContext.getAttribute(TEMP_DIR_CONTEXT_ATTRIBUTE);</span>
	}

	/**
	 * Return the real path of the given path within the web application,
	 * as provided by the servlet container.
	 * &lt;p&gt;Prepends a slash if the path does not already start with a slash,
	 * and throws a FileNotFoundException if the path cannot be resolved to
	 * a resource (in contrast to ServletContext's {@code getRealPath},
	 * which returns null).
	 * @param servletContext the servlet context of the web application
	 * @param path the path within the web application
	 * @return the corresponding real path
	 * @throws FileNotFoundException if the path cannot be resolved to a resource
	 * @see javax.servlet.ServletContext#getRealPath
	 */
	public static String getRealPath(ServletContext servletContext, String path) throws FileNotFoundException {
<span class="nc" id="L336">		Assert.notNull(servletContext, &quot;ServletContext must not be null&quot;);</span>
		// Interpret location as relative to the web application root directory.
<span class="nc bnc" id="L338" title="All 2 branches missed.">		if (!path.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L339">			path = &quot;/&quot; + path;</span>
		}
<span class="nc" id="L341">		String realPath = servletContext.getRealPath(path);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">		if (realPath == null) {</span>
<span class="nc" id="L343">			throw new FileNotFoundException(</span>
					&quot;ServletContext resource [&quot; + path + &quot;] cannot be resolved to absolute file path - &quot; +
					&quot;web application archive not expanded?&quot;);
		}
<span class="nc" id="L347">		return realPath;</span>
	}

	/**
	 * Determine the session id of the given request, if any.
	 * @param request current HTTP request
	 * @return the session id, or {@code null} if none
	 */
	@Nullable
	public static String getSessionId(HttpServletRequest request) {
<span class="nc" id="L357">		Assert.notNull(request, &quot;Request must not be null&quot;);</span>
<span class="nc" id="L358">		HttpSession session = request.getSession(false);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">		return (session != null ? session.getId() : null);</span>
	}

	/**
	 * Check the given request for a session attribute of the given name.
	 * Returns null if there is no session or if the session has no such attribute.
	 * Does not create a new session if none has existed before!
	 * @param request current HTTP request
	 * @param name the name of the session attribute
	 * @return the value of the session attribute, or {@code null} if not found
	 */
	@Nullable
	public static Object getSessionAttribute(HttpServletRequest request, String name) {
<span class="nc" id="L372">		Assert.notNull(request, &quot;Request must not be null&quot;);</span>
<span class="nc" id="L373">		HttpSession session = request.getSession(false);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">		return (session != null ? session.getAttribute(name) : null);</span>
	}

	/**
	 * Check the given request for a session attribute of the given name.
	 * Throws an exception if there is no session or if the session has no such
	 * attribute. Does not create a new session if none has existed before!
	 * @param request current HTTP request
	 * @param name the name of the session attribute
	 * @return the value of the session attribute, or {@code null} if not found
	 * @throws IllegalStateException if the session attribute could not be found
	 */
	public static Object getRequiredSessionAttribute(HttpServletRequest request, String name)
			throws IllegalStateException {

<span class="nc" id="L389">		Object attr = getSessionAttribute(request, name);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">		if (attr == null) {</span>
<span class="nc" id="L391">			throw new IllegalStateException(&quot;No session attribute '&quot; + name + &quot;' found&quot;);</span>
		}
<span class="nc" id="L393">		return attr;</span>
	}

	/**
	 * Set the session attribute with the given name to the given value.
	 * Removes the session attribute if value is null, if a session existed at all.
	 * Does not create a new session if not necessary!
	 * @param request current HTTP request
	 * @param name the name of the session attribute
	 * @param value the value of the session attribute
	 */
	public static void setSessionAttribute(HttpServletRequest request, String name, @Nullable Object value) {
<span class="nc" id="L405">		Assert.notNull(request, &quot;Request must not be null&quot;);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">		if (value != null) {</span>
<span class="nc" id="L407">			request.getSession().setAttribute(name, value);</span>
		}
		else {
<span class="nc" id="L410">			HttpSession session = request.getSession(false);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">			if (session != null) {</span>
<span class="nc" id="L412">				session.removeAttribute(name);</span>
			}
		}
<span class="nc" id="L415">	}</span>

	/**
	 * Return the best available mutex for the given session:
	 * that is, an object to synchronize on for the given session.
	 * &lt;p&gt;Returns the session mutex attribute if available; usually,
	 * this means that the HttpSessionMutexListener needs to be defined
	 * in {@code web.xml}. Falls back to the HttpSession itself
	 * if no mutex attribute found.
	 * &lt;p&gt;The session mutex is guaranteed to be the same object during
	 * the entire lifetime of the session, available under the key defined
	 * by the {@code SESSION_MUTEX_ATTRIBUTE} constant. It serves as a
	 * safe reference to synchronize on for locking on the current session.
	 * &lt;p&gt;In many cases, the HttpSession reference itself is a safe mutex
	 * as well, since it will always be the same object reference for the
	 * same active logical session. However, this is not guaranteed across
	 * different servlet containers; the only 100% safe way is a session mutex.
	 * @param session the HttpSession to find a mutex for
	 * @return the mutex object (never {@code null})
	 * @see #SESSION_MUTEX_ATTRIBUTE
	 * @see HttpSessionMutexListener
	 */
	public static Object getSessionMutex(HttpSession session) {
<span class="fc" id="L438">		Assert.notNull(session, &quot;Session must not be null&quot;);</span>
<span class="fc" id="L439">		Object mutex = session.getAttribute(SESSION_MUTEX_ATTRIBUTE);</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">		if (mutex == null) {</span>
<span class="fc" id="L441">			mutex = session;</span>
		}
<span class="fc" id="L443">		return mutex;</span>
	}


	/**
	 * Return an appropriate request object of the specified type, if available,
	 * unwrapping the given request as far as necessary.
	 * @param request the servlet request to introspect
	 * @param requiredType the desired type of request object
	 * @return the matching request object, or {@code null} if none
	 * of that type is available
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	@Nullable
	public static &lt;T&gt; T getNativeRequest(ServletRequest request, @Nullable Class&lt;T&gt; requiredType) {
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">		if (requiredType != null) {</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">			if (requiredType.isInstance(request)) {</span>
<span class="fc" id="L460">				return (T) request;</span>
			}
<span class="fc bfc" id="L462" title="All 2 branches covered.">			else if (request instanceof ServletRequestWrapper) {</span>
<span class="fc" id="L463">				return getNativeRequest(((ServletRequestWrapper) request).getRequest(), requiredType);</span>
			}
		}
<span class="fc" id="L466">		return null;</span>
	}

	/**
	 * Return an appropriate response object of the specified type, if available,
	 * unwrapping the given response as far as necessary.
	 * @param response the servlet response to introspect
	 * @param requiredType the desired type of response object
	 * @return the matching response object, or {@code null} if none
	 * of that type is available
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	@Nullable
	public static &lt;T&gt; T getNativeResponse(ServletResponse response, @Nullable Class&lt;T&gt; requiredType) {
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">		if (requiredType != null) {</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">			if (requiredType.isInstance(response)) {</span>
<span class="fc" id="L482">				return (T) response;</span>
			}
<span class="fc bfc" id="L484" title="All 2 branches covered.">			else if (response instanceof ServletResponseWrapper) {</span>
<span class="fc" id="L485">				return getNativeResponse(((ServletResponseWrapper) response).getResponse(), requiredType);</span>
			}
		}
<span class="fc" id="L488">		return null;</span>
	}

	/**
	 * Determine whether the given request is an include request,
	 * that is, not a top-level HTTP request coming in from the outside.
	 * &lt;p&gt;Checks the presence of the &quot;javax.servlet.include.request_uri&quot;
	 * request attribute. Could check any request attribute that is only
	 * present in an include request.
	 * @param request current servlet request
	 * @return whether the given request is an include request
	 */
	public static boolean isIncludeRequest(ServletRequest request) {
<span class="nc bnc" id="L501" title="All 2 branches missed.">		return (request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE) != null);</span>
	}

	/**
	 * Expose the Servlet spec's error attributes as {@link javax.servlet.http.HttpServletRequest}
	 * attributes under the keys defined in the Servlet 2.3 specification, for error pages that
	 * are rendered directly rather than through the Servlet container's error page resolution:
	 * {@code javax.servlet.error.status_code},
	 * {@code javax.servlet.error.exception_type},
	 * {@code javax.servlet.error.message},
	 * {@code javax.servlet.error.exception},
	 * {@code javax.servlet.error.request_uri},
	 * {@code javax.servlet.error.servlet_name}.
	 * &lt;p&gt;Does not override values if already present, to respect attribute values
	 * that have been exposed explicitly before.
	 * &lt;p&gt;Exposes status code 200 by default. Set the &quot;javax.servlet.error.status_code&quot;
	 * attribute explicitly (before or after) in order to expose a different status code.
	 * @param request current servlet request
	 * @param ex the exception encountered
	 * @param servletName the name of the offending servlet
	 */
	public static void exposeErrorRequestAttributes(HttpServletRequest request, Throwable ex,
			@Nullable String servletName) {

<span class="nc" id="L525">		exposeRequestAttributeIfNotPresent(request, ERROR_STATUS_CODE_ATTRIBUTE, HttpServletResponse.SC_OK);</span>
<span class="nc" id="L526">		exposeRequestAttributeIfNotPresent(request, ERROR_EXCEPTION_TYPE_ATTRIBUTE, ex.getClass());</span>
<span class="nc" id="L527">		exposeRequestAttributeIfNotPresent(request, ERROR_MESSAGE_ATTRIBUTE, ex.getMessage());</span>
<span class="nc" id="L528">		exposeRequestAttributeIfNotPresent(request, ERROR_EXCEPTION_ATTRIBUTE, ex);</span>
<span class="nc" id="L529">		exposeRequestAttributeIfNotPresent(request, ERROR_REQUEST_URI_ATTRIBUTE, request.getRequestURI());</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">		if (servletName != null) {</span>
<span class="nc" id="L531">			exposeRequestAttributeIfNotPresent(request, ERROR_SERVLET_NAME_ATTRIBUTE, servletName);</span>
		}
<span class="nc" id="L533">	}</span>

	/**
	 * Expose the specified request attribute if not already present.
	 * @param request current servlet request
	 * @param name the name of the attribute
	 * @param value the suggested value of the attribute
	 */
	private static void exposeRequestAttributeIfNotPresent(ServletRequest request, String name, Object value) {
<span class="nc bnc" id="L542" title="All 2 branches missed.">		if (request.getAttribute(name) == null) {</span>
<span class="nc" id="L543">			request.setAttribute(name, value);</span>
		}
<span class="nc" id="L545">	}</span>

	/**
	 * Clear the Servlet spec's error attributes as {@link javax.servlet.http.HttpServletRequest}
	 * attributes under the keys defined in the Servlet 2.3 specification:
	 * {@code javax.servlet.error.status_code},
	 * {@code javax.servlet.error.exception_type},
	 * {@code javax.servlet.error.message},
	 * {@code javax.servlet.error.exception},
	 * {@code javax.servlet.error.request_uri},
	 * {@code javax.servlet.error.servlet_name}.
	 * @param request current servlet request
	 */
	public static void clearErrorRequestAttributes(HttpServletRequest request) {
<span class="nc" id="L559">		request.removeAttribute(ERROR_STATUS_CODE_ATTRIBUTE);</span>
<span class="nc" id="L560">		request.removeAttribute(ERROR_EXCEPTION_TYPE_ATTRIBUTE);</span>
<span class="nc" id="L561">		request.removeAttribute(ERROR_MESSAGE_ATTRIBUTE);</span>
<span class="nc" id="L562">		request.removeAttribute(ERROR_EXCEPTION_ATTRIBUTE);</span>
<span class="nc" id="L563">		request.removeAttribute(ERROR_REQUEST_URI_ATTRIBUTE);</span>
<span class="nc" id="L564">		request.removeAttribute(ERROR_SERVLET_NAME_ATTRIBUTE);</span>
<span class="nc" id="L565">	}</span>

	/**
	 * Retrieve the first cookie with the given name. Note that multiple
	 * cookies can have the same name but different paths or domains.
	 * @param request current servlet request
	 * @param name cookie name
	 * @return the first cookie with the given name, or {@code null} if none is found
	 */
	@Nullable
	public static Cookie getCookie(HttpServletRequest request, String name) {
<span class="nc" id="L576">		Assert.notNull(request, &quot;Request must not be null&quot;);</span>
<span class="nc" id="L577">		Cookie[] cookies = request.getCookies();</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">		if (cookies != null) {</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">			for (Cookie cookie : cookies) {</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">				if (name.equals(cookie.getName())) {</span>
<span class="nc" id="L581">					return cookie;</span>
				}
			}
		}
<span class="nc" id="L585">		return null;</span>
	}

	/**
	 * Check if a specific input type=&quot;submit&quot; parameter was sent in the request,
	 * either via a button (directly with name) or via an image (name + &quot;.x&quot; or
	 * name + &quot;.y&quot;).
	 * @param request current HTTP request
	 * @param name name of the parameter
	 * @return if the parameter was sent
	 * @see #SUBMIT_IMAGE_SUFFIXES
	 */
	public static boolean hasSubmitParameter(ServletRequest request, String name) {
<span class="nc" id="L598">		Assert.notNull(request, &quot;Request must not be null&quot;);</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">		if (request.getParameter(name) != null) {</span>
<span class="nc" id="L600">			return true;</span>
		}
<span class="nc bnc" id="L602" title="All 2 branches missed.">		for (String suffix : SUBMIT_IMAGE_SUFFIXES) {</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">			if (request.getParameter(name + suffix) != null) {</span>
<span class="nc" id="L604">				return true;</span>
			}
		}
<span class="nc" id="L607">		return false;</span>
	}

	/**
	 * Obtain a named parameter from the given request parameters.
	 * &lt;p&gt;See {@link #findParameterValue(java.util.Map, String)}
	 * for a description of the lookup algorithm.
	 * @param request current HTTP request
	 * @param name the &lt;i&gt;logical&lt;/i&gt; name of the request parameter
	 * @return the value of the parameter, or {@code null}
	 * if the parameter does not exist in given request
	 */
	@Nullable
	public static String findParameterValue(ServletRequest request, String name) {
<span class="nc" id="L621">		return findParameterValue(request.getParameterMap(), name);</span>
	}

	/**
	 * Obtain a named parameter from the given request parameters.
	 * &lt;p&gt;This method will try to obtain a parameter value using the
	 * following algorithm:
	 * &lt;ol&gt;
	 * &lt;li&gt;Try to get the parameter value using just the given &lt;i&gt;logical&lt;/i&gt; name.
	 * This handles parameters of the form &lt;tt&gt;logicalName = value&lt;/tt&gt;. For normal
	 * parameters, e.g. submitted using a hidden HTML form field, this will return
	 * the requested value.&lt;/li&gt;
	 * &lt;li&gt;Try to obtain the parameter value from the parameter name, where the
	 * parameter name in the request is of the form &lt;tt&gt;logicalName_value = xyz&lt;/tt&gt;
	 * with &quot;_&quot; being the configured delimiter. This deals with parameter values
	 * submitted using an HTML form submit button.&lt;/li&gt;
	 * &lt;li&gt;If the value obtained in the previous step has a &quot;.x&quot; or &quot;.y&quot; suffix,
	 * remove that. This handles cases where the value was submitted using an
	 * HTML form image button. In this case the parameter in the request would
	 * actually be of the form &lt;tt&gt;logicalName_value.x = 123&lt;/tt&gt;. &lt;/li&gt;
	 * &lt;/ol&gt;
	 * @param parameters the available parameter map
	 * @param name the &lt;i&gt;logical&lt;/i&gt; name of the request parameter
	 * @return the value of the parameter, or {@code null}
	 * if the parameter does not exist in given request
	 */
	@Nullable
	public static String findParameterValue(Map&lt;String, ?&gt; parameters, String name) {
		// First try to get it as a normal name=value parameter
<span class="fc" id="L650">		Object value = parameters.get(name);</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">		if (value instanceof String[]) {</span>
<span class="nc" id="L652">			String[] values = (String[]) value;</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">			return (values.length &gt; 0 ? values[0] : null);</span>
		}
<span class="fc bfc" id="L655" title="All 2 branches covered.">		else if (value != null) {</span>
<span class="fc" id="L656">			return value.toString();</span>
		}
		// If no value yet, try to get it as a name_value=xyz parameter
<span class="fc" id="L659">		String prefix = name + &quot;_&quot;;</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">		for (String paramName : parameters.keySet()) {</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">			if (paramName.startsWith(prefix)) {</span>
				// Support images buttons, which would submit parameters as name_value.x=123
<span class="fc bfc" id="L663" title="All 2 branches covered.">				for (String suffix : SUBMIT_IMAGE_SUFFIXES) {</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">					if (paramName.endsWith(suffix)) {</span>
<span class="fc" id="L665">						return paramName.substring(prefix.length(), paramName.length() - suffix.length());</span>
					}
				}
<span class="fc" id="L668">				return paramName.substring(prefix.length());</span>
			}
<span class="fc" id="L670">		}</span>
		// We couldn't find the parameter value...
<span class="fc" id="L672">		return null;</span>
	}

	/**
	 * Return a map containing all parameters with the given prefix.
	 * Maps single values to String and multiple values to String array.
	 * &lt;p&gt;For example, with a prefix of &quot;spring_&quot;, &quot;spring_param1&quot; and
	 * &quot;spring_param2&quot; result in a Map with &quot;param1&quot; and &quot;param2&quot; as keys.
	 * @param request the HTTP request in which to look for parameters
	 * @param prefix the beginning of parameter names
	 * (if this is null or the empty string, all parameters will match)
	 * @return map containing request parameters &lt;b&gt;without the prefix&lt;/b&gt;,
	 * containing either a String or a String array as values
	 * @see javax.servlet.ServletRequest#getParameterNames
	 * @see javax.servlet.ServletRequest#getParameterValues
	 * @see javax.servlet.ServletRequest#getParameterMap
	 */
	public static Map&lt;String, Object&gt; getParametersStartingWith(ServletRequest request, @Nullable String prefix) {
<span class="fc" id="L690">		Assert.notNull(request, &quot;Request must not be null&quot;);</span>
<span class="fc" id="L691">		Enumeration&lt;String&gt; paramNames = request.getParameterNames();</span>
<span class="fc" id="L692">		Map&lt;String, Object&gt; params = new TreeMap&lt;&gt;();</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">		if (prefix == null) {</span>
<span class="fc" id="L694">			prefix = &quot;&quot;;</span>
		}
<span class="pc bpc" id="L696" title="1 of 4 branches missed.">		while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {</span>
<span class="fc" id="L697">			String paramName = paramNames.nextElement();</span>
<span class="pc bpc" id="L698" title="1 of 4 branches missed.">			if (prefix.isEmpty() || paramName.startsWith(prefix)) {</span>
<span class="fc" id="L699">				String unprefixed = paramName.substring(prefix.length());</span>
<span class="fc" id="L700">				String[] values = request.getParameterValues(paramName);</span>
<span class="pc bpc" id="L701" title="2 of 4 branches missed.">				if (values == null || values.length == 0) {</span>
					// Do nothing, no values found at all.
				}
<span class="fc bfc" id="L704" title="All 2 branches covered.">				else if (values.length &gt; 1) {</span>
<span class="fc" id="L705">					params.put(unprefixed, values);</span>
				}
				else {
<span class="fc" id="L708">					params.put(unprefixed, values[0]);</span>
				}
			}
<span class="fc" id="L711">		}</span>
<span class="fc" id="L712">		return params;</span>
	}

	/**
	 * Parse the given string with matrix variables. An example string would look
	 * like this {@code &quot;q1=a;q1=b;q2=a,b,c&quot;}. The resulting map would contain
	 * keys {@code &quot;q1&quot;} and {@code &quot;q2&quot;} with values {@code [&quot;a&quot;,&quot;b&quot;]} and
	 * {@code [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]} respectively.
	 * @param matrixVariables the unparsed matrix variables string
	 * @return a map with matrix variable names and values (never {@code null})
	 * @since 3.2
	 */
	public static MultiValueMap&lt;String, String&gt; parseMatrixVariables(String matrixVariables) {
<span class="fc" id="L725">		MultiValueMap&lt;String, String&gt; result = new LinkedMultiValueMap&lt;&gt;();</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">		if (!StringUtils.hasText(matrixVariables)) {</span>
<span class="fc" id="L727">			return result;</span>
		}
<span class="fc" id="L729">		StringTokenizer pairs = new StringTokenizer(matrixVariables, &quot;;&quot;);</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">		while (pairs.hasMoreTokens()) {</span>
<span class="fc" id="L731">			String pair = pairs.nextToken();</span>
<span class="fc" id="L732">			int index = pair.indexOf('=');</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">			if (index != -1) {</span>
<span class="fc" id="L734">				String name = pair.substring(0, index);</span>
<span class="fc" id="L735">				String rawValue = pair.substring(index + 1);</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">				for (String value : StringUtils.commaDelimitedListToStringArray(rawValue)) {</span>
<span class="fc" id="L737">					result.add(name, value);</span>
				}
<span class="fc" id="L739">			}</span>
			else {
<span class="fc" id="L741">				result.add(pair, &quot;&quot;);</span>
			}
<span class="fc" id="L743">		}</span>
<span class="fc" id="L744">		return result;</span>
	}

	/**
	 * Check the given request origin against a list of allowed origins.
	 * A list containing &quot;*&quot; means that all origins are allowed.
	 * An empty list means only same origin is allowed.
	 *
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; as of 5.1 this method ignores
	 * {@code &quot;Forwarded&quot;} and {@code &quot;X-Forwarded-*&quot;} headers that specify the
	 * client-originated address. Consider using the {@code ForwardedHeaderFilter}
	 * to extract and use, or to discard such headers.
	 *
	 * @return {@code true} if the request origin is valid, {@code false} otherwise
	 * @since 4.1.5
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc6454&quot;&gt;RFC 6454: The Web Origin Concept&lt;/a&gt;
	 */
	public static boolean isValidOrigin(HttpRequest request, Collection&lt;String&gt; allowedOrigins) {
<span class="fc" id="L762">		Assert.notNull(request, &quot;Request must not be null&quot;);</span>
<span class="fc" id="L763">		Assert.notNull(allowedOrigins, &quot;Allowed origins must not be null&quot;);</span>

<span class="fc" id="L765">		String origin = request.getHeaders().getOrigin();</span>
<span class="pc bpc" id="L766" title="1 of 4 branches missed.">		if (origin == null || allowedOrigins.contains(&quot;*&quot;)) {</span>
<span class="fc" id="L767">			return true;</span>
		}
<span class="fc bfc" id="L769" title="All 2 branches covered.">		else if (CollectionUtils.isEmpty(allowedOrigins)) {</span>
<span class="fc" id="L770">			return isSameOrigin(request);</span>
		}
		else {
<span class="fc" id="L773">			return allowedOrigins.contains(origin);</span>
		}
	}

	/**
	 * Check if the request is a same-origin one, based on {@code Origin}, {@code Host},
	 * {@code Forwarded}, {@code X-Forwarded-Proto}, {@code X-Forwarded-Host} and
	 * {@code X-Forwarded-Port} headers.
	 *
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; as of 5.1 this method ignores
	 * {@code &quot;Forwarded&quot;} and {@code &quot;X-Forwarded-*&quot;} headers that specify the
	 * client-originated address. Consider using the {@code ForwardedHeaderFilter}
	 * to extract and use, or to discard such headers.

	 * @return {@code true} if the request is a same-origin one, {@code false} in case
	 * of cross-origin request
	 * @since 4.2
	 */
	public static boolean isSameOrigin(HttpRequest request) {
<span class="fc" id="L792">		HttpHeaders headers = request.getHeaders();</span>
<span class="fc" id="L793">		String origin = headers.getOrigin();</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">		if (origin == null) {</span>
<span class="nc" id="L795">			return true;</span>
		}

		String scheme;
		String host;
		int port;
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">		if (request instanceof ServletServerHttpRequest) {</span>
			// Build more efficiently if we can: we only need scheme, host, port for origin comparison
<span class="fc" id="L803">			HttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest();</span>
<span class="fc" id="L804">			scheme = servletRequest.getScheme();</span>
<span class="fc" id="L805">			host = servletRequest.getServerName();</span>
<span class="fc" id="L806">			port = servletRequest.getServerPort();</span>
<span class="fc" id="L807">		}</span>
		else {
<span class="nc" id="L809">			URI uri = request.getURI();</span>
<span class="nc" id="L810">			scheme = uri.getScheme();</span>
<span class="nc" id="L811">			host = uri.getHost();</span>
<span class="nc" id="L812">			port = uri.getPort();</span>
		}

<span class="fc" id="L815">		UriComponents originUrl = UriComponentsBuilder.fromOriginHeader(origin).build();</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">		return (ObjectUtils.nullSafeEquals(scheme, originUrl.getScheme()) &amp;&amp;</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">				ObjectUtils.nullSafeEquals(host, originUrl.getHost()) &amp;&amp;</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">				getPort(scheme, port) == getPort(originUrl.getScheme(), originUrl.getPort()));</span>
	}

	private static int getPort(@Nullable String scheme, int port) {
<span class="fc bfc" id="L822" title="All 2 branches covered.">		if (port == -1) {</span>
<span class="fc bfc" id="L823" title="All 4 branches covered.">			if (&quot;http&quot;.equals(scheme) || &quot;ws&quot;.equals(scheme)) {</span>
<span class="fc" id="L824">				port = 80;</span>
			}
<span class="pc bpc" id="L826" title="1 of 4 branches missed.">			else if (&quot;https&quot;.equals(scheme) || &quot;wss&quot;.equals(scheme)) {</span>
<span class="fc" id="L827">				port = 443;</span>
			}
		}
<span class="fc" id="L830">		return port;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>