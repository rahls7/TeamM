<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AspectJAdviceParameterNameDiscoverer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-aop</a> &gt; <a href="index.source.html" class="el_package">org.springframework.aop.aspectj</a> &gt; <span class="el_source">AspectJAdviceParameterNameDiscoverer.java</span></div><h1>AspectJAdviceParameterNameDiscoverer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.aop.aspectj;

import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.weaver.tools.PointcutParser;
import org.aspectj.weaver.tools.PointcutPrimitive;

import org.springframework.core.ParameterNameDiscoverer;
import org.springframework.lang.Nullable;
import org.springframework.util.StringUtils;

/**
 * {@link ParameterNameDiscoverer} implementation that tries to deduce parameter names
 * for an advice method from the pointcut expression, returning, and throwing clauses.
 * If an unambiguous interpretation is not available, it returns {@code null}.
 *
 * &lt;p&gt;This class interprets arguments in the following way:
 * &lt;ol&gt;
 * &lt;li&gt;If the first parameter of the method is of type {@link JoinPoint}
 * or {@link ProceedingJoinPoint}, it is assumed to be for passing
 * {@code thisJoinPoint} to the advice, and the parameter name will
 * be assigned the value {@code &quot;thisJoinPoint&quot;}.&lt;/li&gt;
 * &lt;li&gt;If the first parameter of the method is of type
 * {@code JoinPoint.StaticPart}, it is assumed to be for passing
 * {@code &quot;thisJoinPointStaticPart&quot;} to the advice, and the parameter name
 * will be assigned the value {@code &quot;thisJoinPointStaticPart&quot;}.&lt;/li&gt;
 * &lt;li&gt;If a {@link #setThrowingName(String) throwingName} has been set, and
 * there are no unbound arguments of type {@code Throwable+}, then an
 * {@link IllegalArgumentException} is raised. If there is more than one
 * unbound argument of type {@code Throwable+}, then an
 * {@link AmbiguousBindingException} is raised. If there is exactly one
 * unbound argument of type {@code Throwable+}, then the corresponding
 * parameter name is assigned the value &amp;lt;throwingName&amp;gt;.&lt;/li&gt;
 * &lt;li&gt;If there remain unbound arguments, then the pointcut expression is
 * examined. Let {@code a} be the number of annotation-based pointcut
 * expressions (&amp;#64;annotation, &amp;#64;this, &amp;#64;target, &amp;#64;args,
 * &amp;#64;within, &amp;#64;withincode) that are used in binding form. Usage in
 * binding form has itself to be deduced: if the expression inside the
 * pointcut is a single string literal that meets Java variable name
 * conventions it is assumed to be a variable name. If {@code a} is
 * zero we proceed to the next stage. If {@code a} &amp;gt; 1 then an
 * {@code AmbiguousBindingException} is raised. If {@code a} == 1,
 * and there are no unbound arguments of type {@code Annotation+},
 * then an {@code IllegalArgumentException} is raised. if there is
 * exactly one such argument, then the corresponding parameter name is
 * assigned the value from the pointcut expression.&lt;/li&gt;
 * &lt;li&gt;If a returningName has been set, and there are no unbound arguments
 * then an {@code IllegalArgumentException} is raised. If there is
 * more than one unbound argument then an
 * {@code AmbiguousBindingException} is raised. If there is exactly
 * one unbound argument then the corresponding parameter name is assigned
 * the value &amp;lt;returningName&amp;gt;.&lt;/li&gt;
 * &lt;li&gt;If there remain unbound arguments, then the pointcut expression is
 * examined once more for {@code this}, {@code target}, and
 * {@code args} pointcut expressions used in the binding form (binding
 * forms are deduced as described for the annotation based pointcuts). If
 * there remains more than one unbound argument of a primitive type (which
 * can only be bound in {@code args}) then an
 * {@code AmbiguousBindingException} is raised. If there is exactly
 * one argument of a primitive type, then if exactly one {@code args}
 * bound variable was found, we assign the corresponding parameter name
 * the variable name. If there were no {@code args} bound variables
 * found an {@code IllegalStateException} is raised. If there are
 * multiple {@code args} bound variables, an
 * {@code AmbiguousBindingException} is raised. At this point, if
 * there remains more than one unbound argument we raise an
 * {@code AmbiguousBindingException}. If there are no unbound arguments
 * remaining, we are done. If there is exactly one unbound argument
 * remaining, and only one candidate variable name unbound from
 * {@code this}, {@code target}, or {@code args}, it is
 * assigned as the corresponding parameter name. If there are multiple
 * possibilities, an {@code AmbiguousBindingException} is raised.&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * &lt;p&gt;The behavior on raising an {@code IllegalArgumentException} or
 * {@code AmbiguousBindingException} is configurable to allow this discoverer
 * to be used as part of a chain-of-responsibility. By default the condition will
 * be logged and the {@code getParameterNames(..)} method will simply return
 * {@code null}. If the {@link #setRaiseExceptions(boolean) raiseExceptions}
 * property is set to {@code true}, the conditions will be thrown as
 * {@code IllegalArgumentException} and {@code AmbiguousBindingException},
 * respectively.
 *
 * &lt;p&gt;Was that perfectly clear? ;)
 *
 * &lt;p&gt;Short version: If an unambiguous binding can be deduced, then it is.
 * If the advice requirements cannot possibly be satisfied, then {@code null}
 * is returned. By setting the {@link #setRaiseExceptions(boolean) raiseExceptions}
 * property to {@code true}, descriptive exceptions will be thrown instead of
 * returning {@code null} in the case that the parameter names cannot be discovered.
 *
 * @author Adrian Colyer
 * @author Juergen Hoeller
 * @since 2.0
 */
public class AspectJAdviceParameterNameDiscoverer implements ParameterNameDiscoverer {

	private static final String THIS_JOIN_POINT = &quot;thisJoinPoint&quot;;
	private static final String THIS_JOIN_POINT_STATIC_PART = &quot;thisJoinPointStaticPart&quot;;

	// Steps in the binding algorithm...
	private static final int STEP_JOIN_POINT_BINDING = 1;
	private static final int STEP_THROWING_BINDING = 2;
	private static final int STEP_ANNOTATION_BINDING = 3;
	private static final int STEP_RETURNING_BINDING = 4;
	private static final int STEP_PRIMITIVE_ARGS_BINDING = 5;
	private static final int STEP_THIS_TARGET_ARGS_BINDING = 6;
	private static final int STEP_REFERENCE_PCUT_BINDING = 7;
	private static final int STEP_FINISHED = 8;

<span class="fc" id="L135">	private static final Set&lt;String&gt; singleValuedAnnotationPcds = new HashSet&lt;&gt;();</span>
<span class="fc" id="L136">	private static final Set&lt;String&gt; nonReferencePointcutTokens = new HashSet&lt;&gt;();</span>


	static {
<span class="fc" id="L140">		singleValuedAnnotationPcds.add(&quot;@this&quot;);</span>
<span class="fc" id="L141">		singleValuedAnnotationPcds.add(&quot;@target&quot;);</span>
<span class="fc" id="L142">		singleValuedAnnotationPcds.add(&quot;@within&quot;);</span>
<span class="fc" id="L143">		singleValuedAnnotationPcds.add(&quot;@withincode&quot;);</span>
<span class="fc" id="L144">		singleValuedAnnotationPcds.add(&quot;@annotation&quot;);</span>

<span class="fc" id="L146">		Set&lt;PointcutPrimitive&gt; pointcutPrimitives = PointcutParser.getAllSupportedPointcutPrimitives();</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">		for (PointcutPrimitive primitive : pointcutPrimitives) {</span>
<span class="fc" id="L148">			nonReferencePointcutTokens.add(primitive.getName());</span>
<span class="fc" id="L149">		}</span>
<span class="fc" id="L150">		nonReferencePointcutTokens.add(&quot;&amp;&amp;&quot;);</span>
<span class="fc" id="L151">		nonReferencePointcutTokens.add(&quot;!&quot;);</span>
<span class="fc" id="L152">		nonReferencePointcutTokens.add(&quot;||&quot;);</span>
<span class="fc" id="L153">		nonReferencePointcutTokens.add(&quot;and&quot;);</span>
<span class="fc" id="L154">		nonReferencePointcutTokens.add(&quot;or&quot;);</span>
<span class="fc" id="L155">		nonReferencePointcutTokens.add(&quot;not&quot;);</span>
<span class="fc" id="L156">	}</span>


	/** The pointcut expression associated with the advice, as a simple String. */
	@Nullable
	private String pointcutExpression;

	private boolean raiseExceptions;

	/** If the advice is afterReturning, and binds the return value, this is the parameter name used. */
	@Nullable
	private String returningName;

	/** If the advice is afterThrowing, and binds the thrown value, this is the parameter name used. */
	@Nullable
	private String throwingName;

<span class="fc" id="L173">	private Class&lt;?&gt;[] argumentTypes = new Class&lt;?&gt;[0];</span>

<span class="fc" id="L175">	private String[] parameterNameBindings = new String[0];</span>

	private int numberOfRemainingUnboundArguments;


	/**
	 * Create a new discoverer that attempts to discover parameter names.
	 * from the given pointcut expression.
	 */
<span class="fc" id="L184">	public AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression) {</span>
<span class="fc" id="L185">		this.pointcutExpression = pointcutExpression;</span>
<span class="fc" id="L186">	}</span>


	/**
	 * Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}
	 * must be thrown as appropriate in the case of failing to deduce advice parameter names.
	 * @param raiseExceptions {@code true} if exceptions are to be thrown
	 */
	public void setRaiseExceptions(boolean raiseExceptions) {
<span class="fc" id="L195">		this.raiseExceptions = raiseExceptions;</span>
<span class="fc" id="L196">	}</span>

	/**
	 * If {@code afterReturning} advice binds the return value, the
	 * returning variable name must be specified.
	 * @param returningName the name of the returning variable
	 */
	public void setReturningName(@Nullable String returningName) {
<span class="fc" id="L204">		this.returningName = returningName;</span>
<span class="fc" id="L205">	}</span>

	/**
	 * If {@code afterThrowing} advice binds the thrown value, the
	 * throwing variable name must be specified.
	 * @param throwingName the name of the throwing variable
	 */
	public void setThrowingName(@Nullable String throwingName) {
<span class="fc" id="L213">		this.throwingName = throwingName;</span>
<span class="fc" id="L214">	}</span>


	/**
	 * Deduce the parameter names for an advice method.
	 * &lt;p&gt;See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}
	 * for this class for details of the algorithm used.
	 * @param method the target {@link Method}
	 * @return the parameter names
	 */
	@Override
	@Nullable
	public String[] getParameterNames(Method method) {
<span class="fc" id="L227">		this.argumentTypes = method.getParameterTypes();</span>
<span class="fc" id="L228">		this.numberOfRemainingUnboundArguments = this.argumentTypes.length;</span>
<span class="fc" id="L229">		this.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments];</span>

<span class="fc" id="L231">		int minimumNumberUnboundArgs = 0;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">		if (this.returningName != null) {</span>
<span class="fc" id="L233">			minimumNumberUnboundArgs++;</span>
		}
<span class="fc bfc" id="L235" title="All 2 branches covered.">		if (this.throwingName != null) {</span>
<span class="fc" id="L236">			minimumNumberUnboundArgs++;</span>
		}
<span class="fc bfc" id="L238" title="All 2 branches covered.">		if (this.numberOfRemainingUnboundArguments &lt; minimumNumberUnboundArgs) {</span>
<span class="fc" id="L239">			throw new IllegalStateException(</span>
					&quot;Not enough arguments in method to satisfy binding of returning and throwing variables&quot;);
		}

		try {
<span class="fc" id="L244">			int algorithmicStep = STEP_JOIN_POINT_BINDING;</span>
<span class="fc bfc" id="L245" title="All 4 branches covered.">			while ((this.numberOfRemainingUnboundArguments &gt; 0) &amp;&amp; algorithmicStep &lt; STEP_FINISHED) {</span>
<span class="pc bpc" id="L246" title="1 of 8 branches missed.">				switch (algorithmicStep++) {</span>
					case STEP_JOIN_POINT_BINDING:
<span class="fc bfc" id="L248" title="All 2 branches covered.">						if (!maybeBindThisJoinPoint()) {</span>
<span class="fc" id="L249">							maybeBindThisJoinPointStaticPart();</span>
						}
						break;
					case STEP_THROWING_BINDING:
<span class="fc" id="L253">						maybeBindThrowingVariable();</span>
<span class="fc" id="L254">						break;</span>
					case STEP_ANNOTATION_BINDING:
<span class="fc" id="L256">						maybeBindAnnotationsFromPointcutExpression();</span>
<span class="fc" id="L257">						break;</span>
					case STEP_RETURNING_BINDING:
<span class="fc" id="L259">						maybeBindReturningVariable();</span>
<span class="fc" id="L260">						break;</span>
					case STEP_PRIMITIVE_ARGS_BINDING:
<span class="fc" id="L262">						maybeBindPrimitiveArgsFromPointcutExpression();</span>
<span class="fc" id="L263">						break;</span>
					case STEP_THIS_TARGET_ARGS_BINDING:
<span class="fc" id="L265">						maybeBindThisOrTargetOrArgsFromPointcutExpression();</span>
<span class="fc" id="L266">						break;</span>
					case STEP_REFERENCE_PCUT_BINDING:
<span class="fc" id="L268">						maybeBindReferencePointcutParameter();</span>
<span class="fc" id="L269">						break;</span>
					default:
<span class="nc" id="L271">						throw new IllegalStateException(&quot;Unknown algorithmic step: &quot; + (algorithmicStep - 1));</span>
				}
			}
		}
<span class="fc" id="L275">		catch (AmbiguousBindingException | IllegalArgumentException ex) {</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">			if (this.raiseExceptions) {</span>
<span class="fc" id="L277">				throw ex;</span>
			}
			else {
<span class="nc" id="L280">				return null;</span>
			}
<span class="fc" id="L282">		}</span>

<span class="fc bfc" id="L284" title="All 2 branches covered.">		if (this.numberOfRemainingUnboundArguments == 0) {</span>
<span class="fc" id="L285">			return this.parameterNameBindings;</span>
		}
		else {
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">			if (this.raiseExceptions) {</span>
<span class="fc" id="L289">				throw new IllegalStateException(&quot;Failed to bind all argument names: &quot; +</span>
						this.numberOfRemainingUnboundArguments + &quot; argument(s) could not be bound&quot;);
			}
			else {
				// convention for failing is to return null, allowing participation in a chain of responsibility
<span class="nc" id="L294">				return null;</span>
			}
		}
	}

	/**
	 * An advice method can never be a constructor in Spring.
	 * @return {@code null}
	 * @throws UnsupportedOperationException if
	 * {@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true}
	 */
	@Override
	@Nullable
	public String[] getParameterNames(Constructor&lt;?&gt; ctor) {
<span class="nc bnc" id="L308" title="All 2 branches missed.">		if (this.raiseExceptions) {</span>
<span class="nc" id="L309">			throw new UnsupportedOperationException(&quot;An advice method can never be a constructor&quot;);</span>
		}
		else {
			// we return null rather than throw an exception so that we behave well
			// in a chain-of-responsibility.
<span class="nc" id="L314">			return null;</span>
		}
	}


	private void bindParameterName(int index, String name) {
<span class="fc" id="L320">		this.parameterNameBindings[index] = name;</span>
<span class="fc" id="L321">		this.numberOfRemainingUnboundArguments--;</span>
<span class="fc" id="L322">	}</span>

	/**
	 * If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind &quot;thisJoinPoint&quot; as
	 * parameter name and return true, else return false.
	 */
	private boolean maybeBindThisJoinPoint() {
<span class="fc bfc" id="L329" title="All 4 branches covered.">		if ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {</span>
<span class="fc" id="L330">			bindParameterName(0, THIS_JOIN_POINT);</span>
<span class="fc" id="L331">			return true;</span>
		}
		else {
<span class="fc" id="L334">			return false;</span>
		}
	}

	private void maybeBindThisJoinPointStaticPart() {
<span class="fc bfc" id="L339" title="All 2 branches covered.">		if (this.argumentTypes[0] == JoinPoint.StaticPart.class) {</span>
<span class="fc" id="L340">			bindParameterName(0, THIS_JOIN_POINT_STATIC_PART);</span>
		}
<span class="fc" id="L342">	}</span>

	/**
	 * If a throwing name was specified and there is exactly one choice remaining
	 * (argument that is a subtype of Throwable) then bind it.
	 */
	private void maybeBindThrowingVariable() {
<span class="fc bfc" id="L349" title="All 2 branches covered.">		if (this.throwingName == null) {</span>
<span class="fc" id="L350">			return;</span>
		}

		// So there is binding work to do...
<span class="fc" id="L354">		int throwableIndex = -1;</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">		for (int i = 0; i &lt; this.argumentTypes.length; i++) {</span>
<span class="fc bfc" id="L356" title="All 4 branches covered.">			if (isUnbound(i) &amp;&amp; isSubtypeOf(Throwable.class, i)) {</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">				if (throwableIndex == -1) {</span>
<span class="fc" id="L358">					throwableIndex = i;</span>
				}
				else {
					// Second candidate we've found - ambiguous binding
<span class="fc" id="L362">					throw new AmbiguousBindingException(&quot;Binding of throwing parameter '&quot; +</span>
							this.throwingName + &quot;' is ambiguous: could be bound to argument &quot; +
							throwableIndex + &quot; or argument &quot; + i);
				}
			}
		}

<span class="pc bpc" id="L369" title="1 of 2 branches missed.">		if (throwableIndex == -1) {</span>
<span class="nc" id="L370">			throw new IllegalStateException(&quot;Binding of throwing parameter '&quot; + this.throwingName</span>
					+ &quot;' could not be completed as no available arguments are a subtype of Throwable&quot;);
		}
		else {
<span class="fc" id="L374">			bindParameterName(throwableIndex, this.throwingName);</span>
		}
<span class="fc" id="L376">	}</span>

	/**
	 * If a returning variable was specified and there is only one choice remaining, bind it.
	 */
	private void maybeBindReturningVariable() {
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">		if (this.numberOfRemainingUnboundArguments == 0) {</span>
<span class="nc" id="L383">			throw new IllegalStateException(</span>
					&quot;Algorithm assumes that there must be at least one unbound parameter on entry to this method&quot;);
		}

<span class="fc bfc" id="L387" title="All 2 branches covered.">		if (this.returningName != null) {</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">			if (this.numberOfRemainingUnboundArguments &gt; 1) {</span>
<span class="fc" id="L389">				throw new AmbiguousBindingException(&quot;Binding of returning parameter '&quot; + this.returningName +</span>
						&quot;' is ambiguous, there are &quot; + this.numberOfRemainingUnboundArguments + &quot; candidates.&quot;);
			}

			// We're all set... find the unbound parameter, and bind it.
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">			for (int i = 0; i &lt; this.parameterNameBindings.length; i++) {</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">				if (this.parameterNameBindings[i] == null) {</span>
<span class="fc" id="L396">					bindParameterName(i, this.returningName);</span>
<span class="fc" id="L397">					break;</span>
				}
			}
		}
<span class="fc" id="L401">	}</span>


	/**
	 * Parse the string pointcut expression looking for:
	 * &amp;#64;this, &amp;#64;target, &amp;#64;args, &amp;#64;within, &amp;#64;withincode, &amp;#64;annotation.
	 * If we find one of these pointcut expressions, try and extract a candidate variable
	 * name (or variable names, in the case of args).
	 * &lt;p&gt;Some more support from AspectJ in doing this exercise would be nice... :)
	 */
	private void maybeBindAnnotationsFromPointcutExpression() {
<span class="fc" id="L412">		List&lt;String&gt; varNames = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L413">		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, &quot; &quot;);</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">		for (int i = 0; i &lt; tokens.length; i++) {</span>
<span class="fc" id="L415">			String toMatch = tokens[i];</span>
<span class="fc" id="L416">			int firstParenIndex = toMatch.indexOf('(');</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">			if (firstParenIndex != -1) {</span>
<span class="fc" id="L418">				toMatch = toMatch.substring(0, firstParenIndex);</span>
			}
<span class="fc bfc" id="L420" title="All 2 branches covered.">			if (singleValuedAnnotationPcds.contains(toMatch)) {</span>
<span class="fc" id="L421">				PointcutBody body = getPointcutBody(tokens, i);</span>
<span class="fc" id="L422">				i += body.numTokensConsumed;</span>
<span class="fc" id="L423">				String varName = maybeExtractVariableName(body.text);</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">				if (varName != null) {</span>
<span class="fc" id="L425">					varNames.add(varName);</span>
				}
<span class="fc" id="L427">			}</span>
<span class="pc bpc" id="L428" title="1 of 4 branches missed.">			else if (tokens[i].startsWith(&quot;@args(&quot;) || tokens[i].equals(&quot;@args&quot;)) {</span>
<span class="fc" id="L429">				PointcutBody body = getPointcutBody(tokens, i);</span>
<span class="fc" id="L430">				i += body.numTokensConsumed;</span>
<span class="fc" id="L431">				maybeExtractVariableNamesFromArgs(body.text, varNames);</span>
			}
		}

<span class="fc" id="L435">		bindAnnotationsFromVarNames(varNames);</span>
<span class="fc" id="L436">	}</span>

	/**
	 * Match the given list of extracted variable names to argument slots.
	 */
	private void bindAnnotationsFromVarNames(List&lt;String&gt; varNames) {
<span class="fc bfc" id="L442" title="All 2 branches covered.">		if (!varNames.isEmpty()) {</span>
			// we have work to do...
<span class="fc" id="L444">			int numAnnotationSlots = countNumberOfUnboundAnnotationArguments();</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">			if (numAnnotationSlots &gt; 1) {</span>
<span class="fc" id="L446">				throw new AmbiguousBindingException(&quot;Found &quot; + varNames.size() +</span>
						&quot; potential annotation variable(s), and &quot; +
						numAnnotationSlots + &quot; potential argument slots&quot;);
			}
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">			else if (numAnnotationSlots == 1) {</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">				if (varNames.size() == 1) {</span>
					// it's a match
<span class="fc" id="L453">					findAndBind(Annotation.class, varNames.get(0));</span>
				}
				else {
					// multiple candidate vars, but only one slot
<span class="fc" id="L457">					throw new IllegalArgumentException(&quot;Found &quot; + varNames.size() +</span>
							&quot; candidate annotation binding variables&quot; +
							&quot; but only one potential argument binding slot&quot;);
				}
			}
			else {
				// no slots so presume those candidate vars were actually type names
			}
		}
<span class="fc" id="L466">	}</span>

	/*
	 * If the token starts meets Java identifier conventions, it's in.
	 */
	@Nullable
	private String maybeExtractVariableName(@Nullable String candidateToken) {
<span class="fc bfc" id="L473" title="All 2 branches covered.">		if (!StringUtils.hasLength(candidateToken)) {</span>
<span class="fc" id="L474">			return null;</span>
		}
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">		if (Character.isJavaIdentifierStart(candidateToken.charAt(0)) &amp;&amp;</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">				Character.isLowerCase(candidateToken.charAt(0))) {</span>
<span class="fc" id="L478">			char[] tokenChars = candidateToken.toCharArray();</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">			for (char tokenChar : tokenChars) {</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">				if (!Character.isJavaIdentifierPart(tokenChar)) {</span>
<span class="fc" id="L481">					return null;</span>
				}
			}
<span class="fc" id="L484">			return candidateToken;</span>
		}
		else {
<span class="nc" id="L487">			return null;</span>
		}
	}

	/**
	 * Given an args pointcut body (could be {@code args} or {@code at_args}),
	 * add any candidate variable names to the given list.
	 */
	private void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List&lt;String&gt; varNames) {
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">		if (argsSpec == null) {</span>
<span class="nc" id="L497">			return;</span>
		}
<span class="fc" id="L499">		String[] tokens = StringUtils.tokenizeToStringArray(argsSpec, &quot;,&quot;);</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">		for (int i = 0; i &lt; tokens.length; i++) {</span>
<span class="fc" id="L501">			tokens[i] = StringUtils.trimWhitespace(tokens[i]);</span>
<span class="fc" id="L502">			String varName = maybeExtractVariableName(tokens[i]);</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">			if (varName != null) {</span>
<span class="fc" id="L504">				varNames.add(varName);</span>
			}
		}
<span class="fc" id="L507">	}</span>

	/**
	 * Parse the string pointcut expression looking for this(), target() and args() expressions.
	 * If we find one, try and extract a candidate variable name and bind it.
	 */
	private void maybeBindThisOrTargetOrArgsFromPointcutExpression() {
<span class="fc bfc" id="L514" title="All 2 branches covered.">		if (this.numberOfRemainingUnboundArguments &gt; 1) {</span>
<span class="fc" id="L515">			throw new AmbiguousBindingException(&quot;Still &quot; + this.numberOfRemainingUnboundArguments</span>
					+ &quot; unbound args at this(),target(),args() binding stage, with no way to determine between them&quot;);
		}

<span class="fc" id="L519">		List&lt;String&gt; varNames = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L520">		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, &quot; &quot;);</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">		for (int i = 0; i &lt; tokens.length; i++) {</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">			if (tokens[i].equals(&quot;this&quot;) ||</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">					tokens[i].startsWith(&quot;this(&quot;) ||</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">					tokens[i].equals(&quot;target&quot;) ||</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">					tokens[i].startsWith(&quot;target(&quot;)) {</span>
<span class="fc" id="L526">				PointcutBody body = getPointcutBody(tokens, i);</span>
<span class="fc" id="L527">				i += body.numTokensConsumed;</span>
<span class="fc" id="L528">				String varName = maybeExtractVariableName(body.text);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">				if (varName != null) {</span>
<span class="fc" id="L530">					varNames.add(varName);</span>
				}
<span class="fc" id="L532">			}</span>
<span class="pc bpc" id="L533" title="1 of 4 branches missed.">			else if (tokens[i].equals(&quot;args&quot;) || tokens[i].startsWith(&quot;args(&quot;)) {</span>
<span class="fc" id="L534">				PointcutBody body = getPointcutBody(tokens, i);</span>
<span class="fc" id="L535">				i += body.numTokensConsumed;</span>
<span class="fc" id="L536">				List&lt;String&gt; candidateVarNames = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L537">				maybeExtractVariableNamesFromArgs(body.text, candidateVarNames);</span>
				// we may have found some var names that were bound in previous primitive args binding step,
				// filter them out...
<span class="fc bfc" id="L540" title="All 2 branches covered.">				for (String varName : candidateVarNames) {</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">					if (!alreadyBound(varName)) {</span>
<span class="fc" id="L542">						varNames.add(varName);</span>
					}
<span class="fc" id="L544">				}</span>
			}
		}


<span class="fc bfc" id="L549" title="All 2 branches covered.">		if (varNames.size() &gt; 1) {</span>
<span class="fc" id="L550">			throw new AmbiguousBindingException(&quot;Found &quot; + varNames.size() +</span>
					&quot; candidate this(), target() or args() variables but only one unbound argument slot&quot;);
		}
<span class="fc bfc" id="L553" title="All 2 branches covered.">		else if (varNames.size() == 1) {</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">			for (int j = 0; j &lt; this.parameterNameBindings.length; j++) {</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">				if (isUnbound(j)) {</span>
<span class="fc" id="L556">					bindParameterName(j, varNames.get(0));</span>
<span class="fc" id="L557">					break;</span>
				}
			}
		}
		// else varNames.size must be 0 and we have nothing to bind.
<span class="fc" id="L562">	}</span>

	private void maybeBindReferencePointcutParameter() {
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">		if (this.numberOfRemainingUnboundArguments &gt; 1) {</span>
<span class="nc" id="L566">			throw new AmbiguousBindingException(&quot;Still &quot; + this.numberOfRemainingUnboundArguments</span>
					+ &quot; unbound args at reference pointcut binding stage, with no way to determine between them&quot;);
		}

<span class="fc" id="L570">		List&lt;String&gt; varNames = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L571">		String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, &quot; &quot;);</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">		for (int i = 0; i &lt; tokens.length; i++) {</span>
<span class="fc" id="L573">			String toMatch = tokens[i];</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">			if (toMatch.startsWith(&quot;!&quot;)) {</span>
<span class="nc" id="L575">				toMatch = toMatch.substring(1);</span>
			}
<span class="fc" id="L577">			int firstParenIndex = toMatch.indexOf('(');</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">			if (firstParenIndex != -1) {</span>
<span class="fc" id="L579">				toMatch = toMatch.substring(0, firstParenIndex);</span>
			}
			else {
<span class="fc bfc" id="L582" title="All 2 branches covered.">				if (tokens.length &lt; i + 2) {</span>
					// no &quot;(&quot; and nothing following
<span class="fc" id="L584">					continue;</span>
				}
				else {
<span class="fc" id="L587">					String nextToken = tokens[i + 1];</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">					if (nextToken.charAt(0) != '(') {</span>
						// next token is not &quot;(&quot; either, can't be a pc...
<span class="fc" id="L590">						continue;</span>
					}
				}

			}

			// eat the body
<span class="fc" id="L597">			PointcutBody body = getPointcutBody(tokens, i);</span>
<span class="fc" id="L598">			i += body.numTokensConsumed;</span>

<span class="fc bfc" id="L600" title="All 2 branches covered.">			if (!nonReferencePointcutTokens.contains(toMatch)) {</span>
				// then it could be a reference pointcut
<span class="fc" id="L602">				String varName = maybeExtractVariableName(body.text);</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">				if (varName != null) {</span>
<span class="fc" id="L604">					varNames.add(varName);</span>
				}
			}
		}

<span class="pc bpc" id="L609" title="1 of 2 branches missed.">		if (varNames.size() &gt; 1) {</span>
<span class="nc" id="L610">			throw new AmbiguousBindingException(&quot;Found &quot; + varNames.size() +</span>
					&quot; candidate reference pointcut variables but only one unbound argument slot&quot;);
		}
<span class="fc bfc" id="L613" title="All 2 branches covered.">		else if (varNames.size() == 1) {</span>
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">			for (int j = 0; j &lt; this.parameterNameBindings.length; j++) {</span>
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">				if (isUnbound(j)) {</span>
<span class="fc" id="L616">					bindParameterName(j, varNames.get(0));</span>
<span class="fc" id="L617">					break;</span>
				}
			}
		}
		// else varNames.size must be 0 and we have nothing to bind.
<span class="fc" id="L622">	}</span>

	/*
	 * We've found the start of a binding pointcut at the given index into the
	 * token array. Now we need to extract the pointcut body and return it.
	 */
	private PointcutBody getPointcutBody(String[] tokens, int startIndex) {
<span class="fc" id="L629">		int numTokensConsumed = 0;</span>
<span class="fc" id="L630">		String currentToken = tokens[startIndex];</span>
<span class="fc" id="L631">		int bodyStart = currentToken.indexOf('(');</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">		if (currentToken.charAt(currentToken.length() - 1) == ')') {</span>
			// It's an all in one... get the text between the first (and the last)
<span class="fc" id="L634">			return new PointcutBody(0, currentToken.substring(bodyStart + 1, currentToken.length() - 1));</span>
		}
		else {
<span class="fc" id="L637">			StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L638" title="All 4 branches covered.">			if (bodyStart &gt;= 0 &amp;&amp; bodyStart != (currentToken.length() - 1)) {</span>
<span class="fc" id="L639">				sb.append(currentToken.substring(bodyStart + 1));</span>
<span class="fc" id="L640">				sb.append(&quot; &quot;);</span>
			}
<span class="fc" id="L642">			numTokensConsumed++;</span>
<span class="fc" id="L643">			int currentIndex = startIndex + numTokensConsumed;</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">			while (currentIndex &lt; tokens.length) {</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">				if (tokens[currentIndex].equals(&quot;(&quot;)) {</span>
<span class="fc" id="L646">					currentIndex++;</span>
<span class="fc" id="L647">					continue;</span>
				}

<span class="fc bfc" id="L650" title="All 2 branches covered.">				if (tokens[currentIndex].endsWith(&quot;)&quot;)) {</span>
<span class="fc" id="L651">					sb.append(tokens[currentIndex].substring(0, tokens[currentIndex].length() - 1));</span>
<span class="fc" id="L652">					return new PointcutBody(numTokensConsumed, sb.toString().trim());</span>
				}

<span class="fc" id="L655">				String toAppend = tokens[currentIndex];</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">				if (toAppend.startsWith(&quot;(&quot;)) {</span>
<span class="fc" id="L657">					toAppend = toAppend.substring(1);</span>
				}
<span class="fc" id="L659">				sb.append(toAppend);</span>
<span class="fc" id="L660">				sb.append(&quot; &quot;);</span>
<span class="fc" id="L661">				currentIndex++;</span>
<span class="fc" id="L662">				numTokensConsumed++;</span>
<span class="fc" id="L663">			}</span>

		}

		// We looked and failed...
<span class="fc" id="L668">		return new PointcutBody(numTokensConsumed, null);</span>
	}

	/**
	 * Match up args against unbound arguments of primitive types.
	 */
	private void maybeBindPrimitiveArgsFromPointcutExpression() {
<span class="fc" id="L675">		int numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments();</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">		if (numUnboundPrimitives &gt; 1) {</span>
<span class="nc" id="L677">			throw new AmbiguousBindingException(&quot;Found '&quot; + numUnboundPrimitives +</span>
					&quot;' unbound primitive arguments with no way to distinguish between them.&quot;);
		}
<span class="fc bfc" id="L680" title="All 2 branches covered.">		if (numUnboundPrimitives == 1) {</span>
			// Look for arg variable and bind it if we find exactly one...
<span class="fc" id="L682">			List&lt;String&gt; varNames = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L683">			String[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, &quot; &quot;);</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">			for (int i = 0; i &lt; tokens.length; i++) {</span>
<span class="pc bpc" id="L685" title="1 of 4 branches missed.">				if (tokens[i].equals(&quot;args&quot;) || tokens[i].startsWith(&quot;args(&quot;)) {</span>
<span class="fc" id="L686">					PointcutBody body = getPointcutBody(tokens, i);</span>
<span class="fc" id="L687">					i += body.numTokensConsumed;</span>
<span class="fc" id="L688">					maybeExtractVariableNamesFromArgs(body.text, varNames);</span>
				}
			}
<span class="fc bfc" id="L691" title="All 2 branches covered.">			if (varNames.size() &gt; 1) {</span>
<span class="fc" id="L692">				throw new AmbiguousBindingException(&quot;Found &quot; + varNames.size() +</span>
						&quot; candidate variable names but only one candidate binding slot when matching primitive args&quot;);
			}
<span class="fc bfc" id="L695" title="All 2 branches covered.">			else if (varNames.size() == 1) {</span>
				// 1 primitive arg, and one candidate...
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">				for (int i = 0; i &lt; this.argumentTypes.length; i++) {</span>
<span class="fc bfc" id="L698" title="All 4 branches covered.">					if (isUnbound(i) &amp;&amp; this.argumentTypes[i].isPrimitive()) {</span>
<span class="fc" id="L699">						bindParameterName(i, varNames.get(0));</span>
<span class="fc" id="L700">						break;</span>
					}
				}
			}
		}
<span class="fc" id="L705">	}</span>

	/*
	 * Return true if the parameter name binding for the given parameter
	 * index has not yet been assigned.
	 */
	private boolean isUnbound(int i) {
<span class="fc bfc" id="L712" title="All 2 branches covered.">		return this.parameterNameBindings[i] == null;</span>
	}

	private boolean alreadyBound(String varName) {
<span class="fc bfc" id="L716" title="All 2 branches covered.">		for (int i = 0; i &lt; this.parameterNameBindings.length; i++) {</span>
<span class="fc bfc" id="L717" title="All 4 branches covered.">			if (!isUnbound(i) &amp;&amp; varName.equals(this.parameterNameBindings[i])) {</span>
<span class="fc" id="L718">				return true;</span>
			}
		}
<span class="fc" id="L721">		return false;</span>
	}

	/*
	 * Return {@code true} if the given argument type is a subclass
	 * of the given supertype.
	 */
	private boolean isSubtypeOf(Class&lt;?&gt; supertype, int argumentNumber) {
<span class="fc" id="L729">		return supertype.isAssignableFrom(this.argumentTypes[argumentNumber]);</span>
	}

	private int countNumberOfUnboundAnnotationArguments() {
<span class="fc" id="L733">		int count = 0;</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">		for (int i = 0; i &lt; this.argumentTypes.length; i++) {</span>
<span class="fc bfc" id="L735" title="All 4 branches covered.">			if (isUnbound(i) &amp;&amp; isSubtypeOf(Annotation.class, i)) {</span>
<span class="fc" id="L736">				count++;</span>
			}
		}
<span class="fc" id="L739">		return count;</span>
	}

	private int countNumberOfUnboundPrimitiveArguments() {
<span class="fc" id="L743">		int count = 0;</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">		for (int i = 0; i &lt; this.argumentTypes.length; i++) {</span>
<span class="fc bfc" id="L745" title="All 4 branches covered.">			if (isUnbound(i) &amp;&amp; this.argumentTypes[i].isPrimitive()) {</span>
<span class="fc" id="L746">				count++;</span>
			}
		}
<span class="fc" id="L749">		return count;</span>
	}

	/*
	 * Find the argument index with the given type, and bind the given
	 * {@code varName} in that position.
	 */
	private void findAndBind(Class&lt;?&gt; argumentType, String varName) {
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">		for (int i = 0; i &lt; this.argumentTypes.length; i++) {</span>
<span class="fc bfc" id="L758" title="All 4 branches covered.">			if (isUnbound(i) &amp;&amp; isSubtypeOf(argumentType, i)) {</span>
<span class="fc" id="L759">				bindParameterName(i, varName);</span>
<span class="fc" id="L760">				return;</span>
			}
		}
<span class="nc" id="L763">		throw new IllegalStateException(&quot;Expected to find an unbound argument of type '&quot; +</span>
<span class="nc" id="L764">				argumentType.getName() + &quot;'&quot;);</span>
	}


	/**
	 * Simple struct to hold the extracted text from a pointcut body, together
	 * with the number of tokens consumed in extracting it.
	 */
	private static class PointcutBody {

		private int numTokensConsumed;

		@Nullable
		private String text;

<span class="fc" id="L779">		public PointcutBody(int tokens, @Nullable String text) {</span>
<span class="fc" id="L780">			this.numTokensConsumed = tokens;</span>
<span class="fc" id="L781">			this.text = text;</span>
<span class="fc" id="L782">		}</span>
	}


	/**
	 * Thrown in response to an ambiguous binding being detected when
	 * trying to resolve a method's parameter names.
	 */
	@SuppressWarnings(&quot;serial&quot;)
	public static class AmbiguousBindingException extends RuntimeException {

		/**
		 * Construct a new AmbiguousBindingException with the specified message.
		 * @param msg the detail message
		 */
		public AmbiguousBindingException(String msg) {
<span class="fc" id="L798">			super(msg);</span>
<span class="fc" id="L799">		}</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>