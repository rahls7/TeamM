<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CacheAspectSupport.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-context</a> &gt; <a href="index.source.html" class="el_package">org.springframework.cache.interceptor</a> &gt; <span class="el_source">CacheAspectSupport.java</span></div><h1>CacheAspectSupport.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.cache.interceptor;

import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.aop.framework.AopProxyUtils;
import org.springframework.aop.support.AopUtils;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.NoUniqueBeanDefinitionException;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.beans.factory.annotation.BeanFactoryAnnotationUtils;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.context.expression.AnnotatedElementKey;
import org.springframework.core.BridgeMethodResolver;
import org.springframework.expression.EvaluationContext;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.CollectionUtils;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;
import org.springframework.util.function.SingletonSupplier;
import org.springframework.util.function.SupplierUtils;

/**
 * Base class for caching aspects, such as the {@link CacheInterceptor} or an
 * AspectJ aspect.
 *
 * &lt;p&gt;This enables the underlying Spring caching infrastructure to be used easily
 * to implement an aspect for any aspect system.
 *
 * &lt;p&gt;Subclasses are responsible for calling relevant methods in the correct order.
 *
 * &lt;p&gt;Uses the &lt;b&gt;Strategy&lt;/b&gt; design pattern. A {@link CacheOperationSource} is
 * used for determining caching operations, a {@link KeyGenerator} will build the
 * cache keys, and a {@link CacheResolver} will resolve the actual cache(s) to use.
 *
 * &lt;p&gt;Note: A cache aspect is serializable but does not perform any actual caching
 * after deserialization.
 *
 * @author Costin Leau
 * @author Juergen Hoeller
 * @author Chris Beams
 * @author Phillip Webb
 * @author Sam Brannen
 * @author Stephane Nicoll
 * @since 3.1
 */
<span class="fc" id="L83">public abstract class CacheAspectSupport extends AbstractCacheInvoker</span>
		implements BeanFactoryAware, InitializingBean, SmartInitializingSingleton {

<span class="fc" id="L86">	protected final Log logger = LogFactory.getLog(getClass());</span>

<span class="fc" id="L88">	private final Map&lt;CacheOperationCacheKey, CacheOperationMetadata&gt; metadataCache = new ConcurrentHashMap&lt;&gt;(1024);</span>

<span class="fc" id="L90">	private final CacheOperationExpressionEvaluator evaluator = new CacheOperationExpressionEvaluator();</span>

	@Nullable
	private CacheOperationSource cacheOperationSource;

<span class="fc" id="L95">	private SingletonSupplier&lt;KeyGenerator&gt; keyGenerator = SingletonSupplier.of(SimpleKeyGenerator::new);</span>

	@Nullable
	private SingletonSupplier&lt;CacheResolver&gt; cacheResolver;

	@Nullable
	private BeanFactory beanFactory;

<span class="fc" id="L103">	private boolean initialized = false;</span>


	/**
	 * Configure this aspect with the given error handler, key generator and cache resolver/manager
	 * suppliers, applying the corresponding default if a supplier is not resolvable.
	 * @since 5.1
	 */
	public void configure(
			@Nullable Supplier&lt;CacheErrorHandler&gt; errorHandler, @Nullable Supplier&lt;KeyGenerator&gt; keyGenerator,
			@Nullable Supplier&lt;CacheResolver&gt; cacheResolver, @Nullable Supplier&lt;CacheManager&gt; cacheManager) {

<span class="fc" id="L115">		this.errorHandler = new SingletonSupplier&lt;&gt;(errorHandler, SimpleCacheErrorHandler::new);</span>
<span class="fc" id="L116">		this.keyGenerator = new SingletonSupplier&lt;&gt;(keyGenerator, SimpleKeyGenerator::new);</span>
<span class="fc" id="L117">		this.cacheResolver = new SingletonSupplier&lt;&gt;(cacheResolver,</span>
<span class="fc" id="L118">				() -&gt; SimpleCacheResolver.of(SupplierUtils.resolve(cacheManager)));</span>
<span class="fc" id="L119">	}</span>


	/**
	 * Set one or more cache operation sources which are used to find the cache
	 * attributes. If more than one source is provided, they will be aggregated
	 * using a {@link CompositeCacheOperationSource}.
	 * @see #setCacheOperationSource
	 */
	public void setCacheOperationSources(CacheOperationSource... cacheOperationSources) {
<span class="fc" id="L129">		Assert.notEmpty(cacheOperationSources, &quot;At least 1 CacheOperationSource needs to be specified&quot;);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">		this.cacheOperationSource = (cacheOperationSources.length &gt; 1 ?</span>
				new CompositeCacheOperationSource(cacheOperationSources) : cacheOperationSources[0]);
<span class="fc" id="L132">	}</span>

	/**
	 * Set the CacheOperationSource for this cache aspect.
	 * @since 5.1
	 * @see #setCacheOperationSources
	 */
	public void setCacheOperationSource(@Nullable CacheOperationSource cacheOperationSource) {
<span class="fc" id="L140">		this.cacheOperationSource = cacheOperationSource;</span>
<span class="fc" id="L141">	}</span>

	/**
	 * Return the CacheOperationSource for this cache aspect.
	 */
	@Nullable
	public CacheOperationSource getCacheOperationSource() {
<span class="fc" id="L148">		return this.cacheOperationSource;</span>
	}

	/**
	 * Set the default {@link KeyGenerator} that this cache aspect should delegate to
	 * if no specific key generator has been set for the operation.
	 * &lt;p&gt;The default is a {@link SimpleKeyGenerator}.
	 */
	public void setKeyGenerator(KeyGenerator keyGenerator) {
<span class="fc" id="L157">		this.keyGenerator = SingletonSupplier.of(keyGenerator);</span>
<span class="fc" id="L158">	}</span>

	/**
	 * Return the default {@link KeyGenerator} that this cache aspect delegates to.
	 */
	public KeyGenerator getKeyGenerator() {
<span class="fc" id="L164">		return this.keyGenerator.obtain();</span>
	}

	/**
	 * Set the default {@link CacheResolver} that this cache aspect should delegate
	 * to if no specific cache resolver has been set for the operation.
	 * &lt;p&gt;The default resolver resolves the caches against their names and the
	 * default cache manager.
	 * @see #setCacheManager
	 * @see SimpleCacheResolver
	 */
	public void setCacheResolver(@Nullable CacheResolver cacheResolver) {
<span class="fc" id="L176">		this.cacheResolver = SingletonSupplier.ofNullable(cacheResolver);</span>
<span class="fc" id="L177">	}</span>

	/**
	 * Return the default {@link CacheResolver} that this cache aspect delegates to.
	 */
	@Nullable
	public CacheResolver getCacheResolver() {
<span class="fc" id="L184">		return SupplierUtils.resolve(this.cacheResolver);</span>
	}

	/**
	 * Set the {@link CacheManager} to use to create a default {@link CacheResolver}.
	 * Replace the current {@link CacheResolver}, if any.
	 * @see #setCacheResolver
	 * @see SimpleCacheResolver
	 */
	public void setCacheManager(CacheManager cacheManager) {
<span class="fc" id="L194">		this.cacheResolver = SingletonSupplier.of(new SimpleCacheResolver(cacheManager));</span>
<span class="fc" id="L195">	}</span>

	/**
	 * Set the containing {@link BeanFactory} for {@link CacheManager} and other
	 * service lookups.
	 * @since 4.3
	 */
	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
<span class="fc" id="L204">		this.beanFactory = beanFactory;</span>
<span class="fc" id="L205">	}</span>


	@Override
	public void afterPropertiesSet() {
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">		Assert.state(getCacheOperationSource() != null, &quot;The 'cacheOperationSources' property is required: &quot; +</span>
				&quot;If there are no cacheable methods, then don't use a cache aspect.&quot;);
<span class="fc" id="L212">	}</span>

	@Override
	public void afterSingletonsInstantiated() {
<span class="fc bfc" id="L216" title="All 2 branches covered.">		if (getCacheResolver() == null) {</span>
			// Lazily initialize cache resolver via default cache manager...
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">			Assert.state(this.beanFactory != null, &quot;CacheResolver or BeanFactory must be set on cache aspect&quot;);</span>
			try {
<span class="fc" id="L220">				setCacheManager(this.beanFactory.getBean(CacheManager.class));</span>
			}
<span class="fc" id="L222">			catch (NoUniqueBeanDefinitionException ex) {</span>
<span class="fc" id="L223">				throw new IllegalStateException(&quot;No CacheResolver specified, and no unique bean of type &quot; +</span>
						&quot;CacheManager found. Mark one as primary or declare a specific CacheManager to use.&quot;);
			}
<span class="fc" id="L226">			catch (NoSuchBeanDefinitionException ex) {</span>
<span class="fc" id="L227">				throw new IllegalStateException(&quot;No CacheResolver specified, and no bean of type CacheManager found. &quot; +</span>
						&quot;Register a CacheManager bean or remove the @EnableCaching annotation from your configuration.&quot;);
<span class="fc" id="L229">			}</span>
		}
<span class="fc" id="L231">		this.initialized = true;</span>
<span class="fc" id="L232">	}</span>


	/**
	 * Convenience method to return a String representation of this Method
	 * for use in logging. Can be overridden in subclasses to provide a
	 * different identifier for the given method.
	 * @param method the method we're interested in
	 * @param targetClass class the method is on
	 * @return log message identifying this method
	 * @see org.springframework.util.ClassUtils#getQualifiedMethodName
	 */
	protected String methodIdentification(Method method, Class&lt;?&gt; targetClass) {
<span class="nc" id="L245">		Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);</span>
<span class="nc" id="L246">		return ClassUtils.getQualifiedMethodName(specificMethod);</span>
	}

	protected Collection&lt;? extends Cache&gt; getCaches(
			CacheOperationInvocationContext&lt;CacheOperation&gt; context, CacheResolver cacheResolver) {

<span class="fc" id="L252">		Collection&lt;? extends Cache&gt; caches = cacheResolver.resolveCaches(context);</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">		if (caches.isEmpty()) {</span>
<span class="fc" id="L254">			throw new IllegalStateException(&quot;No cache could be resolved for '&quot; +</span>
<span class="fc" id="L255">					context.getOperation() + &quot;' using resolver '&quot; + cacheResolver +</span>
					&quot;'. At least one cache should be provided per cache operation.&quot;);
		}
<span class="fc" id="L258">		return caches;</span>
	}

	protected CacheOperationContext getOperationContext(
			CacheOperation operation, Method method, Object[] args, Object target, Class&lt;?&gt; targetClass) {

<span class="fc" id="L264">		CacheOperationMetadata metadata = getCacheOperationMetadata(operation, method, targetClass);</span>
<span class="fc" id="L265">		return new CacheOperationContext(metadata, args, target);</span>
	}

	/**
	 * Return the {@link CacheOperationMetadata} for the specified operation.
	 * &lt;p&gt;Resolve the {@link CacheResolver} and the {@link KeyGenerator} to be
	 * used for the operation.
	 * @param operation the operation
	 * @param method the method on which the operation is invoked
	 * @param targetClass the target type
	 * @return the resolved metadata for the operation
	 */
	protected CacheOperationMetadata getCacheOperationMetadata(
			CacheOperation operation, Method method, Class&lt;?&gt; targetClass) {

<span class="fc" id="L280">		CacheOperationCacheKey cacheKey = new CacheOperationCacheKey(operation, method, targetClass);</span>
<span class="fc" id="L281">		CacheOperationMetadata metadata = this.metadataCache.get(cacheKey);</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">		if (metadata == null) {</span>
			KeyGenerator operationKeyGenerator;
<span class="fc bfc" id="L284" title="All 2 branches covered.">			if (StringUtils.hasText(operation.getKeyGenerator())) {</span>
<span class="fc" id="L285">				operationKeyGenerator = getBean(operation.getKeyGenerator(), KeyGenerator.class);</span>
			}
			else {
<span class="fc" id="L288">				operationKeyGenerator = getKeyGenerator();</span>
			}
			CacheResolver operationCacheResolver;
<span class="fc bfc" id="L291" title="All 2 branches covered.">			if (StringUtils.hasText(operation.getCacheResolver())) {</span>
<span class="fc" id="L292">				operationCacheResolver = getBean(operation.getCacheResolver(), CacheResolver.class);</span>
			}
<span class="fc bfc" id="L294" title="All 2 branches covered.">			else if (StringUtils.hasText(operation.getCacheManager())) {</span>
<span class="fc" id="L295">				CacheManager cacheManager = getBean(operation.getCacheManager(), CacheManager.class);</span>
<span class="fc" id="L296">				operationCacheResolver = new SimpleCacheResolver(cacheManager);</span>
<span class="fc" id="L297">			}</span>
			else {
<span class="fc" id="L299">				operationCacheResolver = getCacheResolver();</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">				Assert.state(operationCacheResolver != null, &quot;No CacheResolver/CacheManager set&quot;);</span>
			}
<span class="fc" id="L302">			metadata = new CacheOperationMetadata(operation, method, targetClass,</span>
					operationKeyGenerator, operationCacheResolver);
<span class="fc" id="L304">			this.metadataCache.put(cacheKey, metadata);</span>
		}
<span class="fc" id="L306">		return metadata;</span>
	}

	/**
	 * Return a bean with the specified name and type. Used to resolve services that
	 * are referenced by name in a {@link CacheOperation}.
	 * @param beanName the name of the bean, as defined by the operation
	 * @param expectedType type for the bean
	 * @return the bean matching that name
	 * @throws org.springframework.beans.factory.NoSuchBeanDefinitionException if such bean does not exist
	 * @see CacheOperation#getKeyGenerator()
	 * @see CacheOperation#getCacheManager()
	 * @see CacheOperation#getCacheResolver()
	 */
	protected &lt;T&gt; T getBean(String beanName, Class&lt;T&gt; expectedType) {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">		if (this.beanFactory == null) {</span>
<span class="nc" id="L322">			throw new IllegalStateException(</span>
<span class="nc" id="L323">					&quot;BeanFactory must be set on cache aspect for &quot; + expectedType.getSimpleName() + &quot; retrieval&quot;);</span>
		}
<span class="fc" id="L325">		return BeanFactoryAnnotationUtils.qualifiedBeanOfType(this.beanFactory, expectedType, beanName);</span>
	}

	/**
	 * Clear the cached metadata.
	 */
	protected void clearMetadataCache() {
<span class="nc" id="L332">		this.metadataCache.clear();</span>
<span class="nc" id="L333">		this.evaluator.clear();</span>
<span class="nc" id="L334">	}</span>

	@Nullable
	protected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args) {
		// Check whether aspect is enabled (to cope with cases where the AJ is pulled in automatically)
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">		if (this.initialized) {</span>
<span class="fc" id="L340">			Class&lt;?&gt; targetClass = getTargetClass(target);</span>
<span class="fc" id="L341">			CacheOperationSource cacheOperationSource = getCacheOperationSource();</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">			if (cacheOperationSource != null) {</span>
<span class="fc" id="L343">				Collection&lt;CacheOperation&gt; operations = cacheOperationSource.getCacheOperations(method, targetClass);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">				if (!CollectionUtils.isEmpty(operations)) {</span>
<span class="fc" id="L345">					return execute(invoker, method,</span>
							new CacheOperationContexts(operations, method, args, target, targetClass));
				}
			}
		}

<span class="fc" id="L351">		return invoker.invoke();</span>
	}

	/**
	 * Execute the underlying operation (typically in case of cache miss) and return
	 * the result of the invocation. If an exception occurs it will be wrapped in a
	 * {@link CacheOperationInvoker.ThrowableWrapper}: the exception can be handled
	 * or modified but it &lt;em&gt;must&lt;/em&gt; be wrapped in a
	 * {@link CacheOperationInvoker.ThrowableWrapper} as well.
	 * @param invoker the invoker handling the operation being cached
	 * @return the result of the invocation
	 * @see CacheOperationInvoker#invoke()
	 */
	protected Object invokeOperation(CacheOperationInvoker invoker) {
<span class="fc" id="L365">		return invoker.invoke();</span>
	}

	private Class&lt;?&gt; getTargetClass(Object target) {
<span class="fc" id="L369">		return AopProxyUtils.ultimateTargetClass(target);</span>
	}

	@Nullable
	private Object execute(final CacheOperationInvoker invoker, Method method, CacheOperationContexts contexts) {
		// Special handling of synchronized invocation
<span class="fc bfc" id="L375" title="All 2 branches covered.">		if (contexts.isSynchronized()) {</span>
<span class="fc" id="L376">			CacheOperationContext context = contexts.get(CacheableOperation.class).iterator().next();</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">			if (isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) {</span>
<span class="fc" id="L378">				Object key = generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);</span>
<span class="fc" id="L379">				Cache cache = context.getCaches().iterator().next();</span>
				try {
<span class="fc" id="L381">					return wrapCacheValue(method, cache.get(key, () -&gt; unwrapReturnValue(invokeOperation(invoker))));</span>
				}
<span class="fc" id="L383">				catch (Cache.ValueRetrievalException ex) {</span>
					// The invoker wraps any Throwable in a ThrowableWrapper instance so we
					// can just make sure that one bubbles up the stack.
<span class="fc" id="L386">					throw (CacheOperationInvoker.ThrowableWrapper) ex.getCause();</span>
				}
			}
			else {
				// No caching required, only call the underlying method
<span class="fc" id="L391">				return invokeOperation(invoker);</span>
			}
		}


		// Process any early evictions
<span class="fc" id="L397">		processCacheEvicts(contexts.get(CacheEvictOperation.class), true,</span>
				CacheOperationExpressionEvaluator.NO_RESULT);

		// Check if we have a cached item matching the conditions
<span class="fc" id="L401">		Cache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class));</span>

		// Collect puts from any @Cacheable miss, if no cached item is found
<span class="fc" id="L404">		List&lt;CachePutRequest&gt; cachePutRequests = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">		if (cacheHit == null) {</span>
<span class="fc" id="L406">			collectPutRequests(contexts.get(CacheableOperation.class),</span>
					CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);
		}

		Object cacheValue;
		Object returnValue;

<span class="fc bfc" id="L413" title="All 4 branches covered.">		if (cacheHit != null &amp;&amp; !hasCachePut(contexts)) {</span>
			// If there are no put requests, just use the cache hit
<span class="fc" id="L415">			cacheValue = cacheHit.get();</span>
<span class="fc" id="L416">			returnValue = wrapCacheValue(method, cacheValue);</span>
		}
		else {
			// Invoke the method if we don't have a cache hit
<span class="fc" id="L420">			returnValue = invokeOperation(invoker);</span>
<span class="fc" id="L421">			cacheValue = unwrapReturnValue(returnValue);</span>
		}

		// Collect any explicit @CachePuts
<span class="fc" id="L425">		collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);</span>

		// Process any collected put requests, either from @CachePut or a @Cacheable miss
<span class="fc bfc" id="L428" title="All 2 branches covered.">		for (CachePutRequest cachePutRequest : cachePutRequests) {</span>
<span class="fc" id="L429">			cachePutRequest.apply(cacheValue);</span>
<span class="fc" id="L430">		}</span>

		// Process any late evictions
<span class="fc" id="L433">		processCacheEvicts(contexts.get(CacheEvictOperation.class), false, cacheValue);</span>

<span class="fc" id="L435">		return returnValue;</span>
	}

	@Nullable
	private Object wrapCacheValue(Method method, @Nullable Object cacheValue) {
<span class="pc bpc" id="L440" title="1 of 4 branches missed.">		if (method.getReturnType() == Optional.class &amp;&amp;</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">				(cacheValue == null || cacheValue.getClass() != Optional.class)) {</span>
<span class="fc" id="L442">			return Optional.ofNullable(cacheValue);</span>
		}
<span class="fc" id="L444">		return cacheValue;</span>
	}

	@Nullable
	private Object unwrapReturnValue(Object returnValue) {
<span class="fc" id="L449">		return ObjectUtils.unwrapOptional(returnValue);</span>
	}

	private boolean hasCachePut(CacheOperationContexts contexts) {
		// Evaluate the conditions *without* the result object because we don't have it yet...
<span class="fc" id="L454">		Collection&lt;CacheOperationContext&gt; cachePutContexts = contexts.get(CachePutOperation.class);</span>
<span class="fc" id="L455">		Collection&lt;CacheOperationContext&gt; excluded = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">		for (CacheOperationContext context : cachePutContexts) {</span>
			try {
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">				if (!context.isConditionPassing(CacheOperationExpressionEvaluator.RESULT_UNAVAILABLE)) {</span>
<span class="fc" id="L459">					excluded.add(context);</span>
				}
			}
<span class="fc" id="L462">			catch (VariableNotAvailableException ex) {</span>
				// Ignoring failure due to missing result, consider the cache put has to proceed
<span class="fc" id="L464">			}</span>
<span class="fc" id="L465">		}</span>
		// Check if all puts have been excluded by condition
<span class="fc bfc" id="L467" title="All 2 branches covered.">		return (cachePutContexts.size() != excluded.size());</span>
	}

	private void processCacheEvicts(
			Collection&lt;CacheOperationContext&gt; contexts, boolean beforeInvocation, @Nullable Object result) {

<span class="fc bfc" id="L473" title="All 2 branches covered.">		for (CacheOperationContext context : contexts) {</span>
<span class="fc" id="L474">			CacheEvictOperation operation = (CacheEvictOperation) context.metadata.operation;</span>
<span class="pc bpc" id="L475" title="1 of 4 branches missed.">			if (beforeInvocation == operation.isBeforeInvocation() &amp;&amp; isConditionPassing(context, result)) {</span>
<span class="fc" id="L476">				performCacheEvict(context, operation, result);</span>
			}
<span class="fc" id="L478">		}</span>
<span class="fc" id="L479">	}</span>

	private void performCacheEvict(
			CacheOperationContext context, CacheEvictOperation operation, @Nullable Object result) {

<span class="fc" id="L484">		Object key = null;</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">		for (Cache cache : context.getCaches()) {</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">			if (operation.isCacheWide()) {</span>
<span class="fc" id="L487">				logInvalidating(context, operation, null);</span>
<span class="fc" id="L488">				doClear(cache);</span>
			}
			else {
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">				if (key == null) {</span>
<span class="fc" id="L492">					key = generateKey(context, result);</span>
				}
<span class="fc" id="L494">				logInvalidating(context, operation, key);</span>
<span class="fc" id="L495">				doEvict(cache, key);</span>
			}
<span class="fc" id="L497">		}</span>
<span class="fc" id="L498">	}</span>

	private void logInvalidating(CacheOperationContext context, CacheEvictOperation operation, @Nullable Object key) {
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">		if (logger.isTraceEnabled()) {</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">			logger.trace(&quot;Invalidating &quot; + (key != null ? &quot;cache key [&quot; + key + &quot;]&quot; : &quot;entire cache&quot;) +</span>
<span class="nc" id="L503">					&quot; for operation &quot; + operation + &quot; on method &quot; + context.metadata.method);</span>
		}
<span class="fc" id="L505">	}</span>

	/**
	 * Find a cached item only for {@link CacheableOperation} that passes the condition.
	 * @param contexts the cacheable operations
	 * @return a {@link Cache.ValueWrapper} holding the cached item,
	 * or {@code null} if none is found
	 */
	@Nullable
	private Cache.ValueWrapper findCachedItem(Collection&lt;CacheOperationContext&gt; contexts) {
<span class="fc" id="L515">		Object result = CacheOperationExpressionEvaluator.NO_RESULT;</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">		for (CacheOperationContext context : contexts) {</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">			if (isConditionPassing(context, result)) {</span>
<span class="fc" id="L518">				Object key = generateKey(context, result);</span>
<span class="fc" id="L519">				Cache.ValueWrapper cached = findInCaches(context, key);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">				if (cached != null) {</span>
<span class="fc" id="L521">					return cached;</span>
				}
				else {
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">					if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L525">						logger.trace(&quot;No cache entry for key '&quot; + key + &quot;' in cache(s) &quot; + context.getCacheNames());</span>
					}
				}
			}
<span class="fc" id="L529">		}</span>
<span class="fc" id="L530">		return null;</span>
	}

	/**
	 * Collect the {@link CachePutRequest} for all {@link CacheOperation} using
	 * the specified result item.
	 * @param contexts the contexts to handle
	 * @param result the result item (never {@code null})
	 * @param putRequests the collection to update
	 */
	private void collectPutRequests(Collection&lt;CacheOperationContext&gt; contexts,
			@Nullable Object result, Collection&lt;CachePutRequest&gt; putRequests) {

<span class="fc bfc" id="L543" title="All 2 branches covered.">		for (CacheOperationContext context : contexts) {</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">			if (isConditionPassing(context, result)) {</span>
<span class="fc" id="L545">				Object key = generateKey(context, result);</span>
<span class="fc" id="L546">				putRequests.add(new CachePutRequest(context, key));</span>
			}
<span class="fc" id="L548">		}</span>
<span class="fc" id="L549">	}</span>

	@Nullable
	private Cache.ValueWrapper findInCaches(CacheOperationContext context, Object key) {
<span class="fc bfc" id="L553" title="All 2 branches covered.">		for (Cache cache : context.getCaches()) {</span>
<span class="fc" id="L554">			Cache.ValueWrapper wrapper = doGet(cache, key);</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">			if (wrapper != null) {</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">				if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L557">					logger.trace(&quot;Cache entry for key '&quot; + key + &quot;' found in cache '&quot; + cache.getName() + &quot;'&quot;);</span>
				}
<span class="fc" id="L559">				return wrapper;</span>
			}
<span class="fc" id="L561">		}</span>
<span class="fc" id="L562">		return null;</span>
	}

	private boolean isConditionPassing(CacheOperationContext context, @Nullable Object result) {
<span class="fc" id="L566">		boolean passing = context.isConditionPassing(result);</span>
<span class="pc bpc" id="L567" title="1 of 4 branches missed.">		if (!passing &amp;&amp; logger.isTraceEnabled()) {</span>
<span class="nc" id="L568">			logger.trace(&quot;Cache condition failed on method &quot; + context.metadata.method +</span>
<span class="nc" id="L569">					&quot; for operation &quot; + context.metadata.operation);</span>
		}
<span class="fc" id="L571">		return passing;</span>
	}

	private Object generateKey(CacheOperationContext context, @Nullable Object result) {
<span class="fc" id="L575">		Object key = context.generateKey(result);</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">		if (key == null) {</span>
<span class="nc" id="L577">			throw new IllegalArgumentException(&quot;Null key returned for cache operation (maybe you are &quot; +</span>
<span class="nc" id="L578">					&quot;using named params on classes without debug info?) &quot; + context.metadata.operation);</span>
		}
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">		if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L581">			logger.trace(&quot;Computed cache key '&quot; + key + &quot;' for operation &quot; + context.metadata.operation);</span>
		}
<span class="fc" id="L583">		return key;</span>
	}


	private class CacheOperationContexts {

		private final MultiValueMap&lt;Class&lt;? extends CacheOperation&gt;, CacheOperationContext&gt; contexts;

		private final boolean sync;

		public CacheOperationContexts(Collection&lt;? extends CacheOperation&gt; operations, Method method,
<span class="fc" id="L594">				Object[] args, Object target, Class&lt;?&gt; targetClass) {</span>

<span class="fc" id="L596">			this.contexts = new LinkedMultiValueMap&lt;&gt;(operations.size());</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">			for (CacheOperation op : operations) {</span>
<span class="fc" id="L598">				this.contexts.add(op.getClass(), getOperationContext(op, method, args, target, targetClass));</span>
<span class="fc" id="L599">			}</span>
<span class="fc" id="L600">			this.sync = determineSyncFlag(method);</span>
<span class="fc" id="L601">		}</span>

		public Collection&lt;CacheOperationContext&gt; get(Class&lt;? extends CacheOperation&gt; operationClass) {
<span class="fc" id="L604">			Collection&lt;CacheOperationContext&gt; result = this.contexts.get(operationClass);</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">			return (result != null ? result : Collections.emptyList());</span>
		}

		public boolean isSynchronized() {
<span class="fc" id="L609">			return this.sync;</span>
		}

		private boolean determineSyncFlag(Method method) {
<span class="fc" id="L613">			List&lt;CacheOperationContext&gt; cacheOperationContexts = this.contexts.get(CacheableOperation.class);</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">			if (cacheOperationContexts == null) {  // no @Cacheable operation at all</span>
<span class="fc" id="L615">				return false;</span>
			}
<span class="fc" id="L617">			boolean syncEnabled = false;</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">			for (CacheOperationContext cacheOperationContext : cacheOperationContexts) {</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">				if (((CacheableOperation) cacheOperationContext.getOperation()).isSync()) {</span>
<span class="fc" id="L620">					syncEnabled = true;</span>
<span class="fc" id="L621">					break;</span>
				}
<span class="fc" id="L623">			}</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">			if (syncEnabled) {</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">				if (this.contexts.size() &gt; 1) {</span>
<span class="fc" id="L626">					throw new IllegalStateException(</span>
							&quot;@Cacheable(sync=true) cannot be combined with other cache operations on '&quot; + method + &quot;'&quot;);
				}
<span class="fc bfc" id="L629" title="All 2 branches covered.">				if (cacheOperationContexts.size() &gt; 1) {</span>
<span class="fc" id="L630">					throw new IllegalStateException(</span>
							&quot;Only one @Cacheable(sync=true) entry is allowed on '&quot; + method + &quot;'&quot;);
				}
<span class="fc" id="L633">				CacheOperationContext cacheOperationContext = cacheOperationContexts.iterator().next();</span>
<span class="fc" id="L634">				CacheableOperation operation = (CacheableOperation) cacheOperationContext.getOperation();</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">				if (cacheOperationContext.getCaches().size() &gt; 1) {</span>
<span class="fc" id="L636">					throw new IllegalStateException(</span>
							&quot;@Cacheable(sync=true) only allows a single cache on '&quot; + operation + &quot;'&quot;);
				}
<span class="fc bfc" id="L639" title="All 2 branches covered.">				if (StringUtils.hasText(operation.getUnless())) {</span>
<span class="fc" id="L640">					throw new IllegalStateException(</span>
							&quot;@Cacheable(sync=true) does not support unless attribute on '&quot; + operation + &quot;'&quot;);
				}
<span class="fc" id="L643">				return true;</span>
			}
<span class="fc" id="L645">			return false;</span>
		}
	}


	/**
	 * Metadata of a cache operation that does not depend on a particular invocation
	 * which makes it a good candidate for caching.
	 */
	protected static class CacheOperationMetadata {

		private final CacheOperation operation;

		private final Method method;

		private final Class&lt;?&gt; targetClass;

		private final Method targetMethod;

		private final AnnotatedElementKey methodKey;

		private final KeyGenerator keyGenerator;

		private final CacheResolver cacheResolver;

		public CacheOperationMetadata(CacheOperation operation, Method method, Class&lt;?&gt; targetClass,
<span class="fc" id="L671">				KeyGenerator keyGenerator, CacheResolver cacheResolver) {</span>

<span class="fc" id="L673">			this.operation = operation;</span>
<span class="fc" id="L674">			this.method = BridgeMethodResolver.findBridgedMethod(method);</span>
<span class="fc" id="L675">			this.targetClass = targetClass;</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">			this.targetMethod = (!Proxy.isProxyClass(targetClass) ?</span>
<span class="pc" id="L677">					AopUtils.getMostSpecificMethod(method, targetClass) : this.method);</span>
<span class="fc" id="L678">			this.methodKey = new AnnotatedElementKey(this.targetMethod, targetClass);</span>
<span class="fc" id="L679">			this.keyGenerator = keyGenerator;</span>
<span class="fc" id="L680">			this.cacheResolver = cacheResolver;</span>
<span class="fc" id="L681">		}</span>
	}


	/**
	 * A {@link CacheOperationInvocationContext} context for a {@link CacheOperation}.
	 */
	protected class CacheOperationContext implements CacheOperationInvocationContext&lt;CacheOperation&gt; {

		private final CacheOperationMetadata metadata;

		private final Object[] args;

		private final Object target;

		private final Collection&lt;? extends Cache&gt; caches;

		private final Collection&lt;String&gt; cacheNames;

		@Nullable
		private Boolean conditionPassing;

<span class="fc" id="L703">		public CacheOperationContext(CacheOperationMetadata metadata, Object[] args, Object target) {</span>
<span class="fc" id="L704">			this.metadata = metadata;</span>
<span class="fc" id="L705">			this.args = extractArgs(metadata.method, args);</span>
<span class="fc" id="L706">			this.target = target;</span>
<span class="fc" id="L707">			this.caches = CacheAspectSupport.this.getCaches(this, metadata.cacheResolver);</span>
<span class="fc" id="L708">			this.cacheNames = createCacheNames(this.caches);</span>
<span class="fc" id="L709">		}</span>

		@Override
		public CacheOperation getOperation() {
<span class="fc" id="L713">			return this.metadata.operation;</span>
		}

		@Override
		public Object getTarget() {
<span class="nc" id="L718">			return this.target;</span>
		}

		@Override
		public Method getMethod() {
<span class="nc" id="L723">			return this.metadata.method;</span>
		}

		@Override
		public Object[] getArgs() {
<span class="fc" id="L728">			return this.args;</span>
		}

		private Object[] extractArgs(Method method, Object[] args) {
<span class="fc bfc" id="L732" title="All 2 branches covered.">			if (!method.isVarArgs()) {</span>
<span class="fc" id="L733">				return args;</span>
			}
<span class="fc" id="L735">			Object[] varArgs = ObjectUtils.toObjectArray(args[args.length - 1]);</span>
<span class="fc" id="L736">			Object[] combinedArgs = new Object[args.length - 1 + varArgs.length];</span>
<span class="fc" id="L737">			System.arraycopy(args, 0, combinedArgs, 0, args.length - 1);</span>
<span class="fc" id="L738">			System.arraycopy(varArgs, 0, combinedArgs, args.length - 1, varArgs.length);</span>
<span class="fc" id="L739">			return combinedArgs;</span>
		}

		protected boolean isConditionPassing(@Nullable Object result) {
<span class="fc bfc" id="L743" title="All 2 branches covered.">			if (this.conditionPassing == null) {</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">				if (StringUtils.hasText(this.metadata.operation.getCondition())) {</span>
<span class="fc" id="L745">					EvaluationContext evaluationContext = createEvaluationContext(result);</span>
<span class="fc" id="L746">					this.conditionPassing = evaluator.condition(this.metadata.operation.getCondition(),</span>
<span class="fc" id="L747">							this.metadata.methodKey, evaluationContext);</span>
<span class="fc" id="L748">				}</span>
				else {
<span class="fc" id="L750">					this.conditionPassing = true;</span>
				}
			}
<span class="fc" id="L753">			return this.conditionPassing;</span>
		}

		protected boolean canPutToCache(@Nullable Object value) {
<span class="fc" id="L757">			String unless = &quot;&quot;;</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">			if (this.metadata.operation instanceof CacheableOperation) {</span>
<span class="fc" id="L759">				unless = ((CacheableOperation) this.metadata.operation).getUnless();</span>
			}
<span class="pc bpc" id="L761" title="1 of 2 branches missed.">			else if (this.metadata.operation instanceof CachePutOperation) {</span>
<span class="fc" id="L762">				unless = ((CachePutOperation) this.metadata.operation).getUnless();</span>
			}
<span class="fc bfc" id="L764" title="All 2 branches covered.">			if (StringUtils.hasText(unless)) {</span>
<span class="fc" id="L765">				EvaluationContext evaluationContext = createEvaluationContext(value);</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">				return !evaluator.unless(unless, this.metadata.methodKey, evaluationContext);</span>
			}
<span class="fc" id="L768">			return true;</span>
		}

		/**
		 * Compute the key for the given caching operation.
		 */
		@Nullable
		protected Object generateKey(@Nullable Object result) {
<span class="fc bfc" id="L776" title="All 2 branches covered.">			if (StringUtils.hasText(this.metadata.operation.getKey())) {</span>
<span class="fc" id="L777">				EvaluationContext evaluationContext = createEvaluationContext(result);</span>
<span class="fc" id="L778">				return evaluator.key(this.metadata.operation.getKey(), this.metadata.methodKey, evaluationContext);</span>
			}
<span class="fc" id="L780">			return this.metadata.keyGenerator.generate(this.target, this.metadata.method, this.args);</span>
		}

		private EvaluationContext createEvaluationContext(@Nullable Object result) {
<span class="fc" id="L784">			return evaluator.createEvaluationContext(this.caches, this.metadata.method, this.args,</span>
<span class="fc" id="L785">					this.target, this.metadata.targetClass, this.metadata.targetMethod, result, beanFactory);</span>
		}

		protected Collection&lt;? extends Cache&gt; getCaches() {
<span class="fc" id="L789">			return this.caches;</span>
		}

		protected Collection&lt;String&gt; getCacheNames() {
<span class="nc" id="L793">			return this.cacheNames;</span>
		}

		private Collection&lt;String&gt; createCacheNames(Collection&lt;? extends Cache&gt; caches) {
<span class="fc" id="L797">			Collection&lt;String&gt; names = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">			for (Cache cache : caches) {</span>
<span class="fc" id="L799">				names.add(cache.getName());</span>
<span class="fc" id="L800">			}</span>
<span class="fc" id="L801">			return names;</span>
		}
	}


	private class CachePutRequest {

		private final CacheOperationContext context;

		private final Object key;

<span class="fc" id="L812">		public CachePutRequest(CacheOperationContext context, Object key) {</span>
<span class="fc" id="L813">			this.context = context;</span>
<span class="fc" id="L814">			this.key = key;</span>
<span class="fc" id="L815">		}</span>

		public void apply(@Nullable Object result) {
<span class="fc bfc" id="L818" title="All 2 branches covered.">			if (this.context.canPutToCache(result)) {</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">				for (Cache cache : this.context.getCaches()) {</span>
<span class="fc" id="L820">					doPut(cache, this.key, result);</span>
<span class="fc" id="L821">				}</span>
			}
<span class="fc" id="L823">		}</span>
	}


	private static final class CacheOperationCacheKey implements Comparable&lt;CacheOperationCacheKey&gt; {

		private final CacheOperation cacheOperation;

		private final AnnotatedElementKey methodCacheKey;

<span class="fc" id="L833">		private CacheOperationCacheKey(CacheOperation cacheOperation, Method method, Class&lt;?&gt; targetClass) {</span>
<span class="fc" id="L834">			this.cacheOperation = cacheOperation;</span>
<span class="fc" id="L835">			this.methodCacheKey = new AnnotatedElementKey(method, targetClass);</span>
<span class="fc" id="L836">		}</span>

		@Override
		public boolean equals(Object other) {
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">			if (this == other) {</span>
<span class="nc" id="L841">				return true;</span>
			}
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">			if (!(other instanceof CacheOperationCacheKey)) {</span>
<span class="nc" id="L844">				return false;</span>
			}
<span class="fc" id="L846">			CacheOperationCacheKey otherKey = (CacheOperationCacheKey) other;</span>
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">			return (this.cacheOperation.equals(otherKey.cacheOperation) &amp;&amp;</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">					this.methodCacheKey.equals(otherKey.methodCacheKey));</span>
		}

		@Override
		public int hashCode() {
<span class="fc" id="L853">			return (this.cacheOperation.hashCode() * 31 + this.methodCacheKey.hashCode());</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L858">			return this.cacheOperation + &quot; on &quot; + this.methodCacheKey;</span>
		}

		@Override
		public int compareTo(CacheOperationCacheKey other) {
<span class="nc" id="L863">			int result = this.cacheOperation.getName().compareTo(other.cacheOperation.getName());</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">			if (result == 0) {</span>
<span class="nc" id="L865">				result = this.methodCacheKey.compareTo(other.methodCacheKey);</span>
			}
<span class="nc" id="L867">			return result;</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>