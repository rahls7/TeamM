<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringSubstitutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Text</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.text</a> &gt; <span class="el_source">StringSubstitutor.java</span></div><h1>StringSubstitutor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.text;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.apache.commons.lang3.Validate;
import org.apache.commons.text.lookup.StringLookup;
import org.apache.commons.text.lookup.StringLookupFactory;
import org.apache.commons.text.matcher.StringMatcher;
import org.apache.commons.text.matcher.StringMatcherFactory;

/**
 * Substitutes variables within a string by values.
 * &lt;p&gt;
 * This class takes a piece of text and substitutes all the variables within it. The default definition of a variable is
 * &lt;code&gt;${variableName}&lt;/code&gt;. The prefix and suffix can be changed via constructors and set methods.
 * &lt;p&gt;
 * Variable values are typically resolved from a map, but could also be resolved from system properties, or by supplying
 * a custom variable resolver.
 * &lt;p&gt;
 * The simplest example is to use this class to replace Java System properties. For example:
 *
 * &lt;pre&gt;
 * StringSubstitutor
 *         .replaceSystemProperties(&quot;You are running with java.version = ${java.version} and os.name = ${os.name}.&quot;);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Typical usage of this class follows the following pattern: First an instance is created and initialized with the map
 * that contains the values for the available variables. If a prefix and/or suffix for variables should be used other
 * than the default ones, the appropriate settings can be performed. After that the {@code replace()} method can be
 * called passing in the source text for interpolation. In the returned text all variable references (as long as their
 * values are known) will be resolved. The following example demonstrates this:
 *
 * &lt;pre&gt;
 * Map valuesMap = HashMap();
 * valuesMap.put(&amp;quot;animal&amp;quot;, &amp;quot;quick brown fox&amp;quot;);
 * valuesMap.put(&amp;quot;target&amp;quot;, &amp;quot;lazy dog&amp;quot;);
 * String templateString = &amp;quot;The ${animal} jumped over the ${target}.&amp;quot;;
 * StringSubstitutor sub = new StringSubstitutor(valuesMap);
 * String resolvedString = sub.replace(templateString);
 * &lt;/pre&gt;
 *
 * yielding:
 *
 * &lt;pre&gt;
 *      The quick brown fox jumped over the lazy dog.
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Also, this class allows to set a default value for unresolved variables. The default value for a variable can be
 * appended to the variable name after the variable default value delimiter. The default value of the variable default
 * value delimiter is ':-', as in bash and other *nix shells, as those are arguably where the default ${} delimiter set
 * originated. The variable default value delimiter can be manually set by calling
 * {@link #setValueDelimiterMatcher(StringMatcher)}, {@link #setValueDelimiter(char)} or
 * {@link #setValueDelimiter(String)}. The following shows an example with variable default value settings:
 *
 * &lt;pre&gt;
 * Map valuesMap = HashMap();
 * valuesMap.put(&amp;quot;animal&amp;quot;, &amp;quot;quick brown fox&amp;quot;);
 * valuesMap.put(&amp;quot;target&amp;quot;, &amp;quot;lazy dog&amp;quot;);
 * String templateString = &amp;quot;The ${animal} jumped over the ${target}. ${undefined.number:-1234567890}.&amp;quot;;
 * StringSubstitutor sub = new StringSubstitutor(valuesMap);
 * String resolvedString = sub.replace(templateString);
 * &lt;/pre&gt;
 *
 * yielding:
 *
 * &lt;pre&gt;
 *      The quick brown fox jumped over the lazy dog. 1234567890.
 * &lt;/pre&gt;
 * &lt;p&gt;
 * In addition to this usage pattern there are some static convenience methods that cover the most common use cases.
 * These methods can be used without the need of manually creating an instance. However if multiple replace operations
 * are to be performed, creating and reusing an instance of this class will be more efficient.
 * &lt;p&gt;
 * Variable replacement works in a recursive way. Thus, if a variable value contains a variable then that variable will
 * also be replaced. Cyclic replacements are detected and will cause an exception to be thrown.
 * &lt;p&gt;
 * Sometimes the interpolation's result must contain a variable prefix. As an example take the following source text:
 *
 * &lt;pre&gt;
 *   The variable ${${name}} must be used.
 * &lt;/pre&gt;
 *
 * Here only the variable's name referred to in the text should be replaced resulting in the text (assuming that the
 * value of the {@code name} variable is {@code x}):
 *
 * &lt;pre&gt;
 *   The variable ${x} must be used.
 * &lt;/pre&gt;
 *
 * To achieve this effect there are two possibilities: Either set a different prefix and suffix for variables which do
 * not conflict with the result text you want to produce. The other possibility is to use the escape character, by
 * default '$'. If this character is placed before a variable reference, this reference is ignored and won't be
 * replaced. For example:
 *
 * &lt;pre&gt;
 *   The variable $${${name}} must be used.
 * &lt;/pre&gt;
 * &lt;p&gt;
 * In some complex scenarios you might even want to perform substitution in the names of variables, for instance
 *
 * &lt;pre&gt;
 * ${jre-${java.specification.version}}
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * {@code StringSubstitutor} supports this recursive substitution in variable names, but it has to be enabled
 * explicitly by calling {@link #setEnableSubstitutionInVariables(boolean)} with {@code true}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * {@code StringSubstitutor} supports throwing exceptions for unresolved variables, you enable this by setting
 * calling {@link #setEnableUndefinedVariableException(boolean)} with {@code true}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This class is &lt;b&gt;not&lt;/b&gt; thread safe.
 * &lt;/p&gt;
 *
 * @since 1.3
 */
public class StringSubstitutor {

    /**
     * The default variable default separator.
     *
     * @since 1.5.
     */
    public static final String DEFAULT_VAR_DEFAULT = &quot;:-&quot;;

    /**
     * The default variable end separator.
     *
     * @since 1.5.
     */
    public static final String DEFAULT_VAR_END = &quot;}&quot;;

    /**
     * The default variable start separator.
     *
     * @since 1.5.
     */
    public static final String DEFAULT_VAR_START = &quot;${&quot;;

    /**
     * Constant for the default escape character.
     */
    public static final char DEFAULT_ESCAPE = '$';

    /**
     * Constant for the default variable prefix.
     */
<span class="fc" id="L171">    public static final StringMatcher DEFAULT_PREFIX = StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_START);</span>

    /**
     * Constant for the default variable suffix.
     */
<span class="fc" id="L176">    public static final StringMatcher DEFAULT_SUFFIX = StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_END);</span>

    /**
     * Constant for the default value delimiter of a variable.
     */
<span class="fc" id="L181">    public static final StringMatcher DEFAULT_VALUE_DELIMITER =</span>
<span class="fc" id="L182">            StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_DEFAULT);</span>

    // -----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables in the given source object with their matching values from the map.
     *
     * @param &lt;V&gt;
     *            the type of the values in the map
     * @param source
     *            the source text containing the variables to substitute, null returns null
     * @param valueMap
     *            the map with the values, may be null
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if a variable is not found and enableUndefinedVariableException is true
     */
    public static &lt;V&gt; String replace(final Object source, final Map&lt;String, V&gt; valueMap) {
<span class="fc" id="L199">        return new StringSubstitutor(valueMap).replace(source);</span>
    }

    /**
     * Replaces all the occurrences of variables in the given source object with their matching values from the map.
     * This method allows to specify a custom variable prefix and suffix
     *
     * @param &lt;V&gt;
     *            the type of the values in the map
     * @param source
     *            the source text containing the variables to substitute, null returns null
     * @param valueMap
     *            the map with the values, may be null
     * @param prefix
     *            the prefix of variables, not null
     * @param suffix
     *            the suffix of variables, not null
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if the prefix or suffix is null
     * @throws IllegalArgumentException
     *             if a variable is not found and enableUndefinedVariableException is true
     */
    public static &lt;V&gt; String replace(final Object source, final Map&lt;String, V&gt; valueMap, final String prefix,
            final String suffix) {
<span class="fc" id="L224">        return new StringSubstitutor(valueMap, prefix, suffix).replace(source);</span>
    }

    /**
     * Replaces all the occurrences of variables in the given source object with their matching values from the
     * properties.
     *
     * @param source
     *            the source text containing the variables to substitute, null returns null
     * @param valueProperties
     *            the properties with values, may be null
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if a variable is not found and enableUndefinedVariableException is true
     */
    public static String replace(final Object source, final Properties valueProperties) {
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (valueProperties == null) {</span>
<span class="nc" id="L241">            return source.toString();</span>
        }
<span class="fc" id="L243">        final Map&lt;String, String&gt; valueMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L244">        final Enumeration&lt;?&gt; propNames = valueProperties.propertyNames();</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">        while (propNames.hasMoreElements()) {</span>
<span class="fc" id="L246">            final String propName = (String) propNames.nextElement();</span>
<span class="fc" id="L247">            final String propValue = valueProperties.getProperty(propName);</span>
<span class="fc" id="L248">            valueMap.put(propName, propValue);</span>
<span class="fc" id="L249">        }</span>
<span class="fc" id="L250">        return StringSubstitutor.replace(source, valueMap);</span>
    }

    /**
     * Replaces all the occurrences of variables in the given source object with their matching values from the system
     * properties.
     *
     * @param source
     *            the source text containing the variables to substitute, null returns null
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if a variable is not found and enableUndefinedVariableException is true
     */
    public static String replaceSystemProperties(final Object source) {
<span class="fc" id="L264">        return new StringSubstitutor(StringLookupFactory.INSTANCE.systemPropertyStringLookup()).replace(source);</span>
    }

    /**
     * Stores the escape character.
     */
    private char escapeChar;

    /**
     * Stores the variable prefix.
     */
    private StringMatcher prefixMatcher;

    /**
     * Stores the variable suffix.
     */
    private StringMatcher suffixMatcher;

    /**
     * Stores the default variable value delimiter.
     */
    private StringMatcher valueDelimiterMatcher;

    /**
     * Variable resolution is delegated to an implementor of {@link StringLookup}.
     */
    private StringLookup variableResolver;

    /**
     * The flag whether substitution in variable names is enabled.
     */
    private boolean enableSubstitutionInVariables;

    /**
     * Whether escapes should be preserved. Default is false;
     */
    private boolean preserveEscapes;

    /**
     * The flag whether substitution in variable values is disabled.
     */
    private boolean disableSubstitutionInValues;

    /**
     * The flag whether exception should be thrown on undefined variable.
     */
    private boolean enableUndefinedVariableException;

    // -----------------------------------------------------------------------
    /**
     * Creates a new instance with defaults for variable prefix and suffix and the escaping character.
     */
    public StringSubstitutor() {
<span class="fc" id="L317">        this((StringLookup) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);</span>
<span class="fc" id="L318">    }</span>

    /**
     * Creates a new instance and initializes it. Uses defaults for variable prefix and suffix and the escaping
     * character.
     *
     * @param &lt;V&gt;
     *            the type of the values in the map
     * @param valueMap
     *            the map with the variables' values, may be null
     */
    public &lt;V&gt; StringSubstitutor(final Map&lt;String, V&gt; valueMap) {
<span class="fc" id="L330">        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);</span>
<span class="fc" id="L331">    }</span>

    /**
     * Creates a new instance and initializes it. Uses a default escaping character.
     *
     * @param &lt;V&gt;
     *            the type of the values in the map
     * @param valueMap
     *            the map with the variables' values, may be null
     * @param prefix
     *            the prefix for variables, not null
     * @param suffix
     *            the suffix for variables, not null
     * @throws IllegalArgumentException
     *             if the prefix or suffix is null
     */
    public &lt;V&gt; StringSubstitutor(final Map&lt;String, V&gt; valueMap, final String prefix, final String suffix) {
<span class="fc" id="L348">        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);</span>
<span class="fc" id="L349">    }</span>

    /**
     * Creates a new instance and initializes it.
     *
     * @param &lt;V&gt;
     *            the type of the values in the map
     * @param valueMap
     *            the map with the variables' values, may be null
     * @param prefix
     *            the prefix for variables, not null
     * @param suffix
     *            the suffix for variables, not null
     * @param escape
     *            the escape character
     * @throws IllegalArgumentException
     *             if the prefix or suffix is null
     */
    public &lt;V&gt; StringSubstitutor(final Map&lt;String, V&gt; valueMap, final String prefix, final String suffix,
            final char escape) {
<span class="fc" id="L369">        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, escape);</span>
<span class="fc" id="L370">    }</span>

    /**
     * Creates a new instance and initializes it.
     *
     * @param &lt;V&gt;
     *            the type of the values in the map
     * @param valueMap
     *            the map with the variables' values, may be null
     * @param prefix
     *            the prefix for variables, not null
     * @param suffix
     *            the suffix for variables, not null
     * @param escape
     *            the escape character
     * @param valueDelimiter
     *            the variable default value delimiter, may be null
     * @throws IllegalArgumentException
     *             if the prefix or suffix is null
     */
    public &lt;V&gt; StringSubstitutor(final Map&lt;String, V&gt; valueMap, final String prefix, final String suffix,
            final char escape, final String valueDelimiter) {
<span class="fc" id="L392">        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, escape, valueDelimiter);</span>
<span class="fc" id="L393">    }</span>

    /**
     * Creates a new instance and initializes it.
     *
     * @param variableResolver
     *            the variable resolver, may be null
     */
    public StringSubstitutor(final StringLookup variableResolver) {
<span class="fc" id="L402">        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);</span>
<span class="fc" id="L403">    }</span>

    /**
     * Creates a new instance and initializes it.
     *
     * @param variableResolver
     *            the variable resolver, may be null
     * @param prefix
     *            the prefix for variables, not null
     * @param suffix
     *            the suffix for variables, not null
     * @param escape
     *            the escape character
     * @throws IllegalArgumentException
     *             if the prefix or suffix is null
     */
    public StringSubstitutor(final StringLookup variableResolver, final String prefix, final String suffix,
<span class="fc" id="L420">            final char escape) {</span>
<span class="fc" id="L421">        this.setVariableResolver(variableResolver);</span>
<span class="fc" id="L422">        this.setVariablePrefix(prefix);</span>
<span class="fc" id="L423">        this.setVariableSuffix(suffix);</span>
<span class="fc" id="L424">        this.setEscapeChar(escape);</span>
<span class="fc" id="L425">        this.setValueDelimiterMatcher(DEFAULT_VALUE_DELIMITER);</span>
<span class="fc" id="L426">    }</span>

    /**
     * Creates a new instance and initializes it.
     *
     * @param variableResolver
     *            the variable resolver, may be null
     * @param prefix
     *            the prefix for variables, not null
     * @param suffix
     *            the suffix for variables, not null
     * @param escape
     *            the escape character
     * @param valueDelimiter
     *            the variable default value delimiter string, may be null
     * @throws IllegalArgumentException
     *             if the prefix or suffix is null
     */
    public StringSubstitutor(final StringLookup variableResolver, final String prefix, final String suffix,
<span class="fc" id="L445">            final char escape, final String valueDelimiter) {</span>
<span class="fc" id="L446">        this.setVariableResolver(variableResolver);</span>
<span class="fc" id="L447">        this.setVariablePrefix(prefix);</span>
<span class="fc" id="L448">        this.setVariableSuffix(suffix);</span>
<span class="fc" id="L449">        this.setEscapeChar(escape);</span>
<span class="fc" id="L450">        this.setValueDelimiter(valueDelimiter);</span>
<span class="fc" id="L451">    }</span>

    /**
     * Creates a new instance and initializes it.
     *
     * @param variableResolver
     *            the variable resolver, may be null
     * @param prefixMatcher
     *            the prefix for variables, not null
     * @param suffixMatcher
     *            the suffix for variables, not null
     * @param escape
     *            the escape character
     * @throws IllegalArgumentException
     *             if the prefix or suffix is null
     */
    public StringSubstitutor(final StringLookup variableResolver, final StringMatcher prefixMatcher,
            final StringMatcher suffixMatcher, final char escape) {
<span class="fc" id="L469">        this(variableResolver, prefixMatcher, suffixMatcher, escape, DEFAULT_VALUE_DELIMITER);</span>
<span class="fc" id="L470">    }</span>

    /**
     * Creates a new instance and initializes it.
     *
     * @param variableResolver
     *            the variable resolver, may be null
     * @param prefixMatcher
     *            the prefix for variables, not null
     * @param suffixMatcher
     *            the suffix for variables, not null
     * @param escape
     *            the escape character
     * @param valueDelimiterMatcher
     *            the variable default value delimiter matcher, may be null
     * @throws IllegalArgumentException
     *             if the prefix or suffix is null
     */
    public StringSubstitutor(final StringLookup variableResolver, final StringMatcher prefixMatcher,
<span class="fc" id="L489">            final StringMatcher suffixMatcher, final char escape, final StringMatcher valueDelimiterMatcher) {</span>
<span class="fc" id="L490">        this.setVariableResolver(variableResolver);</span>
<span class="fc" id="L491">        this.setVariablePrefixMatcher(prefixMatcher);</span>
<span class="fc" id="L492">        this.setVariableSuffixMatcher(suffixMatcher);</span>
<span class="fc" id="L493">        this.setEscapeChar(escape);</span>
<span class="fc" id="L494">        this.setValueDelimiterMatcher(valueDelimiterMatcher);</span>
<span class="fc" id="L495">    }</span>

    /**
     * Checks if the specified variable is already in the stack (list) of variables.
     *
     * @param varName
     *            the variable name to check
     * @param priorVariables
     *            the list of prior variables
     */
    private void checkCyclicSubstitution(final String varName, final List&lt;String&gt; priorVariables) {
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">        if (!priorVariables.contains(varName)) {</span>
<span class="fc" id="L507">            return;</span>
        }
<span class="nc" id="L509">        final TextStringBuilder buf = new TextStringBuilder(256);</span>
<span class="nc" id="L510">        buf.append(&quot;Infinite loop in property interpolation of &quot;);</span>
<span class="nc" id="L511">        buf.append(priorVariables.remove(0));</span>
<span class="nc" id="L512">        buf.append(&quot;: &quot;);</span>
<span class="nc" id="L513">        buf.appendWithSeparators(priorVariables, &quot;-&gt;&quot;);</span>
<span class="nc" id="L514">        throw new IllegalStateException(buf.toString());</span>
    }

    // Escape
    // -----------------------------------------------------------------------
    /**
     * Returns the escape character.
     *
     * @return the character used for escaping variable references
     */
    public char getEscapeChar() {
<span class="fc" id="L525">        return this.escapeChar;</span>
    }

    // Resolver
    // -----------------------------------------------------------------------
    /**
     * Gets the StringLookup that is used to lookup variables.
     *
     * @return the StringLookup
     */
    public StringLookup getStringLookup() {
<span class="fc" id="L536">        return this.variableResolver;</span>
    }

    // Variable Default Value Delimiter
    // -----------------------------------------------------------------------
    /**
     * Gets the variable default value delimiter matcher currently in use.
     * &lt;p&gt;
     * The variable default value delimiter is the character or characters that delimite the variable name and the
     * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default
     * value delimiter matches.
     * &lt;p&gt;
     * If it returns null, then the variable default value resolution is disabled.
     *
     * @return the variable default value delimiter matcher in use, may be null
     */
    public StringMatcher getValueDelimiterMatcher() {
<span class="fc" id="L553">        return valueDelimiterMatcher;</span>
    }

    // Prefix
    // -----------------------------------------------------------------------
    /**
     * Gets the variable prefix matcher currently in use.
     * &lt;p&gt;
     * The variable prefix is the character or characters that identify the start of a variable. This prefix is
     * expressed in terms of a matcher allowing advanced prefix matches.
     *
     * @return the prefix matcher in use
     */
    public StringMatcher getVariablePrefixMatcher() {
<span class="fc" id="L567">        return prefixMatcher;</span>
    }

    // Suffix
    // -----------------------------------------------------------------------
    /**
     * Gets the variable suffix matcher currently in use.
     * &lt;p&gt;
     * The variable suffix is the character or characters that identify the end of a variable. This suffix is expressed
     * in terms of a matcher allowing advanced suffix matches.
     *
     * @return the suffix matcher in use
     */
    public StringMatcher getVariableSuffixMatcher() {
<span class="fc" id="L581">        return suffixMatcher;</span>
    }

    /**
     * Returns a flag whether substitution is disabled in variable values.If set to &lt;b&gt;true&lt;/b&gt;, the values of variables
     * can contain other variables will not be processed and substituted original variable is evaluated, e.g.
     *
     * &lt;pre&gt;
     * Map valuesMap = HashMap();
     * valuesMap.put(&amp;quot;name&amp;quot;, &amp;quot;Douglas ${surname}&amp;quot;);
     * valuesMap.put(&amp;quot;surname&amp;quot;, &amp;quot;Crockford&amp;quot;);
     * String templateString = &amp;quot;Hi ${name}&amp;quot;;
     * StrSubstitutor sub = new StrSubstitutor(valuesMap);
     * String resolvedString = sub.replace(templateString);
     * &lt;/pre&gt;
     *
     * yielding:
     *
     * &lt;pre&gt;
     *      Hi Douglas ${surname}
     * &lt;/pre&gt;
     *
     * @return the substitution in variable values flag
     */
    public boolean isDisableSubstitutionInValues() {
<span class="fc" id="L606">        return disableSubstitutionInValues;</span>
    }

    // Substitution support in variable names
    // -----------------------------------------------------------------------
    /**
     * Returns a flag whether substitution is done in variable names.
     *
     * @return the substitution in variable names flag
     */
    public boolean isEnableSubstitutionInVariables() {
<span class="fc" id="L617">        return enableSubstitutionInVariables;</span>
    }

    /**
     * Returns a flag whether exception can be thrown upon undefined
     * variable.
     *
     * @return the fail on undefined variable flag
     */
    public boolean isEnableUndefinedVariableException() {
<span class="fc" id="L627">        return enableUndefinedVariableException;</span>
    }

    /**
     * Returns the flag controlling whether escapes are preserved during substitution.
     *
     * @return the preserve escape flag
     */
    public boolean isPreserveEscapes() {
<span class="fc" id="L636">        return preserveEscapes;</span>
    }

    // -----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables with their matching values from the resolver using the given source
     * array as a template. The array is not altered by this method.
     *
     * @param source
     *            the character array to replace in, not altered, null returns null
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public String replace(final char[] source) {
<span class="fc bfc" id="L651" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L652">            return null;</span>
        }
<span class="fc" id="L654">        final TextStringBuilder buf = new TextStringBuilder(source.length).append(source);</span>
<span class="fc" id="L655">        substitute(buf, 0, source.length);</span>
<span class="fc" id="L656">        return buf.toString();</span>
    }

    /**
     * Replaces all the occurrences of variables with their matching values from the resolver using the given source
     * array as a template. The array is not altered by this method.
     * &lt;p&gt;
     * Only the specified portion of the array will be processed. The rest of the array is not processed, and is not
     * returned.
     *
     * @param source
     *            the character array to replace in, not altered, null returns null
     * @param offset
     *            the start offset within the array, must be valid
     * @param length
     *            the length within the array to be processed, must be valid
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public String replace(final char[] source, final int offset, final int length) {
<span class="fc bfc" id="L677" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L678">            return null;</span>
        }
<span class="fc" id="L680">        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);</span>
<span class="fc" id="L681">        substitute(buf, 0, length);</span>
<span class="fc" id="L682">        return buf.toString();</span>
    }

    /**
     * Replaces all the occurrences of variables with their matching values from the resolver using the given source as
     * a template. The source is not altered by this method.
     *
     * @param source
     *            the buffer to use as a template, not changed, null returns null
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public String replace(final CharSequence source) {
<span class="fc bfc" id="L696" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L697">            return null;</span>
        }
<span class="fc" id="L699">        return replace(source, 0, source.length());</span>
    }

    /**
     * Replaces all the occurrences of variables with their matching values from the resolver using the given source as
     * a template. The source is not altered by this method.
     * &lt;p&gt;
     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not
     * returned.
     *
     * @param source
     *            the buffer to use as a template, not changed, null returns null
     * @param offset
     *            the start offset within the array, must be valid
     * @param length
     *            the length within the array to be processed, must be valid
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public String replace(final CharSequence source, final int offset, final int length) {
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">        if (source == null) {</span>
<span class="nc" id="L721">            return null;</span>
        }
<span class="fc" id="L723">        final TextStringBuilder buf = new TextStringBuilder(length).append(source.toString(), offset, length);</span>
<span class="fc" id="L724">        substitute(buf, 0, length);</span>
<span class="fc" id="L725">        return buf.toString();</span>
    }

    // -----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables in the given source object with their matching values from the
     * resolver. The input source object is converted to a string using &lt;code&gt;toString&lt;/code&gt; and is not altered.
     *
     * @param source
     *            the source to replace in, null returns null
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if a variable is not found and enableUndefinedVariableException is true
     */
    public String replace(final Object source) {
<span class="fc bfc" id="L740" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L741">            return null;</span>
        }
<span class="fc" id="L743">        final TextStringBuilder buf = new TextStringBuilder().append(source);</span>
<span class="fc" id="L744">        substitute(buf, 0, buf.length());</span>
<span class="fc" id="L745">        return buf.toString();</span>
    }

    // -----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables with their matching values from the resolver using the given source
     * builder as a template. The builder is not altered by this method.
     *
     * @param source
     *            the builder to use as a template, not changed, null returns null
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public String replace(final TextStringBuilder source) {
<span class="fc bfc" id="L760" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L761">            return null;</span>
        }
<span class="fc" id="L763">        final TextStringBuilder buf = new TextStringBuilder(source.length()).append(source);</span>
<span class="fc" id="L764">        substitute(buf, 0, buf.length());</span>
<span class="fc" id="L765">        return buf.toString();</span>
    }

    /**
     * Replaces all the occurrences of variables with their matching values from the resolver using the given source
     * builder as a template. The builder is not altered by this method.
     * &lt;p&gt;
     * Only the specified portion of the builder will be processed. The rest of the builder is not processed, and is not
     * returned.
     *
     * @param source
     *            the builder to use as a template, not changed, null returns null
     * @param offset
     *            the start offset within the array, must be valid
     * @param length
     *            the length within the array to be processed, must be valid
     * @return the result of the replace operation
      * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public String replace(final TextStringBuilder source, final int offset, final int length) {
<span class="fc bfc" id="L786" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L787">            return null;</span>
        }
<span class="fc" id="L789">        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);</span>
<span class="fc" id="L790">        substitute(buf, 0, length);</span>
<span class="fc" id="L791">        return buf.toString();</span>
    }

    // -----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables with their matching values from the resolver using the given source
     * string as a template.
     *
     * @param source
     *            the string to replace in, null returns null
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public String replace(final String source) {
<span class="fc bfc" id="L806" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L807">            return null;</span>
        }
<span class="fc" id="L809">        final TextStringBuilder buf = new TextStringBuilder(source);</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">        if (!substitute(buf, 0, source.length())) {</span>
<span class="fc" id="L811">            return source;</span>
        }
<span class="fc" id="L813">        return buf.toString();</span>
    }

    /**
     * Replaces all the occurrences of variables with their matching values from the resolver using the given source
     * string as a template.
     * &lt;p&gt;
     * Only the specified portion of the string will be processed. The rest of the string is not processed, and is not
     * returned.
     *
     * @param source
     *            the string to replace in, null returns null
     * @param offset
     *            the start offset within the array, must be valid
     * @param length
     *            the length within the array to be processed, must be valid
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public String replace(final String source, final int offset, final int length) {
<span class="fc bfc" id="L834" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L835">            return null;</span>
        }
<span class="fc" id="L837">        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">        if (!substitute(buf, 0, length)) {</span>
<span class="fc" id="L839">            return source.substring(offset, offset + length);</span>
        }
<span class="fc" id="L841">        return buf.toString();</span>
    }

    // -----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables with their matching values from the resolver using the given source
     * buffer as a template. The buffer is not altered by this method.
     *
     * @param source
     *            the buffer to use as a template, not changed, null returns null
     * @return the result of the replace operation
      * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public String replace(final StringBuffer source) {
<span class="fc bfc" id="L856" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L857">            return null;</span>
        }
<span class="fc" id="L859">        final TextStringBuilder buf = new TextStringBuilder(source.length()).append(source);</span>
<span class="fc" id="L860">        substitute(buf, 0, buf.length());</span>
<span class="fc" id="L861">        return buf.toString();</span>
    }

    /**
     * Replaces all the occurrences of variables with their matching values from the resolver using the given source
     * buffer as a template. The buffer is not altered by this method.
     * &lt;p&gt;
     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not
     * returned.
     *
     * @param source
     *            the buffer to use as a template, not changed, null returns null
     * @param offset
     *            the start offset within the array, must be valid
     * @param length
     *            the length within the array to be processed, must be valid
     * @return the result of the replace operation
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public String replace(final StringBuffer source, final int offset, final int length) {
<span class="fc bfc" id="L882" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L883">            return null;</span>
        }
<span class="fc" id="L885">        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);</span>
<span class="fc" id="L886">        substitute(buf, 0, length);</span>
<span class="fc" id="L887">        return buf.toString();</span>
    }

    // -----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables within the given source builder with their matching values from the
     * resolver.
     *
     * @param source
     *            the builder to replace in, updated, null returns zero
     * @return true if altered
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public boolean replaceIn(final TextStringBuilder source) {
<span class="fc bfc" id="L902" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L903">            return false;</span>
        }
<span class="fc" id="L905">        return substitute(source, 0, source.length());</span>
    }

    /**
     * Replaces all the occurrences of variables within the given source builder with their matching values from the
     * resolver.
     * &lt;p&gt;
     * Only the specified portion of the builder will be processed. The rest of the builder is not processed, but it is
     * not deleted.
     *
     * @param source
     *            the builder to replace in, null returns zero
     * @param offset
     *            the start offset within the array, must be valid
     * @param length
     *            the length within the builder to be processed, must be valid
     * @return true if altered
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public boolean replaceIn(final TextStringBuilder source, final int offset, final int length) {
<span class="fc bfc" id="L926" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L927">            return false;</span>
        }
<span class="fc" id="L929">        return substitute(source, offset, length);</span>
    }

    // -----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables within the given source buffer with their matching values from the
     * resolver. The buffer is updated with the result.
     *
     * @param source
     *            the buffer to replace in, updated, null returns zero
     * @return true if altered
     */
    public boolean replaceIn(final StringBuffer source) {
<span class="fc bfc" id="L942" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L943">            return false;</span>
        }
<span class="fc" id="L945">        return replaceIn(source, 0, source.length());</span>
    }

    /**
     * Replaces all the occurrences of variables within the given source buffer with their matching values from the
     * resolver. The buffer is updated with the result.
     * &lt;p&gt;
     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, but it is
     * not deleted.
     *
     * @param source
     *            the buffer to replace in, updated, null returns zero
     * @param offset
     *            the start offset within the array, must be valid
     * @param length
     *            the length within the buffer to be processed, must be valid
     * @return true if altered
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public boolean replaceIn(final StringBuffer source, final int offset, final int length) {
<span class="fc bfc" id="L966" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L967">            return false;</span>
        }
<span class="fc" id="L969">        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">        if (!substitute(buf, 0, length)) {</span>
<span class="fc" id="L971">            return false;</span>
        }
<span class="fc" id="L973">        source.replace(offset, offset + length, buf.toString());</span>
<span class="fc" id="L974">        return true;</span>
    }

    // -----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables within the given source buffer with their matching values from the
     * resolver. The buffer is updated with the result.
     *
     * @param source
     *            the buffer to replace in, updated, null returns zero
     * @return true if altered
     */
    public boolean replaceIn(final StringBuilder source) {
<span class="fc bfc" id="L987" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L988">            return false;</span>
        }
<span class="fc" id="L990">        return replaceIn(source, 0, source.length());</span>
    }

    /**
     * Replaces all the occurrences of variables within the given source builder with their matching values from the
     * resolver. The builder is updated with the result.
     * &lt;p&gt;
     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, but it is
     * not deleted.
     *
     * @param source
     *            the buffer to replace in, updated, null returns zero
     * @param offset
     *            the start offset within the array, must be valid
     * @param length
     *            the length within the buffer to be processed, must be valid
     * @return true if altered
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    public boolean replaceIn(final StringBuilder source, final int offset, final int length) {
<span class="fc bfc" id="L1011" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L1012">            return false;</span>
        }
<span class="fc" id="L1014">        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);</span>
<span class="fc bfc" id="L1015" title="All 2 branches covered.">        if (!substitute(buf, 0, length)) {</span>
<span class="fc" id="L1016">            return false;</span>
        }
<span class="fc" id="L1018">        source.replace(offset, offset + length, buf.toString());</span>
<span class="fc" id="L1019">        return true;</span>
    }

    /**
     * Internal method that resolves the value of a variable.
     * &lt;p&gt;
     * Most users of this class do not need to call this method. This method is called automatically by the substitution
     * process.
     * &lt;p&gt;
     * Writers of subclasses can override this method if they need to alter how each substitution occurs. The method is
     * passed the variable's name and must return the corresponding value. This implementation uses the
     * {@link #getStringLookup()} with the variable's name as the key.
     *
     * @param variableName
     *            the name of the variable, not null
     * @param buf
     *            the buffer where the substitution is occurring, not null
     * @param startPos
     *            the start position of the variable including the prefix, valid
     * @param endPos
     *            the end position of the variable including the suffix, valid
     * @return the variable's value or &lt;b&gt;null&lt;/b&gt; if the variable is unknown
     */
    protected String resolveVariable(final String variableName, final TextStringBuilder buf, final int startPos,
            final int endPos) {
<span class="fc" id="L1044">        final StringLookup resolver = getStringLookup();</span>
<span class="fc bfc" id="L1045" title="All 2 branches covered.">        if (resolver == null) {</span>
<span class="fc" id="L1046">            return null;</span>
        }
<span class="fc" id="L1048">        return resolver.lookup(variableName);</span>
    }

    /**
     * Sets a flag whether substitution is done in variable values (recursive).
     *
     * @param disableSubstitutionInValues
     *            true if substitution in variable value are disabled
     * @return this, to enable chaining
     */
    public StringSubstitutor setDisableSubstitutionInValues(final boolean disableSubstitutionInValues) {
<span class="nc" id="L1059">        this.disableSubstitutionInValues = disableSubstitutionInValues;</span>
<span class="nc" id="L1060">        return this;</span>
    }

    /**
     * Sets a flag whether exception should be thrown if any variable is undefined.
     *
     * @param failOnUndefinedVariable
     *            true if exception should be thrown on undefined variable
     * @return this, to enable chaining
     */
    public StringSubstitutor setEnableUndefinedVariableException(final boolean failOnUndefinedVariable) {
<span class="fc" id="L1071">        this.enableUndefinedVariableException = failOnUndefinedVariable;</span>
<span class="fc" id="L1072">        return this;</span>
    }

    /**
     * Sets a flag whether substitution is done in variable names. If set to &lt;b&gt;true&lt;/b&gt;, the names of variables can
     * contain other variables which are processed first before the original variable is evaluated, e.g.
     * &lt;code&gt;${jre-${java.version}}&lt;/code&gt;. The default value is &lt;b&gt;false&lt;/b&gt;.
     *
     * @param enableSubstitutionInVariables
     *            the new value of the flag
     * @return this, to enable chaining
     */
    public StringSubstitutor setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {
<span class="fc" id="L1085">        this.enableSubstitutionInVariables = enableSubstitutionInVariables;</span>
<span class="fc" id="L1086">        return this;</span>
    }

    /**
     * Sets the escape character. If this character is placed before a variable reference in the source text, this
     * variable will be ignored.
     *
     * @param escapeCharacter
     *            the escape character (0 for disabling escaping)
     * @return this, to enable chaining
     */
    public StringSubstitutor setEscapeChar(final char escapeCharacter) {
<span class="fc" id="L1098">        this.escapeChar = escapeCharacter;</span>
<span class="fc" id="L1099">        return this;</span>
    }

    /**
     * Sets a flag controlling whether escapes are preserved during substitution. If set to &lt;b&gt;true&lt;/b&gt;, the escape
     * character is retained during substitution (e.g. &lt;code&gt;$${this-is-escaped}&lt;/code&gt; remains
     * &lt;code&gt;$${this-is-escaped}&lt;/code&gt;). If set to &lt;b&gt;false&lt;/b&gt;, the escape character is removed during substitution
     * (e.g. &lt;code&gt;$${this-is-escaped}&lt;/code&gt; becomes &lt;code&gt;${this-is-escaped}&lt;/code&gt;). The default value is
     * &lt;b&gt;false&lt;/b&gt;
     *
     * @param preserveEscapes
     *            true if escapes are to be preserved
     * @return this, to enable chaining
     */
    public StringSubstitutor setPreserveEscapes(final boolean preserveEscapes) {
<span class="fc" id="L1114">        this.preserveEscapes = preserveEscapes;</span>
<span class="fc" id="L1115">        return this;</span>
    }

    /**
     * Sets the variable default value delimiter to use.
     * &lt;p&gt;
     * The variable default value delimiter is the character or characters that delimite the variable name and the
     * variable default value. This method allows a single character variable default value delimiter to be easily set.
     *
     * @param valueDelimiter
     *            the variable default value delimiter character to use
     * @return this, to enable chaining
     */
    public StringSubstitutor setValueDelimiter(final char valueDelimiter) {
<span class="fc" id="L1129">        return setValueDelimiterMatcher(StringMatcherFactory.INSTANCE.charMatcher(valueDelimiter));</span>
    }

    /**
     * Sets the variable default value delimiter to use.
     * &lt;p&gt;
     * The variable default value delimiter is the character or characters that delimite the variable name and the
     * variable default value. This method allows a string variable default value delimiter to be easily set.
     * &lt;p&gt;
     * If the &lt;code&gt;valueDelimiter&lt;/code&gt; is null or empty string, then the variable default value resolution becomes
     * disabled.
     *
     * @param valueDelimiter
     *            the variable default value delimiter string to use, may be null or empty
     * @return this, to enable chaining
     */
    public StringSubstitutor setValueDelimiter(final String valueDelimiter) {
<span class="pc bpc" id="L1146" title="1 of 4 branches missed.">        if (valueDelimiter == null || valueDelimiter.length() == 0) {</span>
<span class="fc" id="L1147">            setValueDelimiterMatcher(null);</span>
<span class="fc" id="L1148">            return this;</span>
        }
<span class="fc" id="L1150">        return setValueDelimiterMatcher(StringMatcherFactory.INSTANCE.stringMatcher(valueDelimiter));</span>
    }

    /**
     * Sets the variable default value delimiter matcher to use.
     * &lt;p&gt;
     * The variable default value delimiter is the character or characters that delimite the variable name and the
     * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default
     * value delimiter matches.
     * &lt;p&gt;
     * If the &lt;code&gt;valueDelimiterMatcher&lt;/code&gt; is null, then the variable default value resolution becomes disabled.
     *
     * @param valueDelimiterMatcher
     *            variable default value delimiter matcher to use, may be null
     * @return this, to enable chaining
     */
    public StringSubstitutor setValueDelimiterMatcher(final StringMatcher valueDelimiterMatcher) {
<span class="fc" id="L1167">        this.valueDelimiterMatcher = valueDelimiterMatcher;</span>
<span class="fc" id="L1168">        return this;</span>
    }

    /**
     * Sets the variable prefix to use.
     * &lt;p&gt;
     * The variable prefix is the character or characters that identify the start of a variable. This method allows a
     * single character prefix to be easily set.
     *
     * @param prefix
     *            the prefix character to use
     * @return this, to enable chaining
     */
    public StringSubstitutor setVariablePrefix(final char prefix) {
<span class="fc" id="L1182">        return setVariablePrefixMatcher(StringMatcherFactory.INSTANCE.charMatcher(prefix));</span>
    }

    /**
     * Sets the variable prefix to use.
     * &lt;p&gt;
     * The variable prefix is the character or characters that identify the start of a variable. This method allows a
     * string prefix to be easily set.
     *
     * @param prefix
     *            the prefix for variables, not null
     * @return this, to enable chaining
     * @throws IllegalArgumentException
     *             if the prefix is null
     */
    public StringSubstitutor setVariablePrefix(final String prefix) {
<span class="fc bfc" id="L1198" title="All 2 branches covered.">        Validate.isTrue(prefix != null, &quot;Variable prefix must not be null!&quot;);</span>
<span class="fc" id="L1199">        return setVariablePrefixMatcher(StringMatcherFactory.INSTANCE.stringMatcher(prefix));</span>
    }

    /**
     * Sets the variable prefix matcher currently in use.
     * &lt;p&gt;
     * The variable prefix is the character or characters that identify the start of a variable. This prefix is
     * expressed in terms of a matcher allowing advanced prefix matches.
     *
     * @param prefixMatcher
     *            the prefix matcher to use, null ignored
     * @return this, to enable chaining
     * @throws IllegalArgumentException
     *             if the prefix matcher is null
     */
    public StringSubstitutor setVariablePrefixMatcher(final StringMatcher prefixMatcher) {
<span class="fc bfc" id="L1215" title="All 2 branches covered.">        Validate.isTrue(prefixMatcher != null, &quot;Variable prefix matcher must not be null!&quot;);</span>
<span class="fc" id="L1216">        this.prefixMatcher = prefixMatcher;</span>
<span class="fc" id="L1217">        return this;</span>
    }

    /**
     * Sets the VariableResolver that is used to lookup variables.
     *
     * @param variableResolver
     *            the VariableResolver
     * @return this, to enable chaining
     */
    public StringSubstitutor setVariableResolver(final StringLookup variableResolver) {
<span class="fc" id="L1228">        this.variableResolver = variableResolver;</span>
<span class="fc" id="L1229">        return this;</span>
    }

    /**
     * Sets the variable suffix to use.
     * &lt;p&gt;
     * The variable suffix is the character or characters that identify the end of a variable. This method allows a
     * single character suffix to be easily set.
     *
     * @param suffix
     *            the suffix character to use
     * @return this, to enable chaining
     */
    public StringSubstitutor setVariableSuffix(final char suffix) {
<span class="fc" id="L1243">        return setVariableSuffixMatcher(StringMatcherFactory.INSTANCE.charMatcher(suffix));</span>
    }

    /**
     * Sets the variable suffix to use.
     * &lt;p&gt;
     * The variable suffix is the character or characters that identify the end of a variable. This method allows a
     * string suffix to be easily set.
     *
     * @param suffix
     *            the suffix for variables, not null
     * @return this, to enable chaining
     * @throws IllegalArgumentException
     *             if the suffix is null
     */
    public StringSubstitutor setVariableSuffix(final String suffix) {
<span class="fc bfc" id="L1259" title="All 2 branches covered.">        Validate.isTrue(suffix != null, &quot;Variable suffix must not be null!&quot;);</span>
<span class="fc" id="L1260">        return setVariableSuffixMatcher(StringMatcherFactory.INSTANCE.stringMatcher(suffix));</span>
    }

    /**
     * Sets the variable suffix matcher currently in use.
     * &lt;p&gt;
     * The variable suffix is the character or characters that identify the end of a variable. This suffix is expressed
     * in terms of a matcher allowing advanced suffix matches.
     *
     * @param suffixMatcher
     *            the suffix matcher to use, null ignored
     * @return this, to enable chaining
     * @throws IllegalArgumentException
     *             if the suffix matcher is null
     */
    public StringSubstitutor setVariableSuffixMatcher(final StringMatcher suffixMatcher) {
<span class="fc bfc" id="L1276" title="All 2 branches covered.">        Validate.isTrue(suffixMatcher != null, &quot;Variable suffix matcher must not be null!&quot;);</span>
<span class="fc" id="L1277">        this.suffixMatcher = suffixMatcher;</span>
<span class="fc" id="L1278">        return this;</span>
    }

    // -----------------------------------------------------------------------
    /**
     * Internal method that substitutes the variables.
     * &lt;p&gt;
     * Most users of this class do not need to call this method. This method will be called automatically by another
     * (public) method.
     * &lt;p&gt;
     * Writers of subclasses can override this method if they need access to the substitution process at the start or
     * end.
     *
     * @param buf
     *            the string builder to substitute into, not null
     * @param offset
     *            the start offset within the builder, must be valid
     * @param length
     *            the length within the builder to be processed, must be valid
     * @return true if altered
     */
    protected boolean substitute(final TextStringBuilder buf, final int offset, final int length) {
<span class="fc bfc" id="L1300" title="All 2 branches covered.">        return substitute(buf, offset, length, null) &gt; 0;</span>
    }

    /**
     * Recursive handler for multiple levels of interpolation. This is the main interpolation method, which resolves the
     * values of all variable references contained in the passed in text.
     *
     * @param buf
     *            the string builder to substitute into, not null
     * @param offset
     *            the start offset within the builder, must be valid
     * @param length
     *            the length within the builder to be processed, must be valid
     * @param priorVariables
     *            the stack keeping track of the replaced variables, may be null
     * @return the length change that occurs, unless priorVariables is null when the int represents a boolean flag as to
     *         whether any change occurred.
     * @throws IllegalArgumentException
     *             if variable is not found when its allowed to throw exception
     */
    private int substitute(final TextStringBuilder buf, final int offset, final int length,
            List&lt;String&gt; priorVariables) {
<span class="fc" id="L1322">        final StringMatcher pfxMatcher = getVariablePrefixMatcher();</span>
<span class="fc" id="L1323">        final StringMatcher suffMatcher = getVariableSuffixMatcher();</span>
<span class="fc" id="L1324">        final char escape = getEscapeChar();</span>
<span class="fc" id="L1325">        final StringMatcher valueDelimMatcher = getValueDelimiterMatcher();</span>
<span class="fc" id="L1326">        final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();</span>
<span class="fc" id="L1327">        final boolean substitutionInValuesDisabled = isDisableSubstitutionInValues();</span>
<span class="fc" id="L1328">        final boolean undefinedVariableException = isEnableUndefinedVariableException();</span>

<span class="fc bfc" id="L1330" title="All 2 branches covered.">        final boolean top = priorVariables == null;</span>
<span class="fc" id="L1331">        boolean altered = false;</span>
<span class="fc" id="L1332">        int lengthChange = 0;</span>
<span class="fc" id="L1333">        char[] chars = buf.buffer;</span>
<span class="fc" id="L1334">        int bufEnd = offset + length;</span>
<span class="fc" id="L1335">        int pos = offset;</span>
<span class="fc bfc" id="L1336" title="All 2 branches covered.">        while (pos &lt; bufEnd) {</span>
<span class="fc" id="L1337">            final int startMatchLen = pfxMatcher.isMatch(chars, pos, offset, bufEnd);</span>
<span class="fc bfc" id="L1338" title="All 2 branches covered.">            if (startMatchLen == 0) {</span>
<span class="fc" id="L1339">                pos++;</span>
            } else {
                // found variable start marker
<span class="fc bfc" id="L1342" title="All 4 branches covered.">                if (pos &gt; offset &amp;&amp; chars[pos - 1] == escape) {</span>
                    // escaped
<span class="fc bfc" id="L1344" title="All 2 branches covered.">                    if (preserveEscapes) {</span>
<span class="fc" id="L1345">                        pos++;</span>
<span class="fc" id="L1346">                        continue;</span>
                    }
<span class="fc" id="L1348">                    buf.deleteCharAt(pos - 1);</span>
<span class="fc" id="L1349">                    chars = buf.buffer; // in case buffer was altered</span>
<span class="fc" id="L1350">                    lengthChange--;</span>
<span class="fc" id="L1351">                    altered = true;</span>
<span class="fc" id="L1352">                    bufEnd--;</span>
                } else {
                    // find suffix
<span class="fc" id="L1355">                    final int startPos = pos;</span>
<span class="fc" id="L1356">                    pos += startMatchLen;</span>
<span class="fc" id="L1357">                    int endMatchLen = 0;</span>
<span class="fc" id="L1358">                    int nestedVarCount = 0;</span>
<span class="fc bfc" id="L1359" title="All 2 branches covered.">                    while (pos &lt; bufEnd) {</span>
<span class="fc bfc" id="L1360" title="All 4 branches covered.">                        if (substitutionInVariablesEnabled &amp;&amp; pfxMatcher.isMatch(chars, pos, offset, bufEnd) != 0) {</span>
                            // found a nested variable start
<span class="fc" id="L1362">                            endMatchLen = pfxMatcher.isMatch(chars, pos, offset, bufEnd);</span>
<span class="fc" id="L1363">                            nestedVarCount++;</span>
<span class="fc" id="L1364">                            pos += endMatchLen;</span>
<span class="fc" id="L1365">                            continue;</span>
                        }

<span class="fc" id="L1368">                        endMatchLen = suffMatcher.isMatch(chars, pos, offset, bufEnd);</span>
<span class="fc bfc" id="L1369" title="All 2 branches covered.">                        if (endMatchLen == 0) {</span>
<span class="fc" id="L1370">                            pos++;</span>
                        } else {
                            // found variable end marker
<span class="fc bfc" id="L1373" title="All 2 branches covered.">                            if (nestedVarCount == 0) {</span>
<span class="fc" id="L1374">                                String varNameExpr = new String(chars, startPos + startMatchLen,</span>
                                        pos - startPos - startMatchLen);
<span class="fc bfc" id="L1376" title="All 2 branches covered.">                                if (substitutionInVariablesEnabled) {</span>
<span class="fc" id="L1377">                                    final TextStringBuilder bufName = new TextStringBuilder(varNameExpr);</span>
<span class="fc" id="L1378">                                    substitute(bufName, 0, bufName.length());</span>
<span class="fc" id="L1379">                                    varNameExpr = bufName.toString();</span>
                                }
<span class="fc" id="L1381">                                pos += endMatchLen;</span>
<span class="fc" id="L1382">                                final int endPos = pos;</span>

<span class="fc" id="L1384">                                String varName = varNameExpr;</span>
<span class="fc" id="L1385">                                String varDefaultValue = null;</span>

<span class="pc bpc" id="L1387" title="1 of 2 branches missed.">                                if (valueDelimMatcher != null) {</span>
<span class="fc" id="L1388">                                    final char[] varNameExprChars = varNameExpr.toCharArray();</span>
<span class="fc" id="L1389">                                    int valueDelimiterMatchLen = 0;</span>
<span class="fc bfc" id="L1390" title="All 2 branches covered.">                                    for (int i = 0; i &lt; varNameExprChars.length; i++) {</span>
                                        // if there's any nested variable when nested variable substitution disabled,
                                        // then stop resolving name and default value.
<span class="fc bfc" id="L1393" title="All 4 branches covered.">                                        if (!substitutionInVariablesEnabled &amp;&amp; pfxMatcher.isMatch(varNameExprChars, i,</span>
                                                i, varNameExprChars.length) != 0) {
<span class="fc" id="L1395">                                            break;</span>
                                        }
<span class="fc bfc" id="L1397" title="All 2 branches covered.">                                        if (valueDelimMatcher.isMatch(varNameExprChars, i, 0,</span>
                                                varNameExprChars.length) != 0) {
<span class="fc" id="L1399">                                            valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i, 0,</span>
                                                    varNameExprChars.length);
<span class="fc" id="L1401">                                            varName = varNameExpr.substring(0, i);</span>
<span class="fc" id="L1402">                                            varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);</span>
<span class="fc" id="L1403">                                            break;</span>
                                        }
                                    }
                                }

                                // on the first call initialize priorVariables
<span class="fc bfc" id="L1409" title="All 2 branches covered.">                                if (priorVariables == null) {</span>
<span class="fc" id="L1410">                                    priorVariables = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1411">                                    priorVariables.add(new String(chars, offset, length));</span>
                                }

                                // handle cyclic substitution
<span class="fc" id="L1415">                                checkCyclicSubstitution(varName, priorVariables);</span>
<span class="fc" id="L1416">                                priorVariables.add(varName);</span>

                                // resolve the variable
<span class="fc" id="L1419">                                String varValue = resolveVariable(varName, buf, startPos, endPos);</span>
<span class="fc bfc" id="L1420" title="All 2 branches covered.">                                if (varValue == null) {</span>
<span class="fc" id="L1421">                                    varValue = varDefaultValue;</span>
                                }
<span class="fc bfc" id="L1423" title="All 2 branches covered.">                                if (varValue != null) {</span>
<span class="fc" id="L1424">                                    final int varLen = varValue.length();</span>
<span class="fc" id="L1425">                                    buf.replace(startPos, endPos, varValue);</span>
<span class="fc" id="L1426">                                    altered = true;</span>
<span class="fc" id="L1427">                                    int change = 0;</span>
<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">                                    if (!substitutionInValuesDisabled) { // recursive replace</span>
<span class="fc" id="L1429">                                        change = substitute(buf, startPos, varLen, priorVariables);</span>
                                    }
<span class="fc" id="L1431">                                    change = change + varLen - (endPos - startPos);</span>
<span class="fc" id="L1432">                                    pos += change;</span>
<span class="fc" id="L1433">                                    bufEnd += change;</span>
<span class="fc" id="L1434">                                    lengthChange += change;</span>
<span class="fc" id="L1435">                                    chars = buf.buffer; // in case buffer was altered</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">                                } else if (undefinedVariableException) {</span>
<span class="fc" id="L1437">                                    throw new IllegalArgumentException(String.format(</span>
                                            &quot;Cannot resolve variable '%s' (enableSubstitutionInVariables=%s).&quot;, varName,
<span class="fc" id="L1439">                                            enableSubstitutionInVariables));</span>
                                }

                                // remove variable from the cyclic stack
<span class="fc" id="L1443">                                priorVariables.remove(priorVariables.size() - 1);</span>
<span class="fc" id="L1444">                                break;</span>
                            }
<span class="fc" id="L1446">                            nestedVarCount--;</span>
<span class="fc" id="L1447">                            pos += endMatchLen;</span>
                        }
                    }
                }
            }
<span class="fc" id="L1452">        }</span>
<span class="fc bfc" id="L1453" title="All 2 branches covered.">        if (top) {</span>
<span class="fc bfc" id="L1454" title="All 2 branches covered.">            return altered ? 1 : 0;</span>
        }
<span class="fc" id="L1456">        return lengthChange;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>