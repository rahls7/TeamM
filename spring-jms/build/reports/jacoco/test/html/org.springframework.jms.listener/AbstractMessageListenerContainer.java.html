<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractMessageListenerContainer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-jms</a> &gt; <a href="index.source.html" class="el_package">org.springframework.jms.listener</a> &gt; <span class="el_source">AbstractMessageListenerContainer.java</span></div><h1>AbstractMessageListenerContainer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.jms.listener;

import javax.jms.Connection;
import javax.jms.Destination;
import javax.jms.ExceptionListener;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.MessageListener;
import javax.jms.Queue;
import javax.jms.Session;
import javax.jms.Topic;

import org.springframework.jms.support.JmsUtils;
import org.springframework.jms.support.QosSettings;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.lang.Nullable;
import org.springframework.util.ErrorHandler;

/**
 * Abstract base class for Spring message listener container implementations.
 * Can either host a standard JMS {@link javax.jms.MessageListener} or Spring's
 * {@link SessionAwareMessageListener} for actual message processing.
 *
 * &lt;p&gt;Usually holds a single JMS {@link Connection} that all listeners are supposed
 * to be registered on, which is the standard JMS way of managing listener sessions.
 * Can alternatively also be used with a fresh Connection per listener, for Java EE
 * style XA-aware JMS messaging. The actual registration process is up to concrete
 * subclasses.
 *
 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; The default behavior of this message listener container is to
 * &lt;b&gt;never&lt;/b&gt; propagate an exception thrown by a message listener up to the JMS
 * provider. Instead, it will log any such exception at the error level.
 * This means that from the perspective of the attendant JMS provider no such
 * listener will ever fail. However, if error handling is necessary, then
 * any implementation of the {@link ErrorHandler} strategy may be provided to
 * the {@link #setErrorHandler(ErrorHandler)} method. Note that JMSExceptions
 * &lt;b&gt;will&lt;/b&gt; be passed to the ErrorHandler in addition to (but after) being
 * passed to an {@link ExceptionListener}, if one has been provided.
 *
 * &lt;p&gt;The listener container offers the following message acknowledgment options:
 * &lt;ul&gt;
 * &lt;li&gt;&quot;sessionAcknowledgeMode&quot; set to &quot;AUTO_ACKNOWLEDGE&quot; (default):
 * This mode is container-dependent: For {@link DefaultMessageListenerContainer},
 * it means automatic message acknowledgment &lt;i&gt;before&lt;/i&gt; listener execution, with
 * no redelivery in case of an exception and no redelivery in case of other listener
 * execution interruptions either. For {@link SimpleMessageListenerContainer},
 * it means automatic message acknowledgment &lt;i&gt;after&lt;/i&gt; listener execution, with
 * no redelivery in case of a user exception thrown but potential redelivery in case
 * of the JVM dying during listener execution. In order to consistently arrange for
 * redelivery with any container variant, consider &quot;CLIENT_ACKNOWLEDGE&quot; mode or -
 * preferably - setting &quot;sessionTransacted&quot; to &quot;true&quot; instead.
 * &lt;li&gt;&quot;sessionAcknowledgeMode&quot; set to &quot;DUPS_OK_ACKNOWLEDGE&quot;:
 * &lt;i&gt;Lazy&lt;/i&gt; message acknowledgment during ({@link DefaultMessageListenerContainer})
 * or shortly after ({@link SimpleMessageListenerContainer}) listener execution;
 * no redelivery in case of a user exception thrown but potential redelivery in case
 * of the JVM dying during listener execution. In order to consistently arrange for
 * redelivery with any container variant, consider &quot;CLIENT_ACKNOWLEDGE&quot; mode or -
 * preferably - setting &quot;sessionTransacted&quot; to &quot;true&quot; instead.
 * &lt;li&gt;&quot;sessionAcknowledgeMode&quot; set to &quot;CLIENT_ACKNOWLEDGE&quot;:
 * Automatic message acknowledgment &lt;i&gt;after&lt;/i&gt; successful listener execution;
 * best-effort redelivery in case of a user exception thrown as well as in case
 * of other listener execution interruptions (such as the JVM dying).
 * &lt;li&gt;&quot;sessionTransacted&quot; set to &quot;true&quot;:
 * Transactional acknowledgment after successful listener execution;
 * &lt;i&gt;guaranteed redelivery&lt;/i&gt; in case of a user exception thrown as well as
 * in case of other listener execution interruptions (such as the JVM dying).
 * &lt;/ul&gt;
 *
 * &lt;p&gt;There are two solutions to the duplicate message processing problem:
 * &lt;ul&gt;
 * &lt;li&gt;Either add &lt;i&gt;duplicate message detection&lt;/i&gt; to your listener, in the
 * form of a business entity existence check or a protocol table check. This
 * usually just needs to be done in case of the JMSRedelivered flag being
 * set on the incoming message (otherwise just process straightforwardly).
 * Note that with &quot;sessionTransacted&quot; set to &quot;true&quot;, duplicate messages will
 * only appear in case of the JVM dying at the most unfortunate point possible
 * (i.e. after your business logic executed but before the JMS part got committed),
 * so duplicate message detection is just there to cover a corner case.
 * &lt;li&gt;Or wrap your &lt;i&gt;entire processing with an XA transaction&lt;/i&gt;, covering the
 * reception of the JMS message as well as the execution of the business logic in
 * your message listener (including database operations etc). This is only
 * supported by {@link DefaultMessageListenerContainer}, through specifying
 * an external &quot;transactionManager&quot; (typically a
 * {@link org.springframework.transaction.jta.JtaTransactionManager}, with
 * a corresponding XA-aware JMS {@link javax.jms.ConnectionFactory} passed in
 * as &quot;connectionFactory&quot;).
 * &lt;/ul&gt;
 * Note that XA transaction coordination adds significant runtime overhead,
 * so it might be feasible to avoid it unless absolutely necessary.
 *
 * &lt;p&gt;&lt;b&gt;Recommendations:&lt;/b&gt;
 * &lt;ul&gt;
 * &lt;li&gt;The general recommendation is to set &quot;sessionTransacted&quot; to &quot;true&quot;,
 * typically in combination with local database transactions triggered by the
 * listener implementation, through Spring's standard transaction facilities.
 * This will work nicely in Tomcat or in a standalone environment, often
 * combined with custom duplicate message detection (if it is unacceptable
 * to ever process the same message twice).
 * &lt;li&gt;Alternatively, specify a
 * {@link org.springframework.transaction.jta.JtaTransactionManager} as
 * &quot;transactionManager&quot; for a fully XA-aware JMS provider - typically when
 * running on a Java EE server, but also for other environments with a JTA
 * transaction manager present. This will give full &quot;exactly-once&quot; guarantees
 * without custom duplicate message checks, at the price of additional
 * runtime processing overhead.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Note that the &quot;sessionTransacted&quot; flag is strongly recommended over
 * {@link org.springframework.jms.connection.JmsTransactionManager}, provided
 * that transactions do not need to be managed externally. As a consequence,
 * set the transaction manager only if you are using JTA or if you need to
 * synchronize with custom external transaction arrangements.
 *
 * @author Juergen Hoeller
 * @author Stephane Nicoll
 * @since 2.0
 * @see #setMessageListener
 * @see javax.jms.MessageListener
 * @see SessionAwareMessageListener
 * @see #handleListenerException
 * @see DefaultMessageListenerContainer
 * @see SimpleMessageListenerContainer
 * @see org.springframework.jms.listener.endpoint.JmsMessageEndpointManager
 */
<span class="fc" id="L142">public abstract class AbstractMessageListenerContainer extends AbstractJmsListeningContainer</span>
		implements MessageListenerContainer {

	@Nullable
	private volatile Object destination;

	@Nullable
	private volatile String messageSelector;

	@Nullable
	private volatile Object messageListener;

<span class="fc" id="L154">	private boolean subscriptionDurable = false;</span>

<span class="fc" id="L156">	private boolean subscriptionShared = false;</span>

	@Nullable
	private String subscriptionName;

	@Nullable
	private Boolean replyPubSubDomain;

	@Nullable
	private QosSettings replyQosSettings;

<span class="fc" id="L167">	private boolean pubSubNoLocal = false;</span>

	@Nullable
	private MessageConverter messageConverter;

	@Nullable
	private ExceptionListener exceptionListener;

	@Nullable
	private ErrorHandler errorHandler;

<span class="fc" id="L178">	private boolean exposeListenerSession = true;</span>

<span class="fc" id="L180">	private boolean acceptMessagesWhileStopping = false;</span>


	/**
	 * Specify concurrency limits.
	 */
	public abstract void setConcurrency(String concurrency);

	/**
	 * Set the destination to receive messages from.
	 * &lt;p&gt;Alternatively, specify a &quot;destinationName&quot;, to be dynamically
	 * resolved via the {@link org.springframework.jms.support.destination.DestinationResolver}.
	 * &lt;p&gt;Note: The destination may be replaced at runtime, with the listener
	 * container picking up the new destination immediately (works e.g. with
	 * DefaultMessageListenerContainer, as long as the cache level is less than
	 * CACHE_CONSUMER). However, this is considered advanced usage; use it with care!
	 * @see #setDestinationName(String)
	 */
	public void setDestination(@Nullable Destination destination) {
<span class="fc" id="L199">		this.destination = destination;</span>
<span class="pc bpc" id="L200" title="3 of 4 branches missed.">		if (destination instanceof Topic &amp;&amp; !(destination instanceof Queue)) {</span>
			// Clearly a Topic: let's set the &quot;pubSubDomain&quot; flag accordingly.
<span class="nc" id="L202">			setPubSubDomain(true);</span>
		}
<span class="fc" id="L204">	}</span>

	/**
	 * Return the destination to receive messages from. Will be {@code null}
	 * if the configured destination is not an actual {@link Destination} type;
	 * c.f. {@link #setDestinationName(String) when the destination is a String}.
	 */
	@Nullable
	public Destination getDestination() {
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">		return (this.destination instanceof Destination ? (Destination) this.destination : null);</span>
	}

	/**
	 * Set the name of the destination to receive messages from.
	 * &lt;p&gt;The specified name will be dynamically resolved via the configured
	 * {@link #setDestinationResolver destination resolver}.
	 * &lt;p&gt;Alternatively, specify a JMS {@link Destination} object as &quot;destination&quot;.
	 * &lt;p&gt;Note: The destination may be replaced at runtime, with the listener
	 * container picking up the new destination immediately (works e.g. with
	 * DefaultMessageListenerContainer, as long as the cache level is less than
	 * CACHE_CONSUMER). However, this is considered advanced usage; use it with care!
	 * @see #setDestination(javax.jms.Destination)
	 */
	public void setDestinationName(@Nullable String destinationName) {
<span class="fc" id="L228">		this.destination = destinationName;</span>
<span class="fc" id="L229">	}</span>

	/**
	 * Return the name of the destination to receive messages from.
	 * Will be {@code null} if the configured destination is not a
	 * {@link String} type; c.f. {@link #setDestination(Destination) when
	 * it is an actual Destination}.
	 */
	@Nullable
	public String getDestinationName() {
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">		return (this.destination instanceof String ? (String) this.destination : null);</span>
	}

	/**
	 * Return a descriptive String for this container's JMS destination
	 * (never {@code null}).
	 */
	protected String getDestinationDescription() {
<span class="fc" id="L247">		Object destination = this.destination;</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">		return (destination != null ? destination.toString() : &quot;&quot;);</span>
	}

	/**
	 * Set the JMS message selector expression (or {@code null} if none).
	 * Default is none.
	 * &lt;p&gt;See the JMS specification for a detailed definition of selector expressions.
	 * &lt;p&gt;Note: The message selector may be replaced at runtime, with the listener
	 * container picking up the new selector value immediately (works e.g. with
	 * DefaultMessageListenerContainer, as long as the cache level is less than
	 * CACHE_CONSUMER). However, this is considered advanced usage; use it with care!
	 */
	public void setMessageSelector(@Nullable String messageSelector) {
<span class="fc" id="L261">		this.messageSelector = messageSelector;</span>
<span class="fc" id="L262">	}</span>

	/**
	 * Return the JMS message selector expression (or {@code null} if none).
	 */
	@Nullable
	public String getMessageSelector() {
<span class="fc" id="L269">		return this.messageSelector;</span>
	}


	/**
	 * Set the message listener implementation to register.
	 * This can be either a standard JMS {@link MessageListener} object
	 * or a Spring {@link SessionAwareMessageListener} object.
	 * &lt;p&gt;Note: The message listener may be replaced at runtime, with the listener
	 * container picking up the new listener object immediately (works e.g. with
	 * DefaultMessageListenerContainer, as long as the cache level is less than
	 * CACHE_CONSUMER). However, this is considered advanced usage; use it with care!
	 * @throws IllegalArgumentException if the supplied listener is not a
	 * {@link MessageListener} or a {@link SessionAwareMessageListener}
	 * @see javax.jms.MessageListener
	 * @see SessionAwareMessageListener
	 */
	public void setMessageListener(@Nullable Object messageListener) {
<span class="fc" id="L287">		checkMessageListener(messageListener);</span>
<span class="fc" id="L288">		this.messageListener = messageListener;</span>
<span class="fc bfc" id="L289" title="All 4 branches covered.">		if (messageListener != null &amp;&amp; this.subscriptionName == null) {</span>
<span class="fc" id="L290">			this.subscriptionName = getDefaultSubscriptionName(messageListener);</span>
		}
<span class="fc" id="L292">	}</span>

	/**
	 * Return the message listener object to register.
	 */
	@Nullable
	public Object getMessageListener() {
<span class="fc" id="L299">		return this.messageListener;</span>
	}

	/**
	 * Check the given message listener, throwing an exception
	 * if it does not correspond to a supported listener type.
	 * &lt;p&gt;By default, only a standard JMS {@link MessageListener} object or a
	 * Spring {@link SessionAwareMessageListener} object will be accepted.
	 * @param messageListener the message listener object to check
	 * @throws IllegalArgumentException if the supplied listener is not a
	 * {@link MessageListener} or a {@link SessionAwareMessageListener}
	 * @see javax.jms.MessageListener
	 * @see SessionAwareMessageListener
	 */
	protected void checkMessageListener(@Nullable Object messageListener) {
<span class="fc bfc" id="L314" title="All 6 branches covered.">		if (messageListener != null &amp;&amp; !(messageListener instanceof MessageListener ||</span>
				messageListener instanceof SessionAwareMessageListener)) {
<span class="fc" id="L316">			throw new IllegalArgumentException(</span>
<span class="fc" id="L317">					&quot;Message listener needs to be of type [&quot; + MessageListener.class.getName() +</span>
<span class="fc" id="L318">					&quot;] or [&quot; + SessionAwareMessageListener.class.getName() + &quot;]&quot;);</span>
		}
<span class="fc" id="L320">	}</span>

	/**
	 * Determine the default subscription name for the given message listener.
	 * @param messageListener the message listener object to check
	 * @return the default subscription name
	 * @see SubscriptionNameProvider
	 */
	protected String getDefaultSubscriptionName(Object messageListener) {
<span class="fc bfc" id="L329" title="All 2 branches covered.">		if (messageListener instanceof SubscriptionNameProvider) {</span>
<span class="fc" id="L330">			return ((SubscriptionNameProvider) messageListener).getSubscriptionName();</span>
		}
		else {
<span class="fc" id="L333">			return messageListener.getClass().getName();</span>
		}
	}

	/**
	 * Set whether to make the subscription durable. The durable subscription name
	 * to be used can be specified through the &quot;subscriptionName&quot; property.
	 * &lt;p&gt;Default is &quot;false&quot;. Set this to &quot;true&quot; to register a durable subscription,
	 * typically in combination with a &quot;subscriptionName&quot; value (unless
	 * your message listener class name is good enough as subscription name).
	 * &lt;p&gt;Only makes sense when listening to a topic (pub-sub domain),
	 * therefore this method switches the &quot;pubSubDomain&quot; flag as well.
	 * @see #setSubscriptionName
	 * @see #setPubSubDomain
	 */
	public void setSubscriptionDurable(boolean subscriptionDurable) {
<span class="fc" id="L349">		this.subscriptionDurable = subscriptionDurable;</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">		if (subscriptionDurable) {</span>
<span class="fc" id="L351">			setPubSubDomain(true);</span>
		}
<span class="fc" id="L353">	}</span>

	/**
	 * Return whether to make the subscription durable.
	 */
	public boolean isSubscriptionDurable() {
<span class="fc" id="L359">		return this.subscriptionDurable;</span>
	}

	/**
	 * Set whether to make the subscription shared. The shared subscription name
	 * to be used can be specified through the &quot;subscriptionName&quot; property.
	 * &lt;p&gt;Default is &quot;false&quot;. Set this to &quot;true&quot; to register a shared subscription,
	 * typically in combination with a &quot;subscriptionName&quot; value (unless
	 * your message listener class name is good enough as subscription name).
	 * Note that shared subscriptions may also be durable, so this flag can
	 * (and often will) be combined with &quot;subscriptionDurable&quot; as well.
	 * &lt;p&gt;Only makes sense when listening to a topic (pub-sub domain),
	 * therefore this method switches the &quot;pubSubDomain&quot; flag as well.
	 * &lt;p&gt;&lt;b&gt;Requires a JMS 2.0 compatible message broker.&lt;/b&gt;
	 * @since 4.1
	 * @see #setSubscriptionName
	 * @see #setSubscriptionDurable
	 * @see #setPubSubDomain
	 */
	public void setSubscriptionShared(boolean subscriptionShared) {
<span class="fc" id="L379">		this.subscriptionShared = subscriptionShared;</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">		if (subscriptionShared) {</span>
<span class="nc" id="L381">			setPubSubDomain(true);</span>
		}
<span class="fc" id="L383">	}</span>

	/**
	 * Return whether to make the subscription shared.
	 * @since 4.1
	 */
	public boolean isSubscriptionShared() {
<span class="nc" id="L390">		return this.subscriptionShared;</span>
	}

	/**
	 * Set the name of a subscription to create. To be applied in case
	 * of a topic (pub-sub domain) with a shared or durable subscription.
	 * &lt;p&gt;The subscription name needs to be unique within this client's
	 * JMS client id. Default is the class name of the specified message listener.
	 * &lt;p&gt;Note: Only 1 concurrent consumer (which is the default of this
	 * message listener container) is allowed for each subscription,
	 * except for a shared subscription (which requires JMS 2.0).
	 * @since 4.1
	 * @see #setPubSubDomain
	 * @see #setSubscriptionDurable
	 * @see #setSubscriptionShared
	 * @see #setClientId
	 * @see #setMessageListener
	 */
	public void setSubscriptionName(@Nullable String subscriptionName) {
<span class="fc" id="L409">		this.subscriptionName = subscriptionName;</span>
<span class="fc" id="L410">	}</span>

	/**
	 * Return the name of a subscription to create, if any.
	 * @since 4.1
	 */
	@Nullable
	public String getSubscriptionName() {
<span class="fc" id="L418">		return this.subscriptionName;</span>
	}

	/**
	 * Set the name of a durable subscription to create. This method switches
	 * to pub-sub domain mode and activates subscription durability as well.
	 * &lt;p&gt;The durable subscription name needs to be unique within this client's
	 * JMS client id. Default is the class name of the specified message listener.
	 * &lt;p&gt;Note: Only 1 concurrent consumer (which is the default of this
	 * message listener container) is allowed for each durable subscription,
	 * except for a shared durable subscription (which requires JMS 2.0).
	 * @see #setPubSubDomain
	 * @see #setSubscriptionDurable
	 * @see #setSubscriptionShared
	 * @see #setClientId
	 * @see #setMessageListener
	 */
	public void setDurableSubscriptionName(@Nullable String durableSubscriptionName) {
<span class="nc" id="L436">		this.subscriptionName = durableSubscriptionName;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">		this.subscriptionDurable = (durableSubscriptionName != null);</span>
<span class="nc" id="L438">	}</span>

	/**
	 * Return the name of a durable subscription to create, if any.
	 */
	@Nullable
	public String getDurableSubscriptionName() {
<span class="nc bnc" id="L445" title="All 2 branches missed.">		return (this.subscriptionDurable ? this.subscriptionName : null);</span>
	}

	/**
	 * Set whether to inhibit the delivery of messages published by its own connection.
	 * Default is &quot;false&quot;.
	 * @since 4.1
	 * @see javax.jms.Session#createConsumer(javax.jms.Destination, String, boolean)
	 */
	public void setPubSubNoLocal(boolean pubSubNoLocal) {
<span class="nc" id="L455">		this.pubSubNoLocal = pubSubNoLocal;</span>
<span class="nc" id="L456">	}</span>

	/**
	 * Return whether to inhibit the delivery of messages published by its own connection.
	 * @since 4.1
	 */
	public boolean isPubSubNoLocal() {
<span class="fc" id="L463">		return this.pubSubNoLocal;</span>
	}

	/**
	 * Configure the reply destination type. By default, the configured {@code pubSubDomain}
	 * value is used (see {@link #isPubSubDomain()}.
	 * &lt;p&gt;This setting primarily indicates what type of destination to resolve if dynamic
	 * destinations are enabled.
	 * @param replyPubSubDomain &quot;true&quot; for the Publish/Subscribe domain ({@link Topic Topics}),
	 * &quot;false&quot; for the Point-to-Point domain ({@link Queue Queues})
	 * @since 4.2
	 * @see #setDestinationResolver
	 */
	public void setReplyPubSubDomain(boolean replyPubSubDomain) {
<span class="fc" id="L477">		this.replyPubSubDomain = replyPubSubDomain;</span>
<span class="fc" id="L478">	}</span>

	/**
	 * Return whether the Publish/Subscribe domain ({@link javax.jms.Topic Topics}) is used
	 * for replies. Otherwise, the Point-to-Point domain ({@link javax.jms.Queue Queues})
	 * is used.
	 * @since 4.2
	 */
	@Override
	public boolean isReplyPubSubDomain() {
<span class="fc bfc" id="L488" title="All 2 branches covered.">		if (this.replyPubSubDomain != null) {</span>
<span class="fc" id="L489">			return this.replyPubSubDomain;</span>
		}
		else {
<span class="fc" id="L492">			return isPubSubDomain();</span>
		}
	}

	/**
	 * Configure the {@link QosSettings} to use when sending a reply. Can be set to
	 * {@code null} to indicate that the broker's defaults should be used.
	 * @param replyQosSettings the QoS settings to use when sending a reply or {@code null}
	 * to use the default vas.
	 * @since 5.0
	 */
	public void setReplyQosSettings(@Nullable QosSettings replyQosSettings) {
<span class="fc" id="L504">		this.replyQosSettings = replyQosSettings;</span>
<span class="fc" id="L505">	}</span>

	@Override
	@Nullable
	public QosSettings getReplyQosSettings() {
<span class="fc" id="L510">		return this.replyQosSettings;</span>
	}

	/**
	 * Set the {@link MessageConverter} strategy for converting JMS Messages.
	 * @since 4.1
	 */
	public void setMessageConverter(@Nullable MessageConverter messageConverter) {
<span class="fc" id="L518">		this.messageConverter = messageConverter;</span>
<span class="fc" id="L519">	}</span>

	@Override
	@Nullable
	public MessageConverter getMessageConverter() {
<span class="fc" id="L524">		return this.messageConverter;</span>
	}

	/**
	 * Set the JMS ExceptionListener to notify in case of a JMSException thrown
	 * by the registered message listener or the invocation infrastructure.
	 */
	public void setExceptionListener(@Nullable ExceptionListener exceptionListener) {
<span class="fc" id="L532">		this.exceptionListener = exceptionListener;</span>
<span class="fc" id="L533">	}</span>

	/**
	 * Return the JMS ExceptionListener to notify in case of a JMSException thrown
	 * by the registered message listener or the invocation infrastructure, if any.
	 */
	@Nullable
	public ExceptionListener getExceptionListener() {
<span class="fc" id="L541">		return this.exceptionListener;</span>
	}

	/**
	 * Set the ErrorHandler to be invoked in case of any uncaught exceptions thrown
	 * while processing a Message.
	 * &lt;p&gt;By default, there will be &lt;b&gt;no&lt;/b&gt; ErrorHandler so that error-level
	 * logging is the only result.
	 */
	public void setErrorHandler(@Nullable ErrorHandler errorHandler) {
<span class="fc" id="L551">		this.errorHandler = errorHandler;</span>
<span class="fc" id="L552">	}</span>

	/**
	 * Return the ErrorHandler to be invoked in case of any uncaught exceptions thrown
	 * while processing a Message.
	 * @since 4.1
	 */
	@Nullable
	public ErrorHandler getErrorHandler() {
<span class="fc" id="L561">		return this.errorHandler;</span>
	}

	/**
	 * Set whether to expose the listener JMS Session to a registered
	 * {@link SessionAwareMessageListener} as well as to
	 * {@link org.springframework.jms.core.JmsTemplate} calls.
	 * &lt;p&gt;Default is &quot;true&quot;, reusing the listener's {@link Session}.
	 * Turn this off to expose a fresh JMS Session fetched from the same
	 * underlying JMS {@link Connection} instead, which might be necessary
	 * on some JMS providers.
	 * &lt;p&gt;Note that Sessions managed by an external transaction manager will
	 * always get exposed to {@link org.springframework.jms.core.JmsTemplate}
	 * calls. So in terms of JmsTemplate exposure, this setting only affects
	 * locally transacted Sessions.
	 * @see SessionAwareMessageListener
	 */
	public void setExposeListenerSession(boolean exposeListenerSession) {
<span class="nc" id="L579">		this.exposeListenerSession = exposeListenerSession;</span>
<span class="nc" id="L580">	}</span>

	/**
	 * Return whether to expose the listener JMS {@link Session} to a
	 * registered {@link SessionAwareMessageListener}.
	 */
	public boolean isExposeListenerSession() {
<span class="fc" id="L587">		return this.exposeListenerSession;</span>
	}

	/**
	 * Set whether to accept received messages while the listener container
	 * in the process of stopping.
	 * &lt;p&gt;Default is &quot;false&quot;, rejecting such messages through aborting the
	 * receive attempt. Switch this flag on to fully process such messages
	 * even in the stopping phase, with the drawback that even newly sent
	 * messages might still get processed (if coming in before all receive
	 * timeouts have expired).
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Aborting receive attempts for such incoming messages
	 * might lead to the provider's retry count decreasing for the affected
	 * messages. If you have a high number of concurrent consumers, make sure
	 * that the number of retries is higher than the number of consumers,
	 * to be on the safe side for all potential stopping scenarios.
	 */
	public void setAcceptMessagesWhileStopping(boolean acceptMessagesWhileStopping) {
<span class="nc" id="L605">		this.acceptMessagesWhileStopping = acceptMessagesWhileStopping;</span>
<span class="nc" id="L606">	}</span>

	/**
	 * Return whether to accept received messages while the listener container
	 * in the process of stopping.
	 */
	public boolean isAcceptMessagesWhileStopping() {
<span class="fc" id="L613">		return this.acceptMessagesWhileStopping;</span>
	}

	@Override
	protected void validateConfiguration() {
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">		if (this.destination == null) {</span>
<span class="nc" id="L619">			throw new IllegalArgumentException(&quot;Property 'destination' or 'destinationName' is required&quot;);</span>
		}
<span class="fc" id="L621">	}</span>

	@Override
	public void setupMessageListener(Object messageListener) {
<span class="fc" id="L625">		setMessageListener(messageListener);</span>
<span class="fc" id="L626">	}</span>


	//-------------------------------------------------------------------------
	// Template methods for listener execution
	//-------------------------------------------------------------------------

	/**
	 * Execute the specified listener,
	 * committing or rolling back the transaction afterwards (if necessary).
	 * @param session the JMS Session to operate on
	 * @param message the received JMS Message
	 * @see #invokeListener
	 * @see #commitIfNecessary
	 * @see #rollbackOnExceptionIfNecessary
	 * @see #handleListenerException
	 */
	protected void executeListener(Session session, Message message) {
		try {
<span class="fc" id="L645">			doExecuteListener(session, message);</span>
		}
<span class="fc" id="L647">		catch (Throwable ex) {</span>
<span class="fc" id="L648">			handleListenerException(ex);</span>
<span class="fc" id="L649">		}</span>
<span class="fc" id="L650">	}</span>

	/**
	 * Execute the specified listener,
	 * committing or rolling back the transaction afterwards (if necessary).
	 * @param session the JMS Session to operate on
	 * @param message the received JMS Message
	 * @throws JMSException if thrown by JMS API methods
	 * @see #invokeListener
	 * @see #commitIfNecessary
	 * @see #rollbackOnExceptionIfNecessary
	 * @see #convertJmsAccessException
	 */
	protected void doExecuteListener(Session session, Message message) throws JMSException {
<span class="pc bpc" id="L664" title="2 of 4 branches missed.">		if (!isAcceptMessagesWhileStopping() &amp;&amp; !isRunning()) {</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">			if (logger.isWarnEnabled()) {</span>
<span class="nc" id="L666">				logger.warn(&quot;Rejecting received message because of the listener container &quot; +</span>
						&quot;having been stopped in the meantime: &quot; + message);
			}
<span class="nc" id="L669">			rollbackIfNecessary(session);</span>
<span class="nc" id="L670">			throw new MessageRejectedWhileStoppingException();</span>
		}

		try {
<span class="fc" id="L674">			invokeListener(session, message);</span>
		}
<span class="fc" id="L676">		catch (JMSException | RuntimeException | Error ex) {</span>
<span class="fc" id="L677">			rollbackOnExceptionIfNecessary(session, ex);</span>
<span class="fc" id="L678">			throw ex;</span>
<span class="fc" id="L679">		}</span>
<span class="fc" id="L680">		commitIfNecessary(session, message);</span>
<span class="fc" id="L681">	}</span>

	/**
	 * Invoke the specified listener: either as standard JMS MessageListener
	 * or (preferably) as Spring SessionAwareMessageListener.
	 * @param session the JMS Session to operate on
	 * @param message the received JMS Message
	 * @throws JMSException if thrown by JMS API methods
	 * @see #setMessageListener
	 */
	@SuppressWarnings(&quot;rawtypes&quot;)
	protected void invokeListener(Session session, Message message) throws JMSException {
<span class="fc" id="L693">		Object listener = getMessageListener();</span>

<span class="fc bfc" id="L695" title="All 2 branches covered.">		if (listener instanceof SessionAwareMessageListener) {</span>
<span class="fc" id="L696">			doInvokeListener((SessionAwareMessageListener) listener, session, message);</span>
		}
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">		else if (listener instanceof MessageListener) {</span>
<span class="fc" id="L699">			doInvokeListener((MessageListener) listener, message);</span>
		}
<span class="nc bnc" id="L701" title="All 2 branches missed.">		else if (listener != null) {</span>
<span class="nc" id="L702">			throw new IllegalArgumentException(</span>
					&quot;Only MessageListener and SessionAwareMessageListener supported: &quot; + listener);
		}
		else {
<span class="nc" id="L706">			throw new IllegalStateException(&quot;No message listener specified - see property 'messageListener'&quot;);</span>
		}
<span class="fc" id="L708">	}</span>

	/**
	 * Invoke the specified listener as Spring SessionAwareMessageListener,
	 * exposing a new JMS Session (potentially with its own transaction)
	 * to the listener if demanded.
	 * @param listener the Spring SessionAwareMessageListener to invoke
	 * @param session the JMS Session to operate on
	 * @param message the received JMS Message
	 * @throws JMSException if thrown by JMS API methods
	 * @see SessionAwareMessageListener
	 * @see #setExposeListenerSession
	 */
	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	protected void doInvokeListener(SessionAwareMessageListener listener, Session session, Message message)
			throws JMSException {

<span class="fc" id="L725">		Connection conToClose = null;</span>
<span class="fc" id="L726">		Session sessionToClose = null;</span>
		try {
<span class="fc" id="L728">			Session sessionToUse = session;</span>
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">			if (!isExposeListenerSession()) {</span>
				// We need to expose a separate Session.
<span class="nc" id="L731">				conToClose = createConnection();</span>
<span class="nc" id="L732">				sessionToClose = createSession(conToClose);</span>
<span class="nc" id="L733">				sessionToUse = sessionToClose;</span>
			}
			// Actually invoke the message listener...
<span class="fc" id="L736">			listener.onMessage(message, sessionToUse);</span>
			// Clean up specially exposed Session, if any.
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">			if (sessionToUse != session) {</span>
<span class="nc bnc" id="L739" title="All 4 branches missed.">				if (sessionToUse.getTransacted() &amp;&amp; isSessionLocallyTransacted(sessionToUse)) {</span>
					// Transacted session created by this container -&gt; commit.
<span class="nc" id="L741">					JmsUtils.commitIfNecessary(sessionToUse);</span>
				}
			}
		}
		finally {
<span class="fc" id="L746">			JmsUtils.closeSession(sessionToClose);</span>
<span class="fc" id="L747">			JmsUtils.closeConnection(conToClose);</span>
		}
<span class="fc" id="L749">	}</span>

	/**
	 * Invoke the specified listener as standard JMS MessageListener.
	 * &lt;p&gt;Default implementation performs a plain invocation of the
	 * {@code onMessage} method.
	 * @param listener the JMS MessageListener to invoke
	 * @param message the received JMS Message
	 * @throws JMSException if thrown by JMS API methods
	 * @see javax.jms.MessageListener#onMessage
	 */
	protected void doInvokeListener(MessageListener listener, Message message) throws JMSException {
<span class="fc" id="L761">		listener.onMessage(message);</span>
<span class="fc" id="L762">	}</span>

	/**
	 * Perform a commit or message acknowledgement, as appropriate.
	 * @param session the JMS Session to commit
	 * @param message the Message to acknowledge
	 * @throws javax.jms.JMSException in case of commit failure
	 */
	protected void commitIfNecessary(Session session, @Nullable Message message) throws JMSException {
		// Commit session or acknowledge message.
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">		if (session.getTransacted()) {</span>
			// Commit necessary - but avoid commit call within a JTA transaction.
<span class="nc bnc" id="L774" title="All 2 branches missed.">			if (isSessionLocallyTransacted(session)) {</span>
				// Transacted session created by this container -&gt; commit.
<span class="nc" id="L776">				JmsUtils.commitIfNecessary(session);</span>
			}
		}
<span class="pc bpc" id="L779" title="2 of 4 branches missed.">		else if (message != null &amp;&amp; isClientAcknowledge(session)) {</span>
<span class="nc" id="L780">			message.acknowledge();</span>
		}
<span class="fc" id="L782">	}</span>

	/**
	 * Perform a rollback, if appropriate.
	 * @param session the JMS Session to rollback
	 * @throws javax.jms.JMSException in case of a rollback error
	 */
	protected void rollbackIfNecessary(Session session) throws JMSException {
<span class="nc bnc" id="L790" title="All 2 branches missed.">		if (session.getTransacted()) {</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">			if (isSessionLocallyTransacted(session)) {</span>
				// Transacted session created by this container -&gt; rollback.
<span class="nc" id="L793">				JmsUtils.rollbackIfNecessary(session);</span>
			}
		}
<span class="nc bnc" id="L796" title="All 2 branches missed.">		else if (isClientAcknowledge(session)) {</span>
<span class="nc" id="L797">			session.recover();</span>
		}
<span class="nc" id="L799">	}</span>

	/**
	 * Perform a rollback, handling rollback exceptions properly.
	 * @param session the JMS Session to rollback
	 * @param ex the thrown application exception or error
	 * @throws javax.jms.JMSException in case of a rollback error
	 */
	protected void rollbackOnExceptionIfNecessary(Session session, Throwable ex) throws JMSException {
		try {
<span class="fc bfc" id="L809" title="All 2 branches covered.">			if (session.getTransacted()) {</span>
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">				if (isSessionLocallyTransacted(session)) {</span>
					// Transacted session created by this container -&gt; rollback.
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">					if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L813">						logger.debug(&quot;Initiating transaction rollback on application exception&quot;, ex);</span>
					}
<span class="fc" id="L815">					JmsUtils.rollbackIfNecessary(session);</span>
				}
			}
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">			else if (isClientAcknowledge(session)) {</span>
<span class="nc" id="L819">				session.recover();</span>
			}
		}
<span class="nc" id="L822">		catch (IllegalStateException ex2) {</span>
<span class="nc" id="L823">			logger.debug(&quot;Could not roll back because Session already closed&quot;, ex2);</span>
		}
<span class="nc" id="L825">		catch (JMSException | RuntimeException | Error ex2) {</span>
<span class="nc" id="L826">			logger.error(&quot;Application exception overridden by rollback error&quot;, ex);</span>
<span class="nc" id="L827">			throw ex2;</span>
<span class="pc" id="L828">		}</span>
<span class="fc" id="L829">	}</span>

	/**
	 * Check whether the given Session is locally transacted, that is, whether
	 * its transaction is managed by this listener container's Session handling
	 * and not by an external transaction coordinator.
	 * &lt;p&gt;Note: The Session's own transacted flag will already have been checked
	 * before. This method is about finding out whether the Session's transaction
	 * is local or externally coordinated.
	 * @param session the Session to check
	 * @return whether the given Session is locally transacted
	 * @see #isSessionTransacted()
	 * @see org.springframework.jms.connection.ConnectionFactoryUtils#isSessionTransactional
	 */
	protected boolean isSessionLocallyTransacted(Session session) {
<span class="fc" id="L844">		return isSessionTransacted();</span>
	}

	/**
	 * Create a JMS MessageConsumer for the given Session and Destination.
	 * &lt;p&gt;This implementation uses JMS 1.1 API.
	 * @param session the JMS Session to create a MessageConsumer for
	 * @param destination the JMS Destination to create a MessageConsumer for
	 * @return the new JMS MessageConsumer
	 * @throws javax.jms.JMSException if thrown by JMS API methods
	 */
	protected MessageConsumer createConsumer(Session session, Destination destination) throws JMSException {
<span class="pc bpc" id="L856" title="3 of 4 branches missed.">		if (isPubSubDomain() &amp;&amp; destination instanceof Topic) {</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">			if (isSubscriptionShared()) {</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">				return (isSubscriptionDurable() ?</span>
<span class="nc" id="L859">						session.createSharedDurableConsumer((Topic) destination, getSubscriptionName(), getMessageSelector()) :</span>
<span class="nc" id="L860">						session.createSharedConsumer((Topic) destination, getSubscriptionName(), getMessageSelector()));</span>
			}
<span class="nc bnc" id="L862" title="All 2 branches missed.">			else if (isSubscriptionDurable()) {</span>
<span class="nc" id="L863">				return session.createDurableSubscriber(</span>
<span class="nc" id="L864">						(Topic) destination, getSubscriptionName(), getMessageSelector(), isPubSubNoLocal());</span>
			}
			else {
				// Only pass in the NoLocal flag in case of a Topic (pub-sub mode):
				// Some JMS providers, such as WebSphere MQ 6.0, throw IllegalStateException
				// in case of the NoLocal flag being specified for a Queue.
<span class="nc" id="L870">				return session.createConsumer(destination, getMessageSelector(), isPubSubNoLocal());</span>
			}
		}
		else {
<span class="fc" id="L874">			return session.createConsumer(destination, getMessageSelector());</span>
		}
	}

	/**
	 * Handle the given exception that arose during listener execution.
	 * &lt;p&gt;The default implementation logs the exception at warn level,
	 * not propagating it to the JMS provider &amp;mdash; assuming that all handling of
	 * acknowledgement and/or transactions is done by this listener container.
	 * This can be overridden in subclasses.
	 * @param ex the exception to handle
	 */
	protected void handleListenerException(Throwable ex) {
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">		if (ex instanceof MessageRejectedWhileStoppingException) {</span>
			// Internal exception - has been handled before.
<span class="nc" id="L889">			return;</span>
		}
<span class="fc bfc" id="L891" title="All 2 branches covered.">		if (ex instanceof JMSException) {</span>
<span class="fc" id="L892">			invokeExceptionListener((JMSException) ex);</span>
		}
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">		if (isActive()) {</span>
			// Regular case: failed while active.
			// Invoke ErrorHandler if available.
<span class="fc" id="L897">			invokeErrorHandler(ex);</span>
		}
		else {
			// Rare case: listener thread failed after container shutdown.
			// Log at debug level, to avoid spamming the shutdown log.
<span class="nc" id="L902">			logger.debug(&quot;Listener exception after container shutdown&quot;, ex);</span>
		}
<span class="fc" id="L904">	}</span>

	/**
	 * Invoke the registered JMS ExceptionListener, if any.
	 * @param ex the exception that arose during JMS processing
	 * @see #setExceptionListener
	 */
	protected void invokeExceptionListener(JMSException ex) {
<span class="fc" id="L912">		ExceptionListener exceptionListener = getExceptionListener();</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">		if (exceptionListener != null) {</span>
<span class="fc" id="L914">			exceptionListener.onException(ex);</span>
		}
<span class="fc" id="L916">	}</span>

	/**
	 * Invoke the registered ErrorHandler, if any. Log at warn level otherwise.
	 * @param ex the uncaught error that arose during JMS processing.
	 * @see #setErrorHandler
	 */
	protected void invokeErrorHandler(Throwable ex) {
<span class="fc" id="L924">		ErrorHandler errorHandler = getErrorHandler();</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">		if (errorHandler != null) {</span>
<span class="fc" id="L926">			errorHandler.handleError(ex);</span>
		}
		else {
<span class="fc" id="L929">			logger.warn(&quot;Execution of JMS message listener failed, and no ErrorHandler has been set.&quot;, ex);</span>
		}
<span class="fc" id="L931">	}</span>


	/**
	 * Internal exception class that indicates a rejected message on shutdown.
	 * Used to trigger a rollback for an external transaction manager in that case.
	 */
	@SuppressWarnings(&quot;serial&quot;)
	private static class MessageRejectedWhileStoppingException extends RuntimeException {
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>