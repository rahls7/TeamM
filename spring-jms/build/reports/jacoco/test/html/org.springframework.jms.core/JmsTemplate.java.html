<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JmsTemplate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-jms</a> &gt; <a href="index.source.html" class="el_package">org.springframework.jms.core</a> &gt; <span class="el_source">JmsTemplate.java</span></div><h1>JmsTemplate.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.jms.core;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.DeliveryMode;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.MessageProducer;
import javax.jms.Queue;
import javax.jms.QueueBrowser;
import javax.jms.Session;
import javax.jms.TemporaryQueue;

import org.springframework.jms.JmsException;
import org.springframework.jms.connection.ConnectionFactoryUtils;
import org.springframework.jms.connection.JmsResourceHolder;
import org.springframework.jms.support.JmsUtils;
import org.springframework.jms.support.QosSettings;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.converter.SimpleMessageConverter;
import org.springframework.jms.support.destination.JmsDestinationAccessor;
import org.springframework.lang.Nullable;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.util.Assert;

/**
 * Helper class that simplifies synchronous JMS access code.
 *
 * &lt;p&gt;If you want to use dynamic destination creation, you must specify
 * the type of JMS destination to create, using the &quot;pubSubDomain&quot; property.
 * For other operations, this is not necessary. Point-to-Point (Queues) is the default
 * domain.
 *
 * &lt;p&gt;Default settings for JMS Sessions are &quot;not transacted&quot; and &quot;auto-acknowledge&quot;.
 * As defined by the Java EE specification, the transaction and acknowledgement
 * parameters are ignored when a JMS Session is created inside an active
 * transaction, no matter if a JTA transaction or a Spring-managed transaction.
 * To configure them for native JMS usage, specify appropriate values for
 * the &quot;sessionTransacted&quot; and &quot;sessionAcknowledgeMode&quot; bean properties.
 *
 * &lt;p&gt;This template uses a
 * {@link org.springframework.jms.support.destination.DynamicDestinationResolver}
 * and a {@link org.springframework.jms.support.converter.SimpleMessageConverter}
 * as default strategies for resolving a destination name or converting a message,
 * respectively. These defaults can be overridden through the &quot;destinationResolver&quot;
 * and &quot;messageConverter&quot; bean properties.
 *
 * &lt;p&gt;&lt;b&gt;NOTE: The {@code ConnectionFactory} used with this template should
 * return pooled Connections (or a single shared Connection) as well as pooled
 * Sessions and MessageProducers. Otherwise, performance of ad-hoc JMS operations
 * is going to suffer.&lt;/b&gt; The simplest option is to use the Spring-provided
 * {@link org.springframework.jms.connection.SingleConnectionFactory} as a
 * decorator for your target {@code ConnectionFactory}, reusing a single
 * JMS Connection in a thread-safe fashion; this is often good enough for the
 * purpose of sending messages via this template. In a Java EE environment,
 * make sure that the {@code ConnectionFactory} is obtained from the
 * application's environment naming context via JNDI; application servers
 * typically expose pooled, transaction-aware factories there.
 *
 * @author Mark Pollack
 * @author Juergen Hoeller
 * @author Stephane Nicoll
 * @since 1.1
 * @see #setConnectionFactory
 * @see #setPubSubDomain
 * @see #setDestinationResolver
 * @see #setMessageConverter
 * @see javax.jms.MessageProducer
 * @see javax.jms.MessageConsumer
 */
public class JmsTemplate extends JmsDestinationAccessor implements JmsOperations {

	/** Internal ResourceFactory adapter for interacting with ConnectionFactoryUtils. */
<span class="fc" id="L92">	private final JmsTemplateResourceFactory transactionalResourceFactory = new JmsTemplateResourceFactory();</span>


	@Nullable
	private Object defaultDestination;

	@Nullable
	private MessageConverter messageConverter;


<span class="fc" id="L102">	private boolean messageIdEnabled = true;</span>

<span class="fc" id="L104">	private boolean messageTimestampEnabled = true;</span>

<span class="fc" id="L106">	private boolean pubSubNoLocal = false;</span>

<span class="fc" id="L108">	private long receiveTimeout = RECEIVE_TIMEOUT_INDEFINITE_WAIT;</span>

<span class="fc" id="L110">	private long deliveryDelay = -1;</span>


<span class="fc" id="L113">	private boolean explicitQosEnabled = false;</span>

<span class="fc" id="L115">	private int deliveryMode = Message.DEFAULT_DELIVERY_MODE;</span>

<span class="fc" id="L117">	private int priority = Message.DEFAULT_PRIORITY;</span>

<span class="fc" id="L119">	private long timeToLive = Message.DEFAULT_TIME_TO_LIVE;</span>


	/**
	 * Create a new JmsTemplate for bean-style usage.
	 * &lt;p&gt;Note: The ConnectionFactory has to be set before using the instance.
	 * This constructor can be used to prepare a JmsTemplate via a BeanFactory,
	 * typically setting the ConnectionFactory via setConnectionFactory.
	 * @see #setConnectionFactory
	 */
<span class="fc" id="L129">	public JmsTemplate() {</span>
<span class="fc" id="L130">		initDefaultStrategies();</span>
<span class="fc" id="L131">	}</span>

	/**
	 * Create a new JmsTemplate, given a ConnectionFactory.
	 * @param connectionFactory the ConnectionFactory to obtain Connections from
	 */
	public JmsTemplate(ConnectionFactory connectionFactory) {
<span class="fc" id="L138">		this();</span>
<span class="fc" id="L139">		setConnectionFactory(connectionFactory);</span>
<span class="fc" id="L140">		afterPropertiesSet();</span>
<span class="fc" id="L141">	}</span>

	/**
	 * Initialize the default implementations for the template's strategies:
	 * DynamicDestinationResolver and SimpleMessageConverter.
	 * @see #setDestinationResolver
	 * @see #setMessageConverter
	 * @see org.springframework.jms.support.destination.DynamicDestinationResolver
	 * @see org.springframework.jms.support.converter.SimpleMessageConverter
	 */
	protected void initDefaultStrategies() {
<span class="fc" id="L152">		setMessageConverter(new SimpleMessageConverter());</span>
<span class="fc" id="L153">	}</span>


	/**
	 * Set the destination to be used on send/receive operations that do not
	 * have a destination parameter.
	 * &lt;p&gt;Alternatively, specify a &quot;defaultDestinationName&quot;, to be
	 * dynamically resolved via the DestinationResolver.
	 * @see #send(MessageCreator)
	 * @see #convertAndSend(Object)
	 * @see #convertAndSend(Object, MessagePostProcessor)
	 * @see #setDefaultDestinationName(String)
	 */
	public void setDefaultDestination(@Nullable Destination destination) {
<span class="fc" id="L167">		this.defaultDestination = destination;</span>
<span class="fc" id="L168">	}</span>

	/**
	 * Return the destination to be used on send/receive operations that do not
	 * have a destination parameter.
	 */
	@Nullable
	public Destination getDefaultDestination() {
<span class="fc bfc" id="L176" title="All 2 branches covered.">		return (this.defaultDestination instanceof Destination ? (Destination) this.defaultDestination : null);</span>
	}

	@Nullable
	private Queue getDefaultQueue() {
<span class="nc" id="L181">		Destination defaultDestination = getDefaultDestination();</span>
<span class="nc bnc" id="L182" title="All 4 branches missed.">		if (defaultDestination != null &amp;&amp; !(defaultDestination instanceof Queue)) {</span>
<span class="nc" id="L183">			throw new IllegalStateException(</span>
					&quot;'defaultDestination' does not correspond to a Queue. Check configuration of JmsTemplate.&quot;);
		}
<span class="nc" id="L186">		return (Queue) defaultDestination;</span>
	}

	/**
	 * Set the destination name to be used on send/receive operations that
	 * do not have a destination parameter. The specified name will be
	 * dynamically resolved via the DestinationResolver.
	 * &lt;p&gt;Alternatively, specify a JMS Destination object as &quot;defaultDestination&quot;.
	 * @see #send(MessageCreator)
	 * @see #convertAndSend(Object)
	 * @see #convertAndSend(Object, MessagePostProcessor)
	 * @see #setDestinationResolver
	 * @see #setDefaultDestination(javax.jms.Destination)
	 */
	public void setDefaultDestinationName(@Nullable String destinationName) {
<span class="fc" id="L201">		this.defaultDestination = destinationName;</span>
<span class="fc" id="L202">	}</span>

	/**
	 * Return the destination name to be used on send/receive operations that
	 * do not have a destination parameter.
	 */
	@Nullable
	public String getDefaultDestinationName() {
<span class="fc bfc" id="L210" title="All 2 branches covered.">		return (this.defaultDestination instanceof String ? (String) this.defaultDestination : null);</span>
	}

	private String getRequiredDefaultDestinationName() throws IllegalStateException {
<span class="fc" id="L214">		String name = getDefaultDestinationName();</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">		if (name == null) {</span>
<span class="nc" id="L216">			throw new IllegalStateException(</span>
					&quot;No 'defaultDestination' or 'defaultDestinationName' specified. Check configuration of JmsTemplate.&quot;);
		}
<span class="fc" id="L219">		return name;</span>
	}

	/**
	 * Set the message converter for this template. Used to resolve
	 * Object parameters to convertAndSend methods and Object results
	 * from receiveAndConvert methods.
	 * &lt;p&gt;The default converter is a SimpleMessageConverter, which is able
	 * to handle BytesMessages, TextMessages and ObjectMessages.
	 * @see #convertAndSend
	 * @see #receiveAndConvert
	 * @see org.springframework.jms.support.converter.SimpleMessageConverter
	 */
	public void setMessageConverter(@Nullable MessageConverter messageConverter) {
<span class="fc" id="L233">		this.messageConverter = messageConverter;</span>
<span class="fc" id="L234">	}</span>

	/**
	 * Return the message converter for this template.
	 */
	@Nullable
	public MessageConverter getMessageConverter() {
<span class="fc" id="L241">		return this.messageConverter;</span>
	}

	private MessageConverter getRequiredMessageConverter() throws IllegalStateException {
<span class="fc" id="L245">		MessageConverter converter = getMessageConverter();</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">		if (converter == null) {</span>
<span class="nc" id="L247">			throw new IllegalStateException(&quot;No 'messageConverter' specified. Check configuration of JmsTemplate.&quot;);</span>
		}
<span class="fc" id="L249">		return converter;</span>
	}


	/**
	 * Set whether message IDs are enabled. Default is &quot;true&quot;.
	 * &lt;p&gt;This is only a hint to the JMS producer.
	 * See the JMS javadocs for details.
	 * @see javax.jms.MessageProducer#setDisableMessageID
	 */
	public void setMessageIdEnabled(boolean messageIdEnabled) {
<span class="fc" id="L260">		this.messageIdEnabled = messageIdEnabled;</span>
<span class="fc" id="L261">	}</span>

	/**
	 * Return whether message IDs are enabled.
	 */
	public boolean isMessageIdEnabled() {
<span class="fc" id="L267">		return this.messageIdEnabled;</span>
	}

	/**
	 * Set whether message timestamps are enabled. Default is &quot;true&quot;.
	 * &lt;p&gt;This is only a hint to the JMS producer.
	 * See the JMS javadocs for details.
	 * @see javax.jms.MessageProducer#setDisableMessageTimestamp
	 */
	public void setMessageTimestampEnabled(boolean messageTimestampEnabled) {
<span class="fc" id="L277">		this.messageTimestampEnabled = messageTimestampEnabled;</span>
<span class="fc" id="L278">	}</span>

	/**
	 * Return whether message timestamps are enabled.
	 */
	public boolean isMessageTimestampEnabled() {
<span class="fc" id="L284">		return this.messageTimestampEnabled;</span>
	}

	/**
	 * Set whether to inhibit the delivery of messages published by its own connection.
	 * Default is &quot;false&quot;.
	 * @see javax.jms.Session#createConsumer(javax.jms.Destination, String, boolean)
	 */
	public void setPubSubNoLocal(boolean pubSubNoLocal) {
<span class="fc" id="L293">		this.pubSubNoLocal = pubSubNoLocal;</span>
<span class="fc" id="L294">	}</span>

	/**
	 * Return whether to inhibit the delivery of messages published by its own connection.
	 */
	public boolean isPubSubNoLocal() {
<span class="nc" id="L300">		return this.pubSubNoLocal;</span>
	}

	/**
	 * Set the timeout to use for receive calls (in milliseconds).
	 * &lt;p&gt;The default is {@link #RECEIVE_TIMEOUT_INDEFINITE_WAIT}, which indicates
	 * a blocking receive without timeout.
	 * &lt;p&gt;Specify {@link #RECEIVE_TIMEOUT_NO_WAIT} (or any other negative value)
	 * to indicate that a receive operation should check if a message is
	 * immediately available without blocking.
	 * @see #receiveFromConsumer(MessageConsumer, long)
	 * @see javax.jms.MessageConsumer#receive(long)
	 * @see javax.jms.MessageConsumer#receiveNoWait()
	 * @see javax.jms.MessageConsumer#receive()
	 */
	public void setReceiveTimeout(long receiveTimeout) {
<span class="fc" id="L316">		this.receiveTimeout = receiveTimeout;</span>
<span class="fc" id="L317">	}</span>

	/**
	 * Return the timeout to use for receive calls (in milliseconds).
	 */
	public long getReceiveTimeout() {
<span class="fc" id="L323">		return this.receiveTimeout;</span>
	}

	/**
	 * Set the delivery delay to use for send calls (in milliseconds).
	 * &lt;p&gt;The default is -1 (no delivery delay passed on to the broker).
	 * Note that this feature requires JMS 2.0.
	 */
	public void setDeliveryDelay(long deliveryDelay) {
<span class="nc" id="L332">		this.deliveryDelay = deliveryDelay;</span>
<span class="nc" id="L333">	}</span>

	/**
	 * Return the delivery delay to use for send calls (in milliseconds).
	 */
	public long getDeliveryDelay() {
<span class="nc" id="L339">		return this.deliveryDelay;</span>
	}


	/**
	 * Set if the QOS values (deliveryMode, priority, timeToLive)
	 * should be used for sending a message.
	 * @see #setDeliveryMode
	 * @see #setPriority
	 * @see #setTimeToLive
	 */
	public void setExplicitQosEnabled(boolean explicitQosEnabled) {
<span class="fc" id="L351">		this.explicitQosEnabled = explicitQosEnabled;</span>
<span class="fc" id="L352">	}</span>

	/**
	 * If &quot;true&quot;, then the values of deliveryMode, priority, and timeToLive
	 * will be used when sending a message. Otherwise, the default values,
	 * that may be set administratively, will be used.
	 * @return true if overriding default values of QOS parameters
	 * (deliveryMode, priority, and timeToLive)
	 * @see #setDeliveryMode
	 * @see #setPriority
	 * @see #setTimeToLive
	 */
	public boolean isExplicitQosEnabled() {
<span class="fc" id="L365">		return this.explicitQosEnabled;</span>
	}

	/**
	 * Set the {@link QosSettings} to use when sending a message.
	 * @param settings the deliveryMode, priority, and timeToLive settings to use
	 * @since 5.0
	 * @see #setExplicitQosEnabled(boolean)
	 * @see #setDeliveryMode(int)
	 * @see #setPriority(int)
	 * @see #setTimeToLive(long)
	 */
	public void setQosSettings(QosSettings settings) {
<span class="fc" id="L378">		Assert.notNull(settings, &quot;Settings must not be null&quot;);</span>
<span class="fc" id="L379">		setExplicitQosEnabled(true);</span>
<span class="fc" id="L380">		setDeliveryMode(settings.getDeliveryMode());</span>
<span class="fc" id="L381">		setPriority(settings.getPriority());</span>
<span class="fc" id="L382">		setTimeToLive(settings.getTimeToLive());</span>
<span class="fc" id="L383">	}</span>

	/**
	 * Set whether message delivery should be persistent or non-persistent,
	 * specified as boolean value (&quot;true&quot; or &quot;false&quot;). This will set the delivery
	 * mode accordingly, to either &quot;PERSISTENT&quot; (2) or &quot;NON_PERSISTENT&quot; (1).
	 * &lt;p&gt;Default is &quot;true&quot; a.k.a. delivery mode &quot;PERSISTENT&quot;.
	 * @see #setDeliveryMode(int)
	 * @see javax.jms.DeliveryMode#PERSISTENT
	 * @see javax.jms.DeliveryMode#NON_PERSISTENT
	 */
	public void setDeliveryPersistent(boolean deliveryPersistent) {
<span class="nc bnc" id="L395" title="All 2 branches missed.">		this.deliveryMode = (deliveryPersistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);</span>
<span class="nc" id="L396">	}</span>

	/**
	 * Set the delivery mode to use when sending a message.
	 * Default is the JMS Message default: &quot;PERSISTENT&quot;.
	 * &lt;p&gt;Since a default value may be defined administratively,
	 * this is only used when &quot;isExplicitQosEnabled&quot; equals &quot;true&quot;.
	 * @param deliveryMode the delivery mode to use
	 * @see #isExplicitQosEnabled
	 * @see javax.jms.DeliveryMode#PERSISTENT
	 * @see javax.jms.DeliveryMode#NON_PERSISTENT
	 * @see javax.jms.Message#DEFAULT_DELIVERY_MODE
	 * @see javax.jms.MessageProducer#send(javax.jms.Message, int, int, long)
	 */
	public void setDeliveryMode(int deliveryMode) {
<span class="fc" id="L411">		this.deliveryMode = deliveryMode;</span>
<span class="fc" id="L412">	}</span>

	/**
	 * Return the delivery mode to use when sending a message.
	 */
	public int getDeliveryMode() {
<span class="fc" id="L418">		return this.deliveryMode;</span>
	}

	/**
	 * Set the priority of a message when sending.
	 * &lt;p&gt;Since a default value may be defined administratively,
	 * this is only used when &quot;isExplicitQosEnabled&quot; equals &quot;true&quot;.
	 * @see #isExplicitQosEnabled
	 * @see javax.jms.Message#DEFAULT_PRIORITY
	 * @see javax.jms.MessageProducer#send(javax.jms.Message, int, int, long)
	 */
	public void setPriority(int priority) {
<span class="fc" id="L430">		this.priority = priority;</span>
<span class="fc" id="L431">	}</span>

	/**
	 * Return the priority of a message when sending.
	 */
	public int getPriority() {
<span class="fc" id="L437">		return this.priority;</span>
	}

	/**
	 * Set the time-to-live of the message when sending.
	 * &lt;p&gt;Since a default value may be defined administratively,
	 * this is only used when &quot;isExplicitQosEnabled&quot; equals &quot;true&quot;.
	 * @param timeToLive the message's lifetime (in milliseconds)
	 * @see #isExplicitQosEnabled
	 * @see javax.jms.Message#DEFAULT_TIME_TO_LIVE
	 * @see javax.jms.MessageProducer#send(javax.jms.Message, int, int, long)
	 */
	public void setTimeToLive(long timeToLive) {
<span class="fc" id="L450">		this.timeToLive = timeToLive;</span>
<span class="fc" id="L451">	}</span>

	/**
	 * Return the time-to-live of the message when sending.
	 */
	public long getTimeToLive() {
<span class="fc" id="L457">		return this.timeToLive;</span>
	}


	//---------------------------------------------------------------------------------------
	// JmsOperations execute methods
	//---------------------------------------------------------------------------------------

	@Override
	@Nullable
	public &lt;T&gt; T execute(SessionCallback&lt;T&gt; action) throws JmsException {
<span class="fc" id="L468">		return execute(action, false);</span>
	}

	/**
	 * Execute the action specified by the given action object within a
	 * JMS Session. Generalized version of {@code execute(SessionCallback)},
	 * allowing the JMS Connection to be started on the fly.
	 * &lt;p&gt;Use {@code execute(SessionCallback)} for the general case.
	 * Starting the JMS Connection is just necessary for receiving messages,
	 * which is preferably achieved through the {@code receive} methods.
	 * @param action callback object that exposes the Session
	 * @param startConnection whether to start the Connection
	 * @return the result object from working with the Session
	 * @throws JmsException if there is any problem
	 * @see #execute(SessionCallback)
	 * @see #receive
	 */
	@Nullable
	public &lt;T&gt; T execute(SessionCallback&lt;T&gt; action, boolean startConnection) throws JmsException {
<span class="fc" id="L487">		Assert.notNull(action, &quot;Callback object must not be null&quot;);</span>
<span class="fc" id="L488">		Connection conToClose = null;</span>
<span class="fc" id="L489">		Session sessionToClose = null;</span>
		try {
<span class="fc" id="L491">			Session sessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(</span>
<span class="fc" id="L492">					obtainConnectionFactory(), this.transactionalResourceFactory, startConnection);</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">			if (sessionToUse == null) {</span>
<span class="fc" id="L494">				conToClose = createConnection();</span>
<span class="fc" id="L495">				sessionToClose = createSession(conToClose);</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">				if (startConnection) {</span>
<span class="fc" id="L497">					conToClose.start();</span>
				}
<span class="fc" id="L499">				sessionToUse = sessionToClose;</span>
			}
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L502">				logger.debug(&quot;Executing callback on JMS Session: &quot; + sessionToUse);</span>
			}
<span class="fc" id="L504">			return action.doInJms(sessionToUse);</span>
		}
<span class="fc" id="L506">		catch (JMSException ex) {</span>
<span class="fc" id="L507">			throw convertJmsAccessException(ex);</span>
		}
		finally {
<span class="fc" id="L510">			JmsUtils.closeSession(sessionToClose);</span>
<span class="fc" id="L511">			ConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), startConnection);</span>
		}
	}

	@Override
	@Nullable
	public &lt;T&gt; T execute(ProducerCallback&lt;T&gt; action) throws JmsException {
<span class="fc" id="L518">		String defaultDestinationName = getDefaultDestinationName();</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">		if (defaultDestinationName != null) {</span>
<span class="nc" id="L520">			return execute(defaultDestinationName, action);</span>
		}
		else {
<span class="fc" id="L523">			return execute(getDefaultDestination(), action);</span>
		}
	}

	@Override
	@Nullable
	public &lt;T&gt; T execute(final @Nullable Destination destination, final ProducerCallback&lt;T&gt; action) throws JmsException {
<span class="fc" id="L530">		Assert.notNull(action, &quot;Callback object must not be null&quot;);</span>
<span class="fc" id="L531">		return execute(session -&gt; {</span>
<span class="fc" id="L532">			MessageProducer producer = createProducer(session, destination);</span>
			try {
<span class="fc" id="L534">				return action.doInJms(session, producer);</span>
			}
			finally {
<span class="fc" id="L537">				JmsUtils.closeMessageProducer(producer);</span>
			}
		}, false);
	}

	@Override
	@Nullable
	public &lt;T&gt; T execute(final String destinationName, final ProducerCallback&lt;T&gt; action) throws JmsException {
<span class="nc" id="L545">		Assert.notNull(action, &quot;Callback object must not be null&quot;);</span>
<span class="nc" id="L546">		return execute(session -&gt; {</span>
<span class="nc" id="L547">			Destination destination = resolveDestinationName(session, destinationName);</span>
<span class="nc" id="L548">			MessageProducer producer = createProducer(session, destination);</span>
			try {
<span class="nc" id="L550">				return action.doInJms(session, producer);</span>
			}
			finally {
<span class="nc" id="L553">				JmsUtils.closeMessageProducer(producer);</span>
			}
		}, false);
	}


	//---------------------------------------------------------------------------------------
	// Convenience methods for sending messages
	//---------------------------------------------------------------------------------------

	@Override
	public void send(MessageCreator messageCreator) throws JmsException {
<span class="fc" id="L565">		Destination defaultDestination = getDefaultDestination();</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">		if (defaultDestination != null) {</span>
<span class="fc" id="L567">			send(defaultDestination, messageCreator);</span>
		}
		else {
<span class="fc" id="L570">			send(getRequiredDefaultDestinationName(), messageCreator);</span>
		}
<span class="fc" id="L572">	}</span>

	@Override
	public void send(final Destination destination, final MessageCreator messageCreator) throws JmsException {
<span class="fc" id="L576">		execute(session -&gt; {</span>
<span class="fc" id="L577">			doSend(session, destination, messageCreator);</span>
<span class="fc" id="L578">			return null;</span>
		}, false);
<span class="fc" id="L580">	}</span>

	@Override
	public void send(final String destinationName, final MessageCreator messageCreator) throws JmsException {
<span class="fc" id="L584">		execute(session -&gt; {</span>
<span class="fc" id="L585">			Destination destination = resolveDestinationName(session, destinationName);</span>
<span class="fc" id="L586">			doSend(session, destination, messageCreator);</span>
<span class="fc" id="L587">			return null;</span>
		}, false);
<span class="fc" id="L589">	}</span>

	/**
	 * Send the given JMS message.
	 * @param session the JMS Session to operate on
	 * @param destination the JMS Destination to send to
	 * @param messageCreator callback to create a JMS Message
	 * @throws JMSException if thrown by JMS API methods
	 */
	protected void doSend(Session session, Destination destination, MessageCreator messageCreator)
			throws JMSException {

<span class="fc" id="L601">		Assert.notNull(messageCreator, &quot;MessageCreator must not be null&quot;);</span>
<span class="fc" id="L602">		MessageProducer producer = createProducer(session, destination);</span>
		try {
<span class="fc" id="L604">			Message message = messageCreator.createMessage(session);</span>
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L606">				logger.debug(&quot;Sending created message: &quot; + message);</span>
			}
<span class="fc" id="L608">			doSend(producer, message);</span>
			// Check commit - avoid commit call within a JTA transaction.
<span class="fc bfc" id="L610" title="All 4 branches covered.">			if (session.getTransacted() &amp;&amp; isSessionLocallyTransacted(session)) {</span>
				// Transacted session created by this template -&gt; commit.
<span class="fc" id="L612">				JmsUtils.commitIfNecessary(session);</span>
			}
		}
		finally {
<span class="fc" id="L616">			JmsUtils.closeMessageProducer(producer);</span>
		}
<span class="fc" id="L618">	}</span>

	/**
	 * Actually send the given JMS message.
	 * @param producer the JMS MessageProducer to send with
	 * @param message the JMS Message to send
	 * @throws JMSException if thrown by JMS API methods
	 */
	protected void doSend(MessageProducer producer, Message message) throws JMSException {
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">		if (this.deliveryDelay &gt;= 0) {</span>
<span class="nc" id="L628">			producer.setDeliveryDelay(this.deliveryDelay);</span>
		}
<span class="fc bfc" id="L630" title="All 2 branches covered.">		if (isExplicitQosEnabled()) {</span>
<span class="fc" id="L631">			producer.send(message, getDeliveryMode(), getPriority(), getTimeToLive());</span>
		}
		else {
<span class="fc" id="L634">			producer.send(message);</span>
		}
<span class="fc" id="L636">	}</span>


	//---------------------------------------------------------------------------------------
	// Convenience methods for sending auto-converted messages
	//---------------------------------------------------------------------------------------

	@Override
	public void convertAndSend(Object message) throws JmsException {
<span class="nc" id="L645">		Destination defaultDestination = getDefaultDestination();</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">		if (defaultDestination != null) {</span>
<span class="nc" id="L647">			convertAndSend(defaultDestination, message);</span>
		}
		else {
<span class="nc" id="L650">			convertAndSend(getRequiredDefaultDestinationName(), message);</span>
		}
<span class="nc" id="L652">	}</span>

	@Override
	public void convertAndSend(Destination destination, final Object message) throws JmsException {
<span class="fc" id="L656">		send(destination, session -&gt; getRequiredMessageConverter().toMessage(message, session));</span>
<span class="fc" id="L657">	}</span>

	@Override
	public void convertAndSend(String destinationName, final Object message) throws JmsException {
<span class="nc" id="L661">		send(destinationName, session -&gt; getRequiredMessageConverter().toMessage(message, session));</span>
<span class="nc" id="L662">	}</span>

	@Override
	public void convertAndSend(Object message, MessagePostProcessor postProcessor) throws JmsException {
<span class="nc" id="L666">		Destination defaultDestination = getDefaultDestination();</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">		if (defaultDestination != null) {</span>
<span class="nc" id="L668">			convertAndSend(defaultDestination, message, postProcessor);</span>
		}
		else {
<span class="nc" id="L671">			convertAndSend(getRequiredDefaultDestinationName(), message, postProcessor);</span>
		}
<span class="nc" id="L673">	}</span>

	@Override
	public void convertAndSend(
			Destination destination, final Object message, final MessagePostProcessor postProcessor)
			throws JmsException {

<span class="nc" id="L680">		send(destination, session -&gt; {</span>
<span class="nc" id="L681">			Message msg = getRequiredMessageConverter().toMessage(message, session);</span>
<span class="nc" id="L682">			return postProcessor.postProcessMessage(msg);</span>
		});
<span class="nc" id="L684">	}</span>

	@Override
	public void convertAndSend(
			String destinationName, final Object message, final MessagePostProcessor postProcessor)
		throws JmsException {

<span class="nc" id="L691">		send(destinationName, session -&gt; {</span>
<span class="nc" id="L692">			Message msg = getRequiredMessageConverter().toMessage(message, session);</span>
<span class="nc" id="L693">			return postProcessor.postProcessMessage(msg);</span>
		});
<span class="nc" id="L695">	}</span>


	//---------------------------------------------------------------------------------------
	// Convenience methods for receiving messages
	//---------------------------------------------------------------------------------------

	@Override
	@Nullable
	public Message receive() throws JmsException {
<span class="fc" id="L705">		Destination defaultDestination = getDefaultDestination();</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">		if (defaultDestination != null) {</span>
<span class="fc" id="L707">			return receive(defaultDestination);</span>
		}
		else {
<span class="fc" id="L710">			return receive(getRequiredDefaultDestinationName());</span>
		}
	}

	@Override
	@Nullable
	public Message receive(Destination destination) throws JmsException {
<span class="fc" id="L717">		return receiveSelected(destination, null);</span>
	}

	@Override
	@Nullable
	public Message receive(String destinationName) throws JmsException {
<span class="fc" id="L723">		return receiveSelected(destinationName, null);</span>
	}

	@Override
	@Nullable
	public Message receiveSelected(String messageSelector) throws JmsException {
<span class="fc" id="L729">		Destination defaultDestination = getDefaultDestination();</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">		if (defaultDestination != null) {</span>
<span class="fc" id="L731">			return receiveSelected(defaultDestination, messageSelector);</span>
		}
		else {
<span class="fc" id="L734">			return receiveSelected(getRequiredDefaultDestinationName(), messageSelector);</span>
		}
	}

	@Override
	@Nullable
	public Message receiveSelected(final Destination destination, @Nullable final String messageSelector) throws JmsException {
<span class="fc" id="L741">		return execute(session -&gt; doReceive(session, destination, messageSelector), true);</span>
	}

	@Override
	@Nullable
	public Message receiveSelected(final String destinationName, @Nullable final String messageSelector) throws JmsException {
<span class="fc" id="L747">		return execute(session -&gt; {</span>
<span class="fc" id="L748">			Destination destination = resolveDestinationName(session, destinationName);</span>
<span class="fc" id="L749">			return doReceive(session, destination, messageSelector);</span>
		}, true);
	}

	/**
	 * Receive a JMS message.
	 * @param session the JMS Session to operate on
	 * @param destination the JMS Destination to receive from
	 * @param messageSelector the message selector for this consumer (can be {@code null})
	 * @return the JMS Message received, or {@code null} if none
	 * @throws JMSException if thrown by JMS API methods
	 */
	@Nullable
	protected Message doReceive(Session session, Destination destination, @Nullable String messageSelector)
			throws JMSException {

<span class="fc" id="L765">		return doReceive(session, createConsumer(session, destination, messageSelector));</span>
	}

	/**
	 * Actually receive a JMS message.
	 * @param session the JMS Session to operate on
	 * @param consumer the JMS MessageConsumer to receive with
	 * @return the JMS Message received, or {@code null} if none
	 * @throws JMSException if thrown by JMS API methods
	 */
	@Nullable
	protected Message doReceive(Session session, MessageConsumer consumer) throws JMSException {
		try {
			// Use transaction timeout (if available).
<span class="fc" id="L779">			long timeout = getReceiveTimeout();</span>
<span class="fc" id="L780">			ConnectionFactory connectionFactory = getConnectionFactory();</span>
<span class="fc" id="L781">			JmsResourceHolder resourceHolder = null;</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">			if (connectionFactory != null) {</span>
<span class="fc" id="L783">				resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory);</span>
			}
<span class="pc bpc" id="L785" title="3 of 4 branches missed.">			if (resourceHolder != null &amp;&amp; resourceHolder.hasTimeout()) {</span>
<span class="nc" id="L786">				timeout = Math.min(timeout, resourceHolder.getTimeToLiveInMillis());</span>
			}
<span class="fc" id="L788">			Message message = receiveFromConsumer(consumer, timeout);</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">			if (session.getTransacted()) {</span>
				// Commit necessary - but avoid commit call within a JTA transaction.
<span class="fc bfc" id="L791" title="All 2 branches covered.">				if (isSessionLocallyTransacted(session)) {</span>
					// Transacted session created by this template -&gt; commit.
<span class="fc" id="L793">					JmsUtils.commitIfNecessary(session);</span>
				}
			}
<span class="fc bfc" id="L796" title="All 2 branches covered.">			else if (isClientAcknowledge(session)) {</span>
				// Manually acknowledge message, if any.
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">				if (message != null) {</span>
<span class="fc" id="L799">					message.acknowledge();</span>
				}
			}
<span class="fc" id="L802">			return message;</span>
		}
		finally {
<span class="fc" id="L805">			JmsUtils.closeMessageConsumer(consumer);</span>
		}
	}


	//---------------------------------------------------------------------------------------
	// Convenience methods for receiving auto-converted messages
	//---------------------------------------------------------------------------------------

	@Override
	@Nullable
	public Object receiveAndConvert() throws JmsException {
<span class="fc" id="L817">		return doConvertFromMessage(receive());</span>
	}

	@Override
	@Nullable
	public Object receiveAndConvert(Destination destination) throws JmsException {
<span class="fc" id="L823">		return doConvertFromMessage(receive(destination));</span>
	}

	@Override
	@Nullable
	public Object receiveAndConvert(String destinationName) throws JmsException {
<span class="fc" id="L829">		return doConvertFromMessage(receive(destinationName));</span>
	}

	@Override
	@Nullable
	public Object receiveSelectedAndConvert(String messageSelector) throws JmsException {
<span class="fc" id="L835">		return doConvertFromMessage(receiveSelected(messageSelector));</span>
	}

	@Override
	@Nullable
	public Object receiveSelectedAndConvert(Destination destination, String messageSelector) throws JmsException {
<span class="fc" id="L841">		return doConvertFromMessage(receiveSelected(destination, messageSelector));</span>
	}

	@Override
	@Nullable
	public Object receiveSelectedAndConvert(String destinationName, String messageSelector) throws JmsException {
<span class="fc" id="L847">		return doConvertFromMessage(receiveSelected(destinationName, messageSelector));</span>
	}

	/**
	 * Extract the content from the given JMS message.
	 * @param message the JMS Message to convert (can be {@code null})
	 * @return the content of the message, or {@code null} if none
	 */
	@Nullable
	protected Object doConvertFromMessage(@Nullable Message message) {
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">		if (message != null) {</span>
			try {
<span class="fc" id="L859">				return getRequiredMessageConverter().fromMessage(message);</span>
			}
<span class="nc" id="L861">			catch (JMSException ex) {</span>
<span class="nc" id="L862">				throw convertJmsAccessException(ex);</span>
			}
		}
<span class="nc" id="L865">		return null;</span>
	}


	//---------------------------------------------------------------------------------------
	// Convenience methods for sending messages to and receiving the reply from a destination
	//---------------------------------------------------------------------------------------

	@Override
	@Nullable
	public Message sendAndReceive(MessageCreator messageCreator) throws JmsException {
<span class="fc" id="L876">		Destination defaultDestination = getDefaultDestination();</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">		if (defaultDestination != null) {</span>
<span class="fc" id="L878">			return sendAndReceive(defaultDestination, messageCreator);</span>
		}
		else {
<span class="fc" id="L881">			return sendAndReceive(getRequiredDefaultDestinationName(), messageCreator);</span>
		}
	}

	@Override
	@Nullable
	public Message sendAndReceive(final Destination destination, final MessageCreator messageCreator) throws JmsException {
<span class="fc" id="L888">		return executeLocal(session -&gt; doSendAndReceive(session, destination, messageCreator), true);</span>
	}

	@Override
	@Nullable
	public Message sendAndReceive(final String destinationName, final MessageCreator messageCreator) throws JmsException {
<span class="fc" id="L894">		return executeLocal(session -&gt; {</span>
<span class="fc" id="L895">			Destination destination = resolveDestinationName(session, destinationName);</span>
<span class="fc" id="L896">			return doSendAndReceive(session, destination, messageCreator);</span>
		}, true);
	}

	/**
	 * Send a request message to the given {@link Destination} and block until
	 * a reply has been received on a temporary queue created on-the-fly.
	 * &lt;p&gt;Return the response message or {@code null} if no message has
	 * @throws JMSException if thrown by JMS API methods
	 */
	@Nullable
	protected Message doSendAndReceive(Session session, Destination destination, MessageCreator messageCreator)
			throws JMSException {

<span class="fc" id="L910">		Assert.notNull(messageCreator, &quot;MessageCreator must not be null&quot;);</span>
<span class="fc" id="L911">		TemporaryQueue responseQueue = null;</span>
<span class="fc" id="L912">		MessageProducer producer = null;</span>
<span class="fc" id="L913">		MessageConsumer consumer = null;</span>
		try {
<span class="fc" id="L915">			Message requestMessage = messageCreator.createMessage(session);</span>
<span class="fc" id="L916">			responseQueue = session.createTemporaryQueue();</span>
<span class="fc" id="L917">			producer = session.createProducer(destination);</span>
<span class="fc" id="L918">			consumer = session.createConsumer(responseQueue);</span>
<span class="fc" id="L919">			requestMessage.setJMSReplyTo(responseQueue);</span>
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L921">				logger.debug(&quot;Sending created message: &quot; + requestMessage);</span>
			}
<span class="fc" id="L923">			doSend(producer, requestMessage);</span>
<span class="fc" id="L924">			return receiveFromConsumer(consumer, getReceiveTimeout());</span>
		}
		finally {
<span class="fc" id="L927">			JmsUtils.closeMessageConsumer(consumer);</span>
<span class="fc" id="L928">			JmsUtils.closeMessageProducer(producer);</span>
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">			if (responseQueue != null) {</span>
<span class="fc" id="L930">				responseQueue.delete();</span>
			}
		}
	}

	/**
	 * A variant of {@link #execute(SessionCallback, boolean)} that explicitly
	 * creates a non-transactional {@link Session}. The given {@link SessionCallback}
	 * does not participate in an existing transaction.
	 */
	@Nullable
	private &lt;T&gt; T executeLocal(SessionCallback&lt;T&gt; action, boolean startConnection) throws JmsException {
<span class="fc" id="L942">		Assert.notNull(action, &quot;Callback object must not be null&quot;);</span>
<span class="fc" id="L943">		Connection con = null;</span>
<span class="fc" id="L944">		Session session = null;</span>
		try {
<span class="fc" id="L946">			con = createConnection();</span>
<span class="fc" id="L947">			session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);</span>
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">			if (startConnection) {</span>
<span class="fc" id="L949">				con.start();</span>
			}
<span class="pc bpc" id="L951" title="1 of 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L952">				logger.debug(&quot;Executing callback on JMS Session: &quot; + session);</span>
			}
<span class="fc" id="L954">			return action.doInJms(session);</span>
		}
<span class="nc" id="L956">		catch (JMSException ex) {</span>
<span class="nc" id="L957">			throw convertJmsAccessException(ex);</span>
		}
		finally {
<span class="fc" id="L960">			JmsUtils.closeSession(session);</span>
<span class="fc" id="L961">			ConnectionFactoryUtils.releaseConnection(con, getConnectionFactory(), startConnection);</span>
		}
	}


	//---------------------------------------------------------------------------------------
	// Convenience methods for browsing messages
	//---------------------------------------------------------------------------------------

	@Override
	@Nullable
	public &lt;T&gt; T browse(BrowserCallback&lt;T&gt; action) throws JmsException {
<span class="nc" id="L973">		Queue defaultQueue = getDefaultQueue();</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">		if (defaultQueue != null) {</span>
<span class="nc" id="L975">			return browse(defaultQueue, action);</span>
		}
		else {
<span class="nc" id="L978">			return browse(getRequiredDefaultDestinationName(), action);</span>
		}
	}

	@Override
	@Nullable
	public &lt;T&gt; T browse(Queue queue, BrowserCallback&lt;T&gt; action) throws JmsException {
<span class="nc" id="L985">		return browseSelected(queue, null, action);</span>
	}

	@Override
	@Nullable
	public &lt;T&gt; T browse(String queueName, BrowserCallback&lt;T&gt; action) throws JmsException {
<span class="nc" id="L991">		return browseSelected(queueName, null, action);</span>
	}

	@Override
	@Nullable
	public &lt;T&gt; T browseSelected(String messageSelector, BrowserCallback&lt;T&gt; action) throws JmsException {
<span class="nc" id="L997">		Queue defaultQueue = getDefaultQueue();</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">		if (defaultQueue != null) {</span>
<span class="nc" id="L999">			return browseSelected(defaultQueue, messageSelector, action);</span>
		}
		else {
<span class="nc" id="L1002">			return browseSelected(getRequiredDefaultDestinationName(), messageSelector, action);</span>
		}
	}

	@Override
	@Nullable
	public &lt;T&gt; T browseSelected(final Queue queue, @Nullable final String messageSelector, final BrowserCallback&lt;T&gt; action)
			throws JmsException {

<span class="nc" id="L1011">		Assert.notNull(action, &quot;Callback object must not be null&quot;);</span>
<span class="nc" id="L1012">		return execute(session -&gt; {</span>
<span class="nc" id="L1013">			QueueBrowser browser = createBrowser(session, queue, messageSelector);</span>
			try {
<span class="nc" id="L1015">				return action.doInJms(session, browser);</span>
			}
			finally {
<span class="nc" id="L1018">				JmsUtils.closeQueueBrowser(browser);</span>
			}
		}, true);
	}

	@Override
	@Nullable
	public &lt;T&gt; T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback&lt;T&gt; action)
			throws JmsException {

<span class="nc" id="L1028">		Assert.notNull(action, &quot;Callback object must not be null&quot;);</span>
<span class="nc" id="L1029">		return execute(session -&gt; {</span>
<span class="nc" id="L1030">			Queue queue = (Queue) getDestinationResolver().resolveDestinationName(session, queueName, false);</span>
<span class="nc" id="L1031">			QueueBrowser browser = createBrowser(session, queue, messageSelector);</span>
			try {
<span class="nc" id="L1033">				return action.doInJms(session, browser);</span>
			}
			finally {
<span class="nc" id="L1036">				JmsUtils.closeQueueBrowser(browser);</span>
			}
		}, true);
	}


	/**
	 * Fetch an appropriate Connection from the given JmsResourceHolder.
	 * &lt;p&gt;This implementation accepts any JMS 1.1 Connection.
	 * @param holder the JmsResourceHolder
	 * @return an appropriate Connection fetched from the holder,
	 * or {@code null} if none found
	 */
	@Nullable
	protected Connection getConnection(JmsResourceHolder holder) {
<span class="fc" id="L1051">		return holder.getConnection();</span>
	}

	/**
	 * Fetch an appropriate Session from the given JmsResourceHolder.
	 * &lt;p&gt;This implementation accepts any JMS 1.1 Session.
	 * @param holder the JmsResourceHolder
	 * @return an appropriate Session fetched from the holder,
	 * or {@code null} if none found
	 */
	@Nullable
	protected Session getSession(JmsResourceHolder holder) {
<span class="fc" id="L1063">		return holder.getSession();</span>
	}

	/**
	 * Check whether the given Session is locally transacted, that is, whether
	 * its transaction is managed by this listener container's Session handling
	 * and not by an external transaction coordinator.
	 * &lt;p&gt;Note: The Session's own transacted flag will already have been checked
	 * before. This method is about finding out whether the Session's transaction
	 * is local or externally coordinated.
	 * @param session the Session to check
	 * @return whether the given Session is locally transacted
	 * @see #isSessionTransacted()
	 * @see org.springframework.jms.connection.ConnectionFactoryUtils#isSessionTransactional
	 */
	protected boolean isSessionLocallyTransacted(Session session) {
<span class="fc bfc" id="L1079" title="All 2 branches covered.">		return isSessionTransacted() &amp;&amp;</span>
<span class="pc bpc" id="L1080" title="1 of 2 branches missed.">				!ConnectionFactoryUtils.isSessionTransactional(session, getConnectionFactory());</span>
	}

	/**
	 * Create a JMS MessageProducer for the given Session and Destination,
	 * configuring it to disable message ids and/or timestamps (if necessary).
	 * &lt;p&gt;Delegates to {@link #doCreateProducer} for creation of the raw
	 * JMS MessageProducer.
	 * @param session the JMS Session to create a MessageProducer for
	 * @param destination the JMS Destination to create a MessageProducer for
	 * @return the new JMS MessageProducer
	 * @throws JMSException if thrown by JMS API methods
	 * @see #setMessageIdEnabled
	 * @see #setMessageTimestampEnabled
	 */
	protected MessageProducer createProducer(Session session, @Nullable Destination destination) throws JMSException {
<span class="fc" id="L1096">		MessageProducer producer = doCreateProducer(session, destination);</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">		if (!isMessageIdEnabled()) {</span>
<span class="fc" id="L1098">			producer.setDisableMessageID(true);</span>
		}
<span class="fc bfc" id="L1100" title="All 2 branches covered.">		if (!isMessageTimestampEnabled()) {</span>
<span class="fc" id="L1101">			producer.setDisableMessageTimestamp(true);</span>
		}
<span class="fc" id="L1103">		return producer;</span>
	}

	/**
	 * Create a raw JMS MessageProducer for the given Session and Destination.
	 * &lt;p&gt;This implementation uses JMS 1.1 API.
	 * @param session the JMS Session to create a MessageProducer for
	 * @param destination the JMS Destination to create a MessageProducer for
	 * @return the new JMS MessageProducer
	 * @throws JMSException if thrown by JMS API methods
	 */
	protected MessageProducer doCreateProducer(Session session, @Nullable Destination destination) throws JMSException {
<span class="fc" id="L1115">		return session.createProducer(destination);</span>
	}

	/**
	 * Create a JMS MessageConsumer for the given Session and Destination.
	 * &lt;p&gt;This implementation uses JMS 1.1 API.
	 * @param session the JMS Session to create a MessageConsumer for
	 * @param destination the JMS Destination to create a MessageConsumer for
	 * @param messageSelector the message selector for this consumer (can be {@code null})
	 * @return the new JMS MessageConsumer
	 * @throws JMSException if thrown by JMS API methods
	 */
	protected MessageConsumer createConsumer(Session session, Destination destination, @Nullable String messageSelector)
			throws JMSException {

		// Only pass in the NoLocal flag in case of a Topic:
		// Some JMS providers, such as WebSphere MQ 6.0, throw IllegalStateException
		// in case of the NoLocal flag being specified for a Queue.
<span class="pc bpc" id="L1133" title="1 of 2 branches missed.">		if (isPubSubDomain()) {</span>
<span class="nc" id="L1134">			return session.createConsumer(destination, messageSelector, isPubSubNoLocal());</span>
		}
		else {
<span class="fc" id="L1137">			return session.createConsumer(destination, messageSelector);</span>
		}
	}

	/**
	 * Create a JMS MessageProducer for the given Session and Destination,
	 * configuring it to disable message ids and/or timestamps (if necessary).
	 * &lt;p&gt;Delegates to {@link #doCreateProducer} for creation of the raw
	 * JMS MessageProducer.
	 * @param session the JMS Session to create a QueueBrowser for
	 * @param queue the JMS Queue to create a QueueBrowser for
	 * @param messageSelector the message selector for this consumer (can be {@code null})
	 * @return the new JMS QueueBrowser
	 * @throws JMSException if thrown by JMS API methods
	 * @see #setMessageIdEnabled
	 * @see #setMessageTimestampEnabled
	 */
	protected QueueBrowser createBrowser(Session session, Queue queue, @Nullable String messageSelector)
			throws JMSException {

<span class="nc" id="L1157">		return session.createBrowser(queue, messageSelector);</span>
	}


	/**
	 * ResourceFactory implementation that delegates to this template's protected callback methods.
	 */
<span class="fc" id="L1164">	private class JmsTemplateResourceFactory implements ConnectionFactoryUtils.ResourceFactory {</span>

		@Override
		@Nullable
		public Connection getConnection(JmsResourceHolder holder) {
<span class="fc" id="L1169">			return JmsTemplate.this.getConnection(holder);</span>
		}

		@Override
		@Nullable
		public Session getSession(JmsResourceHolder holder) {
<span class="fc" id="L1175">			return JmsTemplate.this.getSession(holder);</span>
		}

		@Override
		public Connection createConnection() throws JMSException {
<span class="fc" id="L1180">			return JmsTemplate.this.createConnection();</span>
		}

		@Override
		public Session createSession(Connection con) throws JMSException {
<span class="fc" id="L1185">			return JmsTemplate.this.createSession(con);</span>
		}

		@Override
		public boolean isSynchedLocalTransactionAllowed() {
<span class="fc" id="L1190">			return JmsTemplate.this.isSessionTransacted();</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>