<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ComplexUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.complex</a> &gt; <span class="el_source">ComplexUtils.java</span></div><h1>ComplexUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.complex;

import org.apache.commons.numbers.complex.Complex;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.exception.OutOfRangeException;
import org.apache.commons.math4.exception.util.LocalizedFormats;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.math4.util.IntegerSequence;
import org.apache.commons.math4.util.IntegerSequence.Range;

/**
 * Static implementations of common {@link Complex} utilities functions.
 */
public class ComplexUtils {

    /**
     * Utility class.
     */
    private ComplexUtils() {}

    /**
     * Creates a complex number from the given polar representation.
     *
     * If {@code r} is infinite and {@code theta} is finite, infinite or NaN
     * values may be returned in parts of the result, following the rules for
     * double arithmetic.
     *
     * &lt;pre&gt;
     * Examples:
     * {@code
     * polar2Complex(INFINITY, \(\pi\)) = INFINITY + INFINITY i
     * polar2Complex(INFINITY, 0) = INFINITY + NaN i
     * polar2Complex(INFINITY, \(-\frac{\pi}{4}\)) = INFINITY - INFINITY i
     * polar2Complex(INFINITY, \(5\frac{\pi}{4}\)) = -INFINITY - INFINITY i }
     * &lt;/pre&gt;
     *
     * @param r the modulus of the complex number to create
     * @param theta the argument of the complex number to create
     * @return {@code Complex}
     * @throws MathIllegalArgumentException  if {@code r} is negative.
     * @since 1.1
     */
    public static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException {
<span class="fc bfc" id="L61" title="All 2 branches covered.">        if (r &lt; 0) {</span>
<span class="fc" id="L62">            throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_COMPLEX_MODULE, r);</span>
        }
<span class="fc" id="L64">        return Complex.ofCartesian(r * FastMath.cos(theta), r * FastMath.sin(theta));</span>
    }

    /**
     * Creates {@code Complex[]} array given {@code double[]} arrays of r and
     * theta.
     *
     * @param r {@code double[]} of moduli
     * @param theta {@code double[]} of arguments
     * @return {@code Complex[]}
     * @throws MathIllegalArgumentException
     *             if {@code r} is negative.
     * @since 4.0
     */
    public static Complex[] polar2Complex(double[] r, double[] theta) throws MathIllegalArgumentException {
<span class="nc" id="L79">        final int length = r.length;</span>
<span class="nc" id="L80">        final Complex[] c = new Complex[length];</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        for (int x = 0; x &lt; length; x++) {</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">            if (r[x] &lt; 0) {</span>
<span class="nc" id="L83">                throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_COMPLEX_MODULE, r[x]);</span>
            }
<span class="nc" id="L85">            c[x] = Complex.ofCartesian(r[x] * FastMath.cos(theta[x]), r[x] * FastMath.sin(theta[x]));</span>
        }
<span class="nc" id="L87">        return c;</span>
    }

    /**
     * Creates {@code Complex[][]} array given {@code double[][]} arrays of r
     * and theta.
     *
     * @param r {@code double[]} of moduli
     * @param theta {@code double[]} of arguments
     * @return {@code Complex[][]}
     * @throws MathIllegalArgumentException
     *             if {@code r} is negative.
     * @since 4.0
     */
    public static Complex[][] polar2Complex(double[][] r, double[][] theta) throws MathIllegalArgumentException {
<span class="nc" id="L102">        final int length = r.length;</span>
<span class="nc" id="L103">        final Complex[][] c = new Complex[length][];</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        for (int x = 0; x &lt; length; x++) {</span>
<span class="nc" id="L105">            c[x] = polar2Complex(r[x], theta[x]);</span>
        }
<span class="nc" id="L107">        return c;</span>
    }

    /**
     * Creates {@code Complex[][][]} array given {@code double[][][]} arrays of
     * r and theta.
     *
     * @param r array of moduli
     * @param theta array of arguments
     * @return {@code Complex}
     * @throws MathIllegalArgumentException  if {@code r} is negative.
     * @since 4.0
     */
    public static Complex[][][] polar2Complex(double[][][] r, double[][][] theta) throws MathIllegalArgumentException {
<span class="nc" id="L121">        final int length = r.length;</span>
<span class="nc" id="L122">        final Complex[][][] c = new Complex[length][][];</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">        for (int x = 0; x &lt; length; x++) {</span>
<span class="nc" id="L124">            c[x] = polar2Complex(r[x], theta[x]);</span>
        }
<span class="nc" id="L126">        return c;</span>
    }

    /**
     * Returns double from array {@code real[]} at entry {@code index} as a
     * {@code Complex}.
     *
     * @param real array of real numbers
     * @param index location in the array
     * @return {@code Complex}.
     *
     * @since 4.0
     */
    public static Complex extractComplexFromRealArray(double[] real, int index) {
<span class="fc" id="L140">        return Complex.ofReal(real[index]);</span>
    }

    /**
     * Returns float from array {@code real[]} at entry {@code index} as a
     * {@code Complex}.
     *
     * @param real array of real numbers
     * @param index location in the array
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex extractComplexFromRealArray(float[] real, int index) {
<span class="fc" id="L154">        return Complex.ofReal(real[index]);</span>
    }

    /**
     * Returns double from array {@code imaginary[]} at entry {@code index} as a
     * {@code Complex}.
     *
     * @param imaginary array of imaginary numbers
     * @param index location in the array
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex extractComplexFromImaginaryArray(double[] imaginary, int index) {
<span class="fc" id="L168">        return Complex.ofCartesian(0, imaginary[index]);</span>
    }

    /**
     * Returns float from array {@code imaginary[]} at entry {@code index} as a
     * {@code Complex}.
     *
     * @param imaginary array of imaginary numbers
     * @param index location in the array
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex extractComplexFromImaginaryArray(float[] imaginary, int index) {
<span class="fc" id="L182">        return Complex.ofCartesian(0, imaginary[index]);</span>
    }

    /**
     * Returns real component of Complex from array {@code Complex[]} at entry
     * {@code index} as a {@code double}.
     *
     * @param complex array of complex numbers
     * @param index location in the array
     * @return {@code double}.
     *
     * @since 4.0
     */
    public static double extractRealFromComplexArray(Complex[] complex, int index) {
<span class="fc" id="L196">        return complex[index].getReal();</span>
    }

    /**
     * Returns real component of array {@code Complex[]} at entry {@code index}
     * as a {@code float}.
     *
     * @param complex array of complex numbers
     * @param index location in the array
     * @return {@code float}.
     *
     * @since 4.0
     */
    public static float extractRealFloatFromComplexArray(Complex[] complex, int index) {
<span class="fc" id="L210">        return (float) complex[index].getReal();</span>
    }

    /**
     * Returns imaginary component of Complex from array {@code Complex[]} at
     * entry {@code index} as a {@code double}.
     *
     * @param complex array of complex numbers
     * @param index location in the array
     * @return {@code double}.
     *
     * @since 4.0
     */
    public static double extractImaginaryFromComplexArray(Complex[] complex, int index) {
<span class="fc" id="L224">        return complex[index].getImaginary();</span>
    }

    /**
     * Returns imaginary component of array {@code Complex[]} at entry
     * {@code index} as a {@code float}.
     *
     * @param complex array of complex numbers
     * @param index location in the array
     * @return {@code float}.
     *
     * @since 4.0
     */
    public static float extractImaginaryFloatFromComplexArray(Complex[] complex, int index) {
<span class="fc" id="L238">        return (float) complex[index].getImaginary();</span>
    }

    /**
     * Returns a Complex object from interleaved {@code double[]} array at entry
     * {@code index}.
     *
     * @param d array of interleaved complex numbers alternating real and imaginary values
     * @param index location in the array This is the location by complex number, e.g. index number 5 in the array will return {@code Complex.ofCartesian(d[10], d[11])}
     * @return {@code Complex}.
     *
     * @since 4.0
     */
    public static Complex extractComplexFromInterleavedArray(double[] d, int index) {
<span class="fc" id="L252">        return Complex.ofCartesian(d[index * 2], d[index * 2 + 1]);</span>
    }

    /**
     * Returns a Complex object from interleaved {@code float[]} array at entry
     * {@code index}.
     *
     * @param f float array of interleaved complex numbers alternating real and imaginary values
     * @param index location in the array This is the location by complex number, e.g. index number 5 in the {@code float[]} array will return {@code Complex.ofCartesian(d[10], d[11])}
     * @return {@code Complex}.
     *
     * @since 4.0
     */
    public static Complex extractComplexFromInterleavedArray(float[] f, int index) {
<span class="fc" id="L266">        return Complex.ofCartesian(f[index * 2], f[index * 2 + 1]);</span>
    }

    /**
     * Returns values of Complex object from array {@code Complex[]} at entry
     * {@code index} as a size 2 {@code double} of the form {real, imag}.
     *
     * @param complex array of complex numbers
     * @param index location in the array
     * @return size 2 array.
     *
     * @since 4.0
     */
    public static double[] extractInterleavedFromComplexArray(Complex[] complex, int index) {
<span class="fc" id="L280">        return new double[] { complex[index].getReal(), complex[index].getImaginary() };</span>
    }

    /**
     * Returns Complex object from array {@code Complex[]} at entry
     * {@code index} as a size 2 {@code float} of the form {real, imag}.
     *
     * @param complex {@code Complex} array
     * @param index location in the array
     * @return size 2 {@code float[]}.
     *
     * @since 4.0
     */
    public static float[] extractInterleavedFloatFromComplexArray(Complex[] complex, int index) {
<span class="nc" id="L294">        return new float[] { (float) complex[index].getReal(), (float) complex[index].getImaginary() };</span>
    }

    /**
     * Converts a {@code double[]} array to a {@code Complex[]} array for the
     * range {@code start} - {@code end}.
     *
     * @param real array of real numbers to be converted to their {@code Complex} equivalent
     * @param start start index
     * @param end end index
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] real2Complex(double[] real, int start, int end) {
<span class="fc" id="L309">        final Range range = IntegerSequence.range(start, end);</span>
<span class="fc" id="L310">        int index = 0;</span>
<span class="fc" id="L311">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L313">            c[index] = extractComplexFromRealArray(real, i);</span>
<span class="fc" id="L314">            index++;</span>
<span class="fc" id="L315">        }</span>
<span class="fc" id="L316">        return c;</span>
    }

    /**
     * Converts a {@code float[]} array to a {@code Complex[]} array for the
     * range {@code start} - {@code end}.
     *
     * @param real array of real numbers to be converted to their {@code Complex} equivalent
     * @param start start index
     * @param end end index
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] real2Complex(float[] real, int start, int end) {
<span class="fc" id="L331">        final Range range = IntegerSequence.range(start, end);</span>
<span class="fc" id="L332">        int index = 0;</span>
<span class="fc" id="L333">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L335">            c[index] = extractComplexFromRealArray(real, i);</span>
<span class="fc" id="L336">            index++;</span>
<span class="fc" id="L337">        }</span>
<span class="fc" id="L338">        return c;</span>
    }

    /**
     * Converts a {@code double[]} array to a {@code Complex[]} array for the
     * range {@code start} - {@code end} by {@code increment}.
     *
     * @param real array of numbers to be converted to their {@code Complex} equivalent
     * @param start start index
     * @param end end index
     * @param increment range increment
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] real2Complex(double[] real, int start, int end, int increment) {
<span class="fc" id="L354">        final Range range = IntegerSequence.range(start, end, increment);</span>
<span class="fc" id="L355">        int index = 0;</span>
<span class="fc" id="L356">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L358">            c[index] = extractComplexFromRealArray(real, i);</span>
<span class="fc" id="L359">            index++;</span>
<span class="fc" id="L360">        }</span>
<span class="fc" id="L361">        return c;</span>
    }

    /**
     * Converts a {@code float[]} array to a {@code Complex[]} array for the
     * range {@code start} - {@code end} by {@code increment}.
     *
     * @param real array of numbers to be converted to their {@code Complex} equivalent
     * @param start start index
     * @param end end index
     * @param increment range increment
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] real2Complex(float[] real, int start, int end, int increment) {
<span class="fc" id="L377">        final Range range = IntegerSequence.range(start, end, increment);</span>
<span class="fc" id="L378">        int index = 0;</span>
<span class="fc" id="L379">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L381">            c[index] = extractComplexFromRealArray(real, i);</span>
<span class="fc" id="L382">            index++;</span>
<span class="fc" id="L383">        }</span>
<span class="fc" id="L384">        return c;</span>
    }

    /**
     * Converts a {@code double[]} array to a {@code Complex[]} array for the
     * {@code IntegerSequence} range.
     *
     * @param real array of numbers to be converted to their {@code Complex} equivalent
     * @param range an {@code Iterable&lt;Integer&gt;} object returned by {@code IntegerSequence.range()}
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] real2Complex(double[] real, Range range) {
<span class="fc" id="L398">        int index = 0;</span>
<span class="fc" id="L399">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L401">            c[index] = extractComplexFromRealArray(real, i);</span>
<span class="fc" id="L402">            index++;</span>
<span class="fc" id="L403">        }</span>
<span class="fc" id="L404">        return c;</span>
    }

    /**
     * Converts a {@code float[]} array to a {@code Complex[]} array for the
     * {@code IntegerSequence} range.
     *
     * @param real array of numbers to be converted to their {@code Complex} equivalent
     * @param range an {@code Iterable&lt;Integer&gt;} object returned by {@code IntegerSequence.range()}
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] real2Complex(float[] real, Range range) {
<span class="fc" id="L418">        int index = 0;</span>
<span class="fc" id="L419">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L421">            c[index] = extractComplexFromRealArray(real, i);</span>
<span class="fc" id="L422">            index++;</span>
<span class="fc" id="L423">        }</span>
<span class="fc" id="L424">        return c;</span>
    }

    /**
     * Converts a {@code double[]} array to a {@code Complex[]} array.
     *
     * @param real array of numbers to be converted to their {@code Complex} equivalent
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] real2Complex(double[] real) {
<span class="fc" id="L436">        int index = 0;</span>
<span class="fc" id="L437">        final Complex c[] = new Complex[real.length];</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">        for (double d : real) {</span>
<span class="fc" id="L439">            c[index] = Complex.ofReal(d);</span>
<span class="fc" id="L440">            index++;</span>
        }
<span class="fc" id="L442">        return c;</span>
    }

    /**
     * Converts a {@code float[]} array to a {@code Complex[]} array.
     *
     * @param real array of numbers to be converted to their {@code Complex} equivalent
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] real2Complex(float[] real) {
<span class="fc" id="L454">        int index = 0;</span>
<span class="fc" id="L455">        final Complex c[] = new Complex[real.length];</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">        for (float d : real) {</span>
<span class="fc" id="L457">            c[index] = Complex.ofReal(d);</span>
<span class="fc" id="L458">            index++;</span>
        }
<span class="fc" id="L460">        return c;</span>
    }

    /**
     * Converts a 2D real {@code double[][]} array to a 2D {@code Complex[][]}
     * array.
     *
     * @param d 2D array
     * @return 2D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][] real2Complex(double[][] d) {
<span class="nc" id="L473">        final int width = d.length;</span>
<span class="nc" id="L474">        final Complex[][] c = new Complex[width][];</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">        for (int n = 0; n &lt; width; n++) {</span>
<span class="nc" id="L476">            c[n] = ComplexUtils.real2Complex(d[n]);</span>
        }
<span class="nc" id="L478">        return c;</span>
    }

    /**
     * Converts a 3D real {@code double[][][]} array to a {@code Complex [][][]}
     * array.
     *
     * @param d 3D complex interleaved array
     * @return 3D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][][] real2Complex(double[][][] d) {
<span class="nc" id="L491">        final int width = d.length;</span>
<span class="nc" id="L492">        final Complex[][][] c = new Complex[width][][];</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        for (int x = 0; x &lt; width; x++) {</span>
<span class="nc" id="L494">            c[x] = ComplexUtils.real2Complex(d[x]);</span>
        }
<span class="nc" id="L496">        return c;</span>
    }

    /**
     * Converts a {@code Complex[]} array to a {@code double[]} array for the
     * range {@code start} - {@code end}.
     *
     * @param c {@code Complex} array
     * @param start start index
     * @param end end index
     * @return array of the real component
     *
     * @since 4.0
     */
    public static double[] complex2Real(Complex[] c, int start, int end) {
<span class="fc" id="L511">        final Range range = IntegerSequence.range(start, end);</span>
<span class="fc" id="L512">        int index = 0;</span>
<span class="fc" id="L513">        final double d[] = new double[range.size()];</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L515">            d[index] = extractRealFromComplexArray(c, i);</span>
<span class="fc" id="L516">            index++;</span>
<span class="fc" id="L517">        }</span>
<span class="fc" id="L518">        return d;</span>
    }

    /**
     * Converts a {@code Complex[]} array to a {@code float[]} array for the
     * range {@code start} - {@code end}.
     *
     * @param c {@code Complex} array
     * @param start start index
     * @param end end index
     * @return {@code float[]} array of the real component
     *
     * @since 4.0
     */
    public static float[] complex2RealFloat(Complex[] c, int start, int end) {
<span class="fc" id="L533">        final Range range = IntegerSequence.range(start, end);</span>
<span class="fc" id="L534">        int index = 0;</span>
<span class="fc" id="L535">        final float f[] = new float[range.size()];</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L537">            f[index] = extractRealFloatFromComplexArray(c, i);</span>
<span class="fc" id="L538">            index++;</span>
<span class="fc" id="L539">        }</span>
<span class="fc" id="L540">        return f;</span>
    }

    /**
     * Converts a {@code Complex[]} array to a {@code double[]} array for the
     * range {@code start} - {@code end} by {@code increment}.
     *
     * @param c {@code Complex} array
     * @param start start index
     * @param end end index
     * @param increment range increment
     * @return array of the real component
     *
     * @since 4.0
     */
    public static double[] complex2Real(Complex[] c, int start, int end, int increment) {
<span class="fc" id="L556">        final Range range = IntegerSequence.range(start, end, increment);</span>
<span class="fc" id="L557">        int index = 0;</span>
<span class="fc" id="L558">        final double d[] = new double[range.size()];</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L560">            d[index] = extractRealFromComplexArray(c, i);</span>
<span class="fc" id="L561">            index++;</span>
<span class="fc" id="L562">        }</span>
<span class="fc" id="L563">        return d;</span>
    }

    /**
     * Converts a {@code Complex[]} array to a {@code float[]} array for the
     * range {@code start} - {@code end} by {@code increment}.
     *
     * @param c {@code Complex} array
     * @param start start index
     * @param end end index
     * @param increment range increment
     * @return {@code float[]} array of the real component
     *
     * @since 4.0
     */
    public static float[] complex2RealFloat(Complex[] c, int start, int end, int increment) {
<span class="fc" id="L579">        final Range range = IntegerSequence.range(start, end, increment);</span>
<span class="fc" id="L580">        int index = 0;</span>
<span class="fc" id="L581">        final float f[] = new float[range.size()];</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L583">            f[index] = extractRealFloatFromComplexArray(c, i);</span>
<span class="fc" id="L584">            index++;</span>
<span class="fc" id="L585">        }</span>
<span class="fc" id="L586">        return f;</span>
    }

    /**
     * Converts a {@code Complex[]} array to a {@code double[]} array for the
     * {@code IntegerSequence} range.
     *
     * @param c {@code Complex} array
     * @param range an {@code Iterable&lt;Integer&gt;} object returned by {@code IntegerSequence.range()}
     * @return array of the real component
     *
     * @since 4.0
     */
    public static double[] complex2Real(Complex[] c, Range range) {
<span class="fc" id="L600">        int index = 0;</span>
<span class="fc" id="L601">        final double d[] = new double[range.size()];</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L603">            d[index] = extractRealFromComplexArray(c, i);</span>
<span class="fc" id="L604">            index++;</span>
<span class="fc" id="L605">        }</span>
<span class="fc" id="L606">        return d;</span>
    }

    /**
     * Converts a {@code Complex[]} array to a {@code float[]} array for the
     * {@code IntegerSequence} range.
     *
     * @param c {@code Complex} array
     * @param range an {@code Iterable&lt;Integer&gt;} object returned by {@code IntegerSequence.range()}
     * @return {@code float[]} array of the real component
     *
     * @since 4.0
     */
    public static float[] complex2RealFloat(Complex[] c, Range range) {
<span class="fc" id="L620">        int index = 0;</span>
<span class="fc" id="L621">        final float f[] = new float[range.size()];</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L623">            f[index] = extractRealFloatFromComplexArray(c, i);</span>
<span class="fc" id="L624">            index++;</span>
<span class="fc" id="L625">        }</span>
<span class="fc" id="L626">        return f;</span>
    }

    /**
     * Converts real component of {@code Complex[]} array to a {@code double[]}
     * array.
     *
     * @param c {@code Complex} array
     * @return array of the real component
     *
     * @since 4.0
     */
    public static double[] complex2Real(Complex[] c) {
<span class="fc" id="L639">        int index = 0;</span>
<span class="fc" id="L640">        final double d[] = new double[c.length];</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">        for (Complex cc : c) {</span>
<span class="fc" id="L642">            d[index] = cc.getReal();</span>
<span class="fc" id="L643">            index++;</span>
        }
<span class="fc" id="L645">        return d;</span>
    }

    /**
     * Converts real component of {@code Complex[]} array to a {@code float[]}
     * array.
     *
     * @param c {@code Complex} array
     * @return {@code float[]} array of the real component
     *
     * @since 4.0
     */
    public static float[] complex2RealFloat(Complex[] c) {
<span class="fc" id="L658">        int index = 0;</span>
<span class="fc" id="L659">        final float f[] = new float[c.length];</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">        for (Complex cc : c) {</span>
<span class="fc" id="L661">            f[index] = (float) cc.getReal();</span>
<span class="fc" id="L662">            index++;</span>
        }
<span class="fc" id="L664">        return f;</span>
    }

    /**
     * Converts real component of a 2D {@code Complex[][]} array to a 2D
     * {@code double[][]} array.
     *
     * @param c 2D {@code Complex} array
     * @return {@code double[][]} of real component
     * @since 4.0
     */
    public static double[][] complex2Real(Complex[][] c) {
<span class="nc" id="L676">        final int length = c.length;</span>
<span class="nc" id="L677">        double[][] d = new double[length][];</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">        for (int n = 0; n &lt; length; n++) {</span>
<span class="nc" id="L679">            d[n] = complex2Real(c[n]);</span>
        }
<span class="nc" id="L681">        return d;</span>
    }

    /**
     * Converts real component of a 2D {@code Complex[][]} array to a 2D
     * {@code float[][]} array.
     *
     * @param c 2D {@code Complex} array
     * @return {@code float[][]} of real component
     * @since 4.0
     */
    public static float[][] complex2RealFloat(Complex[][] c) {
<span class="nc" id="L693">        final int length = c.length;</span>
<span class="nc" id="L694">        float[][] f = new float[length][];</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">        for (int n = 0; n &lt; length; n++) {</span>
<span class="nc" id="L696">            f[n] = complex2RealFloat(c[n]);</span>
        }
<span class="nc" id="L698">        return f;</span>
    }

    /**
     * Converts real component of a 3D {@code Complex[][][]} array to a 3D
     * {@code double[][][]} array.
     *
     * @param c 3D complex interleaved array
     * @return array of real component
     *
     * @since 4.0
     */
    public static double[][][] complex2Real(Complex[][][] c) {
<span class="nc" id="L711">        final int length = c.length;</span>
<span class="nc" id="L712">        double[][][] d = new double[length][][];</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">        for (int n = 0; n &lt; length; n++) {</span>
<span class="nc" id="L714">            d[n] = complex2Real(c[n]);</span>
        }
<span class="nc" id="L716">        return d;</span>
    }

    /**
     * Converts real component of a 3D {@code Complex[][][]} array to a 3D
     * {@code float[][][]} array.
     *
     * @param c 3D {@code Complex} array
     * @return {@code float[][][]} of real component
     * @since 4.0
     */
    public static float[][][] complex2RealFloat(Complex[][][] c) {
<span class="nc" id="L728">        final int length = c.length;</span>
<span class="nc" id="L729">        float[][][] f = new float[length][][];</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">        for (int n = 0; n &lt; length; n++) {</span>
<span class="nc" id="L731">            f[n] = complex2RealFloat(c[n]);</span>
        }
<span class="nc" id="L733">        return f;</span>
    }

    /**
     * Converts a {@code double[]} array to an imaginary {@code Complex[]} array
     * for the range {@code start} - {@code end}.
     *
     * @param imaginary array of imaginary numbers to be converted to their {@code Complex} equivalent
     * @param start start index
     * @param end end index
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] imaginary2Complex(double[] imaginary, int start, int end) {
<span class="fc" id="L748">        final Range range = IntegerSequence.range(start, end);</span>
<span class="fc" id="L749">        int index = 0;</span>
<span class="fc" id="L750">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L752">            c[index] = extractComplexFromImaginaryArray(imaginary, i);</span>
<span class="fc" id="L753">            index++;</span>
<span class="fc" id="L754">        }</span>
<span class="fc" id="L755">        return c;</span>
    }

    /**
     * Converts a {@code float[]} array to an imaginary {@code Complex[]} array
     * for the range {@code start} - {@code end}.
     *
     * @param imaginary array of imaginary numbers to be converted to their {@code Complex} equivalent
     * @param start start index
     * @param end end index
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] imaginary2Complex(float[] imaginary, int start, int end) {
<span class="fc" id="L770">        final Range range = IntegerSequence.range(start, end);</span>
<span class="fc" id="L771">        int index = 0;</span>
<span class="fc" id="L772">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L774">            c[index] = extractComplexFromImaginaryArray(imaginary, i);</span>
<span class="fc" id="L775">            index++;</span>
<span class="fc" id="L776">        }</span>
<span class="fc" id="L777">        return c;</span>
    }

    /**
     * Converts a {@code double[]} array to an imaginary {@code Complex[]} array
     * for the range {@code start} - {@code end} by {@code increment}.
     *
     * @param imaginary array of numbers to be converted to their {@code Complex} equivalent
     * @param start start index
     * @param end end index
     * @param increment range increment
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] imaginary2Complex(double[] imaginary, int start, int end, int increment) {
<span class="fc" id="L793">        final Range range = IntegerSequence.range(start, end, increment);</span>
<span class="fc" id="L794">        int index = 0;</span>
<span class="fc" id="L795">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L797">            c[index] = extractComplexFromImaginaryArray(imaginary, i);</span>
<span class="fc" id="L798">            index++;</span>
<span class="fc" id="L799">        }</span>
<span class="fc" id="L800">        return c;</span>
    }

    /**
     * Converts a {@code float[]} array to an imaginary {@code Complex[]} array
     * for the range {@code start} - {@code end} by {@code increment}.
     *
     * @param imaginary array of numbers to be converted to their {@code Complex} equivalent
     * @param start start index
     * @param end end index
     * @param increment range increment
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] imaginary2Complex(float[] imaginary, int start, int end, int increment) {
<span class="fc" id="L816">        final Range range = IntegerSequence.range(start, end, increment);</span>
<span class="fc" id="L817">        int index = 0;</span>
<span class="fc" id="L818">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L820">            c[index] = extractComplexFromImaginaryArray(imaginary, i);</span>
<span class="fc" id="L821">            index++;</span>
<span class="fc" id="L822">        }</span>
<span class="fc" id="L823">        return c;</span>
    }

    /**
     * Converts a {@code double[]} array to an imaginary {@code Complex[]} array
     * for the {@code IntegerSequence} range.
     *
     * @param imaginary array of numbers to be converted to their {@code Complex} equivalent
     * @param range an {@code Iterable&lt;Integer&gt;} object returned by {@code IntegerSequence.range()}
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] imaginary2Complex(double[] imaginary, Range range) {
<span class="fc" id="L837">        int index = 0;</span>
<span class="fc" id="L838">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L840">            c[index] = extractComplexFromImaginaryArray(imaginary, i);</span>
<span class="fc" id="L841">            index++;</span>
<span class="fc" id="L842">        }</span>
<span class="fc" id="L843">        return c;</span>
    }

    /**
     * Converts a {@code float[]} array to an imaginary {@code Complex[]} array
     * for the {@code IntegerSequence} range.
     *
     * @param imaginary array of numbers to be converted to their {@code Complex} equivalent
     * @param range an {@code Iterable&lt;Integer&gt;} object returned by {@code IntegerSequence.range()}
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] imaginary2Complex(float[] imaginary, Range range) {
<span class="fc" id="L857">        int index = 0;</span>
<span class="fc" id="L858">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L859" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L860">            c[index] = extractComplexFromImaginaryArray(imaginary, i);</span>
<span class="fc" id="L861">            index++;</span>
<span class="fc" id="L862">        }</span>
<span class="fc" id="L863">        return c;</span>
    }

    /**
     * Converts a {@code double[]} array to an imaginary {@code Complex[]}
     * array.
     *
     * @param imaginary array of numbers to be converted to their {@code Complex} equivalent
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] imaginary2Complex(double[] imaginary) {
<span class="fc" id="L876">        int index = 0;</span>
<span class="fc" id="L877">        final Complex c[] = new Complex[imaginary.length];</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">        for (double d : imaginary) {</span>
<span class="fc" id="L879">            c[index] = Complex.ofCartesian(0, d);</span>
<span class="fc" id="L880">            index++;</span>
        }
<span class="fc" id="L882">        return c;</span>
    }

    /**
     * Converts a {@code float[]} array to an imaginary {@code Complex[]} array.
     *
     * @param imaginary array of numbers to be converted to their {@code Complex} equivalent
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] imaginary2Complex(float[] imaginary) {
<span class="fc" id="L894">        int index = 0;</span>
<span class="fc" id="L895">        final Complex c[] = new Complex[imaginary.length];</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">        for (float d : imaginary) {</span>
<span class="fc" id="L897">            c[index] = Complex.ofCartesian(0, d);</span>
<span class="fc" id="L898">            index++;</span>
        }
<span class="fc" id="L900">        return c;</span>
    }

    /**
     * Converts a 2D imaginary array {@code double[][]} to a 2D
     * {@code Complex[][]} array.
     *
     * @param d 2D array
     * @return 2D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][] imaginary2Complex(double[][] d) {
<span class="nc" id="L913">        int width = d.length;</span>
<span class="nc" id="L914">        int height = d[0].length;</span>
<span class="nc" id="L915">        Complex[][] c = new Complex[width][height];</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">        for (int n = 0; n &lt; width; n++) {</span>
<span class="nc" id="L917">            c[n] = ComplexUtils.imaginary2Complex(d[n]);</span>
        }
<span class="nc" id="L919">        return c;</span>
    }

    /**
     * Converts a 3D imaginary array {@code double[][][]} to a {@code Complex[]}
     * array.
     *
     * @param d 3D complex imaginary array
     * @return 3D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][][] imaginary2Complex(double[][][] d) {
<span class="nc" id="L932">        int width = d.length;</span>
<span class="nc" id="L933">        int height = d[0].length;</span>
<span class="nc" id="L934">        int depth = d[0].length;</span>
<span class="nc" id="L935">        Complex[][][] c = new Complex[width][height][depth];</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">        for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">            for (int y = 0; y &lt; height; y++) {</span>
<span class="nc" id="L938">                c[x][y] = ComplexUtils.imaginary2Complex(d[x][y]);</span>
            }
        }
<span class="nc" id="L941">        return c;</span>
    }

    /**
     * Converts imaginary part of {@code Complex[]} array to a {@code double[]}
     * array for the range {@code start} - {@code end}.
     *
     * @param c {@code Complex} array.
     * @param start start index
     * @param end end index
     * @return array of the imaginary component
     *
     * @since 4.0
     */
    public static double[] complex2Imaginary(Complex[] c, int start, int end) {
<span class="fc" id="L956">        final Range range = IntegerSequence.range(start, end);</span>
<span class="fc" id="L957">        int index = 0;</span>
<span class="fc" id="L958">        final double d[] = new double[range.size()];</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L960">            d[index] = extractImaginaryFromComplexArray(c, i);</span>
<span class="fc" id="L961">            index++;</span>
<span class="fc" id="L962">        }</span>
<span class="fc" id="L963">        return d;</span>
    }

    /**
     * Converts imaginary part of a {@code Complex[]} array to a {@code float[]}
     * array for the range {@code start} - {@code end}.
     *
     * @param c Complex array
     * @param start start index
     * @param end end index
     * @return {@code float[]} array of the imaginary component
     *
     * @since 4.0
     */
    public static float[] complex2ImaginaryFloat(Complex[] c, int start, int end) {
<span class="fc" id="L978">        final Range range = IntegerSequence.range(start, end);</span>
<span class="fc" id="L979">        int index = 0;</span>
<span class="fc" id="L980">        final float f[] = new float[range.size()];</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L982">            f[index] = extractImaginaryFloatFromComplexArray(c, i);</span>
<span class="fc" id="L983">            index++;</span>
<span class="fc" id="L984">        }</span>
<span class="fc" id="L985">        return f;</span>
    }

    /**
     * Converts imaginary part of a {@code Complex[]} array to a
     * {@code double[]} array for the range {@code start} - {@code end} by
     * {@code increment}.
     *
     * @param c {@code Complex} array.
     * @param start start index
     * @param end end index
     * @param increment range increment
     * @return array of the imaginary component
     *
     * @since 4.0
     */
    public static double[] complex2Imaginary(Complex[] c, int start, int end, int increment) {
<span class="fc" id="L1002">        final Range range = IntegerSequence.range(start, end, increment);</span>
<span class="fc" id="L1003">        int index = 0;</span>
<span class="fc" id="L1004">        final double d[] = new double[range.size()];</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1006">            d[index] = extractImaginaryFromComplexArray(c, i);</span>
<span class="fc" id="L1007">            index++;</span>
<span class="fc" id="L1008">        }</span>
<span class="fc" id="L1009">        return d;</span>
    }

    /**
     * Converts imaginary part of a {@code Complex[]} array to a {@code float[]}
     * array for the range {@code start} - {@code end} by {@code increment}.
     *
     * @param c {@code Complex} array.
     * @param start start index
     * @param end end index
     * @param increment range increment
     * @return {@code float[]} array of the imaginary component
     *
     * @since 4.0
     */
    public static float[] complex2ImaginaryFloat(Complex[] c, int start, int end, int increment) {
<span class="fc" id="L1025">        final Range range = IntegerSequence.range(start, end, increment);</span>
<span class="fc" id="L1026">        int index = 0;</span>
<span class="fc" id="L1027">        final float f[] = new float[range.size()];</span>
<span class="fc bfc" id="L1028" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1029">            f[index] = extractImaginaryFloatFromComplexArray(c, i);</span>
<span class="fc" id="L1030">            index++;</span>
<span class="fc" id="L1031">        }</span>
<span class="fc" id="L1032">        return f;</span>
    }

    /**
     * Converts imaginary part of a {@code Complex[]} array to a
     * {@code double[]} array for the {@code IntegerSequence} range.
     *
     * @param c {@code Complex} array.
     * @param range an {@code Iterable&lt;Integer&gt;} object returned by {@code IntegerSequence.range()}
     * @return array of the imaginary component
     *
     * @since 4.0
     */
    public static double[] complex2Imaginary(Complex[] c, Range range) {
<span class="fc" id="L1046">        int index = 0;</span>
<span class="fc" id="L1047">        final double d[] = new double[range.size()];</span>
<span class="fc bfc" id="L1048" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1049">            d[index] = extractImaginaryFromComplexArray(c, i);</span>
<span class="fc" id="L1050">            index++;</span>
<span class="fc" id="L1051">        }</span>
<span class="fc" id="L1052">        return d;</span>
    }

    /**
     * Converts imaginary part of a {@code Complex[]} array to a {@code float[]}
     * array for the {@code IntegerSequence} range.
     *
     * @param c {@code Complex} array.
     * @param range an {@code Iterable&lt;Integer&gt;} object returned by {@code IntegerSequence.range()}
     * @return {@code float[]} array of the imaginary component
     *
     * @since 4.0
     */
    public static float[] complex2ImaginaryFloat(Complex[] c, Range range) {
<span class="fc" id="L1066">        int index = 0;</span>
<span class="fc" id="L1067">        final float f[] = new float[range.size()];</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1069">            f[index] = extractImaginaryFloatFromComplexArray(c, i);</span>
<span class="fc" id="L1070">            index++;</span>
<span class="fc" id="L1071">        }</span>
<span class="fc" id="L1072">        return f;</span>
    }

    /**
     * Converts imaginary part of a {@code Complex[]} array to a
     * {@code double[]} array.
     *
     * @param c {@code Complex} array.
     * @return array of the imaginary component
     *
     * @since 4.0
     */
    public static double[] complex2Imaginary(Complex[] c) {
<span class="fc" id="L1085">        int index = 0;</span>
<span class="fc" id="L1086">        final double d[] = new double[c.length];</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">        for (Complex cc : c) {</span>
<span class="fc" id="L1088">            d[index] = cc.getImaginary();</span>
<span class="fc" id="L1089">            index++;</span>
        }
<span class="fc" id="L1091">        return d;</span>
    }

    /**
     * Converts imaginary component of a {@code Complex[]} array to a
     * {@code float[]} array.
     *
     * @param c {@code Complex} array.
     * @return {@code float[]} array of the imaginary component
     *
     * @since 4.0
     */
    public static float[] complex2ImaginaryFloat(Complex[] c) {
<span class="fc" id="L1104">        int index = 0;</span>
<span class="fc" id="L1105">        final float f[] = new float[c.length];</span>
<span class="fc bfc" id="L1106" title="All 2 branches covered.">        for (Complex cc : c) {</span>
<span class="fc" id="L1107">            f[index] = (float) cc.getImaginary();</span>
<span class="fc" id="L1108">            index++;</span>
        }
<span class="fc" id="L1110">        return f;</span>
    }

    /**
     * Converts imaginary component of a 2D {@code Complex[][]} array to a 2D
     * {@code double[][]} array.
     *
     * @param c 2D {@code Complex} array
     * @return {@code double[][]} of imaginary component
     * @since 4.0
     */
    public static double[][] complex2Imaginary(Complex[][] c) {
<span class="nc" id="L1122">        final int length = c.length;</span>
<span class="nc" id="L1123">        double[][] d = new double[length][];</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">        for (int n = 0; n &lt; length; n++) {</span>
<span class="nc" id="L1125">            d[n] = complex2Imaginary(c[n]);</span>
        }
<span class="nc" id="L1127">        return d;</span>
    }

    /**
     * Converts imaginary component of a 2D {@code Complex[][]} array to a 2D
     * {@code float[][]} array.
     *
     * @param c 2D {@code Complex} array
     * @return {@code float[][]} of imaginary component
     * @since 4.0
     */
    public static float[][] complex2ImaginaryFloat(Complex[][] c) {
<span class="nc" id="L1139">        final int length = c.length;</span>
<span class="nc" id="L1140">        float[][] f = new float[length][];</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">        for (int n = 0; n &lt; length; n++) {</span>
<span class="nc" id="L1142">            f[n] = complex2ImaginaryFloat(c[n]);</span>
        }
<span class="nc" id="L1144">        return f;</span>
    }

    /**
     * Converts imaginary component of a 3D {@code Complex[][][]} array to a 3D
     * {@code double[][][]} array.
     *
     * @param c 3D complex interleaved array
     * @return 3D {@code Complex} array
     *
     * @since 4.0
     */
    public static double[][][] complex2Imaginary(Complex[][][] c) {
<span class="nc" id="L1157">        final int length = c.length;</span>
<span class="nc" id="L1158">        double[][][] d = new double[length][][];</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">        for (int n = 0; n &lt; length; n++) {</span>
<span class="nc" id="L1160">            d[n] = complex2Imaginary(c[n]);</span>
        }
<span class="nc" id="L1162">        return d;</span>
    }

    /**
     * Converts imaginary component of a 3D {@code Complex[][][]} array to a 3D
     * {@code float[][][]} array.
     *
     * @param c 3D {@code Complex} array
     * @return {@code float[][][]} of imaginary component
     * @since 4.0
     */
    public static float[][][] complex2ImaginaryFloat(Complex[][][] c) {
<span class="nc" id="L1174">        final int length = c.length;</span>
<span class="nc" id="L1175">        float[][][] f = new float[length][][];</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">        for (int n = 0; n &lt; length; n++) {</span>
<span class="nc" id="L1177">            f[n] = complex2ImaginaryFloat(c[n]);</span>
        }
<span class="nc" id="L1179">        return f;</span>
    }

    // INTERLEAVED METHODS

    /**
     * Converts a complex interleaved {@code double[]} array to a
     * {@code Complex[]} array for the range {@code start} - {@code end}.
     *
     * @param interleaved array of numbers to be converted to their {@code Complex} equivalent
     * @param start start index
     * @param end end index
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] interleaved2Complex(double[] interleaved, int start, int end) {
<span class="fc" id="L1196">        final Range range = IntegerSequence.range(start, end);</span>
<span class="fc" id="L1197">        int index = 0;</span>
<span class="fc" id="L1198">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1200">            c[index] = extractComplexFromInterleavedArray(interleaved, i);</span>
<span class="fc" id="L1201">            index++;</span>
<span class="fc" id="L1202">        }</span>
<span class="fc" id="L1203">        return c;</span>
    }

    /**
     * Converts a complex interleaved {@code float[]} array to a
     * {@code Complex[]} array for the range {@code start} - {@code end}.
     *
     * @param interleaved float array of numbers to be converted to their {@code Complex} equivalent
     * @param start start index
     * @param end end index
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] interleaved2Complex(float[] interleaved, int start, int end) {
<span class="fc" id="L1218">        final Range range = IntegerSequence.range(start, end);</span>
<span class="fc" id="L1219">        int index = 0;</span>
<span class="fc" id="L1220">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1222">            c[index] = extractComplexFromInterleavedArray(interleaved, i);</span>
<span class="fc" id="L1223">            index++;</span>
<span class="fc" id="L1224">        }</span>
<span class="fc" id="L1225">        return c;</span>
    }

    /**
     * Converts a complex interleaved {@code double[]} array to a
     * {@code Complex[]} array for the range {@code start} - {@code end} by
     * {@code increment}.
     *
     * @param interleaved array of numbers to be converted to their {@code Complex} equivalent
     * @param start start index
     * @param end end index
     * @param increment range increment
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] interleaved2Complex(double[] interleaved, int start, int end, int increment) {
<span class="fc" id="L1242">        final Range range = IntegerSequence.range(start, end, increment);</span>
<span class="fc" id="L1243">        int index = 0;</span>
<span class="fc" id="L1244">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L1245" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1246">            c[index] = extractComplexFromInterleavedArray(interleaved, i);</span>
<span class="fc" id="L1247">            index++;</span>
<span class="fc" id="L1248">        }</span>
<span class="fc" id="L1249">        return c;</span>
    }

    /**
     * Converts a complex interleaved {@code float[]} array to a
     * {@code Complex[]} array for the range {@code start} - {@code end} by
     * {@code increment}.
     *
     * @param interleaved float array of numbers to be converted to their {@code Complex} equivalent
     * @param start start index
     * @param end end index
     * @param increment range increment
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] interleaved2Complex(float[] interleaved, int start, int end, int increment) {
<span class="fc" id="L1266">        final Range range = IntegerSequence.range(start, end, increment);</span>
<span class="fc" id="L1267">        int index = 0;</span>
<span class="fc" id="L1268">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L1269" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1270">            c[index] = extractComplexFromInterleavedArray(interleaved, i);</span>
<span class="fc" id="L1271">            index++;</span>
<span class="fc" id="L1272">        }</span>
<span class="fc" id="L1273">        return c;</span>
    }

    /**
     * Converts a complex interleaved {@code double[]} array to a
     * {@code Complex[]} array for the {@code IntegerSequence} range.
     *
     * @param interleaved array of numbers to be converted to their {@code Complex} equivalent
     * @param range an {@code Iterable&lt;Integer&gt;} object returned by {@code IntegerSequence.range()}
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] interleaved2Complex(double[] interleaved, Range range) {
<span class="fc" id="L1287">        int index = 0;</span>
<span class="fc" id="L1288">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L1289" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1290">            c[index] = extractComplexFromInterleavedArray(interleaved, i);</span>
<span class="fc" id="L1291">            index++;</span>
<span class="fc" id="L1292">        }</span>
<span class="fc" id="L1293">        return c;</span>
    }

    /**
     * Converts a complex interleaved {@code float[]} array to a
     * {@code Complex[]} array for the {@code IntegerSequence} range.
     *
     * @param interleaved float array of numbers to be converted to their {@code Complex} equivalent
     * @param range an {@code Iterable&lt;Integer&gt;} object returned by {@code IntegerSequence.range()}
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] interleaved2Complex(float[] interleaved, Range range) {
<span class="fc" id="L1307">        int index = 0;</span>
<span class="fc" id="L1308">        final Complex c[] = new Complex[range.size()];</span>
<span class="fc bfc" id="L1309" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1310">            c[index] = extractComplexFromInterleavedArray(interleaved, i);</span>
<span class="fc" id="L1311">            index++;</span>
<span class="fc" id="L1312">        }</span>
<span class="fc" id="L1313">        return c;</span>
    }

    /**
     * Converts a complex interleaved {@code double[]} array to a
     * {@code Complex[]} array
     *
     * @param interleaved array of numbers to be converted to their {@code Complex} equivalent
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] interleaved2Complex(double[] interleaved) {
<span class="fc" id="L1326">        final int length = interleaved.length / 2;</span>
<span class="fc" id="L1327">        final Complex c[] = new Complex[length];</span>
<span class="fc bfc" id="L1328" title="All 2 branches covered.">        for (int n = 0; n &lt; length; n++) {</span>
<span class="fc" id="L1329">            c[n] = Complex.ofCartesian(interleaved[n * 2], interleaved[n * 2 + 1]);</span>
        }
<span class="fc" id="L1331">        return c;</span>
    }

    /**
     * Converts a complex interleaved {@code float[]} array to a
     * {@code Complex[]} array
     *
     * @param interleaved float[] array of numbers to be converted to their {@code Complex} equivalent
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] interleaved2Complex(float[] interleaved) {
<span class="fc" id="L1344">        final int length = interleaved.length / 2;</span>
<span class="fc" id="L1345">        final Complex c[] = new Complex[length];</span>
<span class="fc bfc" id="L1346" title="All 2 branches covered.">        for (int n = 0; n &lt; length; n++) {</span>
<span class="fc" id="L1347">            c[n] = Complex.ofCartesian(interleaved[n * 2], interleaved[n * 2 + 1]);</span>
        }
<span class="fc" id="L1349">        return c;</span>
    }

    /**
     * Converts a {@code Complex[]} array to an interleaved complex
     * {@code double[]} array for the range {@code start} - {@code end}.
     *
     * @param c Complex array
     * @param start start index
     * @param end end index
     * @return complex interleaved array alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static double[] complex2Interleaved(Complex[] c, int start, int end) {
<span class="fc" id="L1365">        final Range range = IntegerSequence.range(start, end);</span>
<span class="fc" id="L1366">        int index = 0;</span>
<span class="fc" id="L1367">        final double d[] = new double[range.size() * 2];</span>
<span class="fc bfc" id="L1368" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1369">            int real = index * 2;</span>
<span class="fc" id="L1370">            int imag = index * 2 + 1;</span>
<span class="fc" id="L1371">            d[real] = c[i].getReal();</span>
<span class="fc" id="L1372">            d[imag] = c[i].getImaginary();</span>
<span class="fc" id="L1373">            index++;</span>
<span class="fc" id="L1374">        }</span>
<span class="fc" id="L1375">        return d;</span>
    }

    /**
     * Converts a {@code Complex[]} array to an interleaved complex
     * {@code float[]} array for the range {@code start} - {@code end}.
     *
     * @param c Complex array
     * @param start start index
     * @param end end index
     * @return complex interleaved {@code float[]} alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static float[] complex2InterleavedFloat(Complex[] c, int start, int end) {
<span class="fc" id="L1391">        final Range range = IntegerSequence.range(start, end);</span>
<span class="fc" id="L1392">        int index = 0;</span>
<span class="fc" id="L1393">        final float f[] = new float[range.size() * 2];</span>
<span class="fc bfc" id="L1394" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1395">            int real = index * 2;</span>
<span class="fc" id="L1396">            int imag = index * 2 + 1;</span>
<span class="fc" id="L1397">            f[real] = (float) c[i].getReal();</span>
<span class="fc" id="L1398">            f[imag] = (float) c[i].getImaginary();</span>
<span class="fc" id="L1399">            index++;</span>
<span class="fc" id="L1400">        }</span>
<span class="fc" id="L1401">        return f;</span>
    }

    /**
     * Converts a {@code Complex[]} array to an interleaved complex
     * {@code double[]} array for the range {@code start} - {@code end} by
     * {@code increment}.
     *
     * @param c Complex array
     * @param start start index
     * @param end end index
     * @param increment range increment
     * @return complex interleaved array alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static double[] complex2Interleaved(Complex[] c, int start, int end, int increment) {
<span class="fc" id="L1419">        final Range range = IntegerSequence.range(start, end, increment);</span>
<span class="fc" id="L1420">        int index = 0;</span>
<span class="fc" id="L1421">        final double d[] = new double[range.size() * 2];</span>
<span class="fc bfc" id="L1422" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1423">            int real = index * 2;</span>
<span class="fc" id="L1424">            int imag = index * 2 + 1;</span>
<span class="fc" id="L1425">            d[real] = c[i].getReal();</span>
<span class="fc" id="L1426">            d[imag] = c[i].getImaginary();</span>
<span class="fc" id="L1427">            index++;</span>
<span class="fc" id="L1428">        }</span>
<span class="fc" id="L1429">        return d;</span>
    }

    /**
     * Converts a {@code Complex[]} array to an interleaved complex
     * {@code float[]} array for the range {@code start} - {@code end} by
     * {@code increment}.
     *
     * @param c Complex array
     * @param start start index
     * @param end end index
     * @param increment range increment
     * @return complex interleaved {@code float[]} alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static float[] complex2InterleavedFloat(Complex[] c, int start, int end, int increment) {
<span class="fc" id="L1447">        final Range range = IntegerSequence.range(start, end, increment);</span>
<span class="fc" id="L1448">        int index = 0;</span>
<span class="fc" id="L1449">        final float f[] = new float[range.size() * 2];</span>
<span class="fc bfc" id="L1450" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1451">            int real = index * 2;</span>
<span class="fc" id="L1452">            int imag = index * 2 + 1;</span>
<span class="fc" id="L1453">            f[real] = (float) c[i].getReal();</span>
<span class="fc" id="L1454">            f[imag] = (float) c[i].getImaginary();</span>
<span class="fc" id="L1455">            index++;</span>
<span class="fc" id="L1456">        }</span>
<span class="fc" id="L1457">        return f;</span>
    }

    /**
     * Converts a {@code Complex[]} array to an interleaved complex
     * {@code double[]} array for the {@code IntegerSequence} range.
     *
     * @param c Complex array
     * @param range an {@code Iterable&lt;Integer&gt;} object returned by {@code IntegerSequence.range()}
     * @return complex interleaved array alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static double[] complex2Interleaved(Complex[] c, Range range) {
<span class="fc" id="L1472">        int index = 0;</span>
<span class="fc" id="L1473">        final double d[] = new double[range.size() * 2];</span>
<span class="fc bfc" id="L1474" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1475">            int real = index * 2;</span>
<span class="fc" id="L1476">            int imag = index * 2 + 1;</span>
<span class="fc" id="L1477">            d[real] = c[i].getReal();</span>
<span class="fc" id="L1478">            d[imag] = c[i].getImaginary();</span>
<span class="fc" id="L1479">            index++;</span>
<span class="fc" id="L1480">        }</span>
<span class="fc" id="L1481">        return d;</span>
    }

    /**
     * Converts a {@code Complex[]} array to an interleaved complex
     * {@code float[]} array for the {@code IntegerSequence} range.
     *
     * @param c Complex array
     * @param range an {@code Iterable&lt;Integer&gt;} object returned by {@code IntegerSequence.range()}
     * @return complex interleaved {@code float[]} alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static float[] complex2InterleavedFloat(Complex[] c, Range range) {
<span class="fc" id="L1496">        int index = 0;</span>
<span class="fc" id="L1497">        final float f[] = new float[range.size() * 2];</span>
<span class="fc bfc" id="L1498" title="All 2 branches covered.">        for (Integer i : range) {</span>
<span class="fc" id="L1499">            int real = index * 2;</span>
<span class="fc" id="L1500">            int imag = index * 2 + 1;</span>
<span class="fc" id="L1501">            f[real] = (float) c[i].getReal();</span>
<span class="fc" id="L1502">            f[imag] = (float) c[i].getImaginary();</span>
<span class="fc" id="L1503">            index++;</span>
<span class="fc" id="L1504">        }</span>
<span class="fc" id="L1505">        return f;</span>
    }

    /**
     * Converts a {@code Complex[]} array to an interleaved complex
     * {@code double[]} array
     *
     * @param c Complex array
     * @return complex interleaved array alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static double[] complex2Interleaved(Complex[] c) {
<span class="fc" id="L1519">        int index = 0;</span>
<span class="fc" id="L1520">        final double d[] = new double[c.length * 2];</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">        for (Complex cc : c) {</span>
<span class="fc" id="L1522">            int real = index * 2;</span>
<span class="fc" id="L1523">            int imag = index * 2 + 1;</span>
<span class="fc" id="L1524">            d[real] = cc.getReal();</span>
<span class="fc" id="L1525">            d[imag] = cc.getImaginary();</span>
<span class="fc" id="L1526">            index++;</span>
        }
<span class="fc" id="L1528">        return d;</span>
    }

    /**
     * Converts a {@code Complex[]} array to an interleaved complex
     * {@code float[]} array
     *
     * @param c Complex array
     * @return complex interleaved {@code float[]} alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static float[] complex2InterleavedFloat(Complex[] c) {
<span class="fc" id="L1542">        int index = 0;</span>
<span class="fc" id="L1543">        final float f[] = new float[c.length * 2];</span>
<span class="fc bfc" id="L1544" title="All 2 branches covered.">        for (Complex cc : c) {</span>
<span class="fc" id="L1545">            int real = index * 2;</span>
<span class="fc" id="L1546">            int imag = index * 2 + 1;</span>
<span class="fc" id="L1547">            f[real] = (float) cc.getReal();</span>
<span class="fc" id="L1548">            f[imag] = (float) cc.getImaginary();</span>
<span class="fc" id="L1549">            index++;</span>
        }
<span class="fc" id="L1551">        return f;</span>
    }

    /**
     * Converts a 2D {@code Complex[][]} array to an interleaved complex
     * {@code double[][]} array.
     *
     * @param c 2D Complex array
     * @param interleavedDim Depth level of the array to interleave
     * @return complex interleaved array alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static double[][] complex2Interleaved(Complex[][] c, int interleavedDim) {
<span class="nc bnc" id="L1566" title="All 4 branches missed.">        if (interleavedDim &gt; 1 || interleavedDim &lt; 0) {</span>
<span class="nc" id="L1567">            throw new OutOfRangeException(interleavedDim, 0, 1);</span>
        }
<span class="nc" id="L1569">        final int width = c.length;</span>
<span class="nc" id="L1570">        final int height = c[0].length;</span>
        double[][] d;
<span class="nc bnc" id="L1572" title="All 2 branches missed.">        if (interleavedDim == 0) {</span>
<span class="nc" id="L1573">            d = new double[2 * width][height];</span>
<span class="nc bnc" id="L1574" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc" id="L1576">                    d[x * 2][y] = c[x][y].getReal();</span>
<span class="nc" id="L1577">                    d[x * 2 + 1][y] = c[x][y].getImaginary();</span>
                }
            }
        } else {
<span class="nc" id="L1581">            d = new double[width][2 * height];</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1583" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc" id="L1584">                    d[x][y * 2] = c[x][y].getReal();</span>
<span class="nc" id="L1585">                    d[x][y * 2 + 1] = c[x][y].getImaginary();</span>
                }
            }
        }
<span class="nc" id="L1589">        return d;</span>
    }

    /**
     * Converts a 2D {@code Complex[][]} array to an interleaved complex
     * {@code double[][]} array. The second depth level of the array is assumed
     * to be interleaved.
     *
     * @param c 2D Complex array
     * @return complex interleaved array alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static double[][] complex2Interleaved(Complex[][] c) {
<span class="nc" id="L1604">        return complex2Interleaved(c, 1);</span>
    }

    /**
     * Converts a 3D {@code Complex[][][]} array to an interleaved complex
     * {@code double[][][]} array.
     *
     * @param c 3D Complex array
     * @param interleavedDim Depth level of the array to interleave
     * @return complex interleaved array alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static double[][][] complex2Interleaved(Complex[][][] c, int interleavedDim) {
<span class="nc bnc" id="L1619" title="All 4 branches missed.">        if (interleavedDim &gt; 2 || interleavedDim &lt; 0) {</span>
<span class="nc" id="L1620">            throw new OutOfRangeException(interleavedDim, 0, 2);</span>
        }
<span class="nc" id="L1622">        int width = c.length;</span>
<span class="nc" id="L1623">        int height = c[0].length;</span>
<span class="nc" id="L1624">        int depth = c[0][0].length;</span>
        double[][][] d;
<span class="nc bnc" id="L1626" title="All 2 branches missed.">        if (interleavedDim == 0) {</span>
<span class="nc" id="L1627">            d = new double[2 * width][height][depth];</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">                    for (int z = 0; z &lt; depth; z++) {</span>
<span class="nc" id="L1631">                        d[x * 2][y][z] = c[x][y][z].getReal();</span>
<span class="nc" id="L1632">                        d[x * 2 + 1][y][z] = c[x][y][z].getImaginary();</span>
                    }
                }
            }
<span class="nc bnc" id="L1636" title="All 2 branches missed.">        } else if (interleavedDim == 1) {</span>
<span class="nc" id="L1637">            d = new double[width][2 * height][depth];</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1639" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">                    for (int z = 0; z &lt; depth; z++) {</span>
<span class="nc" id="L1641">                        d[x][y * 2][z] = c[x][y][z].getReal();</span>
<span class="nc" id="L1642">                        d[x][y * 2 + 1][z] = c[x][y][z].getImaginary();</span>
                    }
                }
            }
        } else {
<span class="nc" id="L1647">            d = new double[width][height][2 * depth];</span>
<span class="nc bnc" id="L1648" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">                    for (int z = 0; z &lt; depth; z++) {</span>
<span class="nc" id="L1651">                        d[x][y][z * 2] = c[x][y][z].getReal();</span>
<span class="nc" id="L1652">                        d[x][y][z * 2 + 1] = c[x][y][z].getImaginary();</span>
                    }
                }
            }
        }
<span class="nc" id="L1657">        return d;</span>
    }

    /**
     * Converts a 3D {@code Complex[][][]} array to an interleaved complex
     * {@code double[][][]} array. The third depth level of the array is
     * interleaved.
     *
     * @param c 3D Complex array
     * @return complex interleaved array alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static double[][][] complex2Interleaved(Complex[][][] c) {
<span class="nc" id="L1672">        return complex2Interleaved(c, 2);</span>
    }

    /**
     * Converts a 2D {@code Complex[][]} array to an interleaved complex
     * {@code float[][]} array.
     *
     * @param c 2D Complex array
     * @param interleavedDim Depth level of the array to interleave
     * @return complex interleaved {@code float[][]} alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static float[][] complex2InterleavedFloat(Complex[][] c, int interleavedDim) {
<span class="nc bnc" id="L1687" title="All 4 branches missed.">        if (interleavedDim &gt; 1 || interleavedDim &lt; 0) {</span>
<span class="nc" id="L1688">            throw new OutOfRangeException(interleavedDim, 0, 1);</span>
        }
<span class="nc" id="L1690">        final int width = c.length;</span>
<span class="nc" id="L1691">        final int height = c[0].length;</span>
        float[][] d;
<span class="nc bnc" id="L1693" title="All 2 branches missed.">        if (interleavedDim == 0) {</span>
<span class="nc" id="L1694">            d = new float[2 * width][height];</span>
<span class="nc bnc" id="L1695" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1696" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc" id="L1697">                    d[x * 2][y] = (float) c[x][y].getReal();</span>
<span class="nc" id="L1698">                    d[x * 2 + 1][y] = (float) c[x][y].getImaginary();</span>
                }
            }
        } else {
<span class="nc" id="L1702">            d = new float[width][2 * height];</span>
<span class="nc bnc" id="L1703" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1704" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc" id="L1705">                    d[x][y * 2] = (float) c[x][y].getReal();</span>
<span class="nc" id="L1706">                    d[x][y * 2 + 1] = (float) c[x][y].getImaginary();</span>
                }
            }
        }
<span class="nc" id="L1710">        return d;</span>
    }

    /**
     * Converts a 2D {@code Complex[][]} array to an interleaved complex
     * {@code float[][]} array. The second depth level of the array is assumed
     * to be interleaved.
     *
     * @param c 2D Complex array
     *
     * @return complex interleaved {@code float[][]} alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static float[][] complex2InterleavedFloat(Complex[][] c) {
<span class="nc" id="L1726">        return complex2InterleavedFloat(c, 1);</span>
    }

    /**
     * Converts a 3D {@code Complex[][][]} array to an interleaved complex
     * {@code float[][][]} array.
     *
     * @param c 3D Complex array
     * @param interleavedDim Depth level of the array to interleave
     * @return complex interleaved {@code float[][][]} alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static float[][][] complex2InterleavedFloat(Complex[][][] c, int interleavedDim) {
<span class="nc bnc" id="L1741" title="All 4 branches missed.">        if (interleavedDim &gt; 2 || interleavedDim &lt; 0) {</span>
<span class="nc" id="L1742">            throw new OutOfRangeException(interleavedDim, 0, 2);</span>
        }
<span class="nc" id="L1744">        final int width = c.length;</span>
<span class="nc" id="L1745">        final int height = c[0].length;</span>
<span class="nc" id="L1746">        final int depth = c[0][0].length;</span>
        float[][][] d;
<span class="nc bnc" id="L1748" title="All 2 branches missed.">        if (interleavedDim == 0) {</span>
<span class="nc" id="L1749">            d = new float[2 * width][height][depth];</span>
<span class="nc bnc" id="L1750" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1752" title="All 2 branches missed.">                    for (int z = 0; z &lt; depth; z++) {</span>
<span class="nc" id="L1753">                        d[x * 2][y][z] = (float) c[x][y][z].getReal();</span>
<span class="nc" id="L1754">                        d[x * 2 + 1][y][z] = (float) c[x][y][z].getImaginary();</span>
                    }
                }
            }
<span class="nc bnc" id="L1758" title="All 2 branches missed.">        } else if (interleavedDim == 1) {</span>
<span class="nc" id="L1759">            d = new float[width][2 * height][depth];</span>
<span class="nc bnc" id="L1760" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">                    for (int z = 0; z &lt; depth; z++) {</span>
<span class="nc" id="L1763">                        d[x][y * 2][z] = (float) c[x][y][z].getReal();</span>
<span class="nc" id="L1764">                        d[x][y * 2 + 1][z] = (float) c[x][y][z].getImaginary();</span>
                    }
                }
            }
        } else {
<span class="nc" id="L1769">            d = new float[width][height][2 * depth];</span>
<span class="nc bnc" id="L1770" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">                    for (int z = 0; z &lt; depth; z++) {</span>
<span class="nc" id="L1773">                        d[x][y][z * 2] = (float) c[x][y][z].getReal();</span>
<span class="nc" id="L1774">                        d[x][y][z * 2 + 1] = (float) c[x][y][z].getImaginary();</span>
                    }
                }
            }
        }
<span class="nc" id="L1779">        return d;</span>
    }

    /**
     * Converts a 3D {@code Complex[][][]} array to an interleaved complex
     * {@code float[][][]} array. The third depth level of the array is
     * interleaved.
     *
     * @param c 2D Complex array
     *
     * @return complex interleaved {@code float[][][]} alternating real and
     *         imaginary values
     *
     * @since 4.0
     */
    public static float[][][] complex2InterleavedFloat(Complex[][][] c) {
<span class="nc" id="L1795">        return complex2InterleavedFloat(c, 2);</span>
    }

    /**
     * Converts a 2D interleaved complex {@code double[][]} array to a
     * {@code Complex[][]} array.
     *
     * @param d 2D complex interleaved array
     * @param interleavedDim Depth level of the array to interleave
     * @return 2D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][] interleaved2Complex(double[][] d, int interleavedDim) {
<span class="nc bnc" id="L1809" title="All 4 branches missed.">        if (interleavedDim &gt; 1 || interleavedDim &lt; 0) {</span>
<span class="nc" id="L1810">            throw new OutOfRangeException(interleavedDim, 0, 1);</span>
        }
<span class="nc" id="L1812">        final int width = d.length;</span>
<span class="nc" id="L1813">        final int height = d[0].length;</span>
        Complex[][] c;
<span class="nc bnc" id="L1815" title="All 2 branches missed.">        if (interleavedDim == 0) {</span>
<span class="nc" id="L1816">            c = new Complex[width / 2][height];</span>
<span class="nc bnc" id="L1817" title="All 2 branches missed.">            for (int x = 0; x &lt; width / 2; x++) {</span>
<span class="nc bnc" id="L1818" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc" id="L1819">                    c[x][y] = Complex.ofCartesian(d[x * 2][y], d[x * 2 + 1][y]);</span>
                }
            }
        } else {
<span class="nc" id="L1823">            c = new Complex[width][height / 2];</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1825" title="All 2 branches missed.">                for (int y = 0; y &lt; height / 2; y++) {</span>
<span class="nc" id="L1826">                    c[x][y] = Complex.ofCartesian(d[x][y * 2], d[x][y * 2 + 1]);</span>
                }
            }
        }
<span class="nc" id="L1830">        return c;</span>
    }

    /**
     * Converts a 2D interleaved complex {@code double[][]} array to a
     * {@code Complex[][]} array. The second depth level of the array is assumed
     * to be interleaved.
     *
     * @param d 2D complex interleaved array
     * @return 2D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][] interleaved2Complex(double[][] d) {
<span class="nc" id="L1844">        return interleaved2Complex(d, 1);</span>
    }

    /**
     * Converts a 3D interleaved complex {@code double[][][]} array to a
     * {@code Complex[][][]} array.
     *
     * @param d 3D complex interleaved array
     * @param interleavedDim Depth level of the array to interleave
     * @return 3D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][][] interleaved2Complex(double[][][] d, int interleavedDim) {
<span class="nc bnc" id="L1858" title="All 4 branches missed.">        if (interleavedDim &gt; 2 || interleavedDim &lt; 0) {</span>
<span class="nc" id="L1859">            throw new OutOfRangeException(interleavedDim, 0, 2);</span>
        }
<span class="nc" id="L1861">        final int width = d.length;</span>
<span class="nc" id="L1862">        final int height = d[0].length;</span>
<span class="nc" id="L1863">        final int depth = d[0][0].length;</span>
        Complex[][][] c;
<span class="nc bnc" id="L1865" title="All 2 branches missed.">        if (interleavedDim == 0) {</span>
<span class="nc" id="L1866">            c = new Complex[width / 2][height][depth];</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">            for (int x = 0; x &lt; width / 2; x++) {</span>
<span class="nc bnc" id="L1868" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1869" title="All 2 branches missed.">                    for (int z = 0; z &lt; depth; z++) {</span>
<span class="nc" id="L1870">                        c[x][y][z] = Complex.ofCartesian(d[x * 2][y][z], d[x * 2 + 1][y][z]);</span>
                    }
                }
            }
<span class="nc bnc" id="L1874" title="All 2 branches missed.">        } else if (interleavedDim == 1) {</span>
<span class="nc" id="L1875">            c = new Complex[width][height / 2][depth];</span>
<span class="nc bnc" id="L1876" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">                for (int y = 0; y &lt; height / 2; y++) {</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">                    for (int z = 0; z &lt; depth; z++) {</span>
<span class="nc" id="L1879">                        c[x][y][z] = Complex.ofCartesian(d[x][y * 2][z], d[x][y * 2 + 1][z]);</span>
                    }
                }
            }
        } else {
<span class="nc" id="L1884">            c = new Complex[width][height][depth / 2];</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">                    for (int z = 0; z &lt; depth / 2; z++) {</span>
<span class="nc" id="L1888">                        c[x][y][z] = Complex.ofCartesian(d[x][y][z * 2], d[x][y][z * 2 + 1]);</span>
                    }
                }
            }
        }
<span class="nc" id="L1893">        return c;</span>
    }

    /**
     * Converts a 3D interleaved complex {@code double[][][]} array to a
     * {@code Complex[][][]} array. The third depth level is assumed to be
     * interleaved.
     *
     * @param d 3D complex interleaved array
     * @return 3D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][][] interleaved2Complex(double[][][] d) {
<span class="nc" id="L1907">        return interleaved2Complex(d, 2);</span>
    }

    /**
     * Converts a 2D interleaved complex {@code float[][]} array to a
     * {@code Complex[][]} array.
     *
     * @param d 2D complex interleaved float array
     * @param interleavedDim Depth level of the array to interleave
     * @return 2D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][] interleaved2Complex(float[][] d, int interleavedDim) {
<span class="nc bnc" id="L1921" title="All 4 branches missed.">        if (interleavedDim &gt; 1 || interleavedDim &lt; 0) {</span>
<span class="nc" id="L1922">            throw new OutOfRangeException(interleavedDim, 0, 1);</span>
        }
<span class="nc" id="L1924">        final int width = d.length;</span>
<span class="nc" id="L1925">        final int height = d[0].length;</span>
        Complex[][] c;
<span class="nc bnc" id="L1927" title="All 2 branches missed.">        if (interleavedDim == 0) {</span>
<span class="nc" id="L1928">            c = new Complex[width / 2][height];</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">            for (int x = 0; x &lt; width / 2; x++) {</span>
<span class="nc bnc" id="L1930" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc" id="L1931">                    c[x][y] = Complex.ofCartesian(d[x * 2][y], d[x * 2 + 1][y]);</span>
                }
            }
        } else {
<span class="nc" id="L1935">            c = new Complex[width][height / 2];</span>
<span class="nc bnc" id="L1936" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1937" title="All 2 branches missed.">                for (int y = 0; y &lt; height / 2; y++) {</span>
<span class="nc" id="L1938">                    c[x][y] = Complex.ofCartesian(d[x][y * 2], d[x][y * 2 + 1]);</span>
                }
            }
        }
<span class="nc" id="L1942">        return c;</span>
    }

    /**
     * Converts a 2D interleaved complex {@code float[][]} array to a
     * {@code Complex[][]} array. The second depth level of the array is assumed
     * to be interleaved.
     *
     * @param d 2D complex interleaved float array
     * @return 2D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][] interleaved2Complex(float[][] d) {
<span class="nc" id="L1956">        return interleaved2Complex(d, 1);</span>
    }

    /**
     * Converts a 3D interleaved complex {@code float[][][]} array to a
     * {@code Complex[][][]} array.
     *
     * @param d 3D complex interleaved float array
     * @param interleavedDim Depth level of the array to interleave
     * @return 3D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][][] interleaved2Complex(float[][][] d, int interleavedDim) {
<span class="nc bnc" id="L1970" title="All 4 branches missed.">        if (interleavedDim &gt; 2 || interleavedDim &lt; 0) {</span>
<span class="nc" id="L1971">            throw new OutOfRangeException(interleavedDim, 0, 2);</span>
        }
<span class="nc" id="L1973">        final int width = d.length;</span>
<span class="nc" id="L1974">        final int height = d[0].length;</span>
<span class="nc" id="L1975">        final int depth = d[0][0].length;</span>
        Complex[][][] c;
<span class="nc bnc" id="L1977" title="All 2 branches missed.">        if (interleavedDim == 0) {</span>
<span class="nc" id="L1978">            c = new Complex[width / 2][height][depth];</span>
<span class="nc bnc" id="L1979" title="All 2 branches missed.">            for (int x = 0; x &lt; width/2; x ++) {</span>
<span class="nc bnc" id="L1980" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1981" title="All 2 branches missed.">                    for (int z = 0; z &lt; depth; z++) {</span>
<span class="nc" id="L1982">                        c[x][y][z] = Complex.ofCartesian(d[x * 2][y][z], d[x * 2 + 1][y][z]);</span>
                    }
                }
            }
<span class="nc bnc" id="L1986" title="All 2 branches missed.">        } else if (interleavedDim == 1) {</span>
<span class="nc" id="L1987">            c = new Complex[width][height / 2][depth];</span>
<span class="nc bnc" id="L1988" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1989" title="All 2 branches missed.">                for (int y = 0; y &lt; height/2; y ++) {</span>
<span class="nc bnc" id="L1990" title="All 2 branches missed.">                    for (int z = 0; z &lt; depth; z++) {</span>
<span class="nc" id="L1991">                        c[x][y][z] = Complex.ofCartesian(d[x][y * 2][z], d[x][y * 2 + 1][z]);</span>
                    }
                }
            }
        } else {
<span class="nc" id="L1996">            c = new Complex[width][height][depth / 2];</span>
<span class="nc bnc" id="L1997" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc bnc" id="L1998" title="All 2 branches missed.">                for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1999" title="All 2 branches missed.">                    for (int z = 0; z &lt; depth/2; z++) {</span>
<span class="nc" id="L2000">                        c[x][y][z] = Complex.ofCartesian(d[x][y][z * 2], d[x][y][z * 2 + 1]);</span>
                    }
                }
            }
        }
<span class="nc" id="L2005">        return c;</span>
    }

    /**
     * Converts a 3D interleaved complex {@code float[][][]} array to a
     * {@code Complex[]} array. The third depth level of the array is assumed to
     * be interleaved.
     *
     * @param d 3D complex interleaved float array
     * @return 3D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][][] interleaved2Complex(float[][][] d) {
<span class="nc" id="L2019">        return interleaved2Complex(d, 2);</span>
    }

    // SPLIT METHODS

    /**
     * Converts a split complex array {@code double[] r, double[] i} to a
     * {@code Complex[]} array.
     *
     * @param real real component
     * @param imag imaginary component
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] split2Complex(double[] real, double[] imag) {
<span class="fc" id="L2035">        final int length = real.length;</span>
<span class="fc" id="L2036">        final Complex[] c = new Complex[length];</span>
<span class="fc bfc" id="L2037" title="All 2 branches covered.">        for (int n = 0; n &lt; length; n++) {</span>
<span class="fc" id="L2038">            c[n] = Complex.ofCartesian(real[n], imag[n]);</span>
        }
<span class="fc" id="L2040">        return c;</span>
    }

    /**
     * Converts a 2D split complex array {@code double[][] r, double[][] i} to a
     * 2D {@code Complex[][]} array.
     *
     * @param real real component
     * @param imag imaginary component
     * @return 2D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][] split2Complex(double[][] real, double[][] imag) {
<span class="nc" id="L2054">        final int length = real.length;</span>
<span class="nc" id="L2055">        Complex[][] c = new Complex[length][];</span>
<span class="nc bnc" id="L2056" title="All 2 branches missed.">        for (int x = 0; x &lt; length; x++) {</span>
<span class="nc" id="L2057">            c[x] = split2Complex(real[x], imag[x]);</span>
        }
<span class="nc" id="L2059">        return c;</span>
    }

    /**
     * Converts a 3D split complex array {@code double[][][] r, double[][][] i}
     * to a 3D {@code Complex[][][]} array.
     *
     * @param real real component
     * @param imag imaginary component
     * @return 3D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][][] split2Complex(double[][][] real, double[][][] imag) {
<span class="nc" id="L2073">        final int length = real.length;</span>
<span class="nc" id="L2074">        Complex[][][] c = new Complex[length][][];</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">        for (int x = 0; x &lt; length; x++) {</span>
<span class="nc" id="L2076">            c[x] = split2Complex(real[x], imag[x]);</span>
        }
<span class="nc" id="L2078">        return c;</span>
    }

    /**
     * Converts a split complex array {@code float[] r, float[] i} to a
     * {@code Complex[]} array.
     *
     * @param real real component
     * @param imag imaginary component
     * @return {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[] split2Complex(float[] real, float[] imag) {
<span class="nc" id="L2092">        final int length = real.length;</span>
<span class="nc" id="L2093">        final Complex[] c = new Complex[length];</span>
<span class="nc bnc" id="L2094" title="All 2 branches missed.">        for (int n = 0; n &lt; length; n++) {</span>
<span class="nc" id="L2095">            c[n] = Complex.ofCartesian(real[n], imag[n]);</span>
        }
<span class="nc" id="L2097">        return c;</span>
    }

    /**
     * Converts a 2D split complex array {@code float[][] r, float[][] i} to a
     * 2D {@code Complex[][]} array.
     *
     * @param real real component
     * @param imag imaginary component
     * @return 2D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][] split2Complex(float[][] real, float[][] imag) {
<span class="nc" id="L2111">        final int length = real.length;</span>
<span class="nc" id="L2112">        Complex[][] c = new Complex[length][];</span>
<span class="nc bnc" id="L2113" title="All 2 branches missed.">        for (int x = 0; x &lt; length; x++) {</span>
<span class="nc" id="L2114">            c[x] = split2Complex(real[x], imag[x]);</span>
        }
<span class="nc" id="L2116">        return c;</span>
    }

    /**
     * Converts a 3D split complex array {@code float[][][] r, float[][][] i} to
     * a 3D {@code Complex[][][]} array.
     *
     * @param real real component
     * @param imag imaginary component
     * @return 3D {@code Complex} array
     *
     * @since 4.0
     */
    public static Complex[][][] split2Complex(float[][][] real, float[][][] imag) {
<span class="nc" id="L2130">        final int length = real.length;</span>
<span class="nc" id="L2131">        Complex[][][] c = new Complex[length][][];</span>
<span class="nc bnc" id="L2132" title="All 2 branches missed.">        for (int x = 0; x &lt; length; x++) {</span>
<span class="nc" id="L2133">            c[x] = split2Complex(real[x], imag[x]);</span>
        }
<span class="nc" id="L2135">        return c;</span>
    }

    // MISC

    /**
     * Initializes a {@code Complex[]} array to zero, to avoid
     * NullPointerExceptions.
     *
     * @param c Complex array
     * @return c
     *
     * @since 4.0
     */
    public static Complex[] initialize(Complex[] c) {
<span class="fc" id="L2150">        final int length = c.length;</span>
<span class="fc bfc" id="L2151" title="All 2 branches covered.">        for (int x = 0; x &lt; length; x++) {</span>
<span class="fc" id="L2152">            c[x] = Complex.ZERO;</span>
        }
<span class="fc" id="L2154">        return c;</span>
    }

    /**
     * Initializes a {@code Complex[][]} array to zero, to avoid
     * NullPointerExceptions.
     *
     * @param c {@code Complex} array
     * @return c
     *
     * @since 4.0
     */
    public static Complex[][] initialize(Complex[][] c) {
<span class="nc" id="L2167">        final int length = c.length;</span>
<span class="nc bnc" id="L2168" title="All 2 branches missed.">        for (int x = 0; x &lt; length; x++) {</span>
<span class="nc" id="L2169">            c[x] = initialize(c[x]);</span>
        }
<span class="nc" id="L2171">        return c;</span>
    }

    /**
     * Initializes a {@code Complex[][][]} array to zero, to avoid
     * NullPointerExceptions.
     *
     * @param c {@code Complex} array
     * @return c
     *
     * @since 4.0
     */
    public static Complex[][][] initialize(Complex[][][] c) {
<span class="nc" id="L2184">        final int length = c.length;</span>
<span class="nc bnc" id="L2185" title="All 2 branches missed.">        for (int x = 0; x &lt; length; x++) {</span>
<span class="nc" id="L2186">            c[x] = initialize(c[x]);</span>
        }
<span class="nc" id="L2188">        return c;</span>
    }

    /**
     * Returns {@code double[]} containing absolute values (magnitudes) of a
     * {@code Complex[]} array.
     *
     * @param c {@code Complex} array
     * @return {@code double[]}
     *
     * @since 4.0
     */
    public static double[] abs(Complex[] c) {
<span class="nc" id="L2201">        final int length = c.length;</span>
<span class="nc" id="L2202">        final double[] d = new double[length];</span>
<span class="nc bnc" id="L2203" title="All 2 branches missed.">        for (int x = 0; x &lt; length; x++) {</span>
<span class="nc" id="L2204">            d[x] = c[x].abs();</span>
        }
<span class="nc" id="L2206">        return d;</span>
    }

    /**
     * Returns {@code double[]} containing arguments (phase angles) of a
     * {@code Complex[]} array.
     *
     * @param c {@code Complex} array
     * @return {@code double[]} array
     *
     * @since 4.0
     */
    public static double[] arg(Complex[] c) {
<span class="nc" id="L2219">        final int length = c.length;</span>
<span class="nc" id="L2220">        final double[] d = new double[length];</span>
<span class="nc bnc" id="L2221" title="All 2 branches missed.">        for (int x = 0; x &lt; length; x++) {</span>
<span class="nc" id="L2222">            d[x] = c[x].getArgument();</span>
        }
<span class="nc" id="L2224">        return d;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>