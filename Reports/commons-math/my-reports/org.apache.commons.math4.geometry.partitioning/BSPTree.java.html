<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BSPTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.geometry.partitioning</a> &gt; <span class="el_source">BSPTree.java</span></div><h1>BSPTree.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.geometry.partitioning;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.math4.exception.MathInternalError;
import org.apache.commons.math4.geometry.Point;
import org.apache.commons.math4.geometry.Space;
import org.apache.commons.math4.util.FastMath;

/** This class represent a Binary Space Partition tree.

 * &lt;p&gt;BSP trees are an efficient way to represent space partitions and
 * to associate attributes with each cell. Each node in a BSP tree
 * represents a convex region which is partitioned in two convex
 * sub-regions at each side of a cut hyperplane. The root tree
 * contains the complete space.&lt;/p&gt;

 * &lt;p&gt;The main use of such partitions is to use a boolean attribute to
 * define an inside/outside property, hence representing arbitrary
 * polytopes (line segments in 1D, polygons in 2D and polyhedrons in
 * 3D) and to operate on them.&lt;/p&gt;

 * &lt;p&gt;Another example would be to represent Voronoi tesselations, the
 * attribute of each cell holding the defining point of the cell.&lt;/p&gt;

 * &lt;p&gt;The application-defined attributes are shared among copied
 * instances and propagated to split parts. These attributes are not
 * used by the BSP-tree algorithms themselves, so the application can
 * use them for any purpose. Since the tree visiting method holds
 * internal and leaf nodes differently, it is possible to use
 * different classes for internal nodes attributes and leaf nodes
 * attributes. This should be used with care, though, because if the
 * tree is modified in any way after attributes have been set, some
 * internal nodes may become leaf nodes and some leaf nodes may become
 * internal nodes.&lt;/p&gt;

 * &lt;p&gt;One of the main sources for the development of this package was
 * Bruce Naylor, John Amanatides and William Thibault paper &lt;a
 * href=&quot;http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf&quot;&gt;Merging
 * BSP Trees Yields Polyhedral Set Operations&lt;/a&gt; Proc. Siggraph '90,
 * Computer Graphics 24(4), August 1990, pp 115-124, published by the
 * Association for Computing Machinery (ACM).&lt;/p&gt;

 * @param &lt;S&gt; Type of the space.

 * @since 3.0
 */
public class BSPTree&lt;S extends Space&gt; {

    /** Cut sub-hyperplane. */
    private SubHyperplane&lt;S&gt; cut;

    /** Tree at the plus side of the cut hyperplane. */
    private BSPTree&lt;S&gt; plus;

    /** Tree at the minus side of the cut hyperplane. */
    private BSPTree&lt;S&gt; minus;

    /** Parent tree. */
    private BSPTree&lt;S&gt; parent;

    /** Application-defined attribute. */
    private Object attribute;

    /** Build a tree having only one root cell representing the whole space.
     */
<span class="fc" id="L84">    public BSPTree() {</span>
<span class="fc" id="L85">        cut       = null;</span>
<span class="fc" id="L86">        plus      = null;</span>
<span class="fc" id="L87">        minus     = null;</span>
<span class="fc" id="L88">        parent    = null;</span>
<span class="fc" id="L89">        attribute = null;</span>
<span class="fc" id="L90">    }</span>

    /** Build a tree having only one root cell representing the whole space.
     * @param attribute attribute of the tree (may be null)
     */
<span class="fc" id="L95">    public BSPTree(final Object attribute) {</span>
<span class="fc" id="L96">        cut    = null;</span>
<span class="fc" id="L97">        plus   = null;</span>
<span class="fc" id="L98">        minus  = null;</span>
<span class="fc" id="L99">        parent = null;</span>
<span class="fc" id="L100">        this.attribute = attribute;</span>
<span class="fc" id="L101">    }</span>

    /** Build a BSPTree from its underlying elements.
     * &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; perform any verification on
     * consistency of its arguments, it should therefore be used only
     * when then caller knows what it is doing.&lt;/p&gt;
     * &lt;p&gt;This method is mainly useful to build trees
     * bottom-up. Building trees top-down is realized with the help of
     * method {@link #insertCut insertCut}.&lt;/p&gt;
     * @param cut cut sub-hyperplane for the tree
     * @param plus plus side sub-tree
     * @param minus minus side sub-tree
     * @param attribute attribute associated with the node (may be null)
     * @see #insertCut
     */
    public BSPTree(final SubHyperplane&lt;S&gt; cut, final BSPTree&lt;S&gt; plus, final BSPTree&lt;S&gt; minus,
<span class="fc" id="L117">                   final Object attribute) {</span>
<span class="fc" id="L118">        this.cut       = cut;</span>
<span class="fc" id="L119">        this.plus      = plus;</span>
<span class="fc" id="L120">        this.minus     = minus;</span>
<span class="fc" id="L121">        this.parent    = null;</span>
<span class="fc" id="L122">        this.attribute = attribute;</span>
<span class="fc" id="L123">        plus.parent    = this;</span>
<span class="fc" id="L124">        minus.parent   = this;</span>
<span class="fc" id="L125">    }</span>

    /** Insert a cut sub-hyperplane in a node.
     * &lt;p&gt;The sub-tree starting at this node will be completely
     * overwritten. The new cut sub-hyperplane will be built from the
     * intersection of the provided hyperplane with the cell. If the
     * hyperplane does intersect the cell, the cell will have two
     * children cells with {@code null} attributes on each side of
     * the inserted cut sub-hyperplane. If the hyperplane does not
     * intersect the cell then &lt;em&gt;no&lt;/em&gt; cut hyperplane will be
     * inserted and the cell will be changed to a leaf cell. The
     * attribute of the node is never changed.&lt;/p&gt;
     * &lt;p&gt;This method is mainly useful when called on leaf nodes
     * (i.e. nodes for which {@link #getCut getCut} returns
     * {@code null}), in this case it provides a way to build a
     * tree top-down (whereas the {@link #BSPTree(SubHyperplane,
     * BSPTree, BSPTree, Object) 4 arguments constructor} is devoted to
     * build trees bottom-up).&lt;/p&gt;
     * @param hyperplane hyperplane to insert, it will be chopped in
     * order to fit in the cell defined by the parent nodes of the
     * instance
     * @return true if a cut sub-hyperplane has been inserted (i.e. if
     * the cell now has two leaf child nodes)
     * @see #BSPTree(SubHyperplane, BSPTree, BSPTree, Object)
     */
    public boolean insertCut(final Hyperplane&lt;S&gt; hyperplane) {

<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if (cut != null) {</span>
<span class="nc" id="L153">            plus.parent  = null;</span>
<span class="nc" id="L154">            minus.parent = null;</span>
        }

<span class="fc" id="L157">        final SubHyperplane&lt;S&gt; chopped = fitToCell(hyperplane.wholeHyperplane());</span>
<span class="pc bpc" id="L158" title="1 of 4 branches missed.">        if (chopped == null || chopped.isEmpty()) {</span>
<span class="fc" id="L159">            cut          = null;</span>
<span class="fc" id="L160">            plus         = null;</span>
<span class="fc" id="L161">            minus        = null;</span>
<span class="fc" id="L162">            return false;</span>
        }

<span class="fc" id="L165">        cut          = chopped;</span>
<span class="fc" id="L166">        plus         = new BSPTree&lt;&gt;();</span>
<span class="fc" id="L167">        plus.parent  = this;</span>
<span class="fc" id="L168">        minus        = new BSPTree&lt;&gt;();</span>
<span class="fc" id="L169">        minus.parent = this;</span>
<span class="fc" id="L170">        return true;</span>

    }

    /** Copy the instance.
     * &lt;p&gt;The instance created is completely independent of the original
     * one. A deep copy is used, none of the underlying objects are
     * shared (except for the nodes attributes and immutable
     * objects).&lt;/p&gt;
     * @return a new tree, copy of the instance
     */
    public BSPTree&lt;S&gt; copySelf() {

<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (cut == null) {</span>
<span class="fc" id="L184">            return new BSPTree&lt;&gt;(attribute);</span>
        }

<span class="fc" id="L187">        return new BSPTree&lt;&gt;(cut.copySelf(), plus.copySelf(), minus.copySelf(),</span>
                           attribute);

    }

    /** Get the cut sub-hyperplane.
     * @return cut sub-hyperplane, null if this is a leaf tree
     */
    public SubHyperplane&lt;S&gt; getCut() {
<span class="fc" id="L196">        return cut;</span>
    }

    /** Get the tree on the plus side of the cut hyperplane.
     * @return tree on the plus side of the cut hyperplane, null if this
     * is a leaf tree
     */
    public BSPTree&lt;S&gt; getPlus() {
<span class="fc" id="L204">        return plus;</span>
    }

    /** Get the tree on the minus side of the cut hyperplane.
     * @return tree on the minus side of the cut hyperplane, null if this
     * is a leaf tree
     */
    public BSPTree&lt;S&gt; getMinus() {
<span class="fc" id="L212">        return minus;</span>
    }

    /** Get the parent node.
     * @return parent node, null if the node has no parents
     */
    public BSPTree&lt;S&gt; getParent() {
<span class="fc" id="L219">        return parent;</span>
    }

    /** Associate an attribute with the instance.
     * @param attribute attribute to associate with the node
     * @see #getAttribute
     */
    public void setAttribute(final Object attribute) {
<span class="fc" id="L227">        this.attribute = attribute;</span>
<span class="fc" id="L228">    }</span>

    /** Get the attribute associated with the instance.
     * @return attribute associated with the node or null if no
     * attribute has been explicitly set using the {@link #setAttribute
     * setAttribute} method
     * @see #setAttribute
     */
    public Object getAttribute() {
<span class="fc" id="L237">        return attribute;</span>
    }

    /** Visit the BSP tree nodes.
     * @param visitor object visiting the tree nodes
     */
    public void visit(final BSPTreeVisitor&lt;S&gt; visitor) {
<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (cut == null) {</span>
<span class="fc" id="L245">            visitor.visitLeafNode(this);</span>
        } else {
<span class="pc bpc" id="L247" title="2 of 7 branches missed.">            switch (visitor.visitOrder(this)) {</span>
            case PLUS_MINUS_SUB:
<span class="fc" id="L249">                plus.visit(visitor);</span>
<span class="fc" id="L250">                minus.visit(visitor);</span>
<span class="fc" id="L251">                visitor.visitInternalNode(this);</span>
<span class="fc" id="L252">                break;</span>
            case PLUS_SUB_MINUS:
<span class="fc" id="L254">                plus.visit(visitor);</span>
<span class="fc" id="L255">                visitor.visitInternalNode(this);</span>
<span class="fc" id="L256">                minus.visit(visitor);</span>
<span class="fc" id="L257">                break;</span>
            case MINUS_PLUS_SUB:
<span class="nc" id="L259">                minus.visit(visitor);</span>
<span class="nc" id="L260">                plus.visit(visitor);</span>
<span class="nc" id="L261">                visitor.visitInternalNode(this);</span>
<span class="nc" id="L262">                break;</span>
            case MINUS_SUB_PLUS:
<span class="fc" id="L264">                minus.visit(visitor);</span>
<span class="fc" id="L265">                visitor.visitInternalNode(this);</span>
<span class="fc" id="L266">                plus.visit(visitor);</span>
<span class="fc" id="L267">                break;</span>
            case SUB_PLUS_MINUS:
<span class="fc" id="L269">                visitor.visitInternalNode(this);</span>
<span class="fc" id="L270">                plus.visit(visitor);</span>
<span class="fc" id="L271">                minus.visit(visitor);</span>
<span class="fc" id="L272">                break;</span>
            case SUB_MINUS_PLUS:
<span class="fc" id="L274">                visitor.visitInternalNode(this);</span>
<span class="fc" id="L275">                minus.visit(visitor);</span>
<span class="fc" id="L276">                plus.visit(visitor);</span>
<span class="fc" id="L277">                break;</span>
            default:
<span class="nc" id="L279">                throw new MathInternalError();</span>
            }

        }
<span class="fc" id="L283">    }</span>

    /** Fit a sub-hyperplane inside the cell defined by the instance.
     * &lt;p&gt;Fitting is done by chopping off the parts of the
     * sub-hyperplane that lie outside of the cell using the
     * cut-hyperplanes of the parent nodes of the instance.&lt;/p&gt;
     * @param sub sub-hyperplane to fit
     * @return a new sub-hyperplane, guaranteed to have no part outside
     * of the instance cell
     */
    private SubHyperplane&lt;S&gt; fitToCell(final SubHyperplane&lt;S&gt; sub) {
<span class="fc" id="L294">        SubHyperplane&lt;S&gt; s = sub;</span>
<span class="fc bfc" id="L295" title="All 4 branches covered.">        for (BSPTree&lt;S&gt; tree = this; tree.parent != null &amp;&amp; s != null; tree = tree.parent) {</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (tree == tree.parent.plus) {</span>
<span class="fc" id="L297">                s = s.split(tree.parent.cut.getHyperplane()).getPlus();</span>
            } else {
<span class="fc" id="L299">                s = s.split(tree.parent.cut.getHyperplane()).getMinus();</span>
            }
        }
<span class="fc" id="L302">        return s;</span>
    }

    /** Get the cell to which a point belongs.
     * &lt;p&gt;If the returned cell is a leaf node the points belongs to the
     * interior of the node, if the cell is an internal node the points
     * belongs to the node cut sub-hyperplane.&lt;/p&gt;
     * @param point point to check
     * @param tolerance tolerance below which points close to a cut hyperplane
     * are considered to belong to the hyperplane itself
     * @return the tree cell to which the point belongs
     */
    public BSPTree&lt;S&gt; getCell(final Point&lt;S&gt; point, final double tolerance) {

<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (cut == null) {</span>
<span class="fc" id="L317">            return this;</span>
        }

        // position of the point with respect to the cut hyperplane
<span class="fc" id="L321">        final double offset = cut.getHyperplane().getOffset(point);</span>

<span class="fc bfc" id="L323" title="All 2 branches covered.">        if (FastMath.abs(offset) &lt; tolerance) {</span>
<span class="fc" id="L324">            return this;</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">        } else if (offset &lt;= 0) {</span>
            // point is on the minus side of the cut hyperplane
<span class="fc" id="L327">            return minus.getCell(point, tolerance);</span>
        } else {
            // point is on the plus side of the cut hyperplane
<span class="fc" id="L330">            return plus.getCell(point, tolerance);</span>
        }

    }

    /** Get the cells whose cut sub-hyperplanes are close to the point.
     * @param point point to check
     * @param maxOffset offset below which a cut sub-hyperplane is considered
     * close to the point (in absolute value)
     * @return close cells (may be empty if all cut sub-hyperplanes are farther
     * than maxOffset from the point)
     */
    public List&lt;BSPTree&lt;S&gt;&gt; getCloseCuts(final Point&lt;S&gt; point, final double maxOffset) {
<span class="fc" id="L343">        final List&lt;BSPTree&lt;S&gt;&gt; close = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L344">        recurseCloseCuts(point, maxOffset, close);</span>
<span class="fc" id="L345">        return close;</span>
    }

    /** Get the cells whose cut sub-hyperplanes are close to the point.
     * @param point point to check
     * @param maxOffset offset below which a cut sub-hyperplane is considered
     * close to the point (in absolute value)
     * @param close list to fill
     */
    private void recurseCloseCuts(final Point&lt;S&gt; point, final double maxOffset,
                                  final List&lt;BSPTree&lt;S&gt;&gt; close) {
<span class="fc bfc" id="L356" title="All 2 branches covered.">        if (cut != null) {</span>

            // position of the point with respect to the cut hyperplane
<span class="fc" id="L359">            final double offset = cut.getHyperplane().getOffset(point);</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">            if (offset &lt; -maxOffset) {</span>
                // point is on the minus side of the cut hyperplane
<span class="fc" id="L363">                minus.recurseCloseCuts(point, maxOffset, close);</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">            } else if (offset &gt; maxOffset) {</span>
                // point is on the plus side of the cut hyperplane
<span class="fc" id="L366">                plus.recurseCloseCuts(point, maxOffset, close);</span>
            } else {
                // point is close to the cut hyperplane
<span class="fc" id="L369">                close.add(this);</span>
<span class="fc" id="L370">                minus.recurseCloseCuts(point, maxOffset, close);</span>
<span class="fc" id="L371">                plus.recurseCloseCuts(point, maxOffset, close);</span>
            }

        }
<span class="fc" id="L375">    }</span>

    /** Perform condensation on a tree.
     * &lt;p&gt;The condensation operation is not recursive, it must be called
     * explicitly from leaves to root.&lt;/p&gt;
     */
    private void condense() {
<span class="pc bpc" id="L382" title="5 of 12 branches missed.">        if ((cut != null) &amp;&amp; (plus.cut == null) &amp;&amp; (minus.cut == null) &amp;&amp;</span>
            (((plus.attribute == null) &amp;&amp; (minus.attribute == null)) ||
<span class="fc bfc" id="L384" title="All 2 branches covered.">             ((plus.attribute != null) &amp;&amp; plus.attribute.equals(minus.attribute)))) {</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">            attribute = (plus.attribute == null) ? minus.attribute : plus.attribute;</span>
<span class="fc" id="L386">            cut       = null;</span>
<span class="fc" id="L387">            plus      = null;</span>
<span class="fc" id="L388">            minus     = null;</span>
        }
<span class="fc" id="L390">    }</span>

    /** Merge a BSP tree with the instance.
     * &lt;p&gt;All trees are modified (parts of them are reused in the new
     * tree), it is the responsibility of the caller to ensure a copy
     * has been done before if any of the former tree should be
     * preserved, &lt;em&gt;no&lt;/em&gt; such copy is done here!&lt;/p&gt;
     * &lt;p&gt;The algorithm used here is directly derived from the one
     * described in the Naylor, Amanatides and Thibault paper (section
     * III, Binary Partitioning of a BSP Tree).&lt;/p&gt;
     * @param tree other tree to merge with the instance (will be
     * &lt;em&gt;unusable&lt;/em&gt; after the operation, as well as the
     * instance itself)
     * @param leafMerger object implementing the final merging phase
     * (this is where the semantic of the operation occurs, generally
     * depending on the attribute of the leaf node)
     * @return a new tree, result of &lt;code&gt;instance &amp;lt;op&amp;gt;
     * tree&lt;/code&gt;, this value can be ignored if parentTree is not null
     * since all connections have already been established
     */
    public BSPTree&lt;S&gt; merge(final BSPTree&lt;S&gt; tree, final LeafMerger&lt;S&gt; leafMerger) {
<span class="fc" id="L411">        return merge(tree, leafMerger, null, false);</span>
    }

    /** Merge a BSP tree with the instance.
     * @param tree other tree to merge with the instance (will be
     * &lt;em&gt;unusable&lt;/em&gt; after the operation, as well as the
     * instance itself)
     * @param leafMerger object implementing the final merging phase
     * (this is where the semantic of the operation occurs, generally
     * depending on the attribute of the leaf node)
     * @param parentTree parent tree to connect to (may be null)
     * @param isPlusChild if true and if parentTree is not null, the
     * resulting tree should be the plus child of its parent, ignored if
     * parentTree is null
     * @return a new tree, result of &lt;code&gt;instance &amp;lt;op&amp;gt;
     * tree&lt;/code&gt;, this value can be ignored if parentTree is not null
     * since all connections have already been established
     */
    private BSPTree&lt;S&gt; merge(final BSPTree&lt;S&gt; tree, final LeafMerger&lt;S&gt; leafMerger,
                             final BSPTree&lt;S&gt; parentTree, final boolean isPlusChild) {
<span class="fc bfc" id="L431" title="All 2 branches covered.">        if (cut == null) {</span>
            // cell/tree operation
<span class="fc" id="L433">            return leafMerger.merge(this, tree, parentTree, isPlusChild, true);</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">        } else if (tree.cut == null) {</span>
            // tree/cell operation
<span class="fc" id="L436">            return leafMerger.merge(tree, this, parentTree, isPlusChild, false);</span>
        } else {
            // tree/tree operation
<span class="fc" id="L439">            final BSPTree&lt;S&gt; merged = tree.split(cut);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">            if (parentTree != null) {</span>
<span class="fc" id="L441">                merged.parent = parentTree;</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">                if (isPlusChild) {</span>
<span class="fc" id="L443">                    parentTree.plus = merged;</span>
                } else {
<span class="fc" id="L445">                    parentTree.minus = merged;</span>
                }
            }

            // merging phase
<span class="fc" id="L450">            plus.merge(merged.plus, leafMerger, merged, true);</span>
<span class="fc" id="L451">            minus.merge(merged.minus, leafMerger, merged, false);</span>
<span class="fc" id="L452">            merged.condense();</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">            if (merged.cut != null) {</span>
<span class="fc" id="L454">                merged.cut = merged.fitToCell(merged.cut.getHyperplane().wholeHyperplane());</span>
            }

<span class="fc" id="L457">            return merged;</span>

        }
    }

    /** This interface gather the merging operations between a BSP tree
     * leaf and another BSP tree.
     * &lt;p&gt;As explained in Bruce Naylor, John Amanatides and William
     * Thibault paper &lt;a
     * href=&quot;http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf&quot;&gt;Merging
     * BSP Trees Yields Polyhedral Set Operations&lt;/a&gt;,
     * the operations on {@link BSPTree BSP trees} can be expressed as a
     * generic recursive merging operation where only the final part,
     * when one of the operand is a leaf, is specific to the real
     * operation semantics. For example, a tree representing a region
     * using a boolean attribute to identify inside cells and outside
     * cells would use four different objects to implement the final
     * merging phase of the four set operations union, intersection,
     * difference and symmetric difference (exclusive or).&lt;/p&gt;
     * @param &lt;S&gt; Type of the space.
     */
    public interface LeafMerger&lt;S extends Space&gt; {

        /** Merge a leaf node and a tree node.
         * &lt;p&gt;This method is called at the end of a recursive merging
         * resulting from a {@code tree1.merge(tree2, leafMerger)}
         * call, when one of the sub-trees involved is a leaf (i.e. when
         * its cut-hyperplane is null). This is the only place where the
         * precise semantics of the operation are required. For all upper
         * level nodes in the tree, the merging operation is only a
         * generic partitioning algorithm.&lt;/p&gt;
         * &lt;p&gt;Since the final operation may be non-commutative, it is
         * important to know if the leaf node comes from the instance tree
         * ({@code tree1}) or the argument tree
         * ({@code tree2}). The third argument of the method is
         * devoted to this. It can be ignored for commutative
         * operations.&lt;/p&gt;
         * &lt;p&gt;The {@link BSPTree#insertInTree BSPTree.insertInTree} method
         * may be useful to implement this method.&lt;/p&gt;
         * @param leaf leaf node (its cut hyperplane is guaranteed to be
         * null)
         * @param tree tree node (its cut hyperplane may be null or not)
         * @param parentTree parent tree to connect to (may be null)
         * @param isPlusChild if true and if parentTree is not null, the
         * resulting tree should be the plus child of its parent, ignored if
         * parentTree is null
         * @param leafFromInstance if true, the leaf node comes from the
         * instance tree ({@code tree1}) and the tree node comes from
         * the argument tree ({@code tree2})
         * @return the BSP tree resulting from the merging (may be one of
         * the arguments)
         */
        BSPTree&lt;S&gt; merge(BSPTree&lt;S&gt; leaf, BSPTree&lt;S&gt; tree, BSPTree&lt;S&gt; parentTree,
                         boolean isPlusChild, boolean leafFromInstance);

    }

    /** This interface handles the corner cases when an internal node cut sub-hyperplane vanishes.
     * &lt;p&gt;
     * Such cases happens for example when a cut sub-hyperplane is inserted into
     * another tree (during a merge operation), and is split in several parts,
     * some of which becomes smaller than the tolerance. The corresponding node
     * as then no cut sub-hyperplane anymore, but does have children. This interface
     * specifies how to handle this situation.
     * setting
     * &lt;/p&gt;
     * @param &lt;S&gt; Type of the space.
     * @since 3.4
     */
    public interface VanishingCutHandler&lt;S extends Space&gt; {

        /** Fix a node with both vanished cut and children.
         * @param node node to fix
         * @return fixed node
         */
        BSPTree&lt;S&gt; fixNode(BSPTree&lt;S&gt; node);

    }

    /** Split a BSP tree by an external sub-hyperplane.
     * &lt;p&gt;Split a tree in two halves, on each side of the
     * sub-hyperplane. The instance is not modified.&lt;/p&gt;
     * &lt;p&gt;The tree returned is not upward-consistent: despite all of its
     * sub-trees cut sub-hyperplanes (including its own cut
     * sub-hyperplane) are bounded to the current cell, it is &lt;em&gt;not&lt;/em&gt;
     * attached to any parent tree yet. This tree is intended to be
     * later inserted into an higher level tree.&lt;/p&gt;
     * &lt;p&gt;The algorithm used here is the one given in Naylor, Amanatides
     * and Thibault paper (section III, Binary Partitioning of a BSP
     * Tree).&lt;/p&gt;
     * @param sub partitioning sub-hyperplane, must be already clipped
     * to the convex region represented by the instance, will be used as
     * the cut sub-hyperplane of the returned tree
     * @return a tree having the specified sub-hyperplane as its cut
     * sub-hyperplane, the two parts of the split instance as its two
     * sub-trees and a null parent
     */
    public BSPTree&lt;S&gt; split(final SubHyperplane&lt;S&gt; sub) {

<span class="fc bfc" id="L556" title="All 2 branches covered.">        if (cut == null) {</span>
<span class="fc" id="L557">            return new BSPTree&lt;&gt;(sub, copySelf(), new BSPTree&lt;S&gt;(attribute), null);</span>
        }

<span class="fc" id="L560">        final Hyperplane&lt;S&gt; cHyperplane = cut.getHyperplane();</span>
<span class="fc" id="L561">        final Hyperplane&lt;S&gt; sHyperplane = sub.getHyperplane();</span>
<span class="fc" id="L562">        final SubHyperplane.SplitSubHyperplane&lt;S&gt; subParts = sub.split(cHyperplane);</span>
<span class="fc bfc" id="L563" title="All 4 branches covered.">        switch (subParts.getSide()) {</span>
        case PLUS :
        { // the partitioning sub-hyperplane is entirely in the plus sub-tree
<span class="fc" id="L566">            final BSPTree&lt;S&gt; split = plus.split(sub);</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">            if (cut.split(sHyperplane).getSide() == Side.PLUS) {</span>
<span class="fc" id="L568">                split.plus =</span>
<span class="fc" id="L569">                    new BSPTree&lt;&gt;(cut.copySelf(), split.plus, minus.copySelf(), attribute);</span>
<span class="fc" id="L570">                split.plus.condense();</span>
<span class="fc" id="L571">                split.plus.parent = split;</span>
            } else {
<span class="fc" id="L573">                split.minus =</span>
<span class="fc" id="L574">                    new BSPTree&lt;&gt;(cut.copySelf(), split.minus, minus.copySelf(), attribute);</span>
<span class="fc" id="L575">                split.minus.condense();</span>
<span class="fc" id="L576">                split.minus.parent = split;</span>
            }
<span class="fc" id="L578">            return split;</span>
        }
        case MINUS :
        { // the partitioning sub-hyperplane is entirely in the minus sub-tree
<span class="fc" id="L582">            final BSPTree&lt;S&gt; split = minus.split(sub);</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">            if (cut.split(sHyperplane).getSide() == Side.PLUS) {</span>
<span class="fc" id="L584">                split.plus =</span>
<span class="fc" id="L585">                    new BSPTree&lt;&gt;(cut.copySelf(), plus.copySelf(), split.plus, attribute);</span>
<span class="fc" id="L586">                split.plus.condense();</span>
<span class="fc" id="L587">                split.plus.parent = split;</span>
            } else {
<span class="fc" id="L589">                split.minus =</span>
<span class="fc" id="L590">                    new BSPTree&lt;&gt;(cut.copySelf(), plus.copySelf(), split.minus, attribute);</span>
<span class="fc" id="L591">                split.minus.condense();</span>
<span class="fc" id="L592">                split.minus.parent = split;</span>
            }
<span class="fc" id="L594">            return split;</span>
        }
        case BOTH :
        {
<span class="fc" id="L598">            final SubHyperplane.SplitSubHyperplane&lt;S&gt; cutParts = cut.split(sHyperplane);</span>
<span class="fc" id="L599">            final BSPTree&lt;S&gt; split =</span>
<span class="fc" id="L600">                new BSPTree&lt;&gt;(sub, plus.split(subParts.getPlus()), minus.split(subParts.getMinus()),</span>
                               null);
<span class="fc" id="L602">            split.plus.cut          = cutParts.getPlus();</span>
<span class="fc" id="L603">            split.minus.cut         = cutParts.getMinus();</span>
<span class="fc" id="L604">            final BSPTree&lt;S&gt; tmp    = split.plus.minus;</span>
<span class="fc" id="L605">            split.plus.minus        = split.minus.plus;</span>
<span class="fc" id="L606">            split.plus.minus.parent = split.plus;</span>
<span class="fc" id="L607">            split.minus.plus        = tmp;</span>
<span class="fc" id="L608">            split.minus.plus.parent = split.minus;</span>
<span class="fc" id="L609">            split.plus.condense();</span>
<span class="fc" id="L610">            split.minus.condense();</span>
<span class="fc" id="L611">            return split;</span>
        }
        default :
<span class="fc bfc" id="L614" title="All 2 branches covered.">            return cHyperplane.sameOrientationAs(sHyperplane) ?</span>
<span class="fc" id="L615">                   new BSPTree&lt;&gt;(sub, plus.copySelf(),  minus.copySelf(), attribute) :</span>
<span class="fc" id="L616">                   new BSPTree&lt;&gt;(sub, minus.copySelf(), plus.copySelf(),  attribute);</span>
        }

    }

    /** Insert the instance into another tree.
     * &lt;p&gt;The instance itself is modified so its former parent should
     * not be used anymore.&lt;/p&gt;
     * @param parentTree parent tree to connect to (may be null)
     * @param isPlusChild if true and if parentTree is not null, the
     * resulting tree should be the plus child of its parent, ignored if
     * parentTree is null
     * @param vanishingHandler handler to use for handling very rare corner
     * cases of vanishing cut sub-hyperplanes in internal nodes during merging
     * @see LeafMerger
     * @since 3.4
     */
    public void insertInTree(final BSPTree&lt;S&gt; parentTree, final boolean isPlusChild,
                             final VanishingCutHandler&lt;S&gt; vanishingHandler) {

        // set up parent/child links
<span class="fc" id="L637">        parent = parentTree;</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">        if (parentTree != null) {</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">            if (isPlusChild) {</span>
<span class="fc" id="L640">                parentTree.plus = this;</span>
            } else {
<span class="fc" id="L642">                parentTree.minus = this;</span>
            }
        }

        // make sure the inserted tree lies in the cell defined by its parent nodes
<span class="fc bfc" id="L647" title="All 2 branches covered.">        if (cut != null) {</span>

            // explore the parent nodes from here towards tree root
<span class="fc bfc" id="L650" title="All 2 branches covered.">            for (BSPTree&lt;S&gt; tree = this; tree.parent != null; tree = tree.parent) {</span>

                // this is an hyperplane of some parent node
<span class="fc" id="L653">                final Hyperplane&lt;S&gt; hyperplane = tree.parent.cut.getHyperplane();</span>

                // chop off the parts of the inserted tree that extend
                // on the wrong side of this parent hyperplane
<span class="fc bfc" id="L657" title="All 2 branches covered.">                if (tree == tree.parent.plus) {</span>
<span class="fc" id="L658">                    cut = cut.split(hyperplane).getPlus();</span>
<span class="fc" id="L659">                    plus.chopOffMinus(hyperplane, vanishingHandler);</span>
<span class="fc" id="L660">                    minus.chopOffMinus(hyperplane, vanishingHandler);</span>
                } else {
<span class="fc" id="L662">                    cut = cut.split(hyperplane).getMinus();</span>
<span class="fc" id="L663">                    plus.chopOffPlus(hyperplane, vanishingHandler);</span>
<span class="fc" id="L664">                    minus.chopOffPlus(hyperplane, vanishingHandler);</span>
                }

<span class="pc bpc" id="L667" title="1 of 2 branches missed.">                if (cut == null) {</span>
                    // the cut sub-hyperplane has vanished
<span class="nc" id="L669">                    final BSPTree&lt;S&gt; fixed = vanishingHandler.fixNode(this);</span>
<span class="nc" id="L670">                    cut       = fixed.cut;</span>
<span class="nc" id="L671">                    plus      = fixed.plus;</span>
<span class="nc" id="L672">                    minus     = fixed.minus;</span>
<span class="nc" id="L673">                    attribute = fixed.attribute;</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                    if (cut == null) {</span>
<span class="nc" id="L675">                        break;</span>
                    }
                }

            }

            // since we may have drop some parts of the inserted tree,
            // perform a condensation pass to keep the tree structure simple
<span class="fc" id="L683">            condense();</span>

        }

<span class="fc" id="L687">    }</span>

    /** Prune a tree around a cell.
     * &lt;p&gt;
     * This method can be used to extract a convex cell from a tree.
     * The original cell may either be a leaf node or an internal node.
     * If it is an internal node, it's subtree will be ignored (i.e. the
     * extracted cell will be a leaf node in all cases). The original
     * tree to which the original cell belongs is not touched at all,
     * a new independent tree will be built.
     * &lt;/p&gt;
     * @param cellAttribute attribute to set for the leaf node
     * corresponding to the initial instance cell
     * @param otherLeafsAttributes attribute to set for the other leaf
     * nodes
     * @param internalAttributes attribute to set for the internal nodes
     * @return a new tree (the original tree is left untouched) containing
     * a single branch with the cell as a leaf node, and other leaf nodes
     * as the remnants of the pruned branches
     * @since 3.3
     */
    public BSPTree&lt;S&gt; pruneAroundConvexCell(final Object cellAttribute,
                                            final Object otherLeafsAttributes,
                                            final Object internalAttributes) {

        // build the current cell leaf
<span class="fc" id="L713">        BSPTree&lt;S&gt; tree = new BSPTree&lt;&gt;(cellAttribute);</span>

        // build the pruned tree bottom-up
<span class="fc bfc" id="L716" title="All 2 branches covered.">        for (BSPTree&lt;S&gt; current = this; current.parent != null; current = current.parent) {</span>
<span class="fc" id="L717">            final SubHyperplane&lt;S&gt; parentCut = current.parent.cut.copySelf();</span>
<span class="fc" id="L718">            final BSPTree&lt;S&gt;       sibling   = new BSPTree&lt;&gt;(otherLeafsAttributes);</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">            if (current == current.parent.plus) {</span>
<span class="fc" id="L720">                tree = new BSPTree&lt;&gt;(parentCut, tree, sibling, internalAttributes);</span>
            } else {
<span class="fc" id="L722">                tree = new BSPTree&lt;&gt;(parentCut, sibling, tree, internalAttributes);</span>
            }
        }

<span class="fc" id="L726">        return tree;</span>

    }

    /** Chop off parts of the tree.
     * &lt;p&gt;The instance is modified in place, all the parts that are on
     * the minus side of the chopping hyperplane are discarded, only the
     * parts on the plus side remain.&lt;/p&gt;
     * @param hyperplane chopping hyperplane
     * @param vanishingHandler handler to use for handling very rare corner
     * cases of vanishing cut sub-hyperplanes in internal nodes during merging
     */
    private void chopOffMinus(final Hyperplane&lt;S&gt; hyperplane, final VanishingCutHandler&lt;S&gt; vanishingHandler) {
<span class="fc bfc" id="L739" title="All 2 branches covered.">        if (cut != null) {</span>

<span class="fc" id="L741">            cut = cut.split(hyperplane).getPlus();</span>
<span class="fc" id="L742">            plus.chopOffMinus(hyperplane, vanishingHandler);</span>
<span class="fc" id="L743">            minus.chopOffMinus(hyperplane, vanishingHandler);</span>

<span class="pc bpc" id="L745" title="1 of 2 branches missed.">            if (cut == null) {</span>
                // the cut sub-hyperplane has vanished
<span class="nc" id="L747">                final BSPTree&lt;S&gt; fixed = vanishingHandler.fixNode(this);</span>
<span class="nc" id="L748">                cut       = fixed.cut;</span>
<span class="nc" id="L749">                plus      = fixed.plus;</span>
<span class="nc" id="L750">                minus     = fixed.minus;</span>
<span class="nc" id="L751">                attribute = fixed.attribute;</span>
            }

        }
<span class="fc" id="L755">    }</span>

    /** Chop off parts of the tree.
     * &lt;p&gt;The instance is modified in place, all the parts that are on
     * the plus side of the chopping hyperplane are discarded, only the
     * parts on the minus side remain.&lt;/p&gt;
     * @param hyperplane chopping hyperplane
     * @param vanishingHandler handler to use for handling very rare corner
     * cases of vanishing cut sub-hyperplanes in internal nodes during merging
     */
    private void chopOffPlus(final Hyperplane&lt;S&gt; hyperplane, final VanishingCutHandler&lt;S&gt; vanishingHandler) {
<span class="fc bfc" id="L766" title="All 2 branches covered.">        if (cut != null) {</span>

<span class="fc" id="L768">            cut = cut.split(hyperplane).getMinus();</span>
<span class="fc" id="L769">            plus.chopOffPlus(hyperplane, vanishingHandler);</span>
<span class="fc" id="L770">            minus.chopOffPlus(hyperplane, vanishingHandler);</span>

<span class="fc bfc" id="L772" title="All 2 branches covered.">            if (cut == null) {</span>
                // the cut sub-hyperplane has vanished
<span class="fc" id="L774">                final BSPTree&lt;S&gt; fixed = vanishingHandler.fixNode(this);</span>
<span class="fc" id="L775">                cut       = fixed.cut;</span>
<span class="fc" id="L776">                plus      = fixed.plus;</span>
<span class="fc" id="L777">                minus     = fixed.minus;</span>
<span class="fc" id="L778">                attribute = fixed.attribute;</span>
            }

        }
<span class="fc" id="L782">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>