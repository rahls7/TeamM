<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MathArrays.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.util</a> &gt; <span class="el_source">MathArrays.java</span></div><h1>MathArrays.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.util;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.TreeSet;

import org.apache.commons.numbers.core.Precision;
import org.apache.commons.math4.Field;
import org.apache.commons.math4.exception.DimensionMismatchException;
import org.apache.commons.math4.exception.MathArithmeticException;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.exception.MathInternalError;
import org.apache.commons.math4.exception.NoDataException;
import org.apache.commons.math4.exception.NonMonotonicSequenceException;
import org.apache.commons.math4.exception.NotANumberException;
import org.apache.commons.math4.exception.NotPositiveException;
import org.apache.commons.math4.exception.NotStrictlyPositiveException;
import org.apache.commons.math4.exception.NullArgumentException;
import org.apache.commons.math4.exception.NumberIsTooLargeException;
import org.apache.commons.math4.exception.util.LocalizedFormats;

/**
 * Arrays utilities.
 *
 * @since 3.0
 */
public class MathArrays {

    /**
     * Private constructor.
     */
    private MathArrays() {}

    /**
     * Real-valued function that operate on an array or a part of it.
     * @since 3.1
     */
    public interface Function {
        /**
         * Operates on an entire array.
         *
         * @param array Array to operate on.
         * @return the result of the operation.
         */
        double evaluate(double[] array);
        /**
         * @param array Array to operate on.
         * @param startIndex Index of the first element to take into account.
         * @param numElements Number of elements to take into account.
         * @return the result of the operation.
         */
        double evaluate(double[] array,
                        int startIndex,
                        int numElements);
    }

    /**
     * Create a copy of an array scaled by a value.
     *
     * @param arr Array to scale.
     * @param val Scalar.
     * @return scaled copy of array with each entry multiplied by val.
     * @since 3.2
     */
    public static double[] scale(double val, final double[] arr) {
<span class="fc" id="L88">        double[] newArr = new double[arr.length];</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        for (int i = 0; i &lt; arr.length; i++) {</span>
<span class="fc" id="L90">            newArr[i] = arr[i] * val;</span>
        }
<span class="fc" id="L92">        return newArr;</span>
    }

    /**
     * &lt;p&gt;Multiply each element of an array by a value.&lt;/p&gt;
     *
     * &lt;p&gt;The array is modified in place (no copy is created).&lt;/p&gt;
     *
     * @param arr Array to scale
     * @param val Scalar
     * @since 3.2
     */
    public static void scaleInPlace(double val, final double[] arr) {
<span class="fc bfc" id="L105" title="All 2 branches covered.">        for (int i = 0; i &lt; arr.length; i++) {</span>
<span class="fc" id="L106">            arr[i] *= val;</span>
        }
<span class="fc" id="L108">    }</span>

    /**
     * Creates an array whose contents will be the element-by-element
     * addition of the arguments.
     *
     * @param a First term of the addition.
     * @param b Second term of the addition.
     * @return a new array {@code r} where {@code r[i] = a[i] + b[i]}.
     * @throws DimensionMismatchException if the array lengths differ.
     * @since 3.1
     */
    public static double[] ebeAdd(double[] a, double[] b)
        throws DimensionMismatchException {
<span class="fc" id="L122">        checkEqualLength(a, b);</span>

<span class="fc" id="L124">        final double[] result = a.clone();</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L126">            result[i] += b[i];</span>
        }
<span class="fc" id="L128">        return result;</span>
    }
    /**
     * Creates an array whose contents will be the element-by-element
     * subtraction of the second argument from the first.
     *
     * @param a First term.
     * @param b Element to be subtracted.
     * @return a new array {@code r} where {@code r[i] = a[i] - b[i]}.
     * @throws DimensionMismatchException if the array lengths differ.
     * @since 3.1
     */
    public static double[] ebeSubtract(double[] a, double[] b)
        throws DimensionMismatchException {
<span class="fc" id="L142">        checkEqualLength(a, b);</span>

<span class="fc" id="L144">        final double[] result = a.clone();</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L146">            result[i] -= b[i];</span>
        }
<span class="fc" id="L148">        return result;</span>
    }
    /**
     * Creates an array whose contents will be the element-by-element
     * multiplication of the arguments.
     *
     * @param a First factor of the multiplication.
     * @param b Second factor of the multiplication.
     * @return a new array {@code r} where {@code r[i] = a[i] * b[i]}.
     * @throws DimensionMismatchException if the array lengths differ.
     * @since 3.1
     */
    public static double[] ebeMultiply(double[] a, double[] b)
        throws DimensionMismatchException {
<span class="fc" id="L162">        checkEqualLength(a, b);</span>

<span class="fc" id="L164">        final double[] result = a.clone();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L166">            result[i] *= b[i];</span>
        }
<span class="fc" id="L168">        return result;</span>
    }
    /**
     * Creates an array whose contents will be the element-by-element
     * division of the first argument by the second.
     *
     * @param a Numerator of the division.
     * @param b Denominator of the division.
     * @return a new array {@code r} where {@code r[i] = a[i] / b[i]}.
     * @throws DimensionMismatchException if the array lengths differ.
     * @since 3.1
     */
    public static double[] ebeDivide(double[] a, double[] b)
        throws DimensionMismatchException {
<span class="fc" id="L182">        checkEqualLength(a, b);</span>

<span class="fc" id="L184">        final double[] result = a.clone();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L186">            result[i] /= b[i];</span>
        }
<span class="fc" id="L188">        return result;</span>
    }

    /**
     * Calculates the L&lt;sub&gt;1&lt;/sub&gt; (sum of abs) distance between two points.
     *
     * @param p1 the first point
     * @param p2 the second point
     * @return the L&lt;sub&gt;1&lt;/sub&gt; distance between the two points
     * @throws DimensionMismatchException if the array lengths differ.
     */
    public static double distance1(double[] p1, double[] p2)
    throws DimensionMismatchException {
<span class="fc" id="L201">        checkEqualLength(p1, p2);</span>
<span class="fc" id="L202">        double sum = 0;</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        for (int i = 0; i &lt; p1.length; i++) {</span>
<span class="fc" id="L204">            sum += FastMath.abs(p1[i] - p2[i]);</span>
        }
<span class="fc" id="L206">        return sum;</span>
    }

    /**
     * Calculates the L&lt;sub&gt;1&lt;/sub&gt; (sum of abs) distance between two points.
     *
     * @param p1 the first point
     * @param p2 the second point
     * @return the L&lt;sub&gt;1&lt;/sub&gt; distance between the two points
     * @throws DimensionMismatchException if the array lengths differ.
     */
    public static int distance1(int[] p1, int[] p2)
    throws DimensionMismatchException {
<span class="fc" id="L219">        checkEqualLength(p1, p2);</span>
<span class="fc" id="L220">        int sum = 0;</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">        for (int i = 0; i &lt; p1.length; i++) {</span>
<span class="fc" id="L222">            sum += FastMath.abs(p1[i] - p2[i]);</span>
        }
<span class="fc" id="L224">        return sum;</span>
    }

    /**
     * Calculates the L&lt;sub&gt;2&lt;/sub&gt; (Euclidean) distance between two points.
     *
     * @param p1 the first point
     * @param p2 the second point
     * @return the L&lt;sub&gt;2&lt;/sub&gt; distance between the two points
     * @throws DimensionMismatchException if the array lengths differ.
     */
    public static double distance(double[] p1, double[] p2)
    throws DimensionMismatchException {
<span class="fc" id="L237">        checkEqualLength(p1, p2);</span>
<span class="fc" id="L238">        double sum = 0;</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        for (int i = 0; i &lt; p1.length; i++) {</span>
<span class="fc" id="L240">            final double dp = p1[i] - p2[i];</span>
<span class="fc" id="L241">            sum += dp * dp;</span>
        }
<span class="fc" id="L243">        return FastMath.sqrt(sum);</span>
    }

    /**
     * Calculates the L&lt;sub&gt;2&lt;/sub&gt; (Euclidean) distance between two points.
     *
     * @param p1 the first point
     * @param p2 the second point
     * @return the L&lt;sub&gt;2&lt;/sub&gt; distance between the two points
     * @throws DimensionMismatchException if the array lengths differ.
     */
    public static double distance(int[] p1, int[] p2)
    throws DimensionMismatchException {
<span class="fc" id="L256">      checkEqualLength(p1, p2);</span>
<span class="fc" id="L257">      double sum = 0;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">      for (int i = 0; i &lt; p1.length; i++) {</span>
<span class="fc" id="L259">          final double dp = p1[i] - p2[i];</span>
<span class="fc" id="L260">          sum += dp * dp;</span>
      }
<span class="fc" id="L262">      return FastMath.sqrt(sum);</span>
    }

    /**
     * Calculates the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; (max of abs) distance between two points.
     *
     * @param p1 the first point
     * @param p2 the second point
     * @return the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; distance between the two points
     * @throws DimensionMismatchException if the array lengths differ.
     */
    public static double distanceInf(double[] p1, double[] p2)
    throws DimensionMismatchException {
<span class="fc" id="L275">        checkEqualLength(p1, p2);</span>
<span class="fc" id="L276">        double max = 0;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">        for (int i = 0; i &lt; p1.length; i++) {</span>
<span class="fc" id="L278">            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));</span>
        }
<span class="fc" id="L280">        return max;</span>
    }

    /**
     * Calculates the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; (max of abs) distance between two points.
     *
     * @param p1 the first point
     * @param p2 the second point
     * @return the L&lt;sub&gt;&amp;infin;&lt;/sub&gt; distance between the two points
     * @throws DimensionMismatchException if the array lengths differ.
     */
    public static int distanceInf(int[] p1, int[] p2)
    throws DimensionMismatchException {
<span class="fc" id="L293">        checkEqualLength(p1, p2);</span>
<span class="fc" id="L294">        int max = 0;</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">        for (int i = 0; i &lt; p1.length; i++) {</span>
<span class="fc" id="L296">            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));</span>
        }
<span class="fc" id="L298">        return max;</span>
    }

    /**
     * Specification of ordering direction.
     */
<span class="fc" id="L304">    public enum OrderDirection {</span>
        /** Constant for increasing direction. */
<span class="fc" id="L306">        INCREASING,</span>
        /** Constant for decreasing direction. */
<span class="fc" id="L308">        DECREASING</span>
    }

    /**
     * Check that an array is monotonically increasing or decreasing.
     *
     * @param &lt;T&gt; the type of the elements in the specified array
     * @param val Values.
     * @param dir Ordering direction.
     * @param strict Whether the order should be strict.
     * @return {@code true} if sorted, {@code false} otherwise.
     */
    public static  &lt;T extends Comparable&lt;? super T&gt;&gt; boolean isMonotonic(T[] val,
                                      OrderDirection dir,
                                      boolean strict) {
<span class="fc" id="L323">        T previous = val[0];</span>
<span class="fc" id="L324">        final int max = val.length;</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">        for (int i = 1; i &lt; max; i++) {</span>
            final int comp;
<span class="pc bpc" id="L327" title="1 of 3 branches missed.">            switch (dir) {</span>
            case INCREASING:
<span class="fc" id="L329">                comp = previous.compareTo(val[i]);</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">                if (strict) {</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">                    if (comp &gt;= 0) {</span>
<span class="fc" id="L332">                        return false;</span>
                    }
                } else {
<span class="fc bfc" id="L335" title="All 2 branches covered.">                    if (comp &gt; 0) {</span>
<span class="fc" id="L336">                        return false;</span>
                    }
                }
                break;
            case DECREASING:
<span class="fc" id="L341">                comp = val[i].compareTo(previous);</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">                if (strict) {</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">                    if (comp &gt;= 0) {</span>
<span class="fc" id="L344">                        return false;</span>
                    }
                } else {
<span class="fc bfc" id="L347" title="All 2 branches covered.">                    if (comp &gt; 0) {</span>
<span class="fc" id="L348">                       return false;</span>
                    }
                }
                break;
            default:
                // Should never happen.
<span class="nc" id="L354">                throw new MathInternalError();</span>
            }

<span class="fc" id="L357">            previous = val[i];</span>
        }
<span class="fc" id="L359">        return true;</span>
    }

    /**
     * Check that an array is monotonically increasing or decreasing.
     *
     * @param val Values.
     * @param dir Ordering direction.
     * @param strict Whether the order should be strict.
     * @return {@code true} if sorted, {@code false} otherwise.
     */
    public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {
<span class="fc" id="L371">        return checkOrder(val, dir, strict, false);</span>
    }

    /**
     * Check that both arrays have the same length.
     *
     * @param a Array.
     * @param b Array.
     * @param abort Whether to throw an exception if the check fails.
     * @return {@code true} if the arrays have the same length.
     * @throws DimensionMismatchException if the lengths differ and
     * {@code abort} is {@code true}.
     * @since 3.6
     */
    public static boolean checkEqualLength(double[] a,
                                           double[] b,
                                           boolean abort) {
<span class="fc bfc" id="L388" title="All 2 branches covered.">        if (a.length == b.length) {</span>
<span class="fc" id="L389">            return true;</span>
        } else {
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">            if (abort) {</span>
<span class="fc" id="L392">                throw new DimensionMismatchException(a.length, b.length);</span>
            }
<span class="nc" id="L394">            return false;</span>
        }
    }

    /**
     * Check that both arrays have the same length.
     *
     * @param a Array.
     * @param b Array.
     * @throws DimensionMismatchException if the lengths differ.
     * @since 3.6
     */
    public static void checkEqualLength(double[] a,
                                        double[] b) {
<span class="fc" id="L408">        checkEqualLength(a, b, true);</span>
<span class="fc" id="L409">    }</span>


    /**
     * Check that both arrays have the same length.
     *
     * @param a Array.
     * @param b Array.
     * @param abort Whether to throw an exception if the check fails.
     * @return {@code true} if the arrays have the same length.
     * @throws DimensionMismatchException if the lengths differ and
     * {@code abort} is {@code true}.
     * @since 3.6
     */
    public static boolean checkEqualLength(int[] a,
                                           int[] b,
                                           boolean abort) {
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        if (a.length == b.length) {</span>
<span class="fc" id="L427">            return true;</span>
        } else {
<span class="nc bnc" id="L429" title="All 2 branches missed.">            if (abort) {</span>
<span class="nc" id="L430">                throw new DimensionMismatchException(a.length, b.length);</span>
            }
<span class="nc" id="L432">            return false;</span>
        }
    }

    /**
     * Check that both arrays have the same length.
     *
     * @param a Array.
     * @param b Array.
     * @throws DimensionMismatchException if the lengths differ.
     * @since 3.6
     */
    public static void checkEqualLength(int[] a,
                                        int[] b) {
<span class="fc" id="L446">        checkEqualLength(a, b, true);</span>
<span class="fc" id="L447">    }</span>

    /**
     * Check that the given array is sorted.
     *
     * @param val Values.
     * @param dir Ordering direction.
     * @param strict Whether the order should be strict.
     * @param abort Whether to throw an exception if the check fails.
     * @return {@code true} if the array is sorted.
     * @throws NonMonotonicSequenceException if the array is not sorted
     * and {@code abort} is {@code true}.
     */
    public static boolean checkOrder(double[] val, OrderDirection dir,
                                     boolean strict, boolean abort)
        throws NonMonotonicSequenceException {
<span class="fc" id="L463">        double previous = val[0];</span>
<span class="fc" id="L464">        final int max = val.length;</span>

        int index;
        ITEM:
<span class="fc bfc" id="L468" title="All 2 branches covered.">        for (index = 1; index &lt; max; index++) {</span>
<span class="pc bpc" id="L469" title="1 of 3 branches missed.">            switch (dir) {</span>
            case INCREASING:
<span class="fc bfc" id="L471" title="All 2 branches covered.">                if (strict) {</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">                    if (val[index] &lt;= previous) {</span>
<span class="fc" id="L473">                        break ITEM;</span>
                    }
                } else {
<span class="fc bfc" id="L476" title="All 2 branches covered.">                    if (val[index] &lt; previous) {</span>
<span class="fc" id="L477">                        break ITEM;</span>
                    }
                }
                break;
            case DECREASING:
<span class="fc bfc" id="L482" title="All 2 branches covered.">                if (strict) {</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">                    if (val[index] &gt;= previous) {</span>
<span class="fc" id="L484">                        break ITEM;</span>
                    }
                } else {
<span class="fc bfc" id="L487" title="All 2 branches covered.">                    if (val[index] &gt; previous) {</span>
<span class="fc" id="L488">                        break ITEM;</span>
                    }
                }
                break;
            default:
                // Should never happen.
<span class="nc" id="L494">                throw new MathInternalError();</span>
            }

<span class="fc" id="L497">            previous = val[index];</span>
        }

<span class="fc bfc" id="L500" title="All 2 branches covered.">        if (index == max) {</span>
            // Loop completed.
<span class="fc" id="L502">            return true;</span>
        }

        // Loop early exit means wrong ordering.
<span class="fc bfc" id="L506" title="All 2 branches covered.">        if (abort) {</span>
<span class="fc" id="L507">            throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);</span>
        } else {
<span class="fc" id="L509">            return false;</span>
        }
    }

    /**
     * Check that the given array is sorted.
     *
     * @param val Values.
     * @param dir Ordering direction.
     * @param strict Whether the order should be strict.
     * @throws NonMonotonicSequenceException if the array is not sorted.
     * @since 2.2
     */
    public static void checkOrder(double[] val, OrderDirection dir,
                                  boolean strict) throws NonMonotonicSequenceException {
<span class="fc" id="L524">        checkOrder(val, dir, strict, true);</span>
<span class="fc" id="L525">    }</span>

    /**
     * Check that the given array is sorted in strictly increasing order.
     *
     * @param val Values.
     * @throws NonMonotonicSequenceException if the array is not sorted.
     * @since 2.2
     */
    public static void checkOrder(double[] val) throws NonMonotonicSequenceException {
<span class="fc" id="L535">        checkOrder(val, OrderDirection.INCREASING, true);</span>
<span class="fc" id="L536">    }</span>

    /**
     * Throws DimensionMismatchException if the input array is not rectangular.
     *
     * @param in array to be tested
     * @throws NullArgumentException if input array is null
     * @throws DimensionMismatchException if input array is not rectangular
     * @since 3.1
     */
    public static void checkRectangular(final long[][] in)
        throws NullArgumentException, DimensionMismatchException {
<span class="fc" id="L548">        MathUtils.checkNotNull(in);</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">        for (int i = 1; i &lt; in.length; i++) {</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if (in[i].length != in[0].length) {</span>
<span class="fc" id="L551">                throw new DimensionMismatchException(</span>
                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,
                        in[i].length, in[0].length);
            }
        }
<span class="fc" id="L556">    }</span>

    /**
     * Check that all entries of the input array are strictly positive.
     *
     * @param in Array to be tested
     * @throws NotStrictlyPositiveException if any entries of the array are not
     * strictly positive.
     * @since 3.1
     */
    public static void checkPositive(final double[] in)
        throws NotStrictlyPositiveException {
<span class="fc bfc" id="L568" title="All 2 branches covered.">        for (int i = 0; i &lt; in.length; i++) {</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">            if (in[i] &lt;= 0) {</span>
<span class="fc" id="L570">                throw new NotStrictlyPositiveException(in[i]);</span>
            }
        }
<span class="fc" id="L573">    }</span>

    /**
     * Check that no entry of the input array is {@code NaN}.
     *
     * @param in Array to be tested.
     * @throws NotANumberException if an entry is {@code NaN}.
     * @since 3.4
     */
    public static void checkNotNaN(final double[] in)
        throws NotANumberException {
<span class="fc bfc" id="L584" title="All 2 branches covered.">        for(int i = 0; i &lt; in.length; i++) {</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">            if (Double.isNaN(in[i])) {</span>
<span class="fc" id="L586">                throw new NotANumberException();</span>
            }
        }
<span class="fc" id="L589">    }</span>

    /**
     * Check that all entries of the input array are &amp;gt;= 0.
     *
     * @param in Array to be tested
     * @throws NotPositiveException if any array entries are less than 0.
     * @since 3.1
     */
    public static void checkNonNegative(final long[] in)
        throws NotPositiveException {
<span class="fc bfc" id="L600" title="All 2 branches covered.">        for (int i = 0; i &lt; in.length; i++) {</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">            if (in[i] &lt; 0) {</span>
<span class="fc" id="L602">                throw new NotPositiveException(in[i]);</span>
            }
        }
<span class="fc" id="L605">    }</span>

    /**
     * Check all entries of the input array are &amp;gt;= 0.
     *
     * @param in Array to be tested
     * @throws NotPositiveException if any array entries are less than 0.
     * @since 3.1
     */
    public static void checkNonNegative(final long[][] in)
        throws NotPositiveException {
<span class="fc bfc" id="L616" title="All 2 branches covered.">        for (int i = 0; i &lt; in.length; i ++) {</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">            for (int j = 0; j &lt; in[i].length; j++) {</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">                if (in[i][j] &lt; 0) {</span>
<span class="fc" id="L619">                    throw new NotPositiveException(in[i][j]);</span>
                }
            }
        }
<span class="fc" id="L623">    }</span>

    /**
     * Sort an array in ascending order in place and perform the same reordering
     * of entries on other arrays. For example, if
     * {@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then
     * {@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},
     * {@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.
     *
     * @param x Array to be sorted and used as a pattern for permutation
     * of the other arrays.
     * @param yList Set of arrays whose permutations of entries will follow
     * those performed on {@code x}.
     * @throws DimensionMismatchException if any {@code y} is not the same
     * size as {@code x}.
     * @throws NullArgumentException if {@code x} or any {@code y} is null.
     * @since 3.0
     */
    public static void sortInPlace(double[] x, double[] ... yList)
        throws DimensionMismatchException, NullArgumentException {
<span class="fc" id="L643">        sortInPlace(x, OrderDirection.INCREASING, yList);</span>
<span class="fc" id="L644">    }</span>

    /**
     * Helper data structure holding a (double, integer) pair.
     */
    private static class PairDoubleInteger {
        /** Key */
        private final double key;
        /** Value */
        private final int value;

        /**
         * @param key Key.
         * @param value Value.
         */
<span class="fc" id="L659">        PairDoubleInteger(double key, int value) {</span>
<span class="fc" id="L660">            this.key = key;</span>
<span class="fc" id="L661">            this.value = value;</span>
<span class="fc" id="L662">        }</span>

        /** @return the key. */
        public double getKey() {
<span class="fc" id="L666">            return key;</span>
        }

        /** @return the value. */
        public int getValue() {
<span class="fc" id="L671">            return value;</span>
        }
    }

    /**
     * Sort an array in place and perform the same reordering of entries on
     * other arrays.  This method works the same as the other
     * {@link #sortInPlace(double[], double[][]) sortInPlace} method, but
     * allows the order of the sort to be provided in the {@code dir}
     * parameter.
     *
     * @param x Array to be sorted and used as a pattern for permutation
     * of the other arrays.
     * @param dir Order direction.
     * @param yList Set of arrays whose permutations of entries will follow
     * those performed on {@code x}.
     * @throws DimensionMismatchException if any {@code y} is not the same
     * size as {@code x}.
     * @throws NullArgumentException if {@code x} or any {@code y} is null
     * @since 3.0
     */
    public static void sortInPlace(double[] x,
                                   final OrderDirection dir,
                                   double[] ... yList)
        throws NullArgumentException,
               DimensionMismatchException {

        // Consistency checks.
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L700">            throw new NullArgumentException();</span>
        }

<span class="fc" id="L703">        final int yListLen = yList.length;</span>
<span class="fc" id="L704">        final int len = x.length;</span>

<span class="fc bfc" id="L706" title="All 2 branches covered.">        for (int j = 0; j &lt; yListLen; j++) {</span>
<span class="fc" id="L707">            final double[] y = yList[j];</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">            if (y == null) {</span>
<span class="fc" id="L709">                throw new NullArgumentException();</span>
            }
<span class="fc bfc" id="L711" title="All 2 branches covered.">            if (y.length != len) {</span>
<span class="fc" id="L712">                throw new DimensionMismatchException(y.length, len);</span>
            }
        }

        // Associate each abscissa &quot;x[i]&quot; with its index &quot;i&quot;.
<span class="fc" id="L717">        final List&lt;PairDoubleInteger&gt; list</span>
            = new ArrayList&lt;&gt;(len);
<span class="fc bfc" id="L719" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L720">            list.add(new PairDoubleInteger(x[i], i));</span>
        }

        // Create comparators for increasing and decreasing orders.
<span class="fc bfc" id="L724" title="All 2 branches covered.">        final Comparator&lt;PairDoubleInteger&gt; comp</span>
            = dir == MathArrays.OrderDirection.INCREASING ?
<span class="fc" id="L726">            new Comparator&lt;PairDoubleInteger&gt;() {</span>
            /** {@inheritDoc} */
            @Override
            public int compare(PairDoubleInteger o1,
                               PairDoubleInteger o2) {
<span class="fc" id="L731">                return Double.compare(o1.getKey(), o2.getKey());</span>
            }
<span class="fc" id="L733">        } : new Comparator&lt;PairDoubleInteger&gt;() {</span>
            /** {@inheritDoc} */
            @Override
            public int compare(PairDoubleInteger o1,
                               PairDoubleInteger o2) {
<span class="fc" id="L738">                return Double.compare(o2.getKey(), o1.getKey());</span>
            }
        };

        // Sort.
<span class="fc" id="L743">        Collections.sort(list, comp);</span>

        // Modify the original array so that its elements are in
        // the prescribed order.
        // Retrieve indices of original locations.
<span class="fc" id="L748">        final int[] indices = new int[len];</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L750">            final PairDoubleInteger e = list.get(i);</span>
<span class="fc" id="L751">            x[i] = e.getKey();</span>
<span class="fc" id="L752">            indices[i] = e.getValue();</span>
        }

        // In each of the associated arrays, move the
        // elements to their new location.
<span class="fc bfc" id="L757" title="All 2 branches covered.">        for (int j = 0; j &lt; yListLen; j++) {</span>
            // Input array will be modified in place.
<span class="fc" id="L759">            final double[] yInPlace = yList[j];</span>
<span class="fc" id="L760">            final double[] yOrig = yInPlace.clone();</span>

<span class="fc bfc" id="L762" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L763">                yInPlace[i] = yOrig[indices[i]];</span>
            }
        }
<span class="fc" id="L766">    }</span>

    /**
     * Creates a copy of the {@code source} array.
     *
     * @param source Array to be copied.
     * @return the copied array.
     */
     public static int[] copyOf(int[] source) {
<span class="fc" id="L775">         return copyOf(source, source.length);</span>
     }

    /**
     * Creates a copy of the {@code source} array.
     *
     * @param source Array to be copied.
     * @return the copied array.
     */
     public static double[] copyOf(double[] source) {
<span class="fc" id="L785">         return copyOf(source, source.length);</span>
     }

    /**
     * Creates a copy of the {@code source} array.
     *
     * @param source Array to be copied.
     * @param len Number of entries to copy. If smaller then the source
     * length, the copy will be truncated, if larger it will padded with
     * zeroes.
     * @return the copied array.
     */
    public static int[] copyOf(int[] source, int len) {
<span class="fc" id="L798">         final int[] output = new int[len];</span>
<span class="fc" id="L799">         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));</span>
<span class="fc" id="L800">         return output;</span>
     }

    /**
     * Creates a copy of the {@code source} array.
     *
     * @param source Array to be copied.
     * @param len Number of entries to copy. If smaller then the source
     * length, the copy will be truncated, if larger it will padded with
     * zeroes.
     * @return the copied array.
     */
    public static double[] copyOf(double[] source, int len) {
<span class="fc" id="L813">         final double[] output = new double[len];</span>
<span class="fc" id="L814">         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));</span>
<span class="fc" id="L815">         return output;</span>
     }

    /**
     * Creates a copy of the {@code source} array.
     *
     * @param source Array to be copied.
     * @param from Initial index of the range to be copied, inclusive.
     * @param to Final index of the range to be copied, exclusive. (This index may lie outside the array.)
     * @return the copied array.
     */
    public static double[] copyOfRange(double[] source, int from, int to) {
<span class="fc" id="L827">        final int len = to - from;</span>
<span class="fc" id="L828">        final double[] output = new double[len];</span>
<span class="fc" id="L829">        System.arraycopy(source, from, output, 0, FastMath.min(len, source.length - from));</span>
<span class="fc" id="L830">        return output;</span>
     }

    /**
     * Returns true iff both arguments are null or have same dimensions and all
     * their elements are equal as defined by
     * {@link Precision#equals(float,float)}.
     *
     * @param x first array
     * @param y second array
     * @return true if the values are both null or have same dimension
     * and equal elements.
     */
    public static boolean equals(float[] x, float[] y) {
<span class="nc bnc" id="L844" title="All 4 branches missed.">        if ((x == null) || (y == null)) {</span>
<span class="nc bnc" id="L845" title="All 6 branches missed.">            return !((x == null) ^ (y == null));</span>
        }
<span class="nc bnc" id="L847" title="All 2 branches missed.">        if (x.length != y.length) {</span>
<span class="nc" id="L848">            return false;</span>
        }
<span class="nc bnc" id="L850" title="All 2 branches missed.">        for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">            if (!Precision.equals(x[i], y[i])) {</span>
<span class="nc" id="L852">                return false;</span>
            }
        }
<span class="nc" id="L855">        return true;</span>
    }

    /**
     * Returns true iff both arguments are null or have same dimensions and all
     * their elements are equal as defined by
     * {@link Precision#equalsIncludingNaN(double,double) this method}.
     *
     * @param x first array
     * @param y second array
     * @return true if the values are both null or have same dimension and
     * equal elements
     * @since 2.2
     */
    public static boolean equalsIncludingNaN(float[] x, float[] y) {
<span class="nc bnc" id="L870" title="All 4 branches missed.">        if ((x == null) || (y == null)) {</span>
<span class="nc bnc" id="L871" title="All 6 branches missed.">            return !((x == null) ^ (y == null));</span>
        }
<span class="nc bnc" id="L873" title="All 2 branches missed.">        if (x.length != y.length) {</span>
<span class="nc" id="L874">            return false;</span>
        }
<span class="nc bnc" id="L876" title="All 2 branches missed.">        for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">            if (!Precision.equalsIncludingNaN(x[i], y[i])) {</span>
<span class="nc" id="L878">                return false;</span>
            }
        }
<span class="nc" id="L881">        return true;</span>
    }

    /**
     * Returns {@code true} iff both arguments are {@code null} or have same
     * dimensions and all their elements are equal as defined by
     * {@link Precision#equals(double,double)}.
     *
     * @param x First array.
     * @param y Second array.
     * @return {@code true} if the values are both {@code null} or have same
     * dimension and equal elements.
     */
    public static boolean equals(double[] x, double[] y) {
<span class="fc bfc" id="L895" title="All 4 branches covered.">        if ((x == null) || (y == null)) {</span>
<span class="fc bfc" id="L896" title="All 6 branches covered.">            return !((x == null) ^ (y == null));</span>
        }
<span class="fc bfc" id="L898" title="All 2 branches covered.">        if (x.length != y.length) {</span>
<span class="fc" id="L899">            return false;</span>
        }
<span class="fc bfc" id="L901" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">            if (!Precision.equals(x[i], y[i])) {</span>
<span class="fc" id="L903">                return false;</span>
            }
        }
<span class="fc" id="L906">        return true;</span>
    }

    /**
     * Returns {@code true} iff both arguments are {@code null} or have same
     * dimensions and all their elements are equal as defined by
     * {@link Precision#equalsIncludingNaN(double,double) this method}.
     *
     * @param x First array.
     * @param y Second array.
     * @return {@code true} if the values are both {@code null} or have same
     * dimension and equal elements.
     * @since 2.2
     */
    public static boolean equalsIncludingNaN(double[] x, double[] y) {
<span class="fc bfc" id="L921" title="All 4 branches covered.">        if ((x == null) || (y == null)) {</span>
<span class="fc bfc" id="L922" title="All 6 branches covered.">            return !((x == null) ^ (y == null));</span>
        }
<span class="fc bfc" id="L924" title="All 2 branches covered.">        if (x.length != y.length) {</span>
<span class="fc" id="L925">            return false;</span>
        }
<span class="fc bfc" id="L927" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc bfc" id="L928" title="All 2 branches covered.">            if (!Precision.equalsIncludingNaN(x[i], y[i])) {</span>
<span class="fc" id="L929">                return false;</span>
            }
        }
<span class="fc" id="L932">        return true;</span>
    }

    /**
     * Normalizes an array to make it sum to a specified value.
     * Returns the result of the transformation
     * &lt;pre&gt;
     *    x |-&amp;gt; x * normalizedSum / sum
     * &lt;/pre&gt;
     * applied to each non-NaN element x of the input array, where sum is the
     * sum of the non-NaN entries in the input array.
     * &lt;p&gt;
     * Throws IllegalArgumentException if {@code normalizedSum} is infinite
     * or NaN and ArithmeticException if the input array contains any infinite elements
     * or sums to 0.
     * &lt;p&gt;
     * Ignores (i.e., copies unchanged to the output array) NaNs in the input array.
     *
     * @param values Input array to be normalized
     * @param normalizedSum Target sum for the normalized array
     * @return the normalized array.
     * @throws MathArithmeticException if the input array contains infinite
     * elements or sums to zero.
     * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.
     * @since 2.1
     */
    public static double[] normalizeArray(double[] values, double normalizedSum)
        throws MathIllegalArgumentException, MathArithmeticException {
<span class="fc bfc" id="L960" title="All 2 branches covered.">        if (Double.isInfinite(normalizedSum)) {</span>
<span class="fc" id="L961">            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);</span>
        }
<span class="fc bfc" id="L963" title="All 2 branches covered.">        if (Double.isNaN(normalizedSum)) {</span>
<span class="fc" id="L964">            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);</span>
        }
<span class="fc" id="L966">        double sum = 0d;</span>
<span class="fc" id="L967">        final int len = values.length;</span>
<span class="fc" id="L968">        double[] out = new double[len];</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">            if (Double.isInfinite(values[i])) {</span>
<span class="fc" id="L971">                throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);</span>
            }
<span class="fc bfc" id="L973" title="All 2 branches covered.">            if (!Double.isNaN(values[i])) {</span>
<span class="fc" id="L974">                sum += values[i];</span>
            }
        }
<span class="fc bfc" id="L977" title="All 2 branches covered.">        if (sum == 0) {</span>
<span class="fc" id="L978">            throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);</span>
        }
<span class="fc bfc" id="L980" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">            if (Double.isNaN(values[i])) {</span>
<span class="fc" id="L982">                out[i] = Double.NaN;</span>
            } else {
<span class="fc" id="L984">                out[i] = values[i] * normalizedSum / sum;</span>
            }
        }
<span class="fc" id="L987">        return out;</span>
    }

    /** Build an array of elements.
     * &lt;p&gt;
     * Arrays are filled with field.getZero()
     *
     * @param &lt;T&gt; the type of the field elements
     * @param field field to which array elements belong
     * @param length of the array
     * @return a new array
     * @since 3.2
     */
    public static &lt;T&gt; T[] buildArray(final Field&lt;T&gt; field, final int length) {
        @SuppressWarnings(&quot;unchecked&quot;) // OK because field must be correct class
<span class="fc" id="L1002">        T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);</span>
<span class="fc" id="L1003">        Arrays.fill(array, field.getZero());</span>
<span class="fc" id="L1004">        return array;</span>
    }

    /** Build a double dimension  array of elements.
     * &lt;p&gt;
     * Arrays are filled with field.getZero()
     *
     * @param &lt;T&gt; the type of the field elements
     * @param field field to which array elements belong
     * @param rows number of rows in the array
     * @param columns number of columns (may be negative to build partial
     * arrays in the same way &lt;code&gt;new Field[rows][]&lt;/code&gt; works)
     * @return a new array
     * @since 3.2
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T[][] buildArray(final Field&lt;T&gt; field, final int rows, final int columns) {
        final T[][] array;
<span class="fc bfc" id="L1022" title="All 2 branches covered.">        if (columns &lt; 0) {</span>
<span class="fc" id="L1023">            T[] dummyRow = buildArray(field, 0);</span>
<span class="fc" id="L1024">            array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);</span>
<span class="fc" id="L1025">        } else {</span>
<span class="fc" id="L1026">            array = (T[][]) Array.newInstance(field.getRuntimeClass(),</span>
                                              new int[] {
                                                  rows, columns
                                              });
<span class="fc bfc" id="L1030" title="All 2 branches covered.">            for (int i = 0; i &lt; rows; ++i) {</span>
<span class="fc" id="L1031">                Arrays.fill(array[i], field.getZero());</span>
            }
        }
<span class="fc" id="L1034">        return array;</span>
    }

    /**
     * Calculates the &lt;a href=&quot;http://en.wikipedia.org/wiki/Convolution&quot;&gt;
     * convolution&lt;/a&gt; between two sequences.
     * &lt;p&gt;
     * The solution is obtained via straightforward computation of the
     * convolution sum (and not via FFT). Whenever the computation needs
     * an element that would be located at an index outside the input arrays,
     * the value is assumed to be zero.
     *
     * @param x First sequence.
     * Typically, this sequence will represent an input signal to a system.
     * @param h Second sequence.
     * Typically, this sequence will represent the impulse response of the system.
     * @return the convolution of {@code x} and {@code h}.
     * This array's length will be {@code x.length + h.length - 1}.
     * @throws NullArgumentException if either {@code x} or {@code h} is {@code null}.
     * @throws NoDataException if either {@code x} or {@code h} is empty.
     *
     * @since 3.3
     */
    public static double[] convolve(double[] x, double[] h)
        throws NullArgumentException,
               NoDataException {
<span class="fc" id="L1060">        MathUtils.checkNotNull(x);</span>
<span class="fc" id="L1061">        MathUtils.checkNotNull(h);</span>

<span class="fc" id="L1063">        final int xLen = x.length;</span>
<span class="fc" id="L1064">        final int hLen = h.length;</span>

<span class="fc bfc" id="L1066" title="All 4 branches covered.">        if (xLen == 0 || hLen == 0) {</span>
<span class="fc" id="L1067">            throw new NoDataException();</span>
        }

        // initialize the output array
<span class="fc" id="L1071">        final int totalLength = xLen + hLen - 1;</span>
<span class="fc" id="L1072">        final double[] y = new double[totalLength];</span>

        // straightforward implementation of the convolution sum
<span class="fc bfc" id="L1075" title="All 2 branches covered.">        for (int n = 0; n &lt; totalLength; n++) {</span>
<span class="fc" id="L1076">            double yn = 0;</span>
<span class="fc" id="L1077">            int k = FastMath.max(0, n + 1 - xLen);</span>
<span class="fc" id="L1078">            int j = n - k;</span>
<span class="fc bfc" id="L1079" title="All 4 branches covered.">            while (k &lt; hLen &amp;&amp; j &gt;= 0) {</span>
<span class="fc" id="L1080">                yn += x[j--] * h[k++];</span>
            }
<span class="fc" id="L1082">            y[n] = yn;</span>
        }

<span class="fc" id="L1085">        return y;</span>
    }

    /**
     * Returns an array representing the natural number {@code n}.
     *
     * @param n Natural number.
     * @return an array whose entries are the numbers 0, 1, ..., {@code n}-1.
     * If {@code n == 0}, the returned array is empty.
     */
    public static int[] natural(int n) {
<span class="fc" id="L1096">        return sequence(n, 0, 1);</span>
    }
    /**
     * Returns an array of {@code size} integers starting at {@code start},
     * skipping {@code stride} numbers.
     *
     * @param size Natural number.
     * @param start Natural number.
     * @param stride Natural number.
     * @return an array whose entries are the numbers
     * {@code start, start + stride, ..., start + (size - 1) * stride}.
     * If {@code size == 0}, the returned array is empty.
     *
     * @since 3.4
     */
    public static int[] sequence(int size,
                                 int start,
                                 int stride) {
<span class="fc" id="L1114">        final int[] a = new int[size];</span>
<span class="fc bfc" id="L1115" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1116">            a[i] = start + i * stride;</span>
        }
<span class="fc" id="L1118">        return a;</span>
    }
    /**
     * This method is used
     * to verify that the input parameters designate a subarray of positive length.
     * &lt;ul&gt;
     * &lt;li&gt;returns &lt;code&gt;true&lt;/code&gt; iff the parameters designate a subarray of
     * positive length&lt;/li&gt;
     * &lt;li&gt;throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if the array is null or
     * or the indices are invalid&lt;/li&gt;
     * &lt;li&gt;returns &lt;code&gt;false&lt;/code&gt; if the array is non-null, but
     * &lt;code&gt;length&lt;/code&gt; is 0.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param values the input array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return true if the parameters are valid and designate a subarray of positive length
     * @throws MathIllegalArgumentException if the indices are invalid or the array is null
     * @since 3.3
     */
    public static boolean verifyValues(final double[] values, final int begin, final int length)
            throws MathIllegalArgumentException {
<span class="fc" id="L1141">        return verifyValues(values, begin, length, false);</span>
    }

    /**
     * This method is used
     * to verify that the input parameters designate a subarray of positive length.
     * &lt;ul&gt;
     * &lt;li&gt;returns &lt;code&gt;true&lt;/code&gt; iff the parameters designate a subarray of
     * non-negative length&lt;/li&gt;
     * &lt;li&gt;throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the array is null or
     * or the indices are invalid&lt;/li&gt;
     * &lt;li&gt;returns &lt;code&gt;false&lt;/code&gt; if the array is non-null, but
     * &lt;code&gt;length&lt;/code&gt; is 0 unless &lt;code&gt;allowEmpty&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param values the input array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @param allowEmpty if &lt;code&gt;true&lt;/code&gt; then zero length arrays are allowed
     * @return true if the parameters are valid
     * @throws MathIllegalArgumentException if the indices are invalid or the array is null
     * @since 3.3
     */
    public static boolean verifyValues(final double[] values, final int begin,
            final int length, final boolean allowEmpty) throws MathIllegalArgumentException {

<span class="fc bfc" id="L1167" title="All 2 branches covered.">        if (values == null) {</span>
<span class="fc" id="L1168">            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);</span>
        }

<span class="fc bfc" id="L1171" title="All 2 branches covered.">        if (begin &lt; 0) {</span>
<span class="fc" id="L1172">            throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));</span>
        }

<span class="fc bfc" id="L1175" title="All 2 branches covered.">        if (length &lt; 0) {</span>
<span class="fc" id="L1176">            throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));</span>
        }

<span class="fc bfc" id="L1179" title="All 2 branches covered.">        if (begin + length &gt; values.length) {</span>
<span class="fc" id="L1180">            throw new NumberIsTooLargeException(LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END,</span>
<span class="fc" id="L1181">                    Integer.valueOf(begin + length), Integer.valueOf(values.length), true);</span>
        }

<span class="fc bfc" id="L1184" title="All 4 branches covered.">        if (length == 0 &amp;&amp; !allowEmpty) {</span>
<span class="fc" id="L1185">            return false;</span>
        }

<span class="fc" id="L1188">        return true;</span>

    }

    /**
     * This method is used
     * to verify that the begin and length parameters designate a subarray of positive length
     * and the weights are all non-negative, non-NaN, finite, and not all zero.
     * &lt;ul&gt;
     * &lt;li&gt;returns &lt;code&gt;true&lt;/code&gt; iff the parameters designate a subarray of
     * positive length and the weights array contains legitimate values.&lt;/li&gt;
     * &lt;li&gt;throws &lt;code&gt;IllegalArgumentException&lt;/code&gt; if any of the following are true:
     * &lt;ul&gt;&lt;li&gt;the values array is null&lt;/li&gt;
     *     &lt;li&gt;the weights array is null&lt;/li&gt;
     *     &lt;li&gt;the weights array does not have the same length as the values array&lt;/li&gt;
     *     &lt;li&gt;the weights array contains one or more infinite values&lt;/li&gt;
     *     &lt;li&gt;the weights array contains one or more NaN values&lt;/li&gt;
     *     &lt;li&gt;the weights array contains negative values&lt;/li&gt;
     *     &lt;li&gt;the start and length arguments do not determine a valid array&lt;/li&gt;&lt;/ul&gt;
     * &lt;/li&gt;
     * &lt;li&gt;returns &lt;code&gt;false&lt;/code&gt; if the array is non-null, but
     * &lt;code&gt;length&lt;/code&gt; is 0.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param values the input array
     * @param weights the weights array
     * @param begin index of the first array element to include
     * @param length the number of elements to include
     * @return true if the parameters are valid and designate a subarray of positive length
     * @throws MathIllegalArgumentException if the indices are invalid or the array is null
     * @since 3.3
     */
    public static boolean verifyValues(
        final double[] values,
        final double[] weights,
        final int begin,
        final int length) throws MathIllegalArgumentException {
<span class="fc" id="L1225">        return verifyValues(values, weights, begin, length, false);</span>
    }

    /**
     * This method is used
     * to verify that the begin and length parameters designate a subarray of positive length
     * and the weights are all non-negative, non-NaN, finite, and not all zero.
     * &lt;ul&gt;
     * &lt;li&gt;returns &lt;code&gt;true&lt;/code&gt; iff the parameters designate a subarray of
     * non-negative length and the weights array contains legitimate values.&lt;/li&gt;
     * &lt;li&gt;throws &lt;code&gt;MathIllegalArgumentException&lt;/code&gt; if any of the following are true:
     * &lt;ul&gt;&lt;li&gt;the values array is null&lt;/li&gt;
     *     &lt;li&gt;the weights array is null&lt;/li&gt;
     *     &lt;li&gt;the weights array does not have the same length as the values array&lt;/li&gt;
     *     &lt;li&gt;the weights array contains one or more infinite values&lt;/li&gt;
     *     &lt;li&gt;the weights array contains one or more NaN values&lt;/li&gt;
     *     &lt;li&gt;the weights array contains negative values&lt;/li&gt;
     *     &lt;li&gt;the start and length arguments do not determine a valid array&lt;/li&gt;&lt;/ul&gt;
     * &lt;/li&gt;
     * &lt;li&gt;returns &lt;code&gt;false&lt;/code&gt; if the array is non-null, but
     * &lt;code&gt;length&lt;/code&gt; is 0 unless &lt;code&gt;allowEmpty&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param values the input array.
     * @param weights the weights array.
     * @param begin index of the first array element to include.
     * @param length the number of elements to include.
     * @param allowEmpty if {@code true} than allow zero length arrays to pass.
     * @return {@code true} if the parameters are valid.
     * @throws NullArgumentException if either of the arrays are null
     * @throws MathIllegalArgumentException if the array indices are not valid,
     * the weights array contains NaN, infinite or negative elements, or there
     * are no positive weights.
     * @since 3.3
     */
    public static boolean verifyValues(final double[] values, final double[] weights,
            final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {

<span class="pc bpc" id="L1263" title="1 of 4 branches missed.">        if (weights == null || values == null) {</span>
<span class="fc" id="L1264">            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);</span>
        }

<span class="fc" id="L1267">        checkEqualLength(weights, values);</span>

<span class="fc" id="L1269">        boolean containsPositiveWeight = false;</span>
<span class="fc bfc" id="L1270" title="All 2 branches covered.">        for (int i = begin; i &lt; begin + length; i++) {</span>
<span class="fc" id="L1271">            final double weight = weights[i];</span>
<span class="pc bpc" id="L1272" title="1 of 2 branches missed.">            if (Double.isNaN(weight)) {</span>
<span class="nc" id="L1273">                throw new MathIllegalArgumentException(LocalizedFormats.NAN_ELEMENT_AT_INDEX, Integer.valueOf(i));</span>
            }
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">            if (Double.isInfinite(weight)) {</span>
<span class="nc" id="L1276">                throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, Double.valueOf(weight), Integer.valueOf(i));</span>
            }
<span class="fc bfc" id="L1278" title="All 2 branches covered.">            if (weight &lt; 0) {</span>
<span class="fc" id="L1279">                throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX, Integer.valueOf(i), Double.valueOf(weight));</span>
            }
<span class="pc bpc" id="L1281" title="1 of 4 branches missed.">            if (!containsPositiveWeight &amp;&amp; weight &gt; 0.0) {</span>
<span class="fc" id="L1282">                containsPositiveWeight = true;</span>
            }
        }

<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">        if (!containsPositiveWeight) {</span>
<span class="nc" id="L1287">            throw new MathIllegalArgumentException(LocalizedFormats.WEIGHT_AT_LEAST_ONE_NON_ZERO);</span>
        }

<span class="fc" id="L1290">        return verifyValues(values, begin, length, allowEmpty);</span>
    }

    /**
     * Concatenates a sequence of arrays. The return array consists of the
     * entries of the input arrays concatenated in the order they appear in
     * the argument list.  Null arrays cause NullPointerExceptions; zero
     * length arrays are allowed (contributing nothing to the output array).
     *
     * @param x list of double[] arrays to concatenate
     * @return a new array consisting of the entries of the argument arrays
     * @throws NullPointerException if any of the arrays are null
     * @since 3.6
     */
    public static double[] concatenate(double[] ...x) {
<span class="fc" id="L1305">        int combinedLength = 0;</span>
<span class="fc bfc" id="L1306" title="All 2 branches covered.">        for (double[] a : x) {</span>
<span class="fc" id="L1307">            combinedLength += a.length;</span>
        }
<span class="fc" id="L1309">        int offset = 0;</span>
<span class="fc" id="L1310">        int curLength = 0;</span>
<span class="fc" id="L1311">        final double[] combined = new double[combinedLength];</span>
<span class="fc bfc" id="L1312" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>
<span class="fc" id="L1313">            curLength = x[i].length;</span>
<span class="fc" id="L1314">            System.arraycopy(x[i], 0, combined, offset, curLength);</span>
<span class="fc" id="L1315">            offset += curLength;</span>
        }
<span class="fc" id="L1317">        return combined;</span>
    }

    /**
     * Returns an array consisting of the unique values in {@code data}.
     * The return array is sorted in descending order.  Empty arrays
     * are allowed, but null arrays result in NullPointerException.
     * Infinities are allowed.  NaN values are allowed with maximum
     * sort order - i.e., if there are NaN values in {@code data},
     * {@code Double.NaN} will be the first element of the output array,
     * even if the array also contains {@code Double.POSITIVE_INFINITY}.
     *
     * @param data array to scan
     * @return descending list of values included in the input array
     * @throws NullPointerException if data is null
     * @since 3.6
     */
    public static double[] unique(double[] data) {
<span class="fc" id="L1335">        TreeSet&lt;Double&gt; values = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L1336" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L1337">            values.add(data[i]);</span>
        }
<span class="fc" id="L1339">        final int count = values.size();</span>
<span class="fc" id="L1340">        final double[] out = new double[count];</span>
<span class="fc" id="L1341">        Iterator&lt;Double&gt; iterator = values.descendingIterator();</span>
<span class="fc" id="L1342">        int i = 0;</span>
<span class="fc bfc" id="L1343" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc" id="L1344">            out[i++] = iterator.next();</span>
        }
<span class="fc" id="L1346">        return out;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>