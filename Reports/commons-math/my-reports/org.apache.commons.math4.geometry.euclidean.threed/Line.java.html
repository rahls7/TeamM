<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Line.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.geometry.euclidean.threed</a> &gt; <span class="el_source">Line.java</span></div><h1>Line.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.geometry.euclidean.threed;

import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.exception.util.LocalizedFormats;
import org.apache.commons.math4.geometry.Point;
import org.apache.commons.math4.geometry.Vector;
import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
import org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D;
import org.apache.commons.math4.geometry.partitioning.Embedding;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.numbers.core.Precision;

/** The class represent lines in a three dimensional space.

 * &lt;p&gt;Each oriented line is intrinsically associated with an abscissa
 * which is a coordinate on the line. The point at abscissa 0 is the
 * orthogonal projection of the origin on the line, another equivalent
 * way to express this is to say that it is the point of the line
 * which is closest to the origin. Abscissa increases in the line
 * direction.&lt;/p&gt;

 * @since 3.0
 */
public class Line implements Embedding&lt;Euclidean3D, Euclidean1D&gt; {

    /** Line direction. */
    private Cartesian3D direction;

    /** Line point closest to the origin. */
    private Cartesian3D zero;

    /** Tolerance below which points are considered identical. */
    private final double tolerance;

    /** Build a line from two points.
     * @param p1 first point belonging to the line (this can be any point)
     * @param p2 second point belonging to the line (this can be any point, different from p1)
     * @param tolerance tolerance below which points are considered identical
     * @exception MathIllegalArgumentException if the points are equal
     * @since 3.3
     */
    public Line(final Cartesian3D p1, final Cartesian3D p2, final double tolerance)
<span class="fc" id="L60">        throws MathIllegalArgumentException {</span>
<span class="fc" id="L61">        reset(p1, p2);</span>
<span class="fc" id="L62">        this.tolerance = tolerance;</span>
<span class="fc" id="L63">    }</span>

    /** Copy constructor.
     * &lt;p&gt;The created instance is completely independent from the
     * original instance, it is a deep copy.&lt;/p&gt;
     * @param line line to copy
     */
<span class="fc" id="L70">    public Line(final Line line) {</span>
<span class="fc" id="L71">        this.direction = line.direction;</span>
<span class="fc" id="L72">        this.zero      = line.zero;</span>
<span class="fc" id="L73">        this.tolerance = line.tolerance;</span>
<span class="fc" id="L74">    }</span>

    /** Reset the instance as if built from two points.
     * @param p1 first point belonging to the line (this can be any point)
     * @param p2 second point belonging to the line (this can be any point, different from p1)
     * @exception MathIllegalArgumentException if the points are equal
     */
    public void reset(final Cartesian3D p1, final Cartesian3D p2) throws MathIllegalArgumentException {
<span class="fc" id="L82">        final Cartesian3D delta = p2.subtract(p1);</span>
<span class="fc" id="L83">        final double norm2 = delta.getNormSq();</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        if (norm2 == 0.0) {</span>
<span class="nc" id="L85">            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);</span>
        }
<span class="fc" id="L87">        this.direction = new Cartesian3D(1.0 / FastMath.sqrt(norm2), delta);</span>
<span class="fc" id="L88">        zero = new Cartesian3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);</span>
<span class="fc" id="L89">    }</span>

    /** Get the tolerance below which points are considered identical.
     * @return tolerance below which points are considered identical
     * @since 3.3
     */
    public double getTolerance() {
<span class="fc" id="L96">        return tolerance;</span>
    }

    /** Get a line with reversed direction.
     * @return a new instance, with reversed direction
     */
    public Line revert() {
<span class="fc" id="L103">        final Line reverted = new Line(this);</span>
<span class="fc" id="L104">        reverted.direction = reverted.direction.negate();</span>
<span class="fc" id="L105">        return reverted;</span>
    }

    /** Get the normalized direction vector.
     * @return normalized direction vector
     */
    public Cartesian3D getDirection() {
<span class="fc" id="L112">        return direction;</span>
    }

    /** Get the line point closest to the origin.
     * @return line point closest to the origin
     */
    public Cartesian3D getOrigin() {
<span class="nc" id="L119">        return zero;</span>
    }

    /** Get the abscissa of a point with respect to the line.
     * &lt;p&gt;The abscissa is 0 if the projection of the point and the
     * projection of the frame origin on the line are the same
     * point.&lt;/p&gt;
     * @param point point to check
     * @return abscissa of the point
     */
    public double getAbscissa(final Cartesian3D point) {
<span class="fc" id="L130">        return point.subtract(zero).dotProduct(direction);</span>
    }

    /** Get one point from the line.
     * @param abscissa desired abscissa for the point
     * @return one point belonging to the line, at specified abscissa
     */
    public Cartesian3D pointAt(final double abscissa) {
<span class="fc" id="L138">        return new Cartesian3D(1.0, zero, abscissa, direction);</span>
    }

    /** Transform a space point into a sub-space point.
     * @param vector n-dimension point of the space
     * @return (n-1)-dimension point of the sub-space corresponding to
     * the specified space point
     */
    public Cartesian1D toSubSpace(Vector&lt;Euclidean3D&gt; vector) {
<span class="nc" id="L147">        return toSubSpace((Point&lt;Euclidean3D&gt;) vector);</span>
    }

    /** Transform a sub-space point into a space point.
     * @param vector (n-1)-dimension point of the sub-space
     * @return n-dimension point of the space corresponding to the
     * specified sub-space point
     */
    public Cartesian3D toSpace(Vector&lt;Euclidean1D&gt; vector) {
<span class="nc" id="L156">        return toSpace((Point&lt;Euclidean1D&gt;) vector);</span>
    }

    /** {@inheritDoc}
     * @see #getAbscissa(Cartesian3D)
     */
    @Override
    public Cartesian1D toSubSpace(final Point&lt;Euclidean3D&gt; point) {
<span class="fc" id="L164">        return toSubSpace((Cartesian3D) point);</span>
    }

    /** {@inheritDoc}
     * @see #pointAt(double)
     */
    @Override
    public Cartesian3D toSpace(final Point&lt;Euclidean1D&gt; point) {
<span class="nc" id="L172">        return toSpace((Cartesian1D) point);</span>
    }

    /** Transform a space point into a sub-space point.
     * @param point n-dimension point of the space
     * @return (n-1)-dimension point of the sub-space corresponding to
     * the specified space point
     */
    public Cartesian1D toSubSpace(final Cartesian3D point) {
<span class="fc" id="L181">        return new Cartesian1D(getAbscissa(point));</span>
    }

    /** Transform a sub-space point into a space point.
     * @param point (n-1)-dimension point of the sub-space
     * @return n-dimension point of the space corresponding to the
     * specified sub-space point
     */
    public Cartesian3D toSpace(final Cartesian1D point) {
<span class="fc" id="L190">        return pointAt(point.getX());</span>
    }

    /** Check if the instance is similar to another line.
     * &lt;p&gt;Lines are considered similar if they contain the same
     * points. This does not mean they are equal since they can have
     * opposite directions.&lt;/p&gt;
     * @param line line to which instance should be compared
     * @return true if the lines are similar
     */
    public boolean isSimilarTo(final Line line) {
<span class="fc" id="L201">        final double angle = Cartesian3D.angle(direction, line.direction);</span>
<span class="pc bpc" id="L202" title="2 of 6 branches missed.">        return ((angle &lt; tolerance) || (angle &gt; (FastMath.PI - tolerance))) &amp;&amp; contains(line.zero);</span>
    }

    /** Check if the instance contains a point.
     * @param p point to check
     * @return true if p belongs to the line
     */
    public boolean contains(final Cartesian3D p) {
<span class="fc bfc" id="L210" title="All 2 branches covered.">        return distance(p) &lt; tolerance;</span>
    }

    /** Compute the distance between the instance and a point.
     * @param p to check
     * @return distance between the instance and the point
     */
    public double distance(final Cartesian3D p) {
<span class="fc" id="L218">        final Cartesian3D d = p.subtract(zero);</span>
<span class="fc" id="L219">        final Cartesian3D n = new Cartesian3D(1.0, d, -d.dotProduct(direction), direction);</span>
<span class="fc" id="L220">        return n.getNorm();</span>
    }

    /** Compute the shortest distance between the instance and another line.
     * @param line line to check against the instance
     * @return shortest distance between the instance and the line
     */
    public double distance(final Line line) {

<span class="fc" id="L229">        final Cartesian3D normal = Cartesian3D.crossProduct(direction, line.direction);</span>
<span class="fc" id="L230">        final double n = normal.getNorm();</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (n &lt; Precision.SAFE_MIN) {</span>
            // lines are parallel
<span class="fc" id="L233">            return distance(line.zero);</span>
        }

        // signed separation of the two parallel planes that contains the lines
<span class="fc" id="L237">        final double offset = line.zero.subtract(zero).dotProduct(normal) / n;</span>

<span class="fc" id="L239">        return FastMath.abs(offset);</span>

    }

    /** Compute the point of the instance closest to another line.
     * @param line line to check against the instance
     * @return point of the instance closest to another line
     */
    public Cartesian3D closestPoint(final Line line) {

<span class="fc" id="L249">        final double cos = direction.dotProduct(line.direction);</span>
<span class="fc" id="L250">        final double n = 1 - cos * cos;</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        if (n &lt; Precision.EPSILON) {</span>
            // the lines are parallel
<span class="nc" id="L253">            return zero;</span>
        }

<span class="fc" id="L256">        final Cartesian3D delta0 = line.zero.subtract(zero);</span>
<span class="fc" id="L257">        final double a        = delta0.dotProduct(direction);</span>
<span class="fc" id="L258">        final double b        = delta0.dotProduct(line.direction);</span>

<span class="fc" id="L260">        return new Cartesian3D(1, zero, (a - b * cos) / n, direction);</span>

    }

    /** Get the intersection point of the instance and another line.
     * @param line other line
     * @return intersection point of the instance and the other line
     * or null if there are no intersection points
     */
    public Cartesian3D intersection(final Line line) {
<span class="fc" id="L270">        final Cartesian3D closest = closestPoint(line);</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">        return line.contains(closest) ? closest : null;</span>
    }

    /** Build a sub-line covering the whole line.
     * @return a sub-line covering the whole line
     */
    public SubLine wholeLine() {
<span class="fc" id="L278">        return new SubLine(this, new IntervalsSet(tolerance));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>