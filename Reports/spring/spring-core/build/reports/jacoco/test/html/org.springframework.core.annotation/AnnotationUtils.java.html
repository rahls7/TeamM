<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AnnotationUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-core</a> &gt; <a href="index.source.html" class="el_package">org.springframework.core.annotation</a> &gt; <span class="el_source">AnnotationUtils.java</span></div><h1>AnnotationUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.annotation;

import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.function.Function;

import org.springframework.core.BridgeMethodResolver;
import org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets.MirrorSet;
import org.springframework.core.annotation.MergedAnnotation.MapValues;
import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;
import org.springframework.lang.Nullable;
import org.springframework.util.ConcurrentReferenceHashMap;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;

/**
 * General utility methods for working with annotations, handling meta-annotations,
 * bridge methods (which the compiler generates for generic declarations) as well
 * as super methods (for optional &lt;em&gt;annotation inheritance&lt;/em&gt;).
 *
 * &lt;p&gt;Note that most of the features of this class are not provided by the
 * JDK's introspection facilities themselves.
 *
 * &lt;p&gt;As a general rule for runtime-retained application annotations (e.g. for
 * transaction control, authorization, or service exposure), always use the
 * lookup methods on this class (e.g. {@link #findAnnotation(Method, Class)} or
 * {@link #getAnnotation(Method, Class)}) instead of the plain annotation lookup
 * methods in the JDK. You can still explicitly choose between a &lt;em&gt;get&lt;/em&gt;
 * lookup on the given class level only ({@link #getAnnotation(Method, Class)})
 * and a &lt;em&gt;find&lt;/em&gt; lookup in the entire inheritance hierarchy of the given
 * method ({@link #findAnnotation(Method, Class)}).
 *
 * &lt;h3&gt;Terminology&lt;/h3&gt;
 * The terms &lt;em&gt;directly present&lt;/em&gt;, &lt;em&gt;indirectly present&lt;/em&gt;, and
 * &lt;em&gt;present&lt;/em&gt; have the same meanings as defined in the class-level
 * javadoc for {@link AnnotatedElement} (in Java 8).
 *
 * &lt;p&gt;An annotation is &lt;em&gt;meta-present&lt;/em&gt; on an element if the annotation
 * is declared as a meta-annotation on some other annotation which is
 * &lt;em&gt;present&lt;/em&gt; on the element. Annotation {@code A} is &lt;em&gt;meta-present&lt;/em&gt;
 * on another annotation if {@code A} is either &lt;em&gt;directly present&lt;/em&gt; or
 * &lt;em&gt;meta-present&lt;/em&gt; on the other annotation.
 *
 * &lt;h3&gt;Meta-annotation Support&lt;/h3&gt;
 * &lt;p&gt;Most {@code find*()} methods and some {@code get*()} methods in this class
 * provide support for finding annotations used as meta-annotations. Consult the
 * javadoc for each method in this class for details. For fine-grained support for
 * meta-annotations with &lt;em&gt;attribute overrides&lt;/em&gt; in &lt;em&gt;composed annotations&lt;/em&gt;,
 * consider using {@link AnnotatedElementUtils}'s more specific methods instead.
 *
 * &lt;h3&gt;Attribute Aliases&lt;/h3&gt;
 * &lt;p&gt;All public methods in this class that return annotations, arrays of
 * annotations, or {@link AnnotationAttributes} transparently support attribute
 * aliases configured via {@link AliasFor @AliasFor}. Consult the various
 * {@code synthesizeAnnotation*(..)} methods for details.
 *
 * &lt;h3&gt;Search Scope&lt;/h3&gt;
 * &lt;p&gt;The search algorithms used by methods in this class stop searching for
 * an annotation once the first annotation of the specified type has been
 * found. As a consequence, additional annotations of the specified type will
 * be silently ignored.
 *
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @author Mark Fisher
 * @author Chris Beams
 * @author Phillip Webb
 * @author Oleg Zhurakousky
 * @since 2.0
 * @see AliasFor
 * @see AnnotationAttributes
 * @see AnnotatedElementUtils
 * @see BridgeMethodResolver
 * @see java.lang.reflect.AnnotatedElement#getAnnotations()
 * @see java.lang.reflect.AnnotatedElement#getAnnotation(Class)
 * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotations()
 */
<span class="nc" id="L106">public abstract class AnnotationUtils {</span>

	/**
	 * The attribute name for annotations with a single element.
	 */
	public static final String VALUE = MergedAnnotation.VALUE;

<span class="fc" id="L113">	private static final AnnotationFilter JAVA_LANG_ANNOTATION_FILTER =</span>
<span class="fc" id="L114">			AnnotationFilter.packages(&quot;java.lang.annotation&quot;);</span>

<span class="fc" id="L116">	private static Map&lt;Class&lt;? extends Annotation&gt;, Map&lt;String, DefaultValueHolder&gt;&gt; defaultValuesCache =</span>
			new ConcurrentReferenceHashMap&lt;&gt;();


	/**
	 * Determine whether the given class is a candidate for carrying one of the specified
	 * annotations (at type, method or field level).
	 * @param clazz the class to introspect
	 * @param annotationTypes the searchable annotation types
	 * @return {@code false} if the class is known to have no such annotations at any level;
	 * {@code true} otherwise. Callers will usually perform full method/field introspection
	 * if {@code true} is being returned here.
	 * @since 5.2
	 * @see #isCandidateClass(Class, Class)
	 */
	public static boolean isCandidateClass(Class&lt;?&gt; clazz, Collection&lt;Class&lt;? extends Annotation&gt;&gt; annotationTypes) {
<span class="nc bnc" id="L132" title="All 2 branches missed.">		for (Class&lt;? extends Annotation&gt; annotationType : annotationTypes) {</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">			if (isCandidateClass(clazz, annotationType)) {</span>
<span class="nc" id="L134">				return true;</span>
			}
<span class="nc" id="L136">		}</span>
<span class="nc" id="L137">		return false;</span>
	}

	/**
	 * Determine whether the given class is a candidate for carrying the specified annotation
	 * (at type, method or field level).
	 * @param clazz the class to introspect
	 * @param annotationType the searchable annotation type
	 * @return {@code false} if the class is known to have no such annotations at any level;
	 * {@code true} otherwise. Callers will usually perform full method/field introspection
	 * if {@code true} is being returned here.
	 * @since 5.2
	 * @see #isCandidateClass(Class, String)
	 */
	public static boolean isCandidateClass(Class&lt;?&gt; clazz, Class&lt;? extends Annotation&gt; annotationType) {
<span class="nc" id="L152">		return isCandidateClass(clazz, annotationType.getName());</span>
	}

	/**
	 * Determine whether the given class is a candidate for carrying the specified annotation
	 * (at type, method or field level).
	 * @param clazz the class to introspect
	 * @param annotationName the fully-qualified name of the searchable annotation type
	 * @return {@code false} if the class is known to have no such annotations at any level;
	 * {@code true} otherwise. Callers will usually perform full method/field introspection
	 * if {@code true} is being returned here.
	 * @since 5.2
	 */
	public static boolean isCandidateClass(Class&lt;?&gt; clazz, String annotationName) {
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">		return !clazz.getName().startsWith(&quot;java&quot;);</span>
	}

	/**
	 * Get a single {@link Annotation} of {@code annotationType} from the supplied
	 * annotation: either the given annotation itself or a direct meta-annotation
	 * thereof.
	 * &lt;p&gt;Note that this method supports only a single level of meta-annotations.
	 * For support for arbitrary levels of meta-annotations, use one of the
	 * {@code find*()} methods instead.
	 * @param annotation the Annotation to check
	 * @param annotationType the annotation type to look for, both locally and as a meta-annotation
	 * @return the first matching annotation, or {@code null} if not found
	 * @since 4.0
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	@Nullable
	public static &lt;A extends Annotation&gt; A getAnnotation(Annotation annotation, Class&lt;A&gt; annotationType) {
		// Shortcut: directly present on the element, with no merging needed?
<span class="nc bnc" id="L185" title="All 2 branches missed.">		if (annotationType.isInstance(annotation)) {</span>
<span class="nc" id="L186">			return synthesizeAnnotation((A) annotation, annotationType);</span>
		}
		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...
<span class="nc bnc" id="L189" title="All 2 branches missed.">		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotation)) {</span>
<span class="nc" id="L190">			return null;</span>
		}
		// Exhaustive retrieval of merged annotations...
<span class="nc" id="L193">		return MergedAnnotations.from(annotation)</span>
<span class="nc" id="L194">				.get(annotationType).withNonMergedAttributes()</span>
<span class="nc" id="L195">				.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);</span>
	}

	/**
	 * Get a single {@link Annotation} of {@code annotationType} from the supplied
	 * {@link AnnotatedElement}, where the annotation is either &lt;em&gt;present&lt;/em&gt; or
	 * &lt;em&gt;meta-present&lt;/em&gt; on the {@code AnnotatedElement}.
	 * &lt;p&gt;Note that this method supports only a single level of meta-annotations.
	 * For support for arbitrary levels of meta-annotations, use
	 * {@link #findAnnotation(AnnotatedElement, Class)} instead.
	 * @param annotatedElement the {@code AnnotatedElement} from which to get the annotation
	 * @param annotationType the annotation type to look for, both locally and as a meta-annotation
	 * @return the first matching annotation, or {@code null} if not found
	 * @since 3.1
	 */
	@Nullable
	public static &lt;A extends Annotation&gt; A getAnnotation(AnnotatedElement annotatedElement, Class&lt;A&gt; annotationType) {
		// Shortcut: directly present on the element, with no merging needed?
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">		if (AnnotationFilter.PLAIN.matches(annotationType)) {</span>
<span class="nc" id="L214">			return annotatedElement.getAnnotation(annotationType);</span>
		}
		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {</span>
<span class="nc" id="L218">			return null;</span>
		}
		// Exhaustive retrieval of merged annotations...
<span class="fc" id="L221">		return MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS,</span>
<span class="fc" id="L222">						RepeatableContainers.none(), AnnotationFilter.PLAIN)</span>
<span class="fc" id="L223">				.get(annotationType).withNonMergedAttributes()</span>
<span class="fc" id="L224">				.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);</span>
	}

	private static &lt;A extends Annotation&gt; boolean isSingleLevelPresent(MergedAnnotation&lt;A&gt; mergedAnnotation) {
<span class="fc" id="L228">		int depth = mergedAnnotation.getDepth();</span>
<span class="fc bfc" id="L229" title="All 4 branches covered.">		return (depth == 0 || depth == 1);</span>
	}

	/**
	 * Get a single {@link Annotation} of {@code annotationType} from the
	 * supplied {@link Method}, where the annotation is either &lt;em&gt;present&lt;/em&gt;
	 * or &lt;em&gt;meta-present&lt;/em&gt; on the method.
	 * &lt;p&gt;Correctly handles bridge {@link Method Methods} generated by the compiler.
	 * &lt;p&gt;Note that this method supports only a single level of meta-annotations.
	 * For support for arbitrary levels of meta-annotations, use
	 * {@link #findAnnotation(Method, Class)} instead.
	 * @param method the method to look for annotations on
	 * @param annotationType the annotation type to look for
	 * @return the first matching annotation, or {@code null} if not found
	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)
	 * @see #getAnnotation(AnnotatedElement, Class)
	 */
	@Nullable
	public static &lt;A extends Annotation&gt; A getAnnotation(Method method, Class&lt;A&gt; annotationType) {
<span class="fc" id="L248">		Method resolvedMethod = BridgeMethodResolver.findBridgedMethod(method);</span>
<span class="fc" id="L249">		return getAnnotation((AnnotatedElement) resolvedMethod, annotationType);</span>
	}

	/**
	 * Get all {@link Annotation Annotations} that are &lt;em&gt;present&lt;/em&gt; on the
	 * supplied {@link AnnotatedElement}.
	 * &lt;p&gt;Meta-annotations will &lt;em&gt;not&lt;/em&gt; be searched.
	 * @param annotatedElement the Method, Constructor or Field to retrieve annotations from
	 * @return the annotations found, an empty array, or {@code null} if not
	 * resolvable (e.g. because nested Class values in annotation attributes
	 * failed to resolve at runtime)
	 * @since 4.0.8
	 * @see AnnotatedElement#getAnnotations()
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	@Deprecated
	@Nullable
	public static Annotation[] getAnnotations(AnnotatedElement annotatedElement) {
		try {
<span class="nc" id="L268">			return synthesizeAnnotationArray(annotatedElement.getAnnotations(), annotatedElement);</span>
		}
<span class="nc" id="L270">		catch (Throwable ex) {</span>
<span class="nc" id="L271">			handleIntrospectionFailure(annotatedElement, ex);</span>
<span class="nc" id="L272">			return null;</span>
		}
	}

	/**
	 * Get all {@link Annotation Annotations} that are &lt;em&gt;present&lt;/em&gt; on the
	 * supplied {@link Method}.
	 * &lt;p&gt;Correctly handles bridge {@link Method Methods} generated by the compiler.
	 * &lt;p&gt;Meta-annotations will &lt;em&gt;not&lt;/em&gt; be searched.
	 * @param method the Method to retrieve annotations from
	 * @return the annotations found, an empty array, or {@code null} if not
	 * resolvable (e.g. because nested Class values in annotation attributes
	 * failed to resolve at runtime)
	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)
	 * @see AnnotatedElement#getAnnotations()
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	@Deprecated
	@Nullable
	public static Annotation[] getAnnotations(Method method) {
		try {
<span class="nc" id="L293">			return synthesizeAnnotationArray(BridgeMethodResolver.findBridgedMethod(method).getAnnotations(), method);</span>
		}
<span class="nc" id="L295">		catch (Throwable ex) {</span>
<span class="nc" id="L296">			handleIntrospectionFailure(method, ex);</span>
<span class="nc" id="L297">			return null;</span>
		}
	}

	/**
	 * Get the &lt;em&gt;repeatable&lt;/em&gt; {@linkplain Annotation annotations} of
	 * {@code annotationType} from the supplied {@link AnnotatedElement}, where
	 * such annotations are either &lt;em&gt;present&lt;/em&gt;, &lt;em&gt;indirectly present&lt;/em&gt;,
	 * or &lt;em&gt;meta-present&lt;/em&gt; on the element.
	 * &lt;p&gt;This method mimics the functionality of Java 8's
	 * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}
	 * with support for automatic detection of a &lt;em&gt;container annotation&lt;/em&gt;
	 * declared via @{@link java.lang.annotation.Repeatable} (when running on
	 * Java 8 or higher) and with additional support for meta-annotations.
	 * &lt;p&gt;Handles both single annotations and annotations nested within a
	 * &lt;em&gt;container annotation&lt;/em&gt;.
	 * &lt;p&gt;Correctly handles &lt;em&gt;bridge methods&lt;/em&gt; generated by the
	 * compiler if the supplied element is a {@link Method}.
	 * &lt;p&gt;Meta-annotations will be searched if the annotation is not
	 * &lt;em&gt;present&lt;/em&gt; on the supplied element.
	 * @param annotatedElement the element to look for annotations on
	 * @param annotationType the annotation type to look for
	 * @return the annotations found or an empty set (never {@code null})
	 * @since 4.2
	 * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)
	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod
	 * @see java.lang.annotation.Repeatable
	 * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	@Deprecated
	public static &lt;A extends Annotation&gt; Set&lt;A&gt; getRepeatableAnnotations(AnnotatedElement annotatedElement,
			Class&lt;A&gt; annotationType) {

<span class="fc" id="L333">		return getRepeatableAnnotations(annotatedElement, annotationType, null);</span>
	}

	/**
	 * Get the &lt;em&gt;repeatable&lt;/em&gt; {@linkplain Annotation annotations} of
	 * {@code annotationType} from the supplied {@link AnnotatedElement}, where
	 * such annotations are either &lt;em&gt;present&lt;/em&gt;, &lt;em&gt;indirectly present&lt;/em&gt;,
	 * or &lt;em&gt;meta-present&lt;/em&gt; on the element.
	 * &lt;p&gt;This method mimics the functionality of Java 8's
	 * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}
	 * with additional support for meta-annotations.
	 * &lt;p&gt;Handles both single annotations and annotations nested within a
	 * &lt;em&gt;container annotation&lt;/em&gt;.
	 * &lt;p&gt;Correctly handles &lt;em&gt;bridge methods&lt;/em&gt; generated by the
	 * compiler if the supplied element is a {@link Method}.
	 * &lt;p&gt;Meta-annotations will be searched if the annotation is not
	 * &lt;em&gt;present&lt;/em&gt; on the supplied element.
	 * @param annotatedElement the element to look for annotations on
	 * @param annotationType the annotation type to look for
	 * @param containerAnnotationType the type of the container that holds
	 * the annotations; may be {@code null} if a container is not supported
	 * or if it should be looked up via @{@link java.lang.annotation.Repeatable}
	 * when running on Java 8 or higher
	 * @return the annotations found or an empty set (never {@code null})
	 * @since 4.2
	 * @see #getRepeatableAnnotations(AnnotatedElement, Class)
	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)
	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod
	 * @see java.lang.annotation.Repeatable
	 * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	@Deprecated
	public static &lt;A extends Annotation&gt; Set&lt;A&gt; getRepeatableAnnotations(AnnotatedElement annotatedElement,
			Class&lt;A&gt; annotationType, @Nullable Class&lt;? extends Annotation&gt; containerAnnotationType) {

<span class="fc bfc" id="L371" title="All 2 branches covered.">		RepeatableContainers repeatableContainers = (containerAnnotationType != null ?</span>
<span class="fc" id="L372">				RepeatableContainers.of(annotationType, containerAnnotationType) :</span>
<span class="fc" id="L373">				RepeatableContainers.standardRepeatables());</span>
<span class="fc" id="L374">		return MergedAnnotations.from(annotatedElement, SearchStrategy.SUPER_CLASS,</span>
						repeatableContainers, AnnotationFilter.PLAIN)
<span class="fc" id="L376">				.stream(annotationType)</span>
<span class="fc" id="L377">				.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))</span>
<span class="fc" id="L378">				.map(MergedAnnotation::withNonMergedAttributes)</span>
<span class="fc" id="L379">				.collect(MergedAnnotationCollectors.toAnnotationSet());</span>
	}

	/**
	 * Get the declared &lt;em&gt;repeatable&lt;/em&gt; {@linkplain Annotation annotations}
	 * of {@code annotationType} from the supplied {@link AnnotatedElement},
	 * where such annotations are either &lt;em&gt;directly present&lt;/em&gt;,
	 * &lt;em&gt;indirectly present&lt;/em&gt;, or &lt;em&gt;meta-present&lt;/em&gt; on the element.
	 * &lt;p&gt;This method mimics the functionality of Java 8's
	 * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}
	 * with support for automatic detection of a &lt;em&gt;container annotation&lt;/em&gt;
	 * declared via @{@link java.lang.annotation.Repeatable} (when running on
	 * Java 8 or higher) and with additional support for meta-annotations.
	 * &lt;p&gt;Handles both single annotations and annotations nested within a
	 * &lt;em&gt;container annotation&lt;/em&gt;.
	 * &lt;p&gt;Correctly handles &lt;em&gt;bridge methods&lt;/em&gt; generated by the
	 * compiler if the supplied element is a {@link Method}.
	 * &lt;p&gt;Meta-annotations will be searched if the annotation is not
	 * &lt;em&gt;present&lt;/em&gt; on the supplied element.
	 * @param annotatedElement the element to look for annotations on
	 * @param annotationType the annotation type to look for
	 * @return the annotations found or an empty set (never {@code null})
	 * @since 4.2
	 * @see #getRepeatableAnnotations(AnnotatedElement, Class)
	 * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)
	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod
	 * @see java.lang.annotation.Repeatable
	 * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	@Deprecated
	public static &lt;A extends Annotation&gt; Set&lt;A&gt; getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,
			Class&lt;A&gt; annotationType) {

<span class="fc" id="L415">		return getDeclaredRepeatableAnnotations(annotatedElement, annotationType, null);</span>
	}

	/**
	 * Get the declared &lt;em&gt;repeatable&lt;/em&gt; {@linkplain Annotation annotations}
	 * of {@code annotationType} from the supplied {@link AnnotatedElement},
	 * where such annotations are either &lt;em&gt;directly present&lt;/em&gt;,
	 * &lt;em&gt;indirectly present&lt;/em&gt;, or &lt;em&gt;meta-present&lt;/em&gt; on the element.
	 * &lt;p&gt;This method mimics the functionality of Java 8's
	 * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}
	 * with additional support for meta-annotations.
	 * &lt;p&gt;Handles both single annotations and annotations nested within a
	 * &lt;em&gt;container annotation&lt;/em&gt;.
	 * &lt;p&gt;Correctly handles &lt;em&gt;bridge methods&lt;/em&gt; generated by the
	 * compiler if the supplied element is a {@link Method}.
	 * &lt;p&gt;Meta-annotations will be searched if the annotation is not
	 * &lt;em&gt;present&lt;/em&gt; on the supplied element.
	 * @param annotatedElement the element to look for annotations on
	 * @param annotationType the annotation type to look for
	 * @param containerAnnotationType the type of the container that holds
	 * the annotations; may be {@code null} if a container is not supported
	 * or if it should be looked up via @{@link java.lang.annotation.Repeatable}
	 * when running on Java 8 or higher
	 * @return the annotations found or an empty set (never {@code null})
	 * @since 4.2
	 * @see #getRepeatableAnnotations(AnnotatedElement, Class)
	 * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)
	 * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod
	 * @see java.lang.annotation.Repeatable
	 * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	@Deprecated
	public static &lt;A extends Annotation&gt; Set&lt;A&gt; getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,
			Class&lt;A&gt; annotationType, @Nullable Class&lt;? extends Annotation&gt; containerAnnotationType) {

<span class="fc bfc" id="L453" title="All 2 branches covered.">		RepeatableContainers repeatableContainers = containerAnnotationType != null ?</span>
<span class="fc" id="L454">				RepeatableContainers.of(annotationType, containerAnnotationType) :</span>
<span class="fc" id="L455">				RepeatableContainers.standardRepeatables();</span>
<span class="fc" id="L456">		return MergedAnnotations.from(annotatedElement, SearchStrategy.DIRECT,</span>
<span class="fc" id="L457">						repeatableContainers, AnnotationFilter.PLAIN).stream(annotationType)</span>
<span class="fc" id="L458">				.map(MergedAnnotation::withNonMergedAttributes)</span>
<span class="fc" id="L459">				.collect(MergedAnnotationCollectors.toAnnotationSet());</span>
	}

	/**
	 * Find a single {@link Annotation} of {@code annotationType} on the
	 * supplied {@link AnnotatedElement}.
	 * &lt;p&gt;Meta-annotations will be searched if the annotation is not
	 * &lt;em&gt;directly present&lt;/em&gt; on the supplied element.
	 * &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: this method operates generically on
	 * annotated elements. In other words, this method does not execute
	 * specialized search algorithms for classes or methods. If you require
	 * the more specific semantics of {@link #findAnnotation(Class, Class)}
	 * or {@link #findAnnotation(Method, Class)}, invoke one of those methods
	 * instead.
	 * @param annotatedElement the {@code AnnotatedElement} on which to find the annotation
	 * @param annotationType the annotation type to look for, both locally and as a meta-annotation
	 * @return the first matching annotation, or {@code null} if not found
	 * @since 4.2
	 */
	@Nullable
	public static &lt;A extends Annotation&gt; A findAnnotation(
			AnnotatedElement annotatedElement, @Nullable Class&lt;A&gt; annotationType) {

<span class="nc bnc" id="L482" title="All 2 branches missed.">		if (annotationType == null) {</span>
<span class="nc" id="L483">			return null;</span>
		}
		// Shortcut: directly present on the element, with no merging needed?
<span class="nc bnc" id="L486" title="All 2 branches missed.">		if (AnnotationFilter.PLAIN.matches(annotationType)) {</span>
<span class="nc" id="L487">			return annotatedElement.getDeclaredAnnotation(annotationType);</span>
		}
		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...
<span class="nc bnc" id="L490" title="All 2 branches missed.">		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {</span>
<span class="nc" id="L491">			return null;</span>
		}
		// Exhaustive retrieval of merged annotations...
<span class="nc" id="L494">		return MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS)</span>
<span class="nc" id="L495">				.get(annotationType).withNonMergedAttributes()</span>
<span class="nc" id="L496">				.synthesize(MergedAnnotation::isPresent).orElse(null);</span>
	}

	/**
	 * Find a single {@link Annotation} of {@code annotationType} on the supplied
	 * {@link Method}, traversing its super methods (i.e. from superclasses and
	 * interfaces) if the annotation is not &lt;em&gt;directly present&lt;/em&gt; on the given
	 * method itself.
	 * &lt;p&gt;Correctly handles bridge {@link Method Methods} generated by the compiler.
	 * &lt;p&gt;Meta-annotations will be searched if the annotation is not
	 * &lt;em&gt;directly present&lt;/em&gt; on the method.
	 * &lt;p&gt;Annotations on methods are not inherited by default, so we need to handle
	 * this explicitly.
	 * @param method the method to look for annotations on
	 * @param annotationType the annotation type to look for
	 * @return the first matching annotation, or {@code null} if not found
	 * @see #getAnnotation(Method, Class)
	 */
	@Nullable
	public static &lt;A extends Annotation&gt; A findAnnotation(Method method, @Nullable Class&lt;A&gt; annotationType) {
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">		if (annotationType == null) {</span>
<span class="nc" id="L517">			return null;</span>
		}
		// Shortcut: directly present on the element, with no merging needed?
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">		if (AnnotationFilter.PLAIN.matches(annotationType)) {</span>
<span class="nc" id="L521">			return method.getDeclaredAnnotation(annotationType);</span>
		}
		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {</span>
<span class="nc" id="L525">			return null;</span>
		}
		// Exhaustive retrieval of merged annotations...
<span class="fc" id="L528">		return MergedAnnotations.from(method, SearchStrategy.EXHAUSTIVE)</span>
<span class="fc" id="L529">				.get(annotationType).withNonMergedAttributes()</span>
<span class="fc" id="L530">				.synthesize(MergedAnnotation::isPresent).orElse(null);</span>
	}

	/**
	 * Find a single {@link Annotation} of {@code annotationType} on the
	 * supplied {@link Class}, traversing its interfaces, annotations, and
	 * superclasses if the annotation is not &lt;em&gt;directly present&lt;/em&gt; on
	 * the given class itself.
	 * &lt;p&gt;This method explicitly handles class-level annotations which are not
	 * declared as {@link java.lang.annotation.Inherited inherited} &lt;em&gt;as well
	 * as meta-annotations and annotations on interfaces&lt;/em&gt;.
	 * &lt;p&gt;The algorithm operates as follows:
	 * &lt;ol&gt;
	 * &lt;li&gt;Search for the annotation on the given class and return it if found.
	 * &lt;li&gt;Recursively search through all annotations that the given class declares.
	 * &lt;li&gt;Recursively search through all interfaces that the given class declares.
	 * &lt;li&gt;Recursively search through the superclass hierarchy of the given class.
	 * &lt;/ol&gt;
	 * &lt;p&gt;Note: in this context, the term &lt;em&gt;recursively&lt;/em&gt; means that the search
	 * process continues by returning to step #1 with the current interface,
	 * annotation, or superclass as the class to look for annotations on.
	 * @param clazz the class to look for annotations on
	 * @param annotationType the type of annotation to look for
	 * @return the first matching annotation, or {@code null} if not found
	 */
	@Nullable
	public static &lt;A extends Annotation&gt; A findAnnotation(Class&lt;?&gt; clazz, @Nullable Class&lt;A&gt; annotationType) {
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">		if (annotationType == null) {</span>
<span class="nc" id="L558">			return null;</span>
		}
		// Shortcut: directly present on the element, with no merging needed?
<span class="fc bfc" id="L561" title="All 2 branches covered.">		if (AnnotationFilter.PLAIN.matches(annotationType)) {</span>
<span class="fc" id="L562">			return clazz.getDeclaredAnnotation(annotationType);</span>
		}
		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {</span>
<span class="nc" id="L566">			return null;</span>
		}
		// Exhaustive retrieval of merged annotations...
<span class="fc" id="L569">		return MergedAnnotations.from(clazz, SearchStrategy.EXHAUSTIVE)</span>
<span class="fc" id="L570">				.get(annotationType).withNonMergedAttributes()</span>
<span class="fc" id="L571">				.synthesize(MergedAnnotation::isPresent).orElse(null);</span>
	}

	/**
	 * Find the first {@link Class} in the inheritance hierarchy of the
	 * specified {@code clazz} (including the specified {@code clazz} itself)
	 * on which an annotation of the specified {@code annotationType} is
	 * &lt;em&gt;directly present&lt;/em&gt;.
	 * &lt;p&gt;If the supplied {@code clazz} is an interface, only the interface
	 * itself will be checked; the inheritance hierarchy for interfaces will
	 * not be traversed.
	 * &lt;p&gt;Meta-annotations will &lt;em&gt;not&lt;/em&gt; be searched.
	 * &lt;p&gt;The standard {@link Class} API does not provide a mechanism for
	 * determining which class in an inheritance hierarchy actually declares
	 * an {@link Annotation}, so we need to handle this explicitly.
	 * @param annotationType the annotation type to look for
	 * @param clazz the class to check for the annotation on (may be {@code null})
	 * @return the first {@link Class} in the inheritance hierarchy that
	 * declares an annotation of the specified {@code annotationType},
	 * or {@code null} if not found
	 * @see Class#isAnnotationPresent(Class)
	 * @see Class#getDeclaredAnnotations()
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	@Deprecated
	@Nullable
	public static Class&lt;?&gt; findAnnotationDeclaringClass(
			Class&lt;? extends Annotation&gt; annotationType, @Nullable Class&lt;?&gt; clazz) {

<span class="pc bpc" id="L600" title="1 of 2 branches missed.">		if (clazz == null) {</span>
<span class="nc" id="L601">			return null;</span>
		}

<span class="fc" id="L604">		return (Class&lt;?&gt;) MergedAnnotations.from(clazz, SearchStrategy.SUPER_CLASS)</span>
<span class="fc" id="L605">				.get(annotationType, MergedAnnotation::isDirectlyPresent)</span>
<span class="fc" id="L606">				.getSource();</span>
	}

	/**
	 * Find the first {@link Class} in the inheritance hierarchy of the
	 * specified {@code clazz} (including the specified {@code clazz} itself)
	 * on which at least one of the specified {@code annotationTypes} is
	 * &lt;em&gt;directly present&lt;/em&gt;.
	 * &lt;p&gt;If the supplied {@code clazz} is an interface, only the interface
	 * itself will be checked; the inheritance hierarchy for interfaces will
	 * not be traversed.
	 * &lt;p&gt;Meta-annotations will &lt;em&gt;not&lt;/em&gt; be searched.
	 * &lt;p&gt;The standard {@link Class} API does not provide a mechanism for
	 * determining which class in an inheritance hierarchy actually declares
	 * one of several candidate {@linkplain Annotation annotations}, so we
	 * need to handle this explicitly.
	 * @param annotationTypes the annotation types to look for
	 * @param clazz the class to check for the annotation on (may be {@code null})
	 * @return the first {@link Class} in the inheritance hierarchy that
	 * declares an annotation of at least one of the specified
	 * {@code annotationTypes}, or {@code null} if not found
	 * @since 3.2.2
	 * @see Class#isAnnotationPresent(Class)
	 * @see Class#getDeclaredAnnotations()
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	@Deprecated
	@Nullable
	public static Class&lt;?&gt; findAnnotationDeclaringClassForTypes(
			List&lt;Class&lt;? extends Annotation&gt;&gt; annotationTypes, @Nullable Class&lt;?&gt; clazz) {

<span class="pc bpc" id="L637" title="1 of 2 branches missed.">		if (clazz == null) {</span>
<span class="nc" id="L638">			return null;</span>
		}

<span class="fc" id="L641">		return (Class&lt;?&gt;) MergedAnnotations.from(clazz, SearchStrategy.SUPER_CLASS)</span>
<span class="fc" id="L642">				.stream()</span>
<span class="fc" id="L643">				.filter(MergedAnnotationPredicates.typeIn(annotationTypes).and(MergedAnnotation::isDirectlyPresent))</span>
<span class="fc" id="L644">				.map(MergedAnnotation::getSource)</span>
<span class="fc" id="L645">				.findFirst().orElse(null);</span>
	}

	/**
	 * Determine whether an annotation of the specified {@code annotationType}
	 * is declared locally (i.e. &lt;em&gt;directly present&lt;/em&gt;) on the supplied
	 * {@code clazz}.
	 * &lt;p&gt;The supplied {@link Class} may represent any type.
	 * &lt;p&gt;Meta-annotations will &lt;em&gt;not&lt;/em&gt; be searched.
	 * &lt;p&gt;Note: This method does &lt;strong&gt;not&lt;/strong&gt; determine if the annotation
	 * is {@linkplain java.lang.annotation.Inherited inherited}.
	 * @param annotationType the annotation type to look for
	 * @param clazz the class to check for the annotation on
	 * @return {@code true} if an annotation of the specified {@code annotationType}
	 * is &lt;em&gt;directly present&lt;/em&gt;
	 * @see java.lang.Class#getDeclaredAnnotations()
	 * @see java.lang.Class#getDeclaredAnnotation(Class)
	 */
	public static boolean isAnnotationDeclaredLocally(Class&lt;? extends Annotation&gt; annotationType, Class&lt;?&gt; clazz) {
<span class="fc" id="L664">		return MergedAnnotations.from(clazz).get(annotationType).isDirectlyPresent();</span>
	}

	/**
	 * Determine whether an annotation of the specified {@code annotationType}
	 * is &lt;em&gt;present&lt;/em&gt; on the supplied {@code clazz} and is
	 * {@linkplain java.lang.annotation.Inherited inherited}
	 * (i.e. not &lt;em&gt;directly present&lt;/em&gt;).
	 * &lt;p&gt;Meta-annotations will &lt;em&gt;not&lt;/em&gt; be searched.
	 * &lt;p&gt;If the supplied {@code clazz} is an interface, only the interface
	 * itself will be checked. In accordance with standard meta-annotation
	 * semantics in Java, the inheritance hierarchy for interfaces will not
	 * be traversed. See the {@linkplain java.lang.annotation.Inherited javadoc}
	 * for the {@code @Inherited} meta-annotation for further details regarding
	 * annotation inheritance.
	 * @param annotationType the annotation type to look for
	 * @param clazz the class to check for the annotation on
	 * @return {@code true} if an annotation of the specified {@code annotationType}
	 * is &lt;em&gt;present&lt;/em&gt; and &lt;em&gt;inherited&lt;/em&gt;
	 * @see Class#isAnnotationPresent(Class)
	 * @see #isAnnotationDeclaredLocally(Class, Class)
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	@Deprecated
	public static boolean isAnnotationInherited(Class&lt;? extends Annotation&gt; annotationType, Class&lt;?&gt; clazz) {
<span class="fc" id="L689">		return MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS)</span>
<span class="fc" id="L690">				.stream(annotationType)</span>
<span class="fc" id="L691">				.filter(MergedAnnotation::isDirectlyPresent)</span>
<span class="fc" id="L692">				.findFirst().orElseGet(MergedAnnotation::missing)</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">				.getAggregateIndex() &gt; 0;</span>
	}

	/**
	 * Determine if an annotation of type {@code metaAnnotationType} is
	 * &lt;em&gt;meta-present&lt;/em&gt; on the supplied {@code annotationType}.
	 * @param annotationType the annotation type to search on
	 * @param metaAnnotationType the type of meta-annotation to search for
	 * @return {@code true} if such an annotation is meta-present
	 * @since 4.2.1
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	@Deprecated
	public static boolean isAnnotationMetaPresent(Class&lt;? extends Annotation&gt; annotationType,
			@Nullable Class&lt;? extends Annotation&gt; metaAnnotationType) {

<span class="pc bpc" id="L709" title="1 of 2 branches missed.">		if (metaAnnotationType == null) {</span>
<span class="nc" id="L710">			return false;</span>
		}
		// Shortcut: directly present on the element, with no merging needed?
<span class="fc bfc" id="L713" title="All 2 branches covered.">		if (AnnotationFilter.PLAIN.matches(annotationType) ||</span>
<span class="pc bpc" id="L714" title="1 of 2 branches missed.">				AnnotationFilter.PLAIN.matches(metaAnnotationType)) {</span>
<span class="fc" id="L715">			return annotationType.isAnnotationPresent(metaAnnotationType);</span>
		}
		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...
<span class="nc bnc" id="L718" title="All 2 branches missed.">		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotationType)) {</span>
<span class="nc" id="L719">			return false;</span>
		}
		// Exhaustive retrieval of merged annotations...
<span class="nc" id="L722">		return (MergedAnnotations.from(</span>
<span class="nc" id="L723">				annotationType, SearchStrategy.INHERITED_ANNOTATIONS).isPresent(metaAnnotationType));</span>
	}

	/**
	 * Determine if the supplied {@link Annotation} is defined in the core JDK
	 * {@code java.lang.annotation} package.
	 * @param annotation the annotation to check
	 * @return {@code true} if the annotation is in the {@code java.lang.annotation} package
	 */
	public static boolean isInJavaLangAnnotationPackage(@Nullable Annotation annotation) {
<span class="nc bnc" id="L733" title="All 4 branches missed.">		return (annotation != null &amp;&amp; JAVA_LANG_ANNOTATION_FILTER.matches(annotation));</span>
	}

	/**
	 * Determine if the {@link Annotation} with the supplied name is defined
	 * in the core JDK {@code java.lang.annotation} package.
	 * @param annotationType the name of the annotation type to check
	 * @return {@code true} if the annotation is in the {@code java.lang.annotation} package
	 * @since 4.2
	 */
	public static boolean isInJavaLangAnnotationPackage(@Nullable String annotationType) {
<span class="pc bpc" id="L744" title="1 of 4 branches missed.">		return (annotationType != null &amp;&amp; JAVA_LANG_ANNOTATION_FILTER.matches(annotationType));</span>
	}

	/**
	 * Check the declared attributes of the given annotation, in particular covering
	 * Google App Engine's late arrival of {@code TypeNotPresentExceptionProxy} for
	 * {@code Class} values (instead of early {@code Class.getAnnotations() failure}.
	 * &lt;p&gt;This method not failing indicates that {@link #getAnnotationAttributes(Annotation)}
	 * won't failure either (when attempted later on).
	 * @param annotation the annotation to validate
	 * @throws IllegalStateException if a declared {@code Class} attribute could not be read
	 * @since 4.3.15
	 * @see Class#getAnnotations()
	 * @see #getAnnotationAttributes(Annotation)
	 */
	public static void validateAnnotation(Annotation annotation) {
<span class="nc" id="L760">		AttributeMethods.forAnnotationType(annotation.annotationType()).validate(annotation);</span>
<span class="nc" id="L761">	}</span>

	/**
	 * Retrieve the given annotation's attributes as a {@link Map}, preserving all
	 * attribute types.
	 * &lt;p&gt;Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}
	 * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters
	 * set to {@code false}.
	 * &lt;p&gt;Note: This method actually returns an {@link AnnotationAttributes} instance.
	 * However, the {@code Map} signature has been preserved for binary compatibility.
	 * @param annotation the annotation to retrieve the attributes for
	 * @return the Map of annotation attributes, with attribute names as keys and
	 * corresponding attribute values as values (never {@code null})
	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation)
	 * @see #getAnnotationAttributes(Annotation, boolean, boolean)
	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)
	 */
	public static Map&lt;String, Object&gt; getAnnotationAttributes(Annotation annotation) {
<span class="fc" id="L779">		return getAnnotationAttributes(null, annotation);</span>
	}

	/**
	 * Retrieve the given annotation's attributes as a {@link Map}.
	 * &lt;p&gt;Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}
	 * with the {@code nestedAnnotationsAsMap} parameter set to {@code false}.
	 * &lt;p&gt;Note: This method actually returns an {@link AnnotationAttributes} instance.
	 * However, the {@code Map} signature has been preserved for binary compatibility.
	 * @param annotation the annotation to retrieve the attributes for
	 * @param classValuesAsString whether to convert Class references into Strings (for
	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata})
	 * or to preserve them as Class references
	 * @return the Map of annotation attributes, with attribute names as keys and
	 * corresponding attribute values as values (never {@code null})
	 * @see #getAnnotationAttributes(Annotation, boolean, boolean)
	 */
	public static Map&lt;String, Object&gt; getAnnotationAttributes(
			Annotation annotation, boolean classValuesAsString) {

<span class="nc" id="L799">		return getAnnotationAttributes(annotation, classValuesAsString, false);</span>
	}

	/**
	 * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.
	 * &lt;p&gt;This method provides fully recursive annotation reading capabilities on par with
	 * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.
	 * @param annotation the annotation to retrieve the attributes for
	 * @param classValuesAsString whether to convert Class references into Strings (for
	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata})
	 * or to preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested annotations into
	 * {@link AnnotationAttributes} maps (for compatibility with
	 * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as
	 * {@code Annotation} instances
	 * @return the annotation attributes (a specialized Map) with attribute names as keys
	 * and corresponding attribute values as values (never {@code null})
	 * @since 3.1.1
	 */
	public static AnnotationAttributes getAnnotationAttributes(
			Annotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {

<span class="fc" id="L821">		return getAnnotationAttributes(null, annotation, classValuesAsString, nestedAnnotationsAsMap);</span>
	}

	/**
	 * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.
	 * &lt;p&gt;Equivalent to calling {@link #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)}
	 * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters
	 * set to {@code false}.
	 * @param annotatedElement the element that is annotated with the supplied annotation;
	 * may be {@code null} if unknown
	 * @param annotation the annotation to retrieve the attributes for
	 * @return the annotation attributes (a specialized Map) with attribute names as keys
	 * and corresponding attribute values as values (never {@code null})
	 * @since 4.2
	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)
	 */
	public static AnnotationAttributes getAnnotationAttributes(
			@Nullable AnnotatedElement annotatedElement, Annotation annotation) {

<span class="fc" id="L840">		return getAnnotationAttributes(annotatedElement, annotation, false, false);</span>
	}

	/**
	 * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.
	 * &lt;p&gt;This method provides fully recursive annotation reading capabilities on par with
	 * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.
	 * @param annotatedElement the element that is annotated with the supplied annotation;
	 * may be {@code null} if unknown
	 * @param annotation the annotation to retrieve the attributes for
	 * @param classValuesAsString whether to convert Class references into Strings (for
	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata})
	 * or to preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested annotations into
	 * {@link AnnotationAttributes} maps (for compatibility with
	 * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as
	 * {@code Annotation} instances
	 * @return the annotation attributes (a specialized Map) with attribute names as keys
	 * and corresponding attribute values as values (never {@code null})
	 * @since 4.2
	 */
	public static AnnotationAttributes getAnnotationAttributes(
			@Nullable AnnotatedElement annotatedElement, Annotation annotation,
			boolean classValuesAsString, boolean nestedAnnotationsAsMap) {

<span class="fc" id="L865">		MapValues[] mapValues = MapValues.of(classValuesAsString, nestedAnnotationsAsMap);</span>
<span class="fc" id="L866">		return MergedAnnotation.from(annotatedElement, annotation)</span>
<span class="fc" id="L867">				.withNonMergedAttributes()</span>
<span class="fc" id="L868">				.asMap(getAnnotationAttributesFactory(), mapValues);</span>
	}

	private static Function&lt;MergedAnnotation&lt;?&gt;, AnnotationAttributes&gt; getAnnotationAttributesFactory() {
<span class="fc" id="L872">		return (annotation -&gt; new AnnotationAttributes(annotation.getType(), true));</span>
	}

	/**
	 * Register the annotation-declared default values for the given attributes,
	 * if available.
	 * @param attributes the annotation attributes to process
	 * @since 4.3.2
	 */
	public static void registerDefaultValues(AnnotationAttributes attributes) {
<span class="fc" id="L882">		Class&lt;? extends Annotation&gt; annotationType = attributes.annotationType();</span>
<span class="pc bpc" id="L883" title="1 of 4 branches missed.">		if (annotationType != null &amp;&amp; Modifier.isPublic(annotationType.getModifiers()) &amp;&amp;</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">				!AnnotationFilter.PLAIN.matches(annotationType)) {</span>
<span class="fc" id="L885">			Map&lt;String, DefaultValueHolder&gt; defaultValues = getDefaultValues(annotationType);</span>
<span class="fc" id="L886">			defaultValues.forEach(attributes::putIfAbsent);</span>
		}
<span class="fc" id="L888">	}</span>

	private static Map&lt;String, DefaultValueHolder&gt; getDefaultValues(
			Class&lt;? extends Annotation&gt; annotationType) {

<span class="fc" id="L893">		return defaultValuesCache.computeIfAbsent(annotationType,</span>
				AnnotationUtils::computeDefaultValues);
	}

	private static Map&lt;String, DefaultValueHolder&gt; computeDefaultValues(
			Class&lt;? extends Annotation&gt; annotationType) {

<span class="fc" id="L900">		AttributeMethods methods = AttributeMethods.forAnnotationType(annotationType);</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">		if (!methods.hasDefaultValueMethod()) {</span>
<span class="fc" id="L902">			return Collections.emptyMap();</span>
		}
<span class="fc" id="L904">		Map&lt;String, DefaultValueHolder&gt; result = new LinkedHashMap&lt;&gt;(methods.size());</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">		if (!methods.hasNestedAnnotation()) {</span>
			// Use simpler method if there are no nested annotations
<span class="fc bfc" id="L907" title="All 2 branches covered.">			for (int i = 0; i &lt; methods.size(); i++) {</span>
<span class="fc" id="L908">				Method method = methods.get(i);</span>
<span class="fc" id="L909">				Object defaultValue = method.getDefaultValue();</span>
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">				if(defaultValue != null) {</span>
<span class="fc" id="L911">					result.put(method.getName(), new DefaultValueHolder(defaultValue));</span>
				}
			}
		}
		else {
			// If we have nested annotations, we need them as nested maps
<span class="fc" id="L917">			AnnotationAttributes attributes = MergedAnnotation.from(annotationType)</span>
<span class="fc" id="L918">					.asMap(getAnnotationAttributesFactory(), MapValues.ANNOTATION_TO_MAP);</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">			for (Map.Entry&lt;String, Object&gt; element : attributes.entrySet()) {</span>
<span class="fc" id="L920">				result.put(element.getKey(), new DefaultValueHolder(element.getValue()));</span>
<span class="fc" id="L921">			}</span>
		}
<span class="fc" id="L923">		return result;</span>
	}

	/**
	 * Post-process the supplied {@link AnnotationAttributes}, preserving nested
	 * annotations as {@code Annotation} instances.
	 * &lt;p&gt;Specifically, this method enforces &lt;em&gt;attribute alias&lt;/em&gt; semantics
	 * for annotation attributes that are annotated with {@link AliasFor @AliasFor}
	 * and replaces default value placeholders with their original default values.
	 * @param annotatedElement the element that is annotated with an annotation or
	 * annotation hierarchy from which the supplied attributes were created;
	 * may be {@code null} if unknown
	 * @param attributes the annotation attributes to post-process
	 * @param classValuesAsString whether to convert Class references into Strings (for
	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata})
	 * or to preserve them as Class references
	 * @since 4.3.2
	 * @see #getDefaultValue(Class, String)
	 */
	public static void postProcessAnnotationAttributes(@Nullable Object annotatedElement,
			@Nullable AnnotationAttributes attributes, boolean classValuesAsString) {

<span class="pc bpc" id="L945" title="1 of 2 branches missed.">		if (attributes == null) {</span>
<span class="nc" id="L946">			return;</span>
		}
<span class="fc bfc" id="L948" title="All 2 branches covered.">		if (!attributes.validated) {</span>
<span class="fc" id="L949">			Class&lt;? extends Annotation&gt; annotationType = attributes.annotationType();</span>
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">			if (annotationType == null) {</span>
<span class="nc" id="L951">				return;</span>
			}
<span class="fc" id="L953">			AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">			for (int i = 0; i &lt; mapping.getMirrorSets().size(); i++) {</span>
<span class="fc" id="L955">				MirrorSet mirrorSet = mapping.getMirrorSets().get(i);</span>
<span class="fc" id="L956">				int resolved = mirrorSet.resolve(attributes.displayName, attributes,</span>
						AnnotationUtils::getAttributeValueForMirrorResolution);
<span class="fc bfc" id="L958" title="All 2 branches covered.">				if (resolved != -1) {</span>
<span class="fc" id="L959">					Method attribute = mapping.getAttributes().get(resolved);</span>
<span class="fc" id="L960">					Object value = attributes.get(attribute.getName());</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">					for (int j = 0; j &lt; mirrorSet.size(); j++) {</span>
<span class="fc" id="L962">						Method mirror = mirrorSet.get(j);</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">						if (mirror != attribute) {</span>
<span class="fc" id="L964">							attributes.put(mirror.getName(),</span>
<span class="fc" id="L965">									adaptValue(annotatedElement, value, classValuesAsString));</span>
						}
					}
				}
			}
		}
<span class="fc bfc" id="L971" title="All 2 branches covered.">		for (Map.Entry&lt;String, Object&gt; attributeEntry : attributes.entrySet()) {</span>
<span class="fc" id="L972">			String attributeName = attributeEntry.getKey();</span>
<span class="fc" id="L973">			Object value = attributeEntry.getValue();</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">			if (value instanceof DefaultValueHolder) {</span>
<span class="fc" id="L975">				value = ((DefaultValueHolder) value).defaultValue;</span>
<span class="fc" id="L976">				attributes.put(attributeName,</span>
<span class="fc" id="L977">						adaptValue(annotatedElement, value, classValuesAsString));</span>
			}
<span class="fc" id="L979">		}</span>
<span class="fc" id="L980">	}</span>

	private static Object getAttributeValueForMirrorResolution(Method attribute, Object attributes) {
<span class="fc" id="L983">		Object result = ((AnnotationAttributes) attributes).get(attribute.getName());</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">		return (result instanceof DefaultValueHolder ? ((DefaultValueHolder) result).defaultValue : result);</span>
	}

	@Nullable
	private static Object adaptValue(
			@Nullable Object annotatedElement, @Nullable Object value, boolean classValuesAsString) {

<span class="fc bfc" id="L991" title="All 2 branches covered.">		if (classValuesAsString) {</span>
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">			if (value instanceof Class) {</span>
<span class="nc" id="L993">				return ((Class&lt;?&gt;) value).getName();</span>
			}
<span class="pc bpc" id="L995" title="1 of 2 branches missed.">			if (value instanceof Class[]) {</span>
<span class="nc" id="L996">				Class&lt;?&gt;[] classes = (Class&lt;?&gt;[]) value;</span>
<span class="nc" id="L997">				String[] names = new String[classes.length];</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">				for (int i = 0; i &lt; classes.length; i++) {</span>
<span class="nc" id="L999">					names[i] = classes[i].getName();</span>
				}
<span class="nc" id="L1001">				return names;</span>
			}
		}
<span class="pc bpc" id="L1004" title="1 of 2 branches missed.">		if (value instanceof Annotation) {</span>
<span class="nc" id="L1005">			Annotation annotation = (Annotation) value;</span>
<span class="nc" id="L1006">			return MergedAnnotation.from(annotatedElement, annotation).synthesize();</span>
		}
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">		if (value instanceof Annotation[]) {</span>
<span class="nc" id="L1009">			Annotation[] annotations = (Annotation[]) value;</span>
<span class="nc" id="L1010">			Annotation[] synthesized = (Annotation[]) Array.newInstance(</span>
<span class="nc" id="L1011">					annotations.getClass().getComponentType(), annotations.length);</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">			for (int i = 0; i &lt; annotations.length; i++) {</span>
<span class="nc" id="L1013">				synthesized[i] = MergedAnnotation.from(annotatedElement, annotations[i]).synthesize();</span>
			}
<span class="nc" id="L1015">			return synthesized;</span>
		}
<span class="fc" id="L1017">		return value;</span>
	}

	/**
	 * Retrieve the &lt;em&gt;value&lt;/em&gt; of the {@code value} attribute of a
	 * single-element Annotation, given an annotation instance.
	 * @param annotation the annotation instance from which to retrieve the value
	 * @return the attribute value, or {@code null} if not found unless the attribute
	 * value cannot be retrieved due to an {@link AnnotationConfigurationException},
	 * in which case such an exception will be rethrown
	 * @see #getValue(Annotation, String)
	 */
	@Nullable
	public static Object getValue(Annotation annotation) {
<span class="fc" id="L1031">		return getValue(annotation, VALUE);</span>
	}

	/**
	 * Retrieve the &lt;em&gt;value&lt;/em&gt; of a named attribute, given an annotation instance.
	 * @param annotation the annotation instance from which to retrieve the value
	 * @param attributeName the name of the attribute value to retrieve
	 * @return the attribute value, or {@code null} if not found unless the attribute
	 * value cannot be retrieved due to an {@link AnnotationConfigurationException},
	 * in which case such an exception will be rethrown
	 * @see #getValue(Annotation)
	 */
	@Nullable
	public static Object getValue(@Nullable Annotation annotation, @Nullable String attributeName) {
<span class="pc bpc" id="L1045" title="2 of 4 branches missed.">		if (annotation == null || !StringUtils.hasText(attributeName)) {</span>
<span class="nc" id="L1046">			return null;</span>
		}
		try {
<span class="fc" id="L1049">			Method method = annotation.annotationType().getDeclaredMethod(attributeName);</span>
<span class="fc" id="L1050">			ReflectionUtils.makeAccessible(method);</span>
<span class="fc" id="L1051">			return method.invoke(annotation);</span>
		}
<span class="nc" id="L1053">		catch (NoSuchMethodException ex) {</span>
<span class="nc" id="L1054">			return null;</span>
		}
<span class="nc" id="L1056">		catch (InvocationTargetException ex) {</span>
<span class="nc" id="L1057">			rethrowAnnotationConfigurationException(ex.getTargetException());</span>
<span class="nc" id="L1058">			throw new IllegalStateException(&quot;Could not obtain value for annotation attribute '&quot; +</span>
					attributeName + &quot;' in &quot; + annotation, ex);
		}
<span class="nc" id="L1061">		catch (Throwable ex) {</span>
<span class="nc" id="L1062">			handleIntrospectionFailure(annotation.getClass(), ex);</span>
<span class="nc" id="L1063">			return null;</span>
		}
	}

	/**
	 * If the supplied throwable is an {@link AnnotationConfigurationException},
	 * it will be cast to an {@code AnnotationConfigurationException} and thrown,
	 * allowing it to propagate to the caller.
	 * &lt;p&gt;Otherwise, this method does nothing.
	 * @param ex the throwable to inspect
	 */
	private static void rethrowAnnotationConfigurationException(Throwable ex) {
<span class="nc bnc" id="L1075" title="All 2 branches missed.">		if (ex instanceof AnnotationConfigurationException) {</span>
<span class="nc" id="L1076">			throw (AnnotationConfigurationException) ex;</span>
		}
<span class="nc" id="L1078">	}</span>

	/**
	 * Handle the supplied annotation introspection exception.
	 * &lt;p&gt;If the supplied exception is an {@link AnnotationConfigurationException},
	 * it will simply be thrown, allowing it to propagate to the caller, and
	 * nothing will be logged.
	 * &lt;p&gt;Otherwise, this method logs an introspection failure (in particular
	 * {@code TypeNotPresentExceptions}) before moving on, assuming nested
	 * Class values were not resolvable within annotation attributes and
	 * thereby effectively pretending there were no annotations on the specified
	 * element.
	 * @param element the element that we tried to introspect annotations on
	 * @param ex the exception that we encountered
	 * @see #rethrowAnnotationConfigurationException
	 */
	private static void handleIntrospectionFailure(@Nullable AnnotatedElement element, Throwable ex) {
<span class="nc" id="L1095">		rethrowAnnotationConfigurationException(ex);</span>
<span class="nc" id="L1096">		IntrospectionFailureLogger logger = IntrospectionFailureLogger.INFO;</span>
<span class="nc" id="L1097">		boolean meta = false;</span>
<span class="nc bnc" id="L1098" title="All 4 branches missed.">		if (element instanceof Class &amp;&amp; Annotation.class.isAssignableFrom((Class&lt;?&gt;) element)) {</span>
			// Meta-annotation or (default) value lookup on an annotation type
<span class="nc" id="L1100">			logger = IntrospectionFailureLogger.DEBUG;</span>
<span class="nc" id="L1101">			meta = true;</span>
		}
<span class="nc bnc" id="L1103" title="All 2 branches missed.">		if (logger.isEnabled()) {</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">			String message = meta ?</span>
					&quot;Failed to meta-introspect annotation &quot; :
					&quot;Failed to introspect annotations on &quot;;
<span class="nc" id="L1107">			logger.log(message + element + &quot;: &quot; + ex);</span>
		}
<span class="nc" id="L1109">	}</span>

	/**
	 * Retrieve the &lt;em&gt;default value&lt;/em&gt; of the {@code value} attribute
	 * of a single-element Annotation, given an annotation instance.
	 * @param annotation the annotation instance from which to retrieve the default value
	 * @return the default value, or {@code null} if not found
	 * @see #getDefaultValue(Annotation, String)
	 */
	@Nullable
	public static Object getDefaultValue(Annotation annotation) {
<span class="fc" id="L1120">		return getDefaultValue(annotation, VALUE);</span>
	}

	/**
	 * Retrieve the &lt;em&gt;default value&lt;/em&gt; of a named attribute, given an annotation instance.
	 * @param annotation the annotation instance from which to retrieve the default value
	 * @param attributeName the name of the attribute value to retrieve
	 * @return the default value of the named attribute, or {@code null} if not found
	 * @see #getDefaultValue(Class, String)
	 */
	@Nullable
	public static Object getDefaultValue(@Nullable Annotation annotation, @Nullable String attributeName) {
<span class="pc bpc" id="L1132" title="1 of 2 branches missed.">		return (annotation != null ? getDefaultValue(annotation.annotationType(), attributeName) : null);</span>
	}

	/**
	 * Retrieve the &lt;em&gt;default value&lt;/em&gt; of the {@code value} attribute
	 * of a single-element Annotation, given the {@link Class annotation type}.
	 * @param annotationType the &lt;em&gt;annotation type&lt;/em&gt; for which the default value should be retrieved
	 * @return the default value, or {@code null} if not found
	 * @see #getDefaultValue(Class, String)
	 */
	@Nullable
	public static Object getDefaultValue(Class&lt;? extends Annotation&gt; annotationType) {
<span class="fc" id="L1144">		return getDefaultValue(annotationType, VALUE);</span>
	}

	/**
	 * Retrieve the &lt;em&gt;default value&lt;/em&gt; of a named attribute, given the
	 * {@link Class annotation type}.
	 * @param annotationType the &lt;em&gt;annotation type&lt;/em&gt; for which the default value should be retrieved
	 * @param attributeName the name of the attribute value to retrieve.
	 * @return the default value of the named attribute, or {@code null} if not found
	 * @see #getDefaultValue(Annotation, String)
	 */
	@Nullable
	public static Object getDefaultValue(
			@Nullable Class&lt;? extends Annotation&gt; annotationType, @Nullable String attributeName) {

<span class="pc bpc" id="L1159" title="2 of 4 branches missed.">		if (annotationType == null || !StringUtils.hasText(attributeName)) {</span>
<span class="nc" id="L1160">			return null;</span>
		}
<span class="fc" id="L1162">		return MergedAnnotation.from(annotationType).getDefaultValue(attributeName).orElse(null);</span>
	}

	/**
	 * &lt;em&gt;Synthesize&lt;/em&gt; an annotation from the supplied {@code annotation}
	 * by wrapping it in a dynamic proxy that transparently enforces
	 * &lt;em&gt;attribute alias&lt;/em&gt; semantics for annotation attributes that are
	 * annotated with {@link AliasFor @AliasFor}.
	 * @param annotation the annotation to synthesize
	 * @param annotatedElement the element that is annotated with the supplied
	 * annotation; may be {@code null} if unknown
	 * @return the synthesized annotation if the supplied annotation is
	 * &lt;em&gt;synthesizable&lt;/em&gt;; {@code null} if the supplied annotation is
	 * {@code null}; otherwise the supplied annotation unmodified
	 * @throws AnnotationConfigurationException if invalid configuration of
	 * {@code @AliasFor} is detected
	 * @since 4.2
	 * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)
	 * @see #synthesizeAnnotation(Class)
	 */
	public static &lt;A extends Annotation&gt; A synthesizeAnnotation(
			A annotation, @Nullable AnnotatedElement annotatedElement) {

<span class="nc bnc" id="L1185" title="All 4 branches missed.">		if (annotation instanceof SynthesizedAnnotation || AnnotationFilter.PLAIN.matches(annotation)) {</span>
<span class="nc" id="L1186">			return annotation;</span>
		}
<span class="nc" id="L1188">		return MergedAnnotation.from(annotatedElement, annotation).synthesize();</span>
	}

	/**
	 * &lt;em&gt;Synthesize&lt;/em&gt; an annotation from its default attributes values.
	 * &lt;p&gt;This method simply delegates to
	 * {@link #synthesizeAnnotation(Map, Class, AnnotatedElement)},
	 * supplying an empty map for the source attribute values and {@code null}
	 * for the {@link AnnotatedElement}.
	 * @param annotationType the type of annotation to synthesize
	 * @return the synthesized annotation
	 * @throws IllegalArgumentException if a required attribute is missing
	 * @throws AnnotationConfigurationException if invalid configuration of
	 * {@code @AliasFor} is detected
	 * @since 4.2
	 * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)
	 * @see #synthesizeAnnotation(Annotation, AnnotatedElement)
	 */
	public static &lt;A extends Annotation&gt; A synthesizeAnnotation(Class&lt;A&gt; annotationType) {
<span class="fc" id="L1207">		return synthesizeAnnotation(Collections.emptyMap(), annotationType, null);</span>
	}

	/**
	 * &lt;em&gt;Synthesize&lt;/em&gt; an annotation from the supplied map of annotation
	 * attributes by wrapping the map in a dynamic proxy that implements an
	 * annotation of the specified {@code annotationType} and transparently
	 * enforces &lt;em&gt;attribute alias&lt;/em&gt; semantics for annotation attributes
	 * that are annotated with {@link AliasFor @AliasFor}.
	 * &lt;p&gt;The supplied map must contain a key-value pair for every attribute
	 * defined in the supplied {@code annotationType} that is not aliased or
	 * does not have a default value. Nested maps and nested arrays of maps
	 * will be recursively synthesized into nested annotations or nested
	 * arrays of annotations, respectively.
	 * &lt;p&gt;Note that {@link AnnotationAttributes} is a specialized type of
	 * {@link Map} that is an ideal candidate for this method's
	 * {@code attributes} argument.
	 * @param attributes the map of annotation attributes to synthesize
	 * @param annotationType the type of annotation to synthesize
	 * @param annotatedElement the element that is annotated with the annotation
	 * corresponding to the supplied attributes; may be {@code null} if unknown
	 * @return the synthesized annotation
	 * @throws IllegalArgumentException if a required attribute is missing or if an
	 * attribute is not of the correct type
	 * @throws AnnotationConfigurationException if invalid configuration of
	 * {@code @AliasFor} is detected
	 * @since 4.2
	 * @see #synthesizeAnnotation(Annotation, AnnotatedElement)
	 * @see #synthesizeAnnotation(Class)
	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation)
	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)
	 */
	public static &lt;A extends Annotation&gt; A synthesizeAnnotation(Map&lt;String, Object&gt; attributes,
			Class&lt;A&gt; annotationType, @Nullable AnnotatedElement annotatedElement) {

		try {
<span class="fc" id="L1243">			return MergedAnnotation.from(annotatedElement, annotationType, attributes).synthesize();</span>
		}
<span class="fc" id="L1245">		catch (NoSuchElementException | IllegalStateException ex) {</span>
<span class="fc" id="L1246">			throw new IllegalArgumentException(ex);</span>
		}
	}

	/**
	 * &lt;em&gt;Synthesize&lt;/em&gt; an array of annotations from the supplied array
	 * of {@code annotations} by creating a new array of the same size and
	 * type and populating it with {@linkplain #synthesizeAnnotation(Annotation,
	 * AnnotatedElement) synthesized} versions of the annotations from the input
	 * array.
	 * @param annotations the array of annotations to synthesize
	 * @param annotatedElement the element that is annotated with the supplied
	 * array of annotations; may be {@code null} if unknown
	 * @return a new array of synthesized annotations, or {@code null} if
	 * the supplied array is {@code null}
	 * @throws AnnotationConfigurationException if invalid configuration of
	 * {@code @AliasFor} is detected
	 * @since 4.2
	 * @see #synthesizeAnnotation(Annotation, AnnotatedElement)
	 * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)
	 */
	static Annotation[] synthesizeAnnotationArray(Annotation[] annotations, AnnotatedElement annotatedElement) {
<span class="nc bnc" id="L1268" title="All 2 branches missed.">		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {</span>
<span class="nc" id="L1269">			return annotations;</span>
		}
<span class="nc" id="L1271">		Annotation[] synthesized = (Annotation[]) Array.newInstance(</span>
<span class="nc" id="L1272">				annotations.getClass().getComponentType(), annotations.length);</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">		for (int i = 0; i &lt; annotations.length; i++) {</span>
<span class="nc" id="L1274">			synthesized[i] = synthesizeAnnotation(annotations[i], annotatedElement);</span>
		}
<span class="nc" id="L1276">		return synthesized;</span>
	}

	/**
	 * Clear the internal annotation metadata cache.
	 * @since 4.3.15
	 */
	public static void clearCache() {
<span class="fc" id="L1284">		AnnotationTypeMappings.clearCache();</span>
<span class="fc" id="L1285">		AnnotationsScanner.clearCache();</span>
<span class="fc" id="L1286">	}</span>


	/**
	 * Internal holder used to wrap default values.
	 */
	private static class DefaultValueHolder {

		final Object defaultValue;

<span class="fc" id="L1296">		public DefaultValueHolder(Object defaultValue) {</span>
<span class="fc" id="L1297">			this.defaultValue = defaultValue;</span>
<span class="fc" id="L1298">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L1302">			return &quot;*&quot; + this.defaultValue;</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>