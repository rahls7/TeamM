<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-core</a> &gt; <a href="index.source.html" class="el_package">org.springframework.asm</a> &gt; <span class="el_source">ClassReader.java</span></div><h1>ClassReader.java</h1><pre class="source lang-java linenums">// ASM: a very small and fast Java bytecode manipulation framework
// Copyright (c) 2000-2011 INRIA, France Telecom
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.
package org.springframework.asm;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * A parser to make a {@link ClassVisitor} visit a ClassFile structure, as defined in the Java
 * Virtual Machine Specification (JVMS). This class parses the ClassFile content and calls the
 * appropriate visit methods of a given {@link ClassVisitor} for each field, method and bytecode
 * instruction encountered.
 *
 * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html&quot;&gt;JVMS 4&lt;/a&gt;
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
public class ClassReader {

  /**
   * A flag to skip the Code attributes. If this flag is set the Code attributes are neither parsed
   * nor visited.
   */
  public static final int SKIP_CODE = 1;

  /**
   * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable
   * and LineNumberTable attributes. If this flag is set these attributes are neither parsed nor
   * visited (i.e. {@link ClassVisitor#visitSource}, {@link MethodVisitor#visitLocalVariable} and
   * {@link MethodVisitor#visitLineNumber} are not called).
   */
  public static final int SKIP_DEBUG = 2;

  /**
   * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes
   * are neither parsed nor visited (i.e. {@link MethodVisitor#visitFrame} is not called). This flag
   * is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is used: it avoids visiting frames
   * that will be ignored and recomputed from scratch.
   */
  public static final int SKIP_FRAMES = 4;

  /**
   * A flag to expand the stack map frames. By default stack map frames are visited in their
   * original format (i.e. &quot;expanded&quot; for classes whose version is less than V1_6, and &quot;compressed&quot;
   * for the other classes). If this flag is set, stack map frames are always visited in expanded
   * format (this option adds a decompression/compression step in ClassReader and ClassWriter which
   * degrades performance quite a lot).
   */
  public static final int EXPAND_FRAMES = 8;

  /**
   * A flag to expand the ASM specific instructions into an equivalent sequence of standard bytecode
   * instructions. When resolving a forward jump it may happen that the signed 2 bytes offset
   * reserved for it is not sufficient to store the bytecode offset. In this case the jump
   * instruction is replaced with a temporary ASM specific instruction using an unsigned 2 bytes
   * offset (see {@link Label#resolve}). This internal flag is used to re-read classes containing
   * such instructions, in order to replace them with standard instructions. In addition, when this
   * flag is used, goto_w and jsr_w are &lt;i&gt;not&lt;/i&gt; converted into goto and jsr, to make sure that
   * infinite loops where a goto_w is replaced with a goto in ClassReader and converted back to a
   * goto_w in ClassWriter cannot occur.
   */
  static final int EXPAND_ASM_INSNS = 256;

  /** The size of the temporary byte array used to read class input streams chunk by chunk. */
  private static final int INPUT_STREAM_DATA_CHUNK_SIZE = 4096;

  /**
   * A byte array containing the JVMS ClassFile structure to be parsed.
   *
   * @deprecated Use {@link #readByte(int)} and the other read methods instead. This field will
   *     eventually be deleted.
   */
  @Deprecated
  // DontCheck(MemberName): can't be renamed (for backward binary compatibility).
  public final byte[] b;

  /**
   * A byte array containing the JVMS ClassFile structure to be parsed. &lt;i&gt;The content of this array
   * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally
   * not needed by class visitors.&lt;/i&gt;
   *
   * &lt;p&gt;NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not
   * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct
   * ClassFile element offsets within this byte array.
   */
  final byte[] classFileBuffer;

  /**
   * The offset in bytes, in {@link #classFileBuffer}, of each cp_info entry of the ClassFile's
   * constant_pool array, &lt;i&gt;plus one&lt;/i&gt;. In other words, the offset of constant pool entry i is
   * given by cpInfoOffsets[i] - 1, i.e. its cp_info's tag field is given by b[cpInfoOffsets[i] -
   * 1].
   */
  private final int[] cpInfoOffsets;

  /**
   * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids
   * multiple parsing of a given CONSTANT_Utf8 constant pool item.
   */
  private final String[] constantUtf8Values;

  /**
   * The ConstantDynamic objects corresponding to the CONSTANT_Dynamic constant pool items. This
   * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.
   */
  private final ConstantDynamic[] constantDynamicValues;

  /**
   * The start offsets in {@link #classFileBuffer} of each element of the bootstrap_methods array
   * (in the BootstrapMethods attribute).
   *
   * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23&quot;&gt;JVMS
   *     4.7.23&lt;/a&gt;
   */
  private final int[] bootstrapMethodOffsets;

  /**
   * A conservative estimate of the maximum length of the strings contained in the constant pool of
   * the class.
   */
  private final int maxStringLength;

  /** The offset in bytes of the ClassFile's access_flags field. */
  public final int header;

  // -----------------------------------------------------------------------------------------------
  // Constructors
  // -----------------------------------------------------------------------------------------------

  /**
   * Constructs a new {@link ClassReader} object.
   *
   * @param classFile the JVMS ClassFile structure to be read.
   */
  public ClassReader(final byte[] classFile) {
<span class="fc" id="L162">    this(classFile, 0, classFile.length);</span>
<span class="fc" id="L163">  }</span>

  /**
   * Constructs a new {@link ClassReader} object.
   *
   * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.
   * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
   * @param classFileLength the length in bytes of the ClassFile to be read.
   */
  public ClassReader(
      final byte[] classFileBuffer,
      final int classFileOffset,
      final int classFileLength) { // NOPMD(UnusedFormalParameter) used for backward compatibility.
<span class="fc" id="L176">    this(classFileBuffer, classFileOffset, /* checkClassVersion = */ true);</span>
<span class="fc" id="L177">  }</span>

  /**
   * Constructs a new {@link ClassReader} object. &lt;i&gt;This internal constructor must not be exposed
   * as a public API&lt;/i&gt;.
   *
   * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.
   * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
   * @param checkClassVersion whether to check the class version or not.
   */
  ClassReader(
<span class="fc" id="L188">      final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {</span>
<span class="fc" id="L189">    this.classFileBuffer = classFileBuffer;</span>
<span class="fc" id="L190">    this.b = classFileBuffer;</span>
    // Check the class' major_version. This field is after the magic and minor_version fields, which
    // use 4 and 2 bytes respectively.
<span class="pc bpc" id="L193" title="2 of 4 branches missed.">    if (checkClassVersion &amp;&amp; readShort(classFileOffset + 6) &gt; Opcodes.V13) {</span>
<span class="nc" id="L194">      throw new IllegalArgumentException(</span>
<span class="nc" id="L195">          &quot;Unsupported class file major version &quot; + readShort(classFileOffset + 6));</span>
    }
    // Create the constant pool arrays. The constant_pool_count field is after the magic,
    // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.
<span class="fc" id="L199">    int constantPoolCount = readUnsignedShort(classFileOffset + 8);</span>
<span class="fc" id="L200">    cpInfoOffsets = new int[constantPoolCount];</span>
<span class="fc" id="L201">    constantUtf8Values = new String[constantPoolCount];</span>
    // Compute the offset of each constant pool entry, as well as a conservative estimate of the
    // maximum length of the constant pool strings. The first constant pool entry is after the
    // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2
    // bytes respectively.
<span class="fc" id="L206">    int currentCpInfoIndex = 1;</span>
<span class="fc" id="L207">    int currentCpInfoOffset = classFileOffset + 10;</span>
<span class="fc" id="L208">    int currentMaxStringLength = 0;</span>
<span class="fc" id="L209">    boolean hasBootstrapMethods = false;</span>
<span class="fc" id="L210">    boolean hasConstantDynamic = false;</span>
    // The offset of the other entries depend on the total size of all the previous entries.
<span class="fc bfc" id="L212" title="All 2 branches covered.">    while (currentCpInfoIndex &lt; constantPoolCount) {</span>
<span class="fc" id="L213">      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;</span>
      int cpInfoSize;
<span class="pc bpc" id="L215" title="4 of 8 branches missed.">      switch (classFileBuffer[currentCpInfoOffset]) {</span>
        case Symbol.CONSTANT_FIELDREF_TAG:
        case Symbol.CONSTANT_METHODREF_TAG:
        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:
        case Symbol.CONSTANT_INTEGER_TAG:
        case Symbol.CONSTANT_FLOAT_TAG:
        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
<span class="fc" id="L222">          cpInfoSize = 5;</span>
<span class="fc" id="L223">          break;</span>
        case Symbol.CONSTANT_DYNAMIC_TAG:
<span class="nc" id="L225">          cpInfoSize = 5;</span>
<span class="nc" id="L226">          hasBootstrapMethods = true;</span>
<span class="nc" id="L227">          hasConstantDynamic = true;</span>
<span class="nc" id="L228">          break;</span>
        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
<span class="nc" id="L230">          cpInfoSize = 5;</span>
<span class="nc" id="L231">          hasBootstrapMethods = true;</span>
<span class="nc" id="L232">          break;</span>
        case Symbol.CONSTANT_LONG_TAG:
        case Symbol.CONSTANT_DOUBLE_TAG:
<span class="fc" id="L235">          cpInfoSize = 9;</span>
<span class="fc" id="L236">          currentCpInfoIndex++;</span>
<span class="fc" id="L237">          break;</span>
        case Symbol.CONSTANT_UTF8_TAG:
<span class="fc" id="L239">          cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">          if (cpInfoSize &gt; currentMaxStringLength) {</span>
            // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate
            // of the length in characters of the corresponding string, and is much cheaper to
            // compute than this exact length.
<span class="fc" id="L244">            currentMaxStringLength = cpInfoSize;</span>
          }
          break;
        case Symbol.CONSTANT_METHOD_HANDLE_TAG:
<span class="nc" id="L248">          cpInfoSize = 4;</span>
<span class="nc" id="L249">          break;</span>
        case Symbol.CONSTANT_CLASS_TAG:
        case Symbol.CONSTANT_STRING_TAG:
        case Symbol.CONSTANT_METHOD_TYPE_TAG:
        case Symbol.CONSTANT_PACKAGE_TAG:
        case Symbol.CONSTANT_MODULE_TAG:
<span class="fc" id="L255">          cpInfoSize = 3;</span>
<span class="fc" id="L256">          break;</span>
        default:
<span class="nc" id="L258">          throw new IllegalArgumentException();</span>
      }
<span class="fc" id="L260">      currentCpInfoOffset += cpInfoSize;</span>
<span class="fc" id="L261">    }</span>
<span class="fc" id="L262">    maxStringLength = currentMaxStringLength;</span>
    // The Classfile's access_flags field is just after the last constant pool entry.
<span class="fc" id="L264">    header = currentCpInfoOffset;</span>

    // Allocate the cache of ConstantDynamic values, if there is at least one.
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">    constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;</span>

    // Read the BootstrapMethods attribute, if any (only get the offset of each method).
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">    bootstrapMethodOffsets =</span>
<span class="pc" id="L271">        hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;</span>
<span class="fc" id="L272">  }</span>

  /**
   * Constructs a new {@link ClassReader} object.
   *
   * @param inputStream an input stream of the JVMS ClassFile structure to be read. This input
   *     stream must contain nothing more than the ClassFile structure itself. It is read from its
   *     current position to its end.
   * @throws IOException if a problem occurs during reading.
   */
  public ClassReader(final InputStream inputStream) throws IOException {
<span class="fc" id="L283">    this(readStream(inputStream, false));</span>
<span class="fc" id="L284">  }</span>

  /**
   * Constructs a new {@link ClassReader} object.
   *
   * @param className the fully qualified name of the class to be read. The ClassFile structure is
   *     retrieved with the current class loader's {@link ClassLoader#getSystemResourceAsStream}.
   * @throws IOException if an exception occurs during reading.
   */
  public ClassReader(final String className) throws IOException {
<span class="nc" id="L294">    this(</span>
<span class="nc" id="L295">        readStream(</span>
<span class="nc" id="L296">            ClassLoader.getSystemResourceAsStream(className.replace('.', '/') + &quot;.class&quot;), true));</span>
<span class="nc" id="L297">  }</span>

  /**
   * Reads the given input stream and returns its content as a byte array.
   *
   * @param inputStream an input stream.
   * @param close true to close the input stream after reading.
   * @return the content of the given input stream.
   * @throws IOException if a problem occurs during reading.
   */
  private static byte[] readStream(final InputStream inputStream, final boolean close)
      throws IOException {
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">    if (inputStream == null) {</span>
<span class="nc" id="L310">      throw new IOException(&quot;Class not found&quot;);</span>
    }
<span class="fc" id="L312">    try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {</span>
<span class="fc" id="L313">      byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];</span>
      int bytesRead;
<span class="fc bfc" id="L315" title="All 2 branches covered.">      while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {</span>
<span class="fc" id="L316">        outputStream.write(data, 0, bytesRead);</span>
      }
<span class="fc" id="L318">      outputStream.flush();</span>
<span class="fc" id="L319">      return outputStream.toByteArray();</span>
    } finally {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">      if (close) {</span>
<span class="nc" id="L322">        inputStream.close();</span>
      }
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Accessors
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the class's access flags (see {@link Opcodes}). This value may not reflect Deprecated
   * and Synthetic flags when bytecode is before 1.5 and those flags are represented by attributes.
   *
   * @return the class access flags.
   * @see ClassVisitor#visit(int, int, String, String, String, String[])
   */
  public int getAccess() {
<span class="nc" id="L339">    return readUnsignedShort(header);</span>
  }

  /**
   * Returns the internal name of the class (see {@link Type#getInternalName()}).
   *
   * @return the internal class name.
   * @see ClassVisitor#visit(int, int, String, String, String, String[])
   */
  public String getClassName() {
    // this_class is just after the access_flags field (using 2 bytes).
<span class="nc" id="L350">    return readClass(header + 2, new char[maxStringLength]);</span>
  }

  /**
   * Returns the internal of name of the super class (see {@link Type#getInternalName()}). For
   * interfaces, the super class is {@link Object}.
   *
   * @return the internal name of the super class, or {@literal null} for {@link Object} class.
   * @see ClassVisitor#visit(int, int, String, String, String, String[])
   */
  public String getSuperName() {
    // super_class is after the access_flags and this_class fields (2 bytes each).
<span class="nc" id="L362">    return readClass(header + 4, new char[maxStringLength]);</span>
  }

  /**
   * Returns the internal names of the implemented interfaces (see {@link Type#getInternalName()}).
   *
   * @return the internal names of the directly implemented interfaces. Inherited implemented
   *     interfaces are not returned.
   * @see ClassVisitor#visit(int, int, String, String, String, String[])
   */
  public String[] getInterfaces() {
    // interfaces_count is after the access_flags, this_class and super_class fields (2 bytes each).
<span class="nc" id="L374">    int currentOffset = header + 6;</span>
<span class="nc" id="L375">    int interfacesCount = readUnsignedShort(currentOffset);</span>
<span class="nc" id="L376">    String[] interfaces = new String[interfacesCount];</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">    if (interfacesCount &gt; 0) {</span>
<span class="nc" id="L378">      char[] charBuffer = new char[maxStringLength];</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">      for (int i = 0; i &lt; interfacesCount; ++i) {</span>
<span class="nc" id="L380">        currentOffset += 2;</span>
<span class="nc" id="L381">        interfaces[i] = readClass(currentOffset, charBuffer);</span>
      }
    }
<span class="nc" id="L384">    return interfaces;</span>
  }

  // -----------------------------------------------------------------------------------------------
  // Public methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this
   * {@link ClassReader}.
   *
   * @param classVisitor the visitor that must visit this class.
   * @param parsingOptions the options to use to parse this class. One or more of {@link
   *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
   */
  public void accept(final ClassVisitor classVisitor, final int parsingOptions) {
<span class="fc" id="L400">    accept(classVisitor, new Attribute[0], parsingOptions);</span>
<span class="fc" id="L401">  }</span>

  /**
   * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this
   * {@link ClassReader}.
   *
   * @param classVisitor the visitor that must visit this class.
   * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
   *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
   *     be parsed: its byte array value will be passed unchanged to the ClassWriter. &lt;i&gt;This may
   *     corrupt it if this value contains references to the constant pool, or has syntactic or
   *     semantic links with a class element that has been transformed by a class adapter between
   *     the reader and the writer&lt;/i&gt;.
   * @param parsingOptions the options to use to parse this class. One or more of {@link
   *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
   */
  public void accept(
      final ClassVisitor classVisitor,
      final Attribute[] attributePrototypes,
      final int parsingOptions) {
<span class="fc" id="L421">    Context context = new Context();</span>
<span class="fc" id="L422">    context.attributePrototypes = attributePrototypes;</span>
<span class="fc" id="L423">    context.parsingOptions = parsingOptions;</span>
<span class="fc" id="L424">    context.charBuffer = new char[maxStringLength];</span>

    // Read the access_flags, this_class, super_class, interface_count and interfaces fields.
<span class="fc" id="L427">    char[] charBuffer = context.charBuffer;</span>
<span class="fc" id="L428">    int currentOffset = header;</span>
<span class="fc" id="L429">    int accessFlags = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L430">    String thisClass = readClass(currentOffset + 2, charBuffer);</span>
<span class="fc" id="L431">    String superClass = readClass(currentOffset + 4, charBuffer);</span>
<span class="fc" id="L432">    String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];</span>
<span class="fc" id="L433">    currentOffset += 8;</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">    for (int i = 0; i &lt; interfaces.length; ++i) {</span>
<span class="fc" id="L435">      interfaces[i] = readClass(currentOffset, charBuffer);</span>
<span class="fc" id="L436">      currentOffset += 2;</span>
    }

    // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).
    // Attribute offsets exclude the attribute_name_index and attribute_length fields.
    // - The offset of the InnerClasses attribute, or 0.
<span class="fc" id="L442">    int innerClassesOffset = 0;</span>
    // - The offset of the EnclosingMethod attribute, or 0.
<span class="fc" id="L444">    int enclosingMethodOffset = 0;</span>
    // - The string corresponding to the Signature attribute, or null.
<span class="fc" id="L446">    String signature = null;</span>
    // - The string corresponding to the SourceFile attribute, or null.
<span class="fc" id="L448">    String sourceFile = null;</span>
    // - The string corresponding to the SourceDebugExtension attribute, or null.
<span class="fc" id="L450">    String sourceDebugExtension = null;</span>
    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
<span class="fc" id="L452">    int runtimeVisibleAnnotationsOffset = 0;</span>
    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
<span class="fc" id="L454">    int runtimeInvisibleAnnotationsOffset = 0;</span>
    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
<span class="fc" id="L456">    int runtimeVisibleTypeAnnotationsOffset = 0;</span>
    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
<span class="fc" id="L458">    int runtimeInvisibleTypeAnnotationsOffset = 0;</span>
    // - The offset of the Module attribute, or 0.
<span class="fc" id="L460">    int moduleOffset = 0;</span>
    // - The offset of the ModulePackages attribute, or 0.
<span class="fc" id="L462">    int modulePackagesOffset = 0;</span>
    // - The string corresponding to the ModuleMainClass attribute, or null.
<span class="fc" id="L464">    String moduleMainClass = null;</span>
    // - The string corresponding to the NestHost attribute, or null.
<span class="fc" id="L466">    String nestHostClass = null;</span>
    // - The offset of the NestMembers attribute, or 0.
<span class="fc" id="L468">    int nestMembersOffset = 0;</span>
    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
    //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
<span class="fc" id="L471">    Attribute attributes = null;</span>

<span class="fc" id="L473">    int currentAttributeOffset = getFirstAttributeOffset();</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">    for (int i = readUnsignedShort(currentAttributeOffset - 2); i &gt; 0; --i) {</span>
      // Read the attribute_info's attribute_name and attribute_length fields.
<span class="fc" id="L476">      String attributeName = readUTF8(currentAttributeOffset, charBuffer);</span>
<span class="fc" id="L477">      int attributeLength = readInt(currentAttributeOffset + 2);</span>
<span class="fc" id="L478">      currentAttributeOffset += 6;</span>
      // The tests are sorted in decreasing frequency order (based on frequencies observed on
      // typical classes).
<span class="fc bfc" id="L481" title="All 2 branches covered.">      if (Constants.SOURCE_FILE.equals(attributeName)) {</span>
<span class="fc" id="L482">        sourceFile = readUTF8(currentAttributeOffset, charBuffer);</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">      } else if (Constants.INNER_CLASSES.equals(attributeName)) {</span>
<span class="fc" id="L484">        innerClassesOffset = currentAttributeOffset;</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">      } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {</span>
<span class="nc" id="L486">        enclosingMethodOffset = currentAttributeOffset;</span>
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">      } else if (Constants.NEST_HOST.equals(attributeName)) {</span>
<span class="nc" id="L488">        nestHostClass = readClass(currentAttributeOffset, charBuffer);</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">      } else if (Constants.NEST_MEMBERS.equals(attributeName)) {</span>
<span class="nc" id="L490">        nestMembersOffset = currentAttributeOffset;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">      } else if (Constants.SIGNATURE.equals(attributeName)) {</span>
<span class="fc" id="L492">        signature = readUTF8(currentAttributeOffset, charBuffer);</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="fc" id="L494">        runtimeVisibleAnnotationsOffset = currentAttributeOffset;</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="nc" id="L496">        runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;</span>
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">      } else if (Constants.DEPRECATED.equals(attributeName)) {</span>
<span class="nc" id="L498">        accessFlags |= Opcodes.ACC_DEPRECATED;</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">      } else if (Constants.SYNTHETIC.equals(attributeName)) {</span>
<span class="nc" id="L500">        accessFlags |= Opcodes.ACC_SYNTHETIC;</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">      } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {</span>
<span class="nc" id="L502">        sourceDebugExtension =</span>
<span class="nc" id="L503">            readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);</span>
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="fc" id="L505">        runtimeInvisibleAnnotationsOffset = currentAttributeOffset;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="nc" id="L507">        runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">      } else if (Constants.MODULE.equals(attributeName)) {</span>
<span class="nc" id="L509">        moduleOffset = currentAttributeOffset;</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">      } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {</span>
<span class="nc" id="L511">        moduleMainClass = readClass(currentAttributeOffset, charBuffer);</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">      } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {</span>
<span class="nc" id="L513">        modulePackagesOffset = currentAttributeOffset;</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">      } else if (!Constants.BOOTSTRAP_METHODS.equals(attributeName)) {</span>
        // The BootstrapMethods attribute is read in the constructor.
<span class="nc" id="L516">        Attribute attribute =</span>
<span class="nc" id="L517">            readAttribute(</span>
                attributePrototypes,
                attributeName,
                currentAttributeOffset,
                attributeLength,
                charBuffer,
                -1,
                null);
<span class="nc" id="L525">        attribute.nextAttribute = attributes;</span>
<span class="nc" id="L526">        attributes = attribute;</span>
      }
<span class="fc" id="L528">      currentAttributeOffset += attributeLength;</span>
    }

    // Visit the class declaration. The minor_version and major_version fields start 6 bytes before
    // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).
<span class="fc" id="L533">    classVisitor.visit(</span>
<span class="fc" id="L534">        readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);</span>

    // Visit the SourceFile and SourceDebugExtenstion attributes.
<span class="pc bpc" id="L537" title="3 of 6 branches missed.">    if ((parsingOptions &amp; SKIP_DEBUG) == 0</span>
        &amp;&amp; (sourceFile != null || sourceDebugExtension != null)) {
<span class="fc" id="L539">      classVisitor.visitSource(sourceFile, sourceDebugExtension);</span>
    }

    // Visit the Module, ModulePackages and ModuleMainClass attributes.
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">    if (moduleOffset != 0) {</span>
<span class="nc" id="L544">      readModuleAttributes(</span>
          classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);
    }

    // Visit the NestHost attribute.
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">    if (nestHostClass != null) {</span>
<span class="nc" id="L550">      classVisitor.visitNestHost(nestHostClass);</span>
    }

    // Visit the EnclosingMethod attribute.
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">    if (enclosingMethodOffset != 0) {</span>
<span class="nc" id="L555">      String className = readClass(enclosingMethodOffset, charBuffer);</span>
<span class="nc" id="L556">      int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">      String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">      String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);</span>
<span class="nc" id="L559">      classVisitor.visitOuterClass(className, name, type);</span>
    }

    // Visit the RuntimeVisibleAnnotations attribute.
<span class="fc bfc" id="L563" title="All 2 branches covered.">    if (runtimeVisibleAnnotationsOffset != 0) {</span>
<span class="fc" id="L564">      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);</span>
<span class="fc" id="L565">      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the type_index field.
<span class="fc" id="L568">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="fc" id="L569">        currentAnnotationOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="fc" id="L571">        currentAnnotationOffset =</span>
<span class="fc" id="L572">            readElementValues(</span>
<span class="fc" id="L573">                classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),</span>
                currentAnnotationOffset,
                /* named = */ true,
                charBuffer);
<span class="fc" id="L577">      }</span>
    }

    // Visit the RuntimeInvisibleAnnotations attribute.
<span class="fc bfc" id="L581" title="All 2 branches covered.">    if (runtimeInvisibleAnnotationsOffset != 0) {</span>
<span class="fc" id="L582">      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);</span>
<span class="fc" id="L583">      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the type_index field.
<span class="fc" id="L586">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="fc" id="L587">        currentAnnotationOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="fc" id="L589">        currentAnnotationOffset =</span>
<span class="fc" id="L590">            readElementValues(</span>
<span class="fc" id="L591">                classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),</span>
                currentAnnotationOffset,
                /* named = */ true,
                charBuffer);
<span class="fc" id="L595">      }</span>
    }

    // Visit the RuntimeVisibleTypeAnnotations attribute.
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">    if (runtimeVisibleTypeAnnotationsOffset != 0) {</span>
<span class="nc" id="L600">      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);</span>
<span class="nc" id="L601">      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the target_type, target_info and target_path fields.
<span class="nc" id="L604">        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span>
        // Parse the type_index field.
<span class="nc" id="L606">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="nc" id="L607">        currentAnnotationOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L609">        currentAnnotationOffset =</span>
<span class="nc" id="L610">            readElementValues(</span>
<span class="nc" id="L611">                classVisitor.visitTypeAnnotation(</span>
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible = */ true),
                currentAnnotationOffset,
                /* named = */ true,
                charBuffer);
<span class="nc" id="L619">      }</span>
    }

    // Visit the RuntimeInvisibleTypeAnnotations attribute.
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">    if (runtimeInvisibleTypeAnnotationsOffset != 0) {</span>
<span class="nc" id="L624">      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);</span>
<span class="nc" id="L625">      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the target_type, target_info and target_path fields.
<span class="nc" id="L628">        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span>
        // Parse the type_index field.
<span class="nc" id="L630">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="nc" id="L631">        currentAnnotationOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L633">        currentAnnotationOffset =</span>
<span class="nc" id="L634">            readElementValues(</span>
<span class="nc" id="L635">                classVisitor.visitTypeAnnotation(</span>
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible = */ false),
                currentAnnotationOffset,
                /* named = */ true,
                charBuffer);
<span class="nc" id="L643">      }</span>
    }

    // Visit the non standard attributes.
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">    while (attributes != null) {</span>
      // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.
<span class="nc" id="L649">      Attribute nextAttribute = attributes.nextAttribute;</span>
<span class="nc" id="L650">      attributes.nextAttribute = null;</span>
<span class="nc" id="L651">      classVisitor.visitAttribute(attributes);</span>
<span class="nc" id="L652">      attributes = nextAttribute;</span>
<span class="nc" id="L653">    }</span>

    // Visit the NestedMembers attribute.
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">    if (nestMembersOffset != 0) {</span>
<span class="nc" id="L657">      int numberOfNestMembers = readUnsignedShort(nestMembersOffset);</span>
<span class="nc" id="L658">      int currentNestMemberOffset = nestMembersOffset + 2;</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">      while (numberOfNestMembers-- &gt; 0) {</span>
<span class="nc" id="L660">        classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));</span>
<span class="nc" id="L661">        currentNestMemberOffset += 2;</span>
      }
    }

    // Visit the InnerClasses attribute.
<span class="fc bfc" id="L666" title="All 2 branches covered.">    if (innerClassesOffset != 0) {</span>
<span class="fc" id="L667">      int numberOfClasses = readUnsignedShort(innerClassesOffset);</span>
<span class="fc" id="L668">      int currentClassesOffset = innerClassesOffset + 2;</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">      while (numberOfClasses-- &gt; 0) {</span>
<span class="fc" id="L670">        classVisitor.visitInnerClass(</span>
<span class="fc" id="L671">            readClass(currentClassesOffset, charBuffer),</span>
<span class="fc" id="L672">            readClass(currentClassesOffset + 2, charBuffer),</span>
<span class="fc" id="L673">            readUTF8(currentClassesOffset + 4, charBuffer),</span>
<span class="fc" id="L674">            readUnsignedShort(currentClassesOffset + 6));</span>
<span class="fc" id="L675">        currentClassesOffset += 8;</span>
      }
    }

    // Visit the fields and methods.
<span class="fc" id="L680">    int fieldsCount = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L681">    currentOffset += 2;</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">    while (fieldsCount-- &gt; 0) {</span>
<span class="fc" id="L683">      currentOffset = readField(classVisitor, context, currentOffset);</span>
    }
<span class="fc" id="L685">    int methodsCount = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L686">    currentOffset += 2;</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">    while (methodsCount-- &gt; 0) {</span>
<span class="fc" id="L688">      currentOffset = readMethod(classVisitor, context, currentOffset);</span>
    }

    // Visit the end of the class.
<span class="fc" id="L692">    classVisitor.visitEnd();</span>
<span class="fc" id="L693">  }</span>

  // ----------------------------------------------------------------------------------------------
  // Methods to parse modules, fields and methods
  // ----------------------------------------------------------------------------------------------

  /**
   * Reads the Module, ModulePackages and ModuleMainClass attributes and visit them.
   *
   * @param classVisitor the current class visitor
   * @param context information about the class being parsed.
   * @param moduleOffset the offset of the Module attribute (excluding the attribute_info's
   *     attribute_name_index and attribute_length fields).
   * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the
   *     attribute_info's attribute_name_index and attribute_length fields), or 0.
   * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal
   *     null}.
   */
  private void readModuleAttributes(
      final ClassVisitor classVisitor,
      final Context context,
      final int moduleOffset,
      final int modulePackagesOffset,
      final String moduleMainClass) {
<span class="nc" id="L717">    char[] buffer = context.charBuffer;</span>

    // Read the module_name_index, module_flags and module_version_index fields and visit them.
<span class="nc" id="L720">    int currentOffset = moduleOffset;</span>
<span class="nc" id="L721">    String moduleName = readModule(currentOffset, buffer);</span>
<span class="nc" id="L722">    int moduleFlags = readUnsignedShort(currentOffset + 2);</span>
<span class="nc" id="L723">    String moduleVersion = readUTF8(currentOffset + 4, buffer);</span>
<span class="nc" id="L724">    currentOffset += 6;</span>
<span class="nc" id="L725">    ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">    if (moduleVisitor == null) {</span>
<span class="nc" id="L727">      return;</span>
    }

    // Visit the ModuleMainClass attribute.
<span class="nc bnc" id="L731" title="All 2 branches missed.">    if (moduleMainClass != null) {</span>
<span class="nc" id="L732">      moduleVisitor.visitMainClass(moduleMainClass);</span>
    }

    // Visit the ModulePackages attribute.
<span class="nc bnc" id="L736" title="All 2 branches missed.">    if (modulePackagesOffset != 0) {</span>
<span class="nc" id="L737">      int packageCount = readUnsignedShort(modulePackagesOffset);</span>
<span class="nc" id="L738">      int currentPackageOffset = modulePackagesOffset + 2;</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">      while (packageCount-- &gt; 0) {</span>
<span class="nc" id="L740">        moduleVisitor.visitPackage(readPackage(currentPackageOffset, buffer));</span>
<span class="nc" id="L741">        currentPackageOffset += 2;</span>
      }
    }

    // Read the 'requires_count' and 'requires' fields.
<span class="nc" id="L746">    int requiresCount = readUnsignedShort(currentOffset);</span>
<span class="nc" id="L747">    currentOffset += 2;</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">    while (requiresCount-- &gt; 0) {</span>
      // Read the requires_index, requires_flags and requires_version fields and visit them.
<span class="nc" id="L750">      String requires = readModule(currentOffset, buffer);</span>
<span class="nc" id="L751">      int requiresFlags = readUnsignedShort(currentOffset + 2);</span>
<span class="nc" id="L752">      String requiresVersion = readUTF8(currentOffset + 4, buffer);</span>
<span class="nc" id="L753">      currentOffset += 6;</span>
<span class="nc" id="L754">      moduleVisitor.visitRequire(requires, requiresFlags, requiresVersion);</span>
<span class="nc" id="L755">    }</span>

    // Read the 'exports_count' and 'exports' fields.
<span class="nc" id="L758">    int exportsCount = readUnsignedShort(currentOffset);</span>
<span class="nc" id="L759">    currentOffset += 2;</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">    while (exportsCount-- &gt; 0) {</span>
      // Read the exports_index, exports_flags, exports_to_count and exports_to_index fields
      // and visit them.
<span class="nc" id="L763">      String exports = readPackage(currentOffset, buffer);</span>
<span class="nc" id="L764">      int exportsFlags = readUnsignedShort(currentOffset + 2);</span>
<span class="nc" id="L765">      int exportsToCount = readUnsignedShort(currentOffset + 4);</span>
<span class="nc" id="L766">      currentOffset += 6;</span>
<span class="nc" id="L767">      String[] exportsTo = null;</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">      if (exportsToCount != 0) {</span>
<span class="nc" id="L769">        exportsTo = new String[exportsToCount];</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">        for (int i = 0; i &lt; exportsToCount; ++i) {</span>
<span class="nc" id="L771">          exportsTo[i] = readModule(currentOffset, buffer);</span>
<span class="nc" id="L772">          currentOffset += 2;</span>
        }
      }
<span class="nc" id="L775">      moduleVisitor.visitExport(exports, exportsFlags, exportsTo);</span>
<span class="nc" id="L776">    }</span>

    // Reads the 'opens_count' and 'opens' fields.
<span class="nc" id="L779">    int opensCount = readUnsignedShort(currentOffset);</span>
<span class="nc" id="L780">    currentOffset += 2;</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">    while (opensCount-- &gt; 0) {</span>
      // Read the opens_index, opens_flags, opens_to_count and opens_to_index fields and visit them.
<span class="nc" id="L783">      String opens = readPackage(currentOffset, buffer);</span>
<span class="nc" id="L784">      int opensFlags = readUnsignedShort(currentOffset + 2);</span>
<span class="nc" id="L785">      int opensToCount = readUnsignedShort(currentOffset + 4);</span>
<span class="nc" id="L786">      currentOffset += 6;</span>
<span class="nc" id="L787">      String[] opensTo = null;</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">      if (opensToCount != 0) {</span>
<span class="nc" id="L789">        opensTo = new String[opensToCount];</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">        for (int i = 0; i &lt; opensToCount; ++i) {</span>
<span class="nc" id="L791">          opensTo[i] = readModule(currentOffset, buffer);</span>
<span class="nc" id="L792">          currentOffset += 2;</span>
        }
      }
<span class="nc" id="L795">      moduleVisitor.visitOpen(opens, opensFlags, opensTo);</span>
<span class="nc" id="L796">    }</span>

    // Read the 'uses_count' and 'uses' fields.
<span class="nc" id="L799">    int usesCount = readUnsignedShort(currentOffset);</span>
<span class="nc" id="L800">    currentOffset += 2;</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">    while (usesCount-- &gt; 0) {</span>
<span class="nc" id="L802">      moduleVisitor.visitUse(readClass(currentOffset, buffer));</span>
<span class="nc" id="L803">      currentOffset += 2;</span>
    }

    // Read the  'provides_count' and 'provides' fields.
<span class="nc" id="L807">    int providesCount = readUnsignedShort(currentOffset);</span>
<span class="nc" id="L808">    currentOffset += 2;</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">    while (providesCount-- &gt; 0) {</span>
      // Read the provides_index, provides_with_count and provides_with_index fields and visit them.
<span class="nc" id="L811">      String provides = readClass(currentOffset, buffer);</span>
<span class="nc" id="L812">      int providesWithCount = readUnsignedShort(currentOffset + 2);</span>
<span class="nc" id="L813">      currentOffset += 4;</span>
<span class="nc" id="L814">      String[] providesWith = new String[providesWithCount];</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">      for (int i = 0; i &lt; providesWithCount; ++i) {</span>
<span class="nc" id="L816">        providesWith[i] = readClass(currentOffset, buffer);</span>
<span class="nc" id="L817">        currentOffset += 2;</span>
      }
<span class="nc" id="L819">      moduleVisitor.visitProvide(provides, providesWith);</span>
<span class="nc" id="L820">    }</span>

    // Visit the end of the module attributes.
<span class="nc" id="L823">    moduleVisitor.visitEnd();</span>
<span class="nc" id="L824">  }</span>

  /**
   * Reads a JVMS field_info structure and makes the given visitor visit it.
   *
   * @param classVisitor the visitor that must visit the field.
   * @param context information about the class being parsed.
   * @param fieldInfoOffset the start offset of the field_info structure.
   * @return the offset of the first byte following the field_info structure.
   */
  private int readField(
      final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {
<span class="fc" id="L836">    char[] charBuffer = context.charBuffer;</span>

    // Read the access_flags, name_index and descriptor_index fields.
<span class="fc" id="L839">    int currentOffset = fieldInfoOffset;</span>
<span class="fc" id="L840">    int accessFlags = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L841">    String name = readUTF8(currentOffset + 2, charBuffer);</span>
<span class="fc" id="L842">    String descriptor = readUTF8(currentOffset + 4, charBuffer);</span>
<span class="fc" id="L843">    currentOffset += 6;</span>

    // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).
    // Attribute offsets exclude the attribute_name_index and attribute_length fields.
    // - The value corresponding to the ConstantValue attribute, or null.
<span class="fc" id="L848">    Object constantValue = null;</span>
    // - The string corresponding to the Signature attribute, or null.
<span class="fc" id="L850">    String signature = null;</span>
    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
<span class="fc" id="L852">    int runtimeVisibleAnnotationsOffset = 0;</span>
    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
<span class="fc" id="L854">    int runtimeInvisibleAnnotationsOffset = 0;</span>
    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
<span class="fc" id="L856">    int runtimeVisibleTypeAnnotationsOffset = 0;</span>
    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
<span class="fc" id="L858">    int runtimeInvisibleTypeAnnotationsOffset = 0;</span>
    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
    //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
<span class="fc" id="L861">    Attribute attributes = null;</span>

<span class="fc" id="L863">    int attributesCount = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L864">    currentOffset += 2;</span>
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">    while (attributesCount-- &gt; 0) {</span>
      // Read the attribute_info's attribute_name and attribute_length fields.
<span class="nc" id="L867">      String attributeName = readUTF8(currentOffset, charBuffer);</span>
<span class="nc" id="L868">      int attributeLength = readInt(currentOffset + 2);</span>
<span class="nc" id="L869">      currentOffset += 6;</span>
      // The tests are sorted in decreasing frequency order (based on frequencies observed on
      // typical classes).
<span class="nc bnc" id="L872" title="All 2 branches missed.">      if (Constants.CONSTANT_VALUE.equals(attributeName)) {</span>
<span class="nc" id="L873">        int constantvalueIndex = readUnsignedShort(currentOffset);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">        constantValue = constantvalueIndex == 0 ? null : readConst(constantvalueIndex, charBuffer);</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">      } else if (Constants.SIGNATURE.equals(attributeName)) {</span>
<span class="nc" id="L876">        signature = readUTF8(currentOffset, charBuffer);</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">      } else if (Constants.DEPRECATED.equals(attributeName)) {</span>
<span class="nc" id="L878">        accessFlags |= Opcodes.ACC_DEPRECATED;</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">      } else if (Constants.SYNTHETIC.equals(attributeName)) {</span>
<span class="nc" id="L880">        accessFlags |= Opcodes.ACC_SYNTHETIC;</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="nc" id="L882">        runtimeVisibleAnnotationsOffset = currentOffset;</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="nc" id="L884">        runtimeVisibleTypeAnnotationsOffset = currentOffset;</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="nc" id="L886">        runtimeInvisibleAnnotationsOffset = currentOffset;</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="nc" id="L888">        runtimeInvisibleTypeAnnotationsOffset = currentOffset;</span>
      } else {
<span class="nc" id="L890">        Attribute attribute =</span>
<span class="nc" id="L891">            readAttribute(</span>
                context.attributePrototypes,
                attributeName,
                currentOffset,
                attributeLength,
                charBuffer,
                -1,
                null);
<span class="nc" id="L899">        attribute.nextAttribute = attributes;</span>
<span class="nc" id="L900">        attributes = attribute;</span>
      }
<span class="nc" id="L902">      currentOffset += attributeLength;</span>
<span class="nc" id="L903">    }</span>

    // Visit the field declaration.
<span class="fc" id="L906">    FieldVisitor fieldVisitor =</span>
<span class="fc" id="L907">        classVisitor.visitField(accessFlags, name, descriptor, signature, constantValue);</span>
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">    if (fieldVisitor == null) {</span>
<span class="fc" id="L909">      return currentOffset;</span>
    }

    // Visit the RuntimeVisibleAnnotations attribute.
<span class="nc bnc" id="L913" title="All 2 branches missed.">    if (runtimeVisibleAnnotationsOffset != 0) {</span>
<span class="nc" id="L914">      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);</span>
<span class="nc" id="L915">      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the type_index field.
<span class="nc" id="L918">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="nc" id="L919">        currentAnnotationOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L921">        currentAnnotationOffset =</span>
<span class="nc" id="L922">            readElementValues(</span>
<span class="nc" id="L923">                fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),</span>
                currentAnnotationOffset,
                /* named = */ true,
                charBuffer);
<span class="nc" id="L927">      }</span>
    }

    // Visit the RuntimeInvisibleAnnotations attribute.
<span class="nc bnc" id="L931" title="All 2 branches missed.">    if (runtimeInvisibleAnnotationsOffset != 0) {</span>
<span class="nc" id="L932">      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);</span>
<span class="nc" id="L933">      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the type_index field.
<span class="nc" id="L936">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="nc" id="L937">        currentAnnotationOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L939">        currentAnnotationOffset =</span>
<span class="nc" id="L940">            readElementValues(</span>
<span class="nc" id="L941">                fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),</span>
                currentAnnotationOffset,
                /* named = */ true,
                charBuffer);
<span class="nc" id="L945">      }</span>
    }

    // Visit the RuntimeVisibleTypeAnnotations attribute.
<span class="nc bnc" id="L949" title="All 2 branches missed.">    if (runtimeVisibleTypeAnnotationsOffset != 0) {</span>
<span class="nc" id="L950">      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);</span>
<span class="nc" id="L951">      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the target_type, target_info and target_path fields.
<span class="nc" id="L954">        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span>
        // Parse the type_index field.
<span class="nc" id="L956">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="nc" id="L957">        currentAnnotationOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L959">        currentAnnotationOffset =</span>
<span class="nc" id="L960">            readElementValues(</span>
<span class="nc" id="L961">                fieldVisitor.visitTypeAnnotation(</span>
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible = */ true),
                currentAnnotationOffset,
                /* named = */ true,
                charBuffer);
<span class="nc" id="L969">      }</span>
    }

    // Visit the RuntimeInvisibleTypeAnnotations attribute.
<span class="nc bnc" id="L973" title="All 2 branches missed.">    if (runtimeInvisibleTypeAnnotationsOffset != 0) {</span>
<span class="nc" id="L974">      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);</span>
<span class="nc" id="L975">      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the target_type, target_info and target_path fields.
<span class="nc" id="L978">        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span>
        // Parse the type_index field.
<span class="nc" id="L980">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="nc" id="L981">        currentAnnotationOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L983">        currentAnnotationOffset =</span>
<span class="nc" id="L984">            readElementValues(</span>
<span class="nc" id="L985">                fieldVisitor.visitTypeAnnotation(</span>
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible = */ false),
                currentAnnotationOffset,
                /* named = */ true,
                charBuffer);
<span class="nc" id="L993">      }</span>
    }

    // Visit the non standard attributes.
<span class="nc bnc" id="L997" title="All 2 branches missed.">    while (attributes != null) {</span>
      // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.
<span class="nc" id="L999">      Attribute nextAttribute = attributes.nextAttribute;</span>
<span class="nc" id="L1000">      attributes.nextAttribute = null;</span>
<span class="nc" id="L1001">      fieldVisitor.visitAttribute(attributes);</span>
<span class="nc" id="L1002">      attributes = nextAttribute;</span>
<span class="nc" id="L1003">    }</span>

    // Visit the end of the field.
<span class="nc" id="L1006">    fieldVisitor.visitEnd();</span>
<span class="nc" id="L1007">    return currentOffset;</span>
  }

  /**
   * Reads a JVMS method_info structure and makes the given visitor visit it.
   *
   * @param classVisitor the visitor that must visit the method.
   * @param context information about the class being parsed.
   * @param methodInfoOffset the start offset of the method_info structure.
   * @return the offset of the first byte following the method_info structure.
   */
  private int readMethod(
      final ClassVisitor classVisitor, final Context context, final int methodInfoOffset) {
<span class="fc" id="L1020">    char[] charBuffer = context.charBuffer;</span>

    // Read the access_flags, name_index and descriptor_index fields.
<span class="fc" id="L1023">    int currentOffset = methodInfoOffset;</span>
<span class="fc" id="L1024">    context.currentMethodAccessFlags = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L1025">    context.currentMethodName = readUTF8(currentOffset + 2, charBuffer);</span>
<span class="fc" id="L1026">    context.currentMethodDescriptor = readUTF8(currentOffset + 4, charBuffer);</span>
<span class="fc" id="L1027">    currentOffset += 6;</span>

    // Read the method attributes (the variables are ordered as in Section 4.7 of the JVMS).
    // Attribute offsets exclude the attribute_name_index and attribute_length fields.
    // - The offset of the Code attribute, or 0.
<span class="fc" id="L1032">    int codeOffset = 0;</span>
    // - The offset of the Exceptions attribute, or 0.
<span class="fc" id="L1034">    int exceptionsOffset = 0;</span>
    // - The strings corresponding to the Exceptions attribute, or null.
<span class="fc" id="L1036">    String[] exceptions = null;</span>
    // - Whether the method has a Synthetic attribute.
<span class="fc" id="L1038">    boolean synthetic = false;</span>
    // - The constant pool index contained in the Signature attribute, or 0.
<span class="fc" id="L1040">    int signatureIndex = 0;</span>
    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
<span class="fc" id="L1042">    int runtimeVisibleAnnotationsOffset = 0;</span>
    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
<span class="fc" id="L1044">    int runtimeInvisibleAnnotationsOffset = 0;</span>
    // - The offset of the RuntimeVisibleParameterAnnotations attribute, or 0.
<span class="fc" id="L1046">    int runtimeVisibleParameterAnnotationsOffset = 0;</span>
    // - The offset of the RuntimeInvisibleParameterAnnotations attribute, or 0.
<span class="fc" id="L1048">    int runtimeInvisibleParameterAnnotationsOffset = 0;</span>
    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
<span class="fc" id="L1050">    int runtimeVisibleTypeAnnotationsOffset = 0;</span>
    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
<span class="fc" id="L1052">    int runtimeInvisibleTypeAnnotationsOffset = 0;</span>
    // - The offset of the AnnotationDefault attribute, or 0.
<span class="fc" id="L1054">    int annotationDefaultOffset = 0;</span>
    // - The offset of the MethodParameters attribute, or 0.
<span class="fc" id="L1056">    int methodParametersOffset = 0;</span>
    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
    //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
<span class="fc" id="L1059">    Attribute attributes = null;</span>

<span class="fc" id="L1061">    int attributesCount = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L1062">    currentOffset += 2;</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">    while (attributesCount-- &gt; 0) {</span>
      // Read the attribute_info's attribute_name and attribute_length fields.
<span class="fc" id="L1065">      String attributeName = readUTF8(currentOffset, charBuffer);</span>
<span class="fc" id="L1066">      int attributeLength = readInt(currentOffset + 2);</span>
<span class="fc" id="L1067">      currentOffset += 6;</span>
      // The tests are sorted in decreasing frequency order (based on frequencies observed on
      // typical classes).
<span class="fc bfc" id="L1070" title="All 2 branches covered.">      if (Constants.CODE.equals(attributeName)) {</span>
<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">        if ((context.parsingOptions &amp; SKIP_CODE) == 0) {</span>
<span class="fc" id="L1072">          codeOffset = currentOffset;</span>
        }
<span class="fc bfc" id="L1074" title="All 2 branches covered.">      } else if (Constants.EXCEPTIONS.equals(attributeName)) {</span>
<span class="fc" id="L1075">        exceptionsOffset = currentOffset;</span>
<span class="fc" id="L1076">        exceptions = new String[readUnsignedShort(exceptionsOffset)];</span>
<span class="fc" id="L1077">        int currentExceptionOffset = exceptionsOffset + 2;</span>
<span class="fc bfc" id="L1078" title="All 2 branches covered.">        for (int i = 0; i &lt; exceptions.length; ++i) {</span>
<span class="fc" id="L1079">          exceptions[i] = readClass(currentExceptionOffset, charBuffer);</span>
<span class="fc" id="L1080">          currentExceptionOffset += 2;</span>
        }
<span class="fc bfc" id="L1082" title="All 2 branches covered.">      } else if (Constants.SIGNATURE.equals(attributeName)) {</span>
<span class="fc" id="L1083">        signatureIndex = readUnsignedShort(currentOffset);</span>
<span class="pc bpc" id="L1084" title="1 of 2 branches missed.">      } else if (Constants.DEPRECATED.equals(attributeName)) {</span>
<span class="nc" id="L1085">        context.currentMethodAccessFlags |= Opcodes.ACC_DEPRECATED;</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="fc" id="L1087">        runtimeVisibleAnnotationsOffset = currentOffset;</span>
<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="nc" id="L1089">        runtimeVisibleTypeAnnotationsOffset = currentOffset;</span>
<span class="fc bfc" id="L1090" title="All 2 branches covered.">      } else if (Constants.ANNOTATION_DEFAULT.equals(attributeName)) {</span>
<span class="fc" id="L1091">        annotationDefaultOffset = currentOffset;</span>
<span class="pc bpc" id="L1092" title="1 of 2 branches missed.">      } else if (Constants.SYNTHETIC.equals(attributeName)) {</span>
<span class="nc" id="L1093">        synthetic = true;</span>
<span class="nc" id="L1094">        context.currentMethodAccessFlags |= Opcodes.ACC_SYNTHETIC;</span>
<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="nc" id="L1096">        runtimeInvisibleAnnotationsOffset = currentOffset;</span>
<span class="pc bpc" id="L1097" title="1 of 2 branches missed.">      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="nc" id="L1098">        runtimeInvisibleTypeAnnotationsOffset = currentOffset;</span>
<span class="fc bfc" id="L1099" title="All 2 branches covered.">      } else if (Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {</span>
<span class="fc" id="L1100">        runtimeVisibleParameterAnnotationsOffset = currentOffset;</span>
<span class="pc bpc" id="L1101" title="1 of 2 branches missed.">      } else if (Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {</span>
<span class="nc" id="L1102">        runtimeInvisibleParameterAnnotationsOffset = currentOffset;</span>
<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">      } else if (Constants.METHOD_PARAMETERS.equals(attributeName)) {</span>
<span class="fc" id="L1104">        methodParametersOffset = currentOffset;</span>
      } else {
<span class="nc" id="L1106">        Attribute attribute =</span>
<span class="nc" id="L1107">            readAttribute(</span>
                context.attributePrototypes,
                attributeName,
                currentOffset,
                attributeLength,
                charBuffer,
                -1,
                null);
<span class="nc" id="L1115">        attribute.nextAttribute = attributes;</span>
<span class="nc" id="L1116">        attributes = attribute;</span>
      }
<span class="fc" id="L1118">      currentOffset += attributeLength;</span>
<span class="fc" id="L1119">    }</span>

    // Visit the method declaration.
<span class="fc bfc" id="L1122" title="All 2 branches covered.">    MethodVisitor methodVisitor =</span>
<span class="fc" id="L1123">        classVisitor.visitMethod(</span>
            context.currentMethodAccessFlags,
            context.currentMethodName,
            context.currentMethodDescriptor,
<span class="fc" id="L1127">            signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer),</span>
            exceptions);
<span class="fc bfc" id="L1129" title="All 2 branches covered.">    if (methodVisitor == null) {</span>
<span class="fc" id="L1130">      return currentOffset;</span>
    }

    // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method
    // adapter between the reader and the writer. In this case, it might be possible to copy
    // the method attributes directly into the writer. If so, return early without visiting
    // the content of these attributes.
<span class="pc bpc" id="L1137" title="1 of 2 branches missed.">    if (methodVisitor instanceof MethodWriter) {</span>
<span class="nc" id="L1138">      MethodWriter methodWriter = (MethodWriter) methodVisitor;</span>
<span class="nc bnc" id="L1139" title="All 4 branches missed.">      if (methodWriter.canCopyMethodAttributes(</span>
          this,
          synthetic,
          (context.currentMethodAccessFlags &amp; Opcodes.ACC_DEPRECATED) != 0,
<span class="nc" id="L1143">          readUnsignedShort(methodInfoOffset + 4),</span>
          signatureIndex,
          exceptionsOffset)) {
<span class="nc" id="L1146">        methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);</span>
<span class="nc" id="L1147">        return currentOffset;</span>
      }
    }

    // Visit the MethodParameters attribute.
<span class="fc bfc" id="L1152" title="All 2 branches covered.">    if (methodParametersOffset != 0) {</span>
<span class="fc" id="L1153">      int parametersCount = readByte(methodParametersOffset);</span>
<span class="fc" id="L1154">      int currentParameterOffset = methodParametersOffset + 1;</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">      while (parametersCount-- &gt; 0) {</span>
        // Read the name_index and access_flags fields and visit them.
<span class="fc" id="L1157">        methodVisitor.visitParameter(</span>
<span class="fc" id="L1158">            readUTF8(currentParameterOffset, charBuffer),</span>
<span class="fc" id="L1159">            readUnsignedShort(currentParameterOffset + 2));</span>
<span class="fc" id="L1160">        currentParameterOffset += 4;</span>
      }
    }

    // Visit the AnnotationDefault attribute.
<span class="fc bfc" id="L1165" title="All 2 branches covered.">    if (annotationDefaultOffset != 0) {</span>
<span class="fc" id="L1166">      AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();</span>
<span class="fc" id="L1167">      readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);</span>
<span class="pc bpc" id="L1168" title="1 of 2 branches missed.">      if (annotationVisitor != null) {</span>
<span class="nc" id="L1169">        annotationVisitor.visitEnd();</span>
      }
    }

    // Visit the RuntimeVisibleAnnotations attribute.
<span class="fc bfc" id="L1174" title="All 2 branches covered.">    if (runtimeVisibleAnnotationsOffset != 0) {</span>
<span class="fc" id="L1175">      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);</span>
<span class="fc" id="L1176">      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;</span>
<span class="fc bfc" id="L1177" title="All 2 branches covered.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the type_index field.
<span class="fc" id="L1179">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="fc" id="L1180">        currentAnnotationOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="fc" id="L1182">        currentAnnotationOffset =</span>
<span class="fc" id="L1183">            readElementValues(</span>
<span class="fc" id="L1184">                methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),</span>
                currentAnnotationOffset,
                /* named = */ true,
                charBuffer);
<span class="fc" id="L1188">      }</span>
    }

    // Visit the RuntimeInvisibleAnnotations attribute.
<span class="pc bpc" id="L1192" title="1 of 2 branches missed.">    if (runtimeInvisibleAnnotationsOffset != 0) {</span>
<span class="nc" id="L1193">      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);</span>
<span class="nc" id="L1194">      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the type_index field.
<span class="nc" id="L1197">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="nc" id="L1198">        currentAnnotationOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L1200">        currentAnnotationOffset =</span>
<span class="nc" id="L1201">            readElementValues(</span>
<span class="nc" id="L1202">                methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),</span>
                currentAnnotationOffset,
                /* named = */ true,
                charBuffer);
<span class="nc" id="L1206">      }</span>
    }

    // Visit the RuntimeVisibleTypeAnnotations attribute.
<span class="pc bpc" id="L1210" title="1 of 2 branches missed.">    if (runtimeVisibleTypeAnnotationsOffset != 0) {</span>
<span class="nc" id="L1211">      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);</span>
<span class="nc" id="L1212">      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the target_type, target_info and target_path fields.
<span class="nc" id="L1215">        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span>
        // Parse the type_index field.
<span class="nc" id="L1217">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="nc" id="L1218">        currentAnnotationOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L1220">        currentAnnotationOffset =</span>
<span class="nc" id="L1221">            readElementValues(</span>
<span class="nc" id="L1222">                methodVisitor.visitTypeAnnotation(</span>
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible = */ true),
                currentAnnotationOffset,
                /* named = */ true,
                charBuffer);
<span class="nc" id="L1230">      }</span>
    }

    // Visit the RuntimeInvisibleTypeAnnotations attribute.
<span class="pc bpc" id="L1234" title="1 of 2 branches missed.">    if (runtimeInvisibleTypeAnnotationsOffset != 0) {</span>
<span class="nc" id="L1235">      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);</span>
<span class="nc" id="L1236">      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the target_type, target_info and target_path fields.
<span class="nc" id="L1239">        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span>
        // Parse the type_index field.
<span class="nc" id="L1241">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="nc" id="L1242">        currentAnnotationOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L1244">        currentAnnotationOffset =</span>
<span class="nc" id="L1245">            readElementValues(</span>
<span class="nc" id="L1246">                methodVisitor.visitTypeAnnotation(</span>
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible = */ false),
                currentAnnotationOffset,
                /* named = */ true,
                charBuffer);
<span class="nc" id="L1254">      }</span>
    }

    // Visit the RuntimeVisibleParameterAnnotations attribute.
<span class="fc bfc" id="L1258" title="All 2 branches covered.">    if (runtimeVisibleParameterAnnotationsOffset != 0) {</span>
<span class="fc" id="L1259">      readParameterAnnotations(</span>
          methodVisitor, context, runtimeVisibleParameterAnnotationsOffset, /* visible = */ true);
    }

    // Visit the RuntimeInvisibleParameterAnnotations attribute.
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">    if (runtimeInvisibleParameterAnnotationsOffset != 0) {</span>
<span class="nc" id="L1265">      readParameterAnnotations(</span>
          methodVisitor,
          context,
          runtimeInvisibleParameterAnnotationsOffset,
          /* visible = */ false);
    }

    // Visit the non standard attributes.
<span class="pc bpc" id="L1273" title="1 of 2 branches missed.">    while (attributes != null) {</span>
      // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.
<span class="nc" id="L1275">      Attribute nextAttribute = attributes.nextAttribute;</span>
<span class="nc" id="L1276">      attributes.nextAttribute = null;</span>
<span class="nc" id="L1277">      methodVisitor.visitAttribute(attributes);</span>
<span class="nc" id="L1278">      attributes = nextAttribute;</span>
<span class="nc" id="L1279">    }</span>

    // Visit the Code attribute.
<span class="fc bfc" id="L1282" title="All 2 branches covered.">    if (codeOffset != 0) {</span>
<span class="fc" id="L1283">      methodVisitor.visitCode();</span>
<span class="fc" id="L1284">      readCode(methodVisitor, context, codeOffset);</span>
    }

    // Visit the end of the method.
<span class="fc" id="L1288">    methodVisitor.visitEnd();</span>
<span class="fc" id="L1289">    return currentOffset;</span>
  }

  // ----------------------------------------------------------------------------------------------
  // Methods to parse a Code attribute
  // ----------------------------------------------------------------------------------------------

  /**
   * Reads a JVMS 'Code' attribute and makes the given visitor visit it.
   *
   * @param methodVisitor the visitor that must visit the Code attribute.
   * @param context information about the class being parsed.
   * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding
   *     its attribute_name_index and attribute_length fields.
   */
  private void readCode(
      final MethodVisitor methodVisitor, final Context context, final int codeOffset) {
<span class="fc" id="L1306">    int currentOffset = codeOffset;</span>

    // Read the max_stack, max_locals and code_length fields.
<span class="fc" id="L1309">    final byte[] classBuffer = classFileBuffer;</span>
<span class="fc" id="L1310">    final char[] charBuffer = context.charBuffer;</span>
<span class="fc" id="L1311">    final int maxStack = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L1312">    final int maxLocals = readUnsignedShort(currentOffset + 2);</span>
<span class="fc" id="L1313">    final int codeLength = readInt(currentOffset + 4);</span>
<span class="fc" id="L1314">    currentOffset += 8;</span>

    // Read the bytecode 'code' array to create a label for each referenced instruction.
<span class="fc" id="L1317">    final int bytecodeStartOffset = currentOffset;</span>
<span class="fc" id="L1318">    final int bytecodeEndOffset = currentOffset + codeLength;</span>
<span class="fc" id="L1319">    final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];</span>
<span class="fc bfc" id="L1320" title="All 2 branches covered.">    while (currentOffset &lt; bytecodeEndOffset) {</span>
<span class="fc" id="L1321">      final int bytecodeOffset = currentOffset - bytecodeStartOffset;</span>
<span class="fc" id="L1322">      final int opcode = classBuffer[currentOffset] &amp; 0xFF;</span>
<span class="pc bpc" id="L1323" title="8 of 12 branches missed.">      switch (opcode) {</span>
        case Constants.NOP:
        case Constants.ACONST_NULL:
        case Constants.ICONST_M1:
        case Constants.ICONST_0:
        case Constants.ICONST_1:
        case Constants.ICONST_2:
        case Constants.ICONST_3:
        case Constants.ICONST_4:
        case Constants.ICONST_5:
        case Constants.LCONST_0:
        case Constants.LCONST_1:
        case Constants.FCONST_0:
        case Constants.FCONST_1:
        case Constants.FCONST_2:
        case Constants.DCONST_0:
        case Constants.DCONST_1:
        case Constants.IALOAD:
        case Constants.LALOAD:
        case Constants.FALOAD:
        case Constants.DALOAD:
        case Constants.AALOAD:
        case Constants.BALOAD:
        case Constants.CALOAD:
        case Constants.SALOAD:
        case Constants.IASTORE:
        case Constants.LASTORE:
        case Constants.FASTORE:
        case Constants.DASTORE:
        case Constants.AASTORE:
        case Constants.BASTORE:
        case Constants.CASTORE:
        case Constants.SASTORE:
        case Constants.POP:
        case Constants.POP2:
        case Constants.DUP:
        case Constants.DUP_X1:
        case Constants.DUP_X2:
        case Constants.DUP2:
        case Constants.DUP2_X1:
        case Constants.DUP2_X2:
        case Constants.SWAP:
        case Constants.IADD:
        case Constants.LADD:
        case Constants.FADD:
        case Constants.DADD:
        case Constants.ISUB:
        case Constants.LSUB:
        case Constants.FSUB:
        case Constants.DSUB:
        case Constants.IMUL:
        case Constants.LMUL:
        case Constants.FMUL:
        case Constants.DMUL:
        case Constants.IDIV:
        case Constants.LDIV:
        case Constants.FDIV:
        case Constants.DDIV:
        case Constants.IREM:
        case Constants.LREM:
        case Constants.FREM:
        case Constants.DREM:
        case Constants.INEG:
        case Constants.LNEG:
        case Constants.FNEG:
        case Constants.DNEG:
        case Constants.ISHL:
        case Constants.LSHL:
        case Constants.ISHR:
        case Constants.LSHR:
        case Constants.IUSHR:
        case Constants.LUSHR:
        case Constants.IAND:
        case Constants.LAND:
        case Constants.IOR:
        case Constants.LOR:
        case Constants.IXOR:
        case Constants.LXOR:
        case Constants.I2L:
        case Constants.I2F:
        case Constants.I2D:
        case Constants.L2I:
        case Constants.L2F:
        case Constants.L2D:
        case Constants.F2I:
        case Constants.F2L:
        case Constants.F2D:
        case Constants.D2I:
        case Constants.D2L:
        case Constants.D2F:
        case Constants.I2B:
        case Constants.I2C:
        case Constants.I2S:
        case Constants.LCMP:
        case Constants.FCMPL:
        case Constants.FCMPG:
        case Constants.DCMPL:
        case Constants.DCMPG:
        case Constants.IRETURN:
        case Constants.LRETURN:
        case Constants.FRETURN:
        case Constants.DRETURN:
        case Constants.ARETURN:
        case Constants.RETURN:
        case Constants.ARRAYLENGTH:
        case Constants.ATHROW:
        case Constants.MONITORENTER:
        case Constants.MONITOREXIT:
        case Constants.ILOAD_0:
        case Constants.ILOAD_1:
        case Constants.ILOAD_2:
        case Constants.ILOAD_3:
        case Constants.LLOAD_0:
        case Constants.LLOAD_1:
        case Constants.LLOAD_2:
        case Constants.LLOAD_3:
        case Constants.FLOAD_0:
        case Constants.FLOAD_1:
        case Constants.FLOAD_2:
        case Constants.FLOAD_3:
        case Constants.DLOAD_0:
        case Constants.DLOAD_1:
        case Constants.DLOAD_2:
        case Constants.DLOAD_3:
        case Constants.ALOAD_0:
        case Constants.ALOAD_1:
        case Constants.ALOAD_2:
        case Constants.ALOAD_3:
        case Constants.ISTORE_0:
        case Constants.ISTORE_1:
        case Constants.ISTORE_2:
        case Constants.ISTORE_3:
        case Constants.LSTORE_0:
        case Constants.LSTORE_1:
        case Constants.LSTORE_2:
        case Constants.LSTORE_3:
        case Constants.FSTORE_0:
        case Constants.FSTORE_1:
        case Constants.FSTORE_2:
        case Constants.FSTORE_3:
        case Constants.DSTORE_0:
        case Constants.DSTORE_1:
        case Constants.DSTORE_2:
        case Constants.DSTORE_3:
        case Constants.ASTORE_0:
        case Constants.ASTORE_1:
        case Constants.ASTORE_2:
        case Constants.ASTORE_3:
<span class="fc" id="L1471">          currentOffset += 1;</span>
<span class="fc" id="L1472">          break;</span>
        case Constants.IFEQ:
        case Constants.IFNE:
        case Constants.IFLT:
        case Constants.IFGE:
        case Constants.IFGT:
        case Constants.IFLE:
        case Constants.IF_ICMPEQ:
        case Constants.IF_ICMPNE:
        case Constants.IF_ICMPLT:
        case Constants.IF_ICMPGE:
        case Constants.IF_ICMPGT:
        case Constants.IF_ICMPLE:
        case Constants.IF_ACMPEQ:
        case Constants.IF_ACMPNE:
        case Constants.GOTO:
        case Constants.JSR:
        case Constants.IFNULL:
        case Constants.IFNONNULL:
<span class="fc" id="L1491">          createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);</span>
<span class="fc" id="L1492">          currentOffset += 3;</span>
<span class="fc" id="L1493">          break;</span>
        case Constants.ASM_IFEQ:
        case Constants.ASM_IFNE:
        case Constants.ASM_IFLT:
        case Constants.ASM_IFGE:
        case Constants.ASM_IFGT:
        case Constants.ASM_IFLE:
        case Constants.ASM_IF_ICMPEQ:
        case Constants.ASM_IF_ICMPNE:
        case Constants.ASM_IF_ICMPLT:
        case Constants.ASM_IF_ICMPGE:
        case Constants.ASM_IF_ICMPGT:
        case Constants.ASM_IF_ICMPLE:
        case Constants.ASM_IF_ACMPEQ:
        case Constants.ASM_IF_ACMPNE:
        case Constants.ASM_GOTO:
        case Constants.ASM_JSR:
        case Constants.ASM_IFNULL:
        case Constants.ASM_IFNONNULL:
<span class="nc" id="L1512">          createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);</span>
<span class="nc" id="L1513">          currentOffset += 3;</span>
<span class="nc" id="L1514">          break;</span>
        case Constants.GOTO_W:
        case Constants.JSR_W:
        case Constants.ASM_GOTO_W:
<span class="nc" id="L1518">          createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);</span>
<span class="nc" id="L1519">          currentOffset += 5;</span>
<span class="nc" id="L1520">          break;</span>
        case Constants.WIDE:
<span class="nc bnc" id="L1522" title="All 3 branches missed.">          switch (classBuffer[currentOffset + 1] &amp; 0xFF) {</span>
            case Constants.ILOAD:
            case Constants.FLOAD:
            case Constants.ALOAD:
            case Constants.LLOAD:
            case Constants.DLOAD:
            case Constants.ISTORE:
            case Constants.FSTORE:
            case Constants.ASTORE:
            case Constants.LSTORE:
            case Constants.DSTORE:
            case Constants.RET:
<span class="nc" id="L1534">              currentOffset += 4;</span>
<span class="nc" id="L1535">              break;</span>
            case Constants.IINC:
<span class="nc" id="L1537">              currentOffset += 6;</span>
<span class="nc" id="L1538">              break;</span>
            default:
<span class="nc" id="L1540">              throw new IllegalArgumentException();</span>
          }
          break;
        case Constants.TABLESWITCH:
          // Skip 0 to 3 padding bytes.
<span class="nc" id="L1545">          currentOffset += 4 - (bytecodeOffset &amp; 3);</span>
          // Read the default label and the number of table entries.
<span class="nc" id="L1547">          createLabel(bytecodeOffset + readInt(currentOffset), labels);</span>
<span class="nc" id="L1548">          int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;</span>
<span class="nc" id="L1549">          currentOffset += 12;</span>
          // Read the table labels.
<span class="nc bnc" id="L1551" title="All 2 branches missed.">          while (numTableEntries-- &gt; 0) {</span>
<span class="nc" id="L1552">            createLabel(bytecodeOffset + readInt(currentOffset), labels);</span>
<span class="nc" id="L1553">            currentOffset += 4;</span>
          }
          break;
        case Constants.LOOKUPSWITCH:
          // Skip 0 to 3 padding bytes.
<span class="nc" id="L1558">          currentOffset += 4 - (bytecodeOffset &amp; 3);</span>
          // Read the default label and the number of switch cases.
<span class="nc" id="L1560">          createLabel(bytecodeOffset + readInt(currentOffset), labels);</span>
<span class="nc" id="L1561">          int numSwitchCases = readInt(currentOffset + 4);</span>
<span class="nc" id="L1562">          currentOffset += 8;</span>
          // Read the switch labels.
<span class="nc bnc" id="L1564" title="All 2 branches missed.">          while (numSwitchCases-- &gt; 0) {</span>
<span class="nc" id="L1565">            createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);</span>
<span class="nc" id="L1566">            currentOffset += 8;</span>
          }
          break;
        case Constants.ILOAD:
        case Constants.LLOAD:
        case Constants.FLOAD:
        case Constants.DLOAD:
        case Constants.ALOAD:
        case Constants.ISTORE:
        case Constants.LSTORE:
        case Constants.FSTORE:
        case Constants.DSTORE:
        case Constants.ASTORE:
        case Constants.RET:
        case Constants.BIPUSH:
        case Constants.NEWARRAY:
        case Constants.LDC:
<span class="fc" id="L1583">          currentOffset += 2;</span>
<span class="fc" id="L1584">          break;</span>
        case Constants.SIPUSH:
        case Constants.LDC_W:
        case Constants.LDC2_W:
        case Constants.GETSTATIC:
        case Constants.PUTSTATIC:
        case Constants.GETFIELD:
        case Constants.PUTFIELD:
        case Constants.INVOKEVIRTUAL:
        case Constants.INVOKESPECIAL:
        case Constants.INVOKESTATIC:
        case Constants.NEW:
        case Constants.ANEWARRAY:
        case Constants.CHECKCAST:
        case Constants.INSTANCEOF:
        case Constants.IINC:
<span class="fc" id="L1600">          currentOffset += 3;</span>
<span class="fc" id="L1601">          break;</span>
        case Constants.INVOKEINTERFACE:
        case Constants.INVOKEDYNAMIC:
<span class="nc" id="L1604">          currentOffset += 5;</span>
<span class="nc" id="L1605">          break;</span>
        case Constants.MULTIANEWARRAY:
<span class="nc" id="L1607">          currentOffset += 4;</span>
<span class="nc" id="L1608">          break;</span>
        default:
<span class="nc" id="L1610">          throw new IllegalArgumentException();</span>
      }
<span class="fc" id="L1612">    }</span>

    // Read the 'exception_table_length' and 'exception_table' field to create a label for each
    // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.
<span class="fc" id="L1616">    int exceptionTableLength = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L1617">    currentOffset += 2;</span>
<span class="pc bpc" id="L1618" title="1 of 2 branches missed.">    while (exceptionTableLength-- &gt; 0) {</span>
<span class="nc" id="L1619">      Label start = createLabel(readUnsignedShort(currentOffset), labels);</span>
<span class="nc" id="L1620">      Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);</span>
<span class="nc" id="L1621">      Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);</span>
<span class="nc" id="L1622">      String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);</span>
<span class="nc" id="L1623">      currentOffset += 8;</span>
<span class="nc" id="L1624">      methodVisitor.visitTryCatchBlock(start, end, handler, catchType);</span>
<span class="nc" id="L1625">    }</span>

    // Read the Code attributes to create a label for each referenced instruction (the variables
    // are ordered as in Section 4.7 of the JVMS). Attribute offsets exclude the
    // attribute_name_index and attribute_length fields.
    // - The offset of the current 'stack_map_frame' in the StackMap[Table] attribute, or 0.
    // Initially, this is the offset of the first 'stack_map_frame' entry. Then this offset is
    // updated after each stack_map_frame is read.
<span class="fc" id="L1633">    int stackMapFrameOffset = 0;</span>
    // - The end offset of the StackMap[Table] attribute, or 0.
<span class="fc" id="L1635">    int stackMapTableEndOffset = 0;</span>
    // - Whether the stack map frames are compressed (i.e. in a StackMapTable) or not.
<span class="fc" id="L1637">    boolean compressedFrames = true;</span>
    // - The offset of the LocalVariableTable attribute, or 0.
<span class="fc" id="L1639">    int localVariableTableOffset = 0;</span>
    // - The offset of the LocalVariableTypeTable attribute, or 0.
<span class="fc" id="L1641">    int localVariableTypeTableOffset = 0;</span>
    // - The offset of each 'type_annotation' entry in the RuntimeVisibleTypeAnnotations
    // attribute, or null.
<span class="fc" id="L1644">    int[] visibleTypeAnnotationOffsets = null;</span>
    // - The offset of each 'type_annotation' entry in the RuntimeInvisibleTypeAnnotations
    // attribute, or null.
<span class="fc" id="L1647">    int[] invisibleTypeAnnotationOffsets = null;</span>
    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
    //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
<span class="fc" id="L1650">    Attribute attributes = null;</span>

<span class="fc" id="L1652">    int attributesCount = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L1653">    currentOffset += 2;</span>
<span class="fc bfc" id="L1654" title="All 2 branches covered.">    while (attributesCount-- &gt; 0) {</span>
      // Read the attribute_info's attribute_name and attribute_length fields.
<span class="fc" id="L1656">      String attributeName = readUTF8(currentOffset, charBuffer);</span>
<span class="fc" id="L1657">      int attributeLength = readInt(currentOffset + 2);</span>
<span class="fc" id="L1658">      currentOffset += 6;</span>
<span class="fc bfc" id="L1659" title="All 2 branches covered.">      if (Constants.LOCAL_VARIABLE_TABLE.equals(attributeName)) {</span>
<span class="fc bfc" id="L1660" title="All 2 branches covered.">        if ((context.parsingOptions &amp; SKIP_DEBUG) == 0) {</span>
<span class="fc" id="L1661">          localVariableTableOffset = currentOffset;</span>
          // Parse the attribute to find the corresponding (debug only) labels.
<span class="fc" id="L1663">          int currentLocalVariableTableOffset = currentOffset;</span>
<span class="fc" id="L1664">          int localVariableTableLength = readUnsignedShort(currentLocalVariableTableOffset);</span>
<span class="fc" id="L1665">          currentLocalVariableTableOffset += 2;</span>
<span class="fc bfc" id="L1666" title="All 2 branches covered.">          while (localVariableTableLength-- &gt; 0) {</span>
<span class="fc" id="L1667">            int startPc = readUnsignedShort(currentLocalVariableTableOffset);</span>
<span class="fc" id="L1668">            createDebugLabel(startPc, labels);</span>
<span class="fc" id="L1669">            int length = readUnsignedShort(currentLocalVariableTableOffset + 2);</span>
<span class="fc" id="L1670">            createDebugLabel(startPc + length, labels);</span>
            // Skip the name_index, descriptor_index and index fields (2 bytes each).
<span class="fc" id="L1672">            currentLocalVariableTableOffset += 10;</span>
<span class="fc" id="L1673">          }</span>
<span class="fc" id="L1674">        }</span>
<span class="fc bfc" id="L1675" title="All 2 branches covered.">      } else if (Constants.LOCAL_VARIABLE_TYPE_TABLE.equals(attributeName)) {</span>
<span class="fc" id="L1676">        localVariableTypeTableOffset = currentOffset;</span>
        // Here we do not extract the labels corresponding to the attribute content. We assume they
        // are the same or a subset of those of the LocalVariableTable attribute.
<span class="fc bfc" id="L1679" title="All 2 branches covered.">      } else if (Constants.LINE_NUMBER_TABLE.equals(attributeName)) {</span>
<span class="fc bfc" id="L1680" title="All 2 branches covered.">        if ((context.parsingOptions &amp; SKIP_DEBUG) == 0) {</span>
          // Parse the attribute to find the corresponding (debug only) labels.
<span class="fc" id="L1682">          int currentLineNumberTableOffset = currentOffset;</span>
<span class="fc" id="L1683">          int lineNumberTableLength = readUnsignedShort(currentLineNumberTableOffset);</span>
<span class="fc" id="L1684">          currentLineNumberTableOffset += 2;</span>
<span class="fc bfc" id="L1685" title="All 2 branches covered.">          while (lineNumberTableLength-- &gt; 0) {</span>
<span class="fc" id="L1686">            int startPc = readUnsignedShort(currentLineNumberTableOffset);</span>
<span class="fc" id="L1687">            int lineNumber = readUnsignedShort(currentLineNumberTableOffset + 2);</span>
<span class="fc" id="L1688">            currentLineNumberTableOffset += 4;</span>
<span class="fc" id="L1689">            createDebugLabel(startPc, labels);</span>
<span class="fc" id="L1690">            labels[startPc].addLineNumber(lineNumber);</span>
<span class="fc" id="L1691">          }</span>
<span class="fc" id="L1692">        }</span>
<span class="pc bpc" id="L1693" title="1 of 2 branches missed.">      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="nc" id="L1694">        visibleTypeAnnotationOffsets =</span>
<span class="nc" id="L1695">            readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ true);</span>
        // Here we do not extract the labels corresponding to the attribute content. This would
        // require a full parsing of the attribute, which would need to be repeated when parsing
        // the bytecode instructions (see below). Instead, the content of the attribute is read one
        // type annotation at a time (i.e. after a type annotation has been visited, the next type
        // annotation is read), and the labels it contains are also extracted one annotation at a
        // time. This assumes that type annotations are ordered by increasing bytecode offset.
<span class="pc bpc" id="L1702" title="1 of 2 branches missed.">      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="nc" id="L1703">        invisibleTypeAnnotationOffsets =</span>
<span class="nc" id="L1704">            readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ false);</span>
        // Same comment as above for the RuntimeVisibleTypeAnnotations attribute.
<span class="pc bpc" id="L1706" title="1 of 2 branches missed.">      } else if (Constants.STACK_MAP_TABLE.equals(attributeName)) {</span>
<span class="pc bpc" id="L1707" title="1 of 2 branches missed.">        if ((context.parsingOptions &amp; SKIP_FRAMES) == 0) {</span>
<span class="fc" id="L1708">          stackMapFrameOffset = currentOffset + 2;</span>
<span class="fc" id="L1709">          stackMapTableEndOffset = currentOffset + attributeLength;</span>
        }
        // Here we do not extract the labels corresponding to the attribute content. This would
        // require a full parsing of the attribute, which would need to be repeated when parsing
        // the bytecode instructions (see below). Instead, the content of the attribute is read one
        // frame at a time (i.e. after a frame has been visited, the next frame is read), and the
        // labels it contains are also extracted one frame at a time. Thanks to the ordering of
        // frames, having only a &quot;one frame lookahead&quot; is not a problem, i.e. it is not possible to
        // see an offset smaller than the offset of the current instruction and for which no Label
        // exist. Except for UNINITIALIZED type offsets. We solve this by parsing the stack map
        // table without a full decoding (see below).
<span class="nc bnc" id="L1720" title="All 2 branches missed.">      } else if (&quot;StackMap&quot;.equals(attributeName)) {</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">        if ((context.parsingOptions &amp; SKIP_FRAMES) == 0) {</span>
<span class="nc" id="L1722">          stackMapFrameOffset = currentOffset + 2;</span>
<span class="nc" id="L1723">          stackMapTableEndOffset = currentOffset + attributeLength;</span>
<span class="nc" id="L1724">          compressedFrames = false;</span>
        }
        // IMPORTANT! Here we assume that the frames are ordered, as in the StackMapTable attribute,
        // although this is not guaranteed by the attribute format. This allows an incremental
        // extraction of the labels corresponding to this attribute (see the comment above for the
        // StackMapTable attribute).
      } else {
<span class="nc" id="L1731">        Attribute attribute =</span>
<span class="nc" id="L1732">            readAttribute(</span>
                context.attributePrototypes,
                attributeName,
                currentOffset,
                attributeLength,
                charBuffer,
                codeOffset,
                labels);
<span class="nc" id="L1740">        attribute.nextAttribute = attributes;</span>
<span class="nc" id="L1741">        attributes = attribute;</span>
      }
<span class="fc" id="L1743">      currentOffset += attributeLength;</span>
<span class="fc" id="L1744">    }</span>

    // Initialize the context fields related to stack map frames, and generate the first
    // (implicit) stack map frame, if needed.
<span class="pc bpc" id="L1748" title="1 of 2 branches missed.">    final boolean expandFrames = (context.parsingOptions &amp; EXPAND_FRAMES) != 0;</span>
<span class="fc bfc" id="L1749" title="All 2 branches covered.">    if (stackMapFrameOffset != 0) {</span>
      // The bytecode offset of the first explicit frame is not offset_delta + 1 but only
      // offset_delta. Setting the implicit frame offset to -1 allows us to use of the
      // &quot;offset_delta + 1&quot; rule in all cases.
<span class="fc" id="L1753">      context.currentFrameOffset = -1;</span>
<span class="fc" id="L1754">      context.currentFrameType = 0;</span>
<span class="fc" id="L1755">      context.currentFrameLocalCount = 0;</span>
<span class="fc" id="L1756">      context.currentFrameLocalCountDelta = 0;</span>
<span class="fc" id="L1757">      context.currentFrameLocalTypes = new Object[maxLocals];</span>
<span class="fc" id="L1758">      context.currentFrameStackCount = 0;</span>
<span class="fc" id="L1759">      context.currentFrameStackTypes = new Object[maxStack];</span>
<span class="pc bpc" id="L1760" title="1 of 2 branches missed.">      if (expandFrames) {</span>
<span class="nc" id="L1761">        computeImplicitFrame(context);</span>
      }
      // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the
      // stack map table, we look for 3 consecutive bytes that &quot;look like&quot; an UNINITIALIZED type
      // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).
      // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,
      // and the only consequence will be the creation of an unneeded label. This is better than
      // creating a label for each NEW instruction, and faster than fully decoding the whole stack
      // map table.
<span class="pc bpc" id="L1770" title="1 of 2 branches missed.">      for (int offset = stackMapFrameOffset; offset &lt; stackMapTableEndOffset - 2; ++offset) {</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">        if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {</span>
<span class="nc" id="L1772">          int potentialBytecodeOffset = readUnsignedShort(offset + 1);</span>
<span class="nc bnc" id="L1773" title="All 6 branches missed.">          if (potentialBytecodeOffset &gt;= 0</span>
              &amp;&amp; potentialBytecodeOffset &lt; codeLength
              &amp;&amp; (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] &amp; 0xFF)
                  == Opcodes.NEW) {
<span class="nc" id="L1777">            createLabel(potentialBytecodeOffset, labels);</span>
          }
        }
      }
    }
<span class="pc bpc" id="L1782" title="3 of 4 branches missed.">    if (expandFrames &amp;&amp; (context.parsingOptions &amp; EXPAND_ASM_INSNS) != 0) {</span>
      // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method
      // does not currently have any frame. These inserted frames must be computed by simulating the
      // effect of the bytecode instructions, one by one, starting from the implicit first frame.
      // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To
      // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is
      // computed in MethodWriter).
<span class="nc" id="L1789">      methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);</span>
    }

    // Visit the bytecode instructions. First, introduce state variables for the incremental parsing
    // of the type annotations.

    // Index of the next runtime visible type annotation to read (in the
    // visibleTypeAnnotationOffsets array).
<span class="fc" id="L1797">    int currentVisibleTypeAnnotationIndex = 0;</span>
    // The bytecode offset of the next runtime visible type annotation to read, or -1.
<span class="fc" id="L1799">    int currentVisibleTypeAnnotationBytecodeOffset =</span>
<span class="fc" id="L1800">        getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, 0);</span>
    // Index of the next runtime invisible type annotation to read (in the
    // invisibleTypeAnnotationOffsets array).
<span class="fc" id="L1803">    int currentInvisibleTypeAnnotationIndex = 0;</span>
    // The bytecode offset of the next runtime invisible type annotation to read, or -1.
<span class="fc" id="L1805">    int currentInvisibleTypeAnnotationBytecodeOffset =</span>
<span class="fc" id="L1806">        getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, 0);</span>

    // Whether a F_INSERT stack map frame must be inserted before the current instruction.
<span class="fc" id="L1809">    boolean insertFrame = false;</span>

    // The delta to subtract from a goto_w or jsr_w opcode to get the corresponding goto or jsr
    // opcode, or 0 if goto_w and jsr_w must be left unchanged (i.e. when expanding ASM specific
    // instructions).
<span class="pc bpc" id="L1814" title="1 of 2 branches missed.">    final int wideJumpOpcodeDelta =</span>
        (context.parsingOptions &amp; EXPAND_ASM_INSNS) == 0 ? Constants.WIDE_JUMP_OPCODE_DELTA : 0;

<span class="fc" id="L1817">    currentOffset = bytecodeStartOffset;</span>
<span class="fc bfc" id="L1818" title="All 2 branches covered.">    while (currentOffset &lt; bytecodeEndOffset) {</span>
<span class="fc" id="L1819">      final int currentBytecodeOffset = currentOffset - bytecodeStartOffset;</span>

      // Visit the label and the line number(s) for this bytecode offset, if any.
<span class="fc" id="L1822">      Label currentLabel = labels[currentBytecodeOffset];</span>
<span class="fc bfc" id="L1823" title="All 2 branches covered.">      if (currentLabel != null) {</span>
<span class="pc bpc" id="L1824" title="1 of 2 branches missed.">        currentLabel.accept(methodVisitor, (context.parsingOptions &amp; SKIP_DEBUG) == 0);</span>
      }

      // Visit the stack map frame for this bytecode offset, if any.
<span class="fc bfc" id="L1828" title="All 6 branches covered.">      while (stackMapFrameOffset != 0</span>
          &amp;&amp; (context.currentFrameOffset == currentBytecodeOffset
              || context.currentFrameOffset == -1)) {
        // If there is a stack map frame for this offset, make methodVisitor visit it, and read the
        // next stack map frame if there is one.
<span class="fc bfc" id="L1833" title="All 2 branches covered.">        if (context.currentFrameOffset != -1) {</span>
<span class="pc bpc" id="L1834" title="2 of 4 branches missed.">          if (!compressedFrames || expandFrames) {</span>
<span class="nc" id="L1835">            methodVisitor.visitFrame(</span>
                Opcodes.F_NEW,
                context.currentFrameLocalCount,
                context.currentFrameLocalTypes,
                context.currentFrameStackCount,
                context.currentFrameStackTypes);
          } else {
<span class="fc" id="L1842">            methodVisitor.visitFrame(</span>
                context.currentFrameType,
                context.currentFrameLocalCountDelta,
                context.currentFrameLocalTypes,
                context.currentFrameStackCount,
                context.currentFrameStackTypes);
          }
          // Since there is already a stack map frame for this bytecode offset, there is no need to
          // insert a new one.
<span class="fc" id="L1851">          insertFrame = false;</span>
        }
<span class="fc bfc" id="L1853" title="All 2 branches covered.">        if (stackMapFrameOffset &lt; stackMapTableEndOffset) {</span>
<span class="fc" id="L1854">          stackMapFrameOffset =</span>
<span class="fc" id="L1855">              readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);</span>
        } else {
<span class="fc" id="L1857">          stackMapFrameOffset = 0;</span>
        }
      }

      // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to
      // true during the previous iteration. The actual frame content is computed in MethodWriter.
<span class="pc bpc" id="L1863" title="1 of 2 branches missed.">      if (insertFrame) {</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">        if ((context.parsingOptions &amp; EXPAND_FRAMES) != 0) {</span>
<span class="nc" id="L1865">          methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);</span>
        }
<span class="nc" id="L1867">        insertFrame = false;</span>
      }

      // Visit the instruction at this bytecode offset.
<span class="fc" id="L1871">      int opcode = classBuffer[currentOffset] &amp; 0xFF;</span>
<span class="pc bpc" id="L1872" title="11 of 21 branches missed.">      switch (opcode) {</span>
        case Constants.NOP:
        case Constants.ACONST_NULL:
        case Constants.ICONST_M1:
        case Constants.ICONST_0:
        case Constants.ICONST_1:
        case Constants.ICONST_2:
        case Constants.ICONST_3:
        case Constants.ICONST_4:
        case Constants.ICONST_5:
        case Constants.LCONST_0:
        case Constants.LCONST_1:
        case Constants.FCONST_0:
        case Constants.FCONST_1:
        case Constants.FCONST_2:
        case Constants.DCONST_0:
        case Constants.DCONST_1:
        case Constants.IALOAD:
        case Constants.LALOAD:
        case Constants.FALOAD:
        case Constants.DALOAD:
        case Constants.AALOAD:
        case Constants.BALOAD:
        case Constants.CALOAD:
        case Constants.SALOAD:
        case Constants.IASTORE:
        case Constants.LASTORE:
        case Constants.FASTORE:
        case Constants.DASTORE:
        case Constants.AASTORE:
        case Constants.BASTORE:
        case Constants.CASTORE:
        case Constants.SASTORE:
        case Constants.POP:
        case Constants.POP2:
        case Constants.DUP:
        case Constants.DUP_X1:
        case Constants.DUP_X2:
        case Constants.DUP2:
        case Constants.DUP2_X1:
        case Constants.DUP2_X2:
        case Constants.SWAP:
        case Constants.IADD:
        case Constants.LADD:
        case Constants.FADD:
        case Constants.DADD:
        case Constants.ISUB:
        case Constants.LSUB:
        case Constants.FSUB:
        case Constants.DSUB:
        case Constants.IMUL:
        case Constants.LMUL:
        case Constants.FMUL:
        case Constants.DMUL:
        case Constants.IDIV:
        case Constants.LDIV:
        case Constants.FDIV:
        case Constants.DDIV:
        case Constants.IREM:
        case Constants.LREM:
        case Constants.FREM:
        case Constants.DREM:
        case Constants.INEG:
        case Constants.LNEG:
        case Constants.FNEG:
        case Constants.DNEG:
        case Constants.ISHL:
        case Constants.LSHL:
        case Constants.ISHR:
        case Constants.LSHR:
        case Constants.IUSHR:
        case Constants.LUSHR:
        case Constants.IAND:
        case Constants.LAND:
        case Constants.IOR:
        case Constants.LOR:
        case Constants.IXOR:
        case Constants.LXOR:
        case Constants.I2L:
        case Constants.I2F:
        case Constants.I2D:
        case Constants.L2I:
        case Constants.L2F:
        case Constants.L2D:
        case Constants.F2I:
        case Constants.F2L:
        case Constants.F2D:
        case Constants.D2I:
        case Constants.D2L:
        case Constants.D2F:
        case Constants.I2B:
        case Constants.I2C:
        case Constants.I2S:
        case Constants.LCMP:
        case Constants.FCMPL:
        case Constants.FCMPG:
        case Constants.DCMPL:
        case Constants.DCMPG:
        case Constants.IRETURN:
        case Constants.LRETURN:
        case Constants.FRETURN:
        case Constants.DRETURN:
        case Constants.ARETURN:
        case Constants.RETURN:
        case Constants.ARRAYLENGTH:
        case Constants.ATHROW:
        case Constants.MONITORENTER:
        case Constants.MONITOREXIT:
<span class="fc" id="L1980">          methodVisitor.visitInsn(opcode);</span>
<span class="fc" id="L1981">          currentOffset += 1;</span>
<span class="fc" id="L1982">          break;</span>
        case Constants.ILOAD_0:
        case Constants.ILOAD_1:
        case Constants.ILOAD_2:
        case Constants.ILOAD_3:
        case Constants.LLOAD_0:
        case Constants.LLOAD_1:
        case Constants.LLOAD_2:
        case Constants.LLOAD_3:
        case Constants.FLOAD_0:
        case Constants.FLOAD_1:
        case Constants.FLOAD_2:
        case Constants.FLOAD_3:
        case Constants.DLOAD_0:
        case Constants.DLOAD_1:
        case Constants.DLOAD_2:
        case Constants.DLOAD_3:
        case Constants.ALOAD_0:
        case Constants.ALOAD_1:
        case Constants.ALOAD_2:
        case Constants.ALOAD_3:
<span class="fc" id="L2003">          opcode -= Constants.ILOAD_0;</span>
<span class="fc" id="L2004">          methodVisitor.visitVarInsn(Opcodes.ILOAD + (opcode &gt;&gt; 2), opcode &amp; 0x3);</span>
<span class="fc" id="L2005">          currentOffset += 1;</span>
<span class="fc" id="L2006">          break;</span>
        case Constants.ISTORE_0:
        case Constants.ISTORE_1:
        case Constants.ISTORE_2:
        case Constants.ISTORE_3:
        case Constants.LSTORE_0:
        case Constants.LSTORE_1:
        case Constants.LSTORE_2:
        case Constants.LSTORE_3:
        case Constants.FSTORE_0:
        case Constants.FSTORE_1:
        case Constants.FSTORE_2:
        case Constants.FSTORE_3:
        case Constants.DSTORE_0:
        case Constants.DSTORE_1:
        case Constants.DSTORE_2:
        case Constants.DSTORE_3:
        case Constants.ASTORE_0:
        case Constants.ASTORE_1:
        case Constants.ASTORE_2:
        case Constants.ASTORE_3:
<span class="fc" id="L2027">          opcode -= Constants.ISTORE_0;</span>
<span class="fc" id="L2028">          methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode &gt;&gt; 2), opcode &amp; 0x3);</span>
<span class="fc" id="L2029">          currentOffset += 1;</span>
<span class="fc" id="L2030">          break;</span>
        case Constants.IFEQ:
        case Constants.IFNE:
        case Constants.IFLT:
        case Constants.IFGE:
        case Constants.IFGT:
        case Constants.IFLE:
        case Constants.IF_ICMPEQ:
        case Constants.IF_ICMPNE:
        case Constants.IF_ICMPLT:
        case Constants.IF_ICMPGE:
        case Constants.IF_ICMPGT:
        case Constants.IF_ICMPLE:
        case Constants.IF_ACMPEQ:
        case Constants.IF_ACMPNE:
        case Constants.GOTO:
        case Constants.JSR:
        case Constants.IFNULL:
        case Constants.IFNONNULL:
<span class="fc" id="L2049">          methodVisitor.visitJumpInsn(</span>
<span class="fc" id="L2050">              opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);</span>
<span class="fc" id="L2051">          currentOffset += 3;</span>
<span class="fc" id="L2052">          break;</span>
        case Constants.GOTO_W:
        case Constants.JSR_W:
<span class="nc" id="L2055">          methodVisitor.visitJumpInsn(</span>
              opcode - wideJumpOpcodeDelta,
<span class="nc" id="L2057">              labels[currentBytecodeOffset + readInt(currentOffset + 1)]);</span>
<span class="nc" id="L2058">          currentOffset += 5;</span>
<span class="nc" id="L2059">          break;</span>
        case Constants.ASM_IFEQ:
        case Constants.ASM_IFNE:
        case Constants.ASM_IFLT:
        case Constants.ASM_IFGE:
        case Constants.ASM_IFGT:
        case Constants.ASM_IFLE:
        case Constants.ASM_IF_ICMPEQ:
        case Constants.ASM_IF_ICMPNE:
        case Constants.ASM_IF_ICMPLT:
        case Constants.ASM_IF_ICMPGE:
        case Constants.ASM_IF_ICMPGT:
        case Constants.ASM_IF_ICMPLE:
        case Constants.ASM_IF_ACMPEQ:
        case Constants.ASM_IF_ACMPNE:
        case Constants.ASM_GOTO:
        case Constants.ASM_JSR:
        case Constants.ASM_IFNULL:
        case Constants.ASM_IFNONNULL:
          {
            // A forward jump with an offset &gt; 32767. In this case we automatically replace ASM_GOTO
            // with GOTO_W, ASM_JSR with JSR_W and ASM_IFxxx &lt;l&gt; with IFNOTxxx &lt;L&gt; GOTO_W &lt;l&gt; L:...,
            // where IFNOTxxx is the &quot;opposite&quot; opcode of ASMS_IFxxx (e.g. IFNE for ASM_IFEQ) and
            // where &lt;L&gt; designates the instruction just after the GOTO_W.
            // First, change the ASM specific opcodes ASM_IFEQ ... ASM_JSR, ASM_IFNULL and
            // ASM_IFNONNULL to IFEQ ... JSR, IFNULL and IFNONNULL.
<span class="nc bnc" id="L2085" title="All 2 branches missed.">            opcode =</span>
                opcode &lt; Constants.ASM_IFNULL
                    ? opcode - Constants.ASM_OPCODE_DELTA
                    : opcode - Constants.ASM_IFNULL_OPCODE_DELTA;
<span class="nc" id="L2089">            Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];</span>
<span class="nc bnc" id="L2090" title="All 4 branches missed.">            if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {</span>
              // Replace GOTO with GOTO_W and JSR with JSR_W.
<span class="nc" id="L2092">              methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);</span>
            } else {
              // Compute the &quot;opposite&quot; of opcode. This can be done by flipping the least
              // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ
              // (with a pre and post offset by 1).
<span class="nc bnc" id="L2097" title="All 2 branches missed.">              opcode = opcode &lt; Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;</span>
<span class="nc" id="L2098">              Label endif = createLabel(currentBytecodeOffset + 3, labels);</span>
<span class="nc" id="L2099">              methodVisitor.visitJumpInsn(opcode, endif);</span>
<span class="nc" id="L2100">              methodVisitor.visitJumpInsn(Constants.GOTO_W, target);</span>
              // endif designates the instruction just after GOTO_W, and is visited as part of the
              // next instruction. Since it is a jump target, we need to insert a frame here.
<span class="nc" id="L2103">              insertFrame = true;</span>
            }
<span class="nc" id="L2105">            currentOffset += 3;</span>
<span class="nc" id="L2106">            break;</span>
          }
        case Constants.ASM_GOTO_W:
          // Replace ASM_GOTO_W with GOTO_W.
<span class="nc" id="L2110">          methodVisitor.visitJumpInsn(</span>
<span class="nc" id="L2111">              Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);</span>
          // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns
          // IFNOTxxx &lt;L&gt; ASM_GOTO_W &lt;l&gt; L:..., see MethodWriter), so we need to insert a frame
          // here.
<span class="nc" id="L2115">          insertFrame = true;</span>
<span class="nc" id="L2116">          currentOffset += 5;</span>
<span class="nc" id="L2117">          break;</span>
        case Constants.WIDE:
<span class="nc" id="L2119">          opcode = classBuffer[currentOffset + 1] &amp; 0xFF;</span>
<span class="nc bnc" id="L2120" title="All 2 branches missed.">          if (opcode == Opcodes.IINC) {</span>
<span class="nc" id="L2121">            methodVisitor.visitIincInsn(</span>
<span class="nc" id="L2122">                readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));</span>
<span class="nc" id="L2123">            currentOffset += 6;</span>
          } else {
<span class="nc" id="L2125">            methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));</span>
<span class="nc" id="L2126">            currentOffset += 4;</span>
          }
<span class="nc" id="L2128">          break;</span>
        case Constants.TABLESWITCH:
          {
            // Skip 0 to 3 padding bytes.
<span class="nc" id="L2132">            currentOffset += 4 - (currentBytecodeOffset &amp; 3);</span>
            // Read the instruction.
<span class="nc" id="L2134">            Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];</span>
<span class="nc" id="L2135">            int low = readInt(currentOffset + 4);</span>
<span class="nc" id="L2136">            int high = readInt(currentOffset + 8);</span>
<span class="nc" id="L2137">            currentOffset += 12;</span>
<span class="nc" id="L2138">            Label[] table = new Label[high - low + 1];</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">            for (int i = 0; i &lt; table.length; ++i) {</span>
<span class="nc" id="L2140">              table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];</span>
<span class="nc" id="L2141">              currentOffset += 4;</span>
            }
<span class="nc" id="L2143">            methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);</span>
<span class="nc" id="L2144">            break;</span>
          }
        case Constants.LOOKUPSWITCH:
          {
            // Skip 0 to 3 padding bytes.
<span class="nc" id="L2149">            currentOffset += 4 - (currentBytecodeOffset &amp; 3);</span>
            // Read the instruction.
<span class="nc" id="L2151">            Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];</span>
<span class="nc" id="L2152">            int numPairs = readInt(currentOffset + 4);</span>
<span class="nc" id="L2153">            currentOffset += 8;</span>
<span class="nc" id="L2154">            int[] keys = new int[numPairs];</span>
<span class="nc" id="L2155">            Label[] values = new Label[numPairs];</span>
<span class="nc bnc" id="L2156" title="All 2 branches missed.">            for (int i = 0; i &lt; numPairs; ++i) {</span>
<span class="nc" id="L2157">              keys[i] = readInt(currentOffset);</span>
<span class="nc" id="L2158">              values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];</span>
<span class="nc" id="L2159">              currentOffset += 8;</span>
            }
<span class="nc" id="L2161">            methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);</span>
<span class="nc" id="L2162">            break;</span>
          }
        case Constants.ILOAD:
        case Constants.LLOAD:
        case Constants.FLOAD:
        case Constants.DLOAD:
        case Constants.ALOAD:
        case Constants.ISTORE:
        case Constants.LSTORE:
        case Constants.FSTORE:
        case Constants.DSTORE:
        case Constants.ASTORE:
        case Constants.RET:
<span class="fc" id="L2175">          methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] &amp; 0xFF);</span>
<span class="fc" id="L2176">          currentOffset += 2;</span>
<span class="fc" id="L2177">          break;</span>
        case Constants.BIPUSH:
        case Constants.NEWARRAY:
<span class="fc" id="L2180">          methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);</span>
<span class="fc" id="L2181">          currentOffset += 2;</span>
<span class="fc" id="L2182">          break;</span>
        case Constants.SIPUSH:
<span class="nc" id="L2184">          methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));</span>
<span class="nc" id="L2185">          currentOffset += 3;</span>
<span class="nc" id="L2186">          break;</span>
        case Constants.LDC:
<span class="fc" id="L2188">          methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] &amp; 0xFF, charBuffer));</span>
<span class="fc" id="L2189">          currentOffset += 2;</span>
<span class="fc" id="L2190">          break;</span>
        case Constants.LDC_W:
        case Constants.LDC2_W:
<span class="fc" id="L2193">          methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));</span>
<span class="fc" id="L2194">          currentOffset += 3;</span>
<span class="fc" id="L2195">          break;</span>
        case Constants.GETSTATIC:
        case Constants.PUTSTATIC:
        case Constants.GETFIELD:
        case Constants.PUTFIELD:
        case Constants.INVOKEVIRTUAL:
        case Constants.INVOKESPECIAL:
        case Constants.INVOKESTATIC:
        case Constants.INVOKEINTERFACE:
          {
<span class="fc" id="L2205">            int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];</span>
<span class="fc" id="L2206">            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];</span>
<span class="fc" id="L2207">            String owner = readClass(cpInfoOffset, charBuffer);</span>
<span class="fc" id="L2208">            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);</span>
<span class="fc" id="L2209">            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);</span>
<span class="fc bfc" id="L2210" title="All 2 branches covered.">            if (opcode &lt; Opcodes.INVOKEVIRTUAL) {</span>
<span class="fc" id="L2211">              methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);</span>
            } else {
<span class="pc bpc" id="L2213" title="1 of 2 branches missed.">              boolean isInterface =</span>
                  classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
<span class="fc" id="L2215">              methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);</span>
            }
<span class="pc bpc" id="L2217" title="1 of 2 branches missed.">            if (opcode == Opcodes.INVOKEINTERFACE) {</span>
<span class="nc" id="L2218">              currentOffset += 5;</span>
            } else {
<span class="fc" id="L2220">              currentOffset += 3;</span>
            }
<span class="fc" id="L2222">            break;</span>
          }
        case Constants.INVOKEDYNAMIC:
          {
<span class="nc" id="L2226">            int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];</span>
<span class="nc" id="L2227">            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];</span>
<span class="nc" id="L2228">            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);</span>
<span class="nc" id="L2229">            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);</span>
<span class="nc" id="L2230">            int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];</span>
<span class="nc" id="L2231">            Handle handle =</span>
<span class="nc" id="L2232">                (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);</span>
<span class="nc" id="L2233">            Object[] bootstrapMethodArguments =</span>
<span class="nc" id="L2234">                new Object[readUnsignedShort(bootstrapMethodOffset + 2)];</span>
<span class="nc" id="L2235">            bootstrapMethodOffset += 4;</span>
<span class="nc bnc" id="L2236" title="All 2 branches missed.">            for (int i = 0; i &lt; bootstrapMethodArguments.length; i++) {</span>
<span class="nc" id="L2237">              bootstrapMethodArguments[i] =</span>
<span class="nc" id="L2238">                  readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);</span>
<span class="nc" id="L2239">              bootstrapMethodOffset += 2;</span>
            }
<span class="nc" id="L2241">            methodVisitor.visitInvokeDynamicInsn(</span>
                name, descriptor, handle, bootstrapMethodArguments);
<span class="nc" id="L2243">            currentOffset += 5;</span>
<span class="nc" id="L2244">            break;</span>
          }
        case Constants.NEW:
        case Constants.ANEWARRAY:
        case Constants.CHECKCAST:
        case Constants.INSTANCEOF:
<span class="fc" id="L2250">          methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));</span>
<span class="fc" id="L2251">          currentOffset += 3;</span>
<span class="fc" id="L2252">          break;</span>
        case Constants.IINC:
<span class="nc" id="L2254">          methodVisitor.visitIincInsn(</span>
              classBuffer[currentOffset + 1] &amp; 0xFF, classBuffer[currentOffset + 2]);
<span class="nc" id="L2256">          currentOffset += 3;</span>
<span class="nc" id="L2257">          break;</span>
        case Constants.MULTIANEWARRAY:
<span class="nc" id="L2259">          methodVisitor.visitMultiANewArrayInsn(</span>
<span class="nc" id="L2260">              readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] &amp; 0xFF);</span>
<span class="nc" id="L2261">          currentOffset += 4;</span>
<span class="nc" id="L2262">          break;</span>
        default:
<span class="nc" id="L2264">          throw new AssertionError();</span>
      }

      // Visit the runtime visible instruction annotations, if any.
<span class="pc bpc" id="L2268" title="5 of 6 branches missed.">      while (visibleTypeAnnotationOffsets != null</span>
          &amp;&amp; currentVisibleTypeAnnotationIndex &lt; visibleTypeAnnotationOffsets.length
          &amp;&amp; currentVisibleTypeAnnotationBytecodeOffset &lt;= currentBytecodeOffset) {
<span class="nc bnc" id="L2271" title="All 2 branches missed.">        if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {</span>
          // Parse the target_type, target_info and target_path fields.
<span class="nc" id="L2273">          int currentAnnotationOffset =</span>
<span class="nc" id="L2274">              readTypeAnnotationTarget(</span>
                  context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);
          // Parse the type_index field.
<span class="nc" id="L2277">          String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="nc" id="L2278">          currentAnnotationOffset += 2;</span>
          // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L2280">          readElementValues(</span>
<span class="nc" id="L2281">              methodVisitor.visitInsnAnnotation(</span>
                  context.currentTypeAnnotationTarget,
                  context.currentTypeAnnotationTargetPath,
                  annotationDescriptor,
                  /* visible = */ true),
              currentAnnotationOffset,
              /* named = */ true,
              charBuffer);
        }
<span class="nc" id="L2290">        currentVisibleTypeAnnotationBytecodeOffset =</span>
<span class="nc" id="L2291">            getTypeAnnotationBytecodeOffset(</span>
                visibleTypeAnnotationOffsets, ++currentVisibleTypeAnnotationIndex);
      }

      // Visit the runtime invisible instruction annotations, if any.
<span class="pc bpc" id="L2296" title="5 of 6 branches missed.">      while (invisibleTypeAnnotationOffsets != null</span>
          &amp;&amp; currentInvisibleTypeAnnotationIndex &lt; invisibleTypeAnnotationOffsets.length
          &amp;&amp; currentInvisibleTypeAnnotationBytecodeOffset &lt;= currentBytecodeOffset) {
<span class="nc bnc" id="L2299" title="All 2 branches missed.">        if (currentInvisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {</span>
          // Parse the target_type, target_info and target_path fields.
<span class="nc" id="L2301">          int currentAnnotationOffset =</span>
<span class="nc" id="L2302">              readTypeAnnotationTarget(</span>
                  context, invisibleTypeAnnotationOffsets[currentInvisibleTypeAnnotationIndex]);
          // Parse the type_index field.
<span class="nc" id="L2305">          String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="nc" id="L2306">          currentAnnotationOffset += 2;</span>
          // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L2308">          readElementValues(</span>
<span class="nc" id="L2309">              methodVisitor.visitInsnAnnotation(</span>
                  context.currentTypeAnnotationTarget,
                  context.currentTypeAnnotationTargetPath,
                  annotationDescriptor,
                  /* visible = */ false),
              currentAnnotationOffset,
              /* named = */ true,
              charBuffer);
        }
<span class="nc" id="L2318">        currentInvisibleTypeAnnotationBytecodeOffset =</span>
<span class="nc" id="L2319">            getTypeAnnotationBytecodeOffset(</span>
                invisibleTypeAnnotationOffsets, ++currentInvisibleTypeAnnotationIndex);
      }
<span class="fc" id="L2322">    }</span>
<span class="fc bfc" id="L2323" title="All 2 branches covered.">    if (labels[codeLength] != null) {</span>
<span class="fc" id="L2324">      methodVisitor.visitLabel(labels[codeLength]);</span>
    }

    // Visit LocalVariableTable and LocalVariableTypeTable attributes.
<span class="pc bpc" id="L2328" title="1 of 4 branches missed.">    if (localVariableTableOffset != 0 &amp;&amp; (context.parsingOptions &amp; SKIP_DEBUG) == 0) {</span>
      // The (start_pc, index, signature_index) fields of each entry of the LocalVariableTypeTable.
<span class="fc" id="L2330">      int[] typeTable = null;</span>
<span class="fc bfc" id="L2331" title="All 2 branches covered.">      if (localVariableTypeTableOffset != 0) {</span>
<span class="fc" id="L2332">        typeTable = new int[readUnsignedShort(localVariableTypeTableOffset) * 3];</span>
<span class="fc" id="L2333">        currentOffset = localVariableTypeTableOffset + 2;</span>
<span class="fc" id="L2334">        int typeTableIndex = typeTable.length;</span>
<span class="fc bfc" id="L2335" title="All 2 branches covered.">        while (typeTableIndex &gt; 0) {</span>
          // Store the offset of 'signature_index', and the value of 'index' and 'start_pc'.
<span class="fc" id="L2337">          typeTable[--typeTableIndex] = currentOffset + 6;</span>
<span class="fc" id="L2338">          typeTable[--typeTableIndex] = readUnsignedShort(currentOffset + 8);</span>
<span class="fc" id="L2339">          typeTable[--typeTableIndex] = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L2340">          currentOffset += 10;</span>
        }
      }
<span class="fc" id="L2343">      int localVariableTableLength = readUnsignedShort(localVariableTableOffset);</span>
<span class="fc" id="L2344">      currentOffset = localVariableTableOffset + 2;</span>
<span class="fc bfc" id="L2345" title="All 2 branches covered.">      while (localVariableTableLength-- &gt; 0) {</span>
<span class="fc" id="L2346">        int startPc = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L2347">        int length = readUnsignedShort(currentOffset + 2);</span>
<span class="fc" id="L2348">        String name = readUTF8(currentOffset + 4, charBuffer);</span>
<span class="fc" id="L2349">        String descriptor = readUTF8(currentOffset + 6, charBuffer);</span>
<span class="fc" id="L2350">        int index = readUnsignedShort(currentOffset + 8);</span>
<span class="fc" id="L2351">        currentOffset += 10;</span>
<span class="fc" id="L2352">        String signature = null;</span>
<span class="fc bfc" id="L2353" title="All 2 branches covered.">        if (typeTable != null) {</span>
<span class="fc bfc" id="L2354" title="All 2 branches covered.">          for (int i = 0; i &lt; typeTable.length; i += 3) {</span>
<span class="fc bfc" id="L2355" title="All 4 branches covered.">            if (typeTable[i] == startPc &amp;&amp; typeTable[i + 1] == index) {</span>
<span class="fc" id="L2356">              signature = readUTF8(typeTable[i + 2], charBuffer);</span>
<span class="fc" id="L2357">              break;</span>
            }
          }
        }
<span class="fc" id="L2361">        methodVisitor.visitLocalVariable(</span>
            name, descriptor, signature, labels[startPc], labels[startPc + length], index);
<span class="fc" id="L2363">      }</span>
    }

    // Visit the local variable type annotations of the RuntimeVisibleTypeAnnotations attribute.
<span class="pc bpc" id="L2367" title="1 of 2 branches missed.">    if (visibleTypeAnnotationOffsets != null) {</span>
<span class="nc bnc" id="L2368" title="All 2 branches missed.">      for (int typeAnnotationOffset : visibleTypeAnnotationOffsets) {</span>
<span class="nc" id="L2369">        int targetType = readByte(typeAnnotationOffset);</span>
<span class="nc bnc" id="L2370" title="All 4 branches missed.">        if (targetType == TypeReference.LOCAL_VARIABLE</span>
            || targetType == TypeReference.RESOURCE_VARIABLE) {
          // Parse the target_type, target_info and target_path fields.
<span class="nc" id="L2373">          currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);</span>
          // Parse the type_index field.
<span class="nc" id="L2375">          String annotationDescriptor = readUTF8(currentOffset, charBuffer);</span>
<span class="nc" id="L2376">          currentOffset += 2;</span>
          // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L2378">          readElementValues(</span>
<span class="nc" id="L2379">              methodVisitor.visitLocalVariableAnnotation(</span>
                  context.currentTypeAnnotationTarget,
                  context.currentTypeAnnotationTargetPath,
                  context.currentLocalVariableAnnotationRangeStarts,
                  context.currentLocalVariableAnnotationRangeEnds,
                  context.currentLocalVariableAnnotationRangeIndices,
                  annotationDescriptor,
                  /* visible = */ true),
              currentOffset,
              /* named = */ true,
              charBuffer);
        }
      }
    }

    // Visit the local variable type annotations of the RuntimeInvisibleTypeAnnotations attribute.
<span class="pc bpc" id="L2395" title="1 of 2 branches missed.">    if (invisibleTypeAnnotationOffsets != null) {</span>
<span class="nc bnc" id="L2396" title="All 2 branches missed.">      for (int typeAnnotationOffset : invisibleTypeAnnotationOffsets) {</span>
<span class="nc" id="L2397">        int targetType = readByte(typeAnnotationOffset);</span>
<span class="nc bnc" id="L2398" title="All 4 branches missed.">        if (targetType == TypeReference.LOCAL_VARIABLE</span>
            || targetType == TypeReference.RESOURCE_VARIABLE) {
          // Parse the target_type, target_info and target_path fields.
<span class="nc" id="L2401">          currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);</span>
          // Parse the type_index field.
<span class="nc" id="L2403">          String annotationDescriptor = readUTF8(currentOffset, charBuffer);</span>
<span class="nc" id="L2404">          currentOffset += 2;</span>
          // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L2406">          readElementValues(</span>
<span class="nc" id="L2407">              methodVisitor.visitLocalVariableAnnotation(</span>
                  context.currentTypeAnnotationTarget,
                  context.currentTypeAnnotationTargetPath,
                  context.currentLocalVariableAnnotationRangeStarts,
                  context.currentLocalVariableAnnotationRangeEnds,
                  context.currentLocalVariableAnnotationRangeIndices,
                  annotationDescriptor,
                  /* visible = */ false),
              currentOffset,
              /* named = */ true,
              charBuffer);
        }
      }
    }

    // Visit the non standard attributes.
<span class="pc bpc" id="L2423" title="1 of 2 branches missed.">    while (attributes != null) {</span>
      // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.
<span class="nc" id="L2425">      Attribute nextAttribute = attributes.nextAttribute;</span>
<span class="nc" id="L2426">      attributes.nextAttribute = null;</span>
<span class="nc" id="L2427">      methodVisitor.visitAttribute(attributes);</span>
<span class="nc" id="L2428">      attributes = nextAttribute;</span>
<span class="nc" id="L2429">    }</span>

    // Visit the max stack and max locals values.
<span class="fc" id="L2432">    methodVisitor.visitMaxs(maxStack, maxLocals);</span>
<span class="fc" id="L2433">  }</span>

  /**
   * Returns the label corresponding to the given bytecode offset. The default implementation of
   * this method creates a label for the given offset if it has not been already created.
   *
   * @param bytecodeOffset a bytecode offset in a method.
   * @param labels the already created labels, indexed by their offset. If a label already exists
   *     for bytecodeOffset this method must not create a new one. Otherwise it must store the new
   *     label in this array.
   * @return a non null Label, which must be equal to labels[bytecodeOffset].
   */
  protected Label readLabel(final int bytecodeOffset, final Label[] labels) {
    // SPRING PATCH: leniently handle offset mismatch
<span class="pc bpc" id="L2447" title="1 of 2 branches missed.">    if (bytecodeOffset &gt;= labels.length) {</span>
<span class="nc" id="L2448">      return new Label();</span>
    }
    // END OF PATCH
<span class="fc bfc" id="L2451" title="All 2 branches covered.">    if (labels[bytecodeOffset] == null) {</span>
<span class="fc" id="L2452">      labels[bytecodeOffset] = new Label();</span>
    }
<span class="fc" id="L2454">    return labels[bytecodeOffset];</span>
  }

  /**
   * Creates a label without the {@link Label#FLAG_DEBUG_ONLY} flag set, for the given bytecode
   * offset. The label is created with a call to {@link #readLabel} and its {@link
   * Label#FLAG_DEBUG_ONLY} flag is cleared.
   *
   * @param bytecodeOffset a bytecode offset in a method.
   * @param labels the already created labels, indexed by their offset.
   * @return a Label without the {@link Label#FLAG_DEBUG_ONLY} flag set.
   */
  private Label createLabel(final int bytecodeOffset, final Label[] labels) {
<span class="fc" id="L2467">    Label label = readLabel(bytecodeOffset, labels);</span>
<span class="fc" id="L2468">    label.flags &amp;= ~Label.FLAG_DEBUG_ONLY;</span>
<span class="fc" id="L2469">    return label;</span>
  }

  /**
   * Creates a label with the {@link Label#FLAG_DEBUG_ONLY} flag set, if there is no already
   * existing label for the given bytecode offset (otherwise does nothing). The label is created
   * with a call to {@link #readLabel}.
   *
   * @param bytecodeOffset a bytecode offset in a method.
   * @param labels the already created labels, indexed by their offset.
   */
  private void createDebugLabel(final int bytecodeOffset, final Label[] labels) {
<span class="fc bfc" id="L2481" title="All 2 branches covered.">    if (labels[bytecodeOffset] == null) {</span>
<span class="fc" id="L2482">      readLabel(bytecodeOffset, labels).flags |= Label.FLAG_DEBUG_ONLY;</span>
    }
<span class="fc" id="L2484">  }</span>

  // ----------------------------------------------------------------------------------------------
  // Methods to parse annotations, type annotations and parameter annotations
  // ----------------------------------------------------------------------------------------------

  /**
   * Parses a Runtime[In]VisibleTypeAnnotations attribute to find the offset of each type_annotation
   * entry it contains, to find the corresponding labels, and to visit the try catch block
   * annotations.
   *
   * @param methodVisitor the method visitor to be used to visit the try catch block annotations.
   * @param context information about the class being parsed.
   * @param runtimeTypeAnnotationsOffset the start offset of a Runtime[In]VisibleTypeAnnotations
   *     attribute, excluding the attribute_info's attribute_name_index and attribute_length fields.
   * @param visible true if the attribute to parse is a RuntimeVisibleTypeAnnotations attribute,
   *     false it is a RuntimeInvisibleTypeAnnotations attribute.
   * @return the start offset of each entry of the Runtime[In]VisibleTypeAnnotations_attribute's
   *     'annotations' array field.
   */
  private int[] readTypeAnnotations(
      final MethodVisitor methodVisitor,
      final Context context,
      final int runtimeTypeAnnotationsOffset,
      final boolean visible) {
<span class="nc" id="L2509">    char[] charBuffer = context.charBuffer;</span>
<span class="nc" id="L2510">    int currentOffset = runtimeTypeAnnotationsOffset;</span>
    // Read the num_annotations field and create an array to store the type_annotation offsets.
<span class="nc" id="L2512">    int[] typeAnnotationsOffsets = new int[readUnsignedShort(currentOffset)];</span>
<span class="nc" id="L2513">    currentOffset += 2;</span>
    // Parse the 'annotations' array field.
<span class="nc bnc" id="L2515" title="All 2 branches missed.">    for (int i = 0; i &lt; typeAnnotationsOffsets.length; ++i) {</span>
<span class="nc" id="L2516">      typeAnnotationsOffsets[i] = currentOffset;</span>
      // Parse the type_annotation's target_type and the target_info fields. The size of the
      // target_info field depends on the value of target_type.
<span class="nc" id="L2519">      int targetType = readInt(currentOffset);</span>
<span class="nc bnc" id="L2520" title="All 4 branches missed.">      switch (targetType &gt;&gt;&gt; 24) {</span>
        case TypeReference.LOCAL_VARIABLE:
        case TypeReference.RESOURCE_VARIABLE:
          // A localvar_target has a variable size, which depends on the value of their table_length
          // field. It also references bytecode offsets, for which we need labels.
<span class="nc" id="L2525">          int tableLength = readUnsignedShort(currentOffset + 1);</span>
<span class="nc" id="L2526">          currentOffset += 3;</span>
<span class="nc bnc" id="L2527" title="All 2 branches missed.">          while (tableLength-- &gt; 0) {</span>
<span class="nc" id="L2528">            int startPc = readUnsignedShort(currentOffset);</span>
<span class="nc" id="L2529">            int length = readUnsignedShort(currentOffset + 2);</span>
            // Skip the index field (2 bytes).
<span class="nc" id="L2531">            currentOffset += 6;</span>
<span class="nc" id="L2532">            createLabel(startPc, context.currentMethodLabels);</span>
<span class="nc" id="L2533">            createLabel(startPc + length, context.currentMethodLabels);</span>
<span class="nc" id="L2534">          }</span>
          break;
        case TypeReference.CAST:
        case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
        case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
        case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
        case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
<span class="nc" id="L2541">          currentOffset += 4;</span>
<span class="nc" id="L2542">          break;</span>
        case TypeReference.CLASS_EXTENDS:
        case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
        case TypeReference.THROWS:
        case TypeReference.EXCEPTION_PARAMETER:
        case TypeReference.INSTANCEOF:
        case TypeReference.NEW:
        case TypeReference.CONSTRUCTOR_REFERENCE:
        case TypeReference.METHOD_REFERENCE:
<span class="nc" id="L2552">          currentOffset += 3;</span>
<span class="nc" id="L2553">          break;</span>
        case TypeReference.CLASS_TYPE_PARAMETER:
        case TypeReference.METHOD_TYPE_PARAMETER:
        case TypeReference.METHOD_FORMAL_PARAMETER:
        case TypeReference.FIELD:
        case TypeReference.METHOD_RETURN:
        case TypeReference.METHOD_RECEIVER:
        default:
          // TypeReference type which can't be used in Code attribute, or which is unknown.
<span class="nc" id="L2562">          throw new IllegalArgumentException();</span>
      }
      // Parse the rest of the type_annotation structure, starting with the target_path structure
      // (whose size depends on its path_length field).
<span class="nc" id="L2566">      int pathLength = readByte(currentOffset);</span>
<span class="nc bnc" id="L2567" title="All 2 branches missed.">      if ((targetType &gt;&gt;&gt; 24) == TypeReference.EXCEPTION_PARAMETER) {</span>
        // Parse the target_path structure and create a corresponding TypePath.
<span class="nc bnc" id="L2569" title="All 2 branches missed.">        TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);</span>
<span class="nc" id="L2570">        currentOffset += 1 + 2 * pathLength;</span>
        // Parse the type_index field.
<span class="nc" id="L2572">        String annotationDescriptor = readUTF8(currentOffset, charBuffer);</span>
<span class="nc" id="L2573">        currentOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="nc" id="L2575">        currentOffset =</span>
<span class="nc" id="L2576">            readElementValues(</span>
<span class="nc" id="L2577">                methodVisitor.visitTryCatchAnnotation(</span>
                    targetType &amp; 0xFFFFFF00, path, annotationDescriptor, visible),
                currentOffset,
                /* named = */ true,
                charBuffer);
<span class="nc" id="L2582">      } else {</span>
        // We don't want to visit the other target_type annotations, so we just skip them (which
        // requires some parsing because the element_value_pairs array has a variable size). First,
        // skip the target_path structure:
<span class="nc" id="L2586">        currentOffset += 3 + 2 * pathLength;</span>
        // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them
        // with a null AnnotationVisitor).
<span class="nc" id="L2589">        currentOffset =</span>
<span class="nc" id="L2590">            readElementValues(</span>
                /* annotationVisitor = */ null, currentOffset, /* named = */ true, charBuffer);
      }
    }
<span class="nc" id="L2594">    return typeAnnotationsOffsets;</span>
  }

  /**
   * Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or
   * -1 if there is no such type_annotation of if it does not have a bytecode offset.
   *
   * @param typeAnnotationOffsets the offset of each 'type_annotation' entry in a
   *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.
   * @param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.
   * @return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1
   *     if there is no such type_annotation of if it does not have a bytecode offset.
   */
  private int getTypeAnnotationBytecodeOffset(
      final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {
<span class="pc bpc" id="L2609" title="3 of 4 branches missed.">    if (typeAnnotationOffsets == null</span>
        || typeAnnotationIndex &gt;= typeAnnotationOffsets.length
<span class="nc bnc" id="L2611" title="All 2 branches missed.">        || readByte(typeAnnotationOffsets[typeAnnotationIndex]) &lt; TypeReference.INSTANCEOF) {</span>
<span class="fc" id="L2612">      return -1;</span>
    }
<span class="nc" id="L2614">    return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);</span>
  }

  /**
   * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info
   * and target_path (the result is stored in the given context), and returns the start offset of
   * the rest of the type_annotation structure.
   *
   * @param context information about the class being parsed. This is where the extracted
   *     target_type and target_path must be stored.
   * @param typeAnnotationOffset the start offset of a type_annotation structure.
   * @return the start offset of the rest of the type_annotation structure.
   */
  private int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) {
<span class="nc" id="L2628">    int currentOffset = typeAnnotationOffset;</span>
    // Parse and store the target_type structure.
<span class="nc" id="L2630">    int targetType = readInt(typeAnnotationOffset);</span>
<span class="nc bnc" id="L2631" title="All 7 branches missed.">    switch (targetType &gt;&gt;&gt; 24) {</span>
      case TypeReference.CLASS_TYPE_PARAMETER:
      case TypeReference.METHOD_TYPE_PARAMETER:
      case TypeReference.METHOD_FORMAL_PARAMETER:
<span class="nc" id="L2635">        targetType &amp;= 0xFFFF0000;</span>
<span class="nc" id="L2636">        currentOffset += 2;</span>
<span class="nc" id="L2637">        break;</span>
      case TypeReference.FIELD:
      case TypeReference.METHOD_RETURN:
      case TypeReference.METHOD_RECEIVER:
<span class="nc" id="L2641">        targetType &amp;= 0xFF000000;</span>
<span class="nc" id="L2642">        currentOffset += 1;</span>
<span class="nc" id="L2643">        break;</span>
      case TypeReference.LOCAL_VARIABLE:
      case TypeReference.RESOURCE_VARIABLE:
<span class="nc" id="L2646">        targetType &amp;= 0xFF000000;</span>
<span class="nc" id="L2647">        int tableLength = readUnsignedShort(currentOffset + 1);</span>
<span class="nc" id="L2648">        currentOffset += 3;</span>
<span class="nc" id="L2649">        context.currentLocalVariableAnnotationRangeStarts = new Label[tableLength];</span>
<span class="nc" id="L2650">        context.currentLocalVariableAnnotationRangeEnds = new Label[tableLength];</span>
<span class="nc" id="L2651">        context.currentLocalVariableAnnotationRangeIndices = new int[tableLength];</span>
<span class="nc bnc" id="L2652" title="All 2 branches missed.">        for (int i = 0; i &lt; tableLength; ++i) {</span>
<span class="nc" id="L2653">          int startPc = readUnsignedShort(currentOffset);</span>
<span class="nc" id="L2654">          int length = readUnsignedShort(currentOffset + 2);</span>
<span class="nc" id="L2655">          int index = readUnsignedShort(currentOffset + 4);</span>
<span class="nc" id="L2656">          currentOffset += 6;</span>
<span class="nc" id="L2657">          context.currentLocalVariableAnnotationRangeStarts[i] =</span>
<span class="nc" id="L2658">              createLabel(startPc, context.currentMethodLabels);</span>
<span class="nc" id="L2659">          context.currentLocalVariableAnnotationRangeEnds[i] =</span>
<span class="nc" id="L2660">              createLabel(startPc + length, context.currentMethodLabels);</span>
<span class="nc" id="L2661">          context.currentLocalVariableAnnotationRangeIndices[i] = index;</span>
        }
<span class="nc" id="L2663">        break;</span>
      case TypeReference.CAST:
      case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
      case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
      case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
      case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
<span class="nc" id="L2669">        targetType &amp;= 0xFF0000FF;</span>
<span class="nc" id="L2670">        currentOffset += 4;</span>
<span class="nc" id="L2671">        break;</span>
      case TypeReference.CLASS_EXTENDS:
      case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
      case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
      case TypeReference.THROWS:
      case TypeReference.EXCEPTION_PARAMETER:
<span class="nc" id="L2677">        targetType &amp;= 0xFFFFFF00;</span>
<span class="nc" id="L2678">        currentOffset += 3;</span>
<span class="nc" id="L2679">        break;</span>
      case TypeReference.INSTANCEOF:
      case TypeReference.NEW:
      case TypeReference.CONSTRUCTOR_REFERENCE:
      case TypeReference.METHOD_REFERENCE:
<span class="nc" id="L2684">        targetType &amp;= 0xFF000000;</span>
<span class="nc" id="L2685">        currentOffset += 3;</span>
<span class="nc" id="L2686">        break;</span>
      default:
<span class="nc" id="L2688">        throw new IllegalArgumentException();</span>
    }
<span class="nc" id="L2690">    context.currentTypeAnnotationTarget = targetType;</span>
    // Parse and store the target_path structure.
<span class="nc" id="L2692">    int pathLength = readByte(currentOffset);</span>
<span class="nc bnc" id="L2693" title="All 2 branches missed.">    context.currentTypeAnnotationTargetPath =</span>
        pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);
    // Return the start offset of the rest of the type_annotation structure.
<span class="nc" id="L2696">    return currentOffset + 1 + 2 * pathLength;</span>
  }

  /**
   * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.
   *
   * @param methodVisitor the visitor that must visit the parameter annotations.
   * @param context information about the class being parsed.
   * @param runtimeParameterAnnotationsOffset the start offset of a
   *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info's
   *     attribute_name_index and attribute_length fields.
   * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations
   *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.
   */
  private void readParameterAnnotations(
      final MethodVisitor methodVisitor,
      final Context context,
      final int runtimeParameterAnnotationsOffset,
      final boolean visible) {
<span class="fc" id="L2715">    int currentOffset = runtimeParameterAnnotationsOffset;</span>
<span class="fc" id="L2716">    int numParameters = classFileBuffer[currentOffset++] &amp; 0xFF;</span>
<span class="fc" id="L2717">    methodVisitor.visitAnnotableParameterCount(numParameters, visible);</span>
<span class="fc" id="L2718">    char[] charBuffer = context.charBuffer;</span>
<span class="fc bfc" id="L2719" title="All 2 branches covered.">    for (int i = 0; i &lt; numParameters; ++i) {</span>
<span class="fc" id="L2720">      int numAnnotations = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L2721">      currentOffset += 2;</span>
<span class="fc bfc" id="L2722" title="All 2 branches covered.">      while (numAnnotations-- &gt; 0) {</span>
        // Parse the type_index field.
<span class="fc" id="L2724">        String annotationDescriptor = readUTF8(currentOffset, charBuffer);</span>
<span class="fc" id="L2725">        currentOffset += 2;</span>
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="fc" id="L2727">        currentOffset =</span>
<span class="fc" id="L2728">            readElementValues(</span>
<span class="fc" id="L2729">                methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible),</span>
                currentOffset,
                /* named = */ true,
                charBuffer);
<span class="fc" id="L2733">      }</span>
    }
<span class="fc" id="L2735">  }</span>

  /**
   * Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit
   * them. This method can also be used to read the values of the JVMS 'array_value' field of an
   * annotation's 'element_value'.
   *
   * @param annotationVisitor the visitor that must visit the values.
   * @param annotationOffset the start offset of an 'annotation' structure (excluding its type_index
   *     field) or of an 'array_value' structure.
   * @param named if the annotation values are named or not. This should be true to parse the values
   *     of a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an
   *     annotation's element_value.
   * @param charBuffer the buffer used to read strings in the constant pool.
   * @return the end offset of the JVMS 'annotation' or 'array_value' structure.
   */
  private int readElementValues(
      final AnnotationVisitor annotationVisitor,
      final int annotationOffset,
      final boolean named,
      final char[] charBuffer) {
<span class="fc" id="L2756">    int currentOffset = annotationOffset;</span>
    // Read the num_element_value_pairs field (or num_values field for an array_value).
<span class="fc" id="L2758">    int numElementValuePairs = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L2759">    currentOffset += 2;</span>
<span class="fc bfc" id="L2760" title="All 2 branches covered.">    if (named) {</span>
      // Parse the element_value_pairs array.
<span class="fc bfc" id="L2762" title="All 2 branches covered.">      while (numElementValuePairs-- &gt; 0) {</span>
<span class="fc" id="L2763">        String elementName = readUTF8(currentOffset, charBuffer);</span>
<span class="fc" id="L2764">        currentOffset =</span>
<span class="fc" id="L2765">            readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);</span>
<span class="fc" id="L2766">      }</span>
    } else {
      // Parse the array_value array.
<span class="fc bfc" id="L2769" title="All 2 branches covered.">      while (numElementValuePairs-- &gt; 0) {</span>
<span class="fc" id="L2770">        currentOffset =</span>
<span class="fc" id="L2771">            readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer);</span>
      }
    }
<span class="fc bfc" id="L2774" title="All 2 branches covered.">    if (annotationVisitor != null) {</span>
<span class="fc" id="L2775">      annotationVisitor.visitEnd();</span>
    }
<span class="fc" id="L2777">    return currentOffset;</span>
  }

  /**
   * Reads a JVMS 'element_value' structure and makes the given visitor visit it.
   *
   * @param annotationVisitor the visitor that must visit the element_value structure.
   * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value
   *     structure to be read.
   * @param elementName the name of the element_value structure to be read, or {@literal null}.
   * @param charBuffer the buffer used to read strings in the constant pool.
   * @return the end offset of the JVMS 'element_value' structure.
   */
  private int readElementValue(
      final AnnotationVisitor annotationVisitor,
      final int elementValueOffset,
      final String elementName,
      final char[] charBuffer) {
<span class="fc" id="L2795">    int currentOffset = elementValueOffset;</span>
<span class="fc bfc" id="L2796" title="All 2 branches covered.">    if (annotationVisitor == null) {</span>
<span class="pc bpc" id="L2797" title="2 of 4 branches missed.">      switch (classFileBuffer[currentOffset] &amp; 0xFF) {</span>
        case 'e': // enum_const_value
<span class="nc" id="L2799">          return currentOffset + 5;</span>
        case '@': // annotation_value
<span class="nc" id="L2801">          return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);</span>
        case '[': // array_value
<span class="fc" id="L2803">          return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);</span>
        default:
<span class="fc" id="L2805">          return currentOffset + 3;</span>
      }
    }
<span class="pc bpc" id="L2808" title="6 of 11 branches missed.">    switch (classFileBuffer[currentOffset++] &amp; 0xFF) {</span>
      case 'B': // const_value_index, CONSTANT_Integer
<span class="nc" id="L2810">        annotationVisitor.visit(</span>
<span class="nc" id="L2811">            elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));</span>
<span class="nc" id="L2812">        currentOffset += 2;</span>
<span class="nc" id="L2813">        break;</span>
      case 'C': // const_value_index, CONSTANT_Integer
<span class="nc" id="L2815">        annotationVisitor.visit(</span>
<span class="nc" id="L2816">            elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));</span>
<span class="nc" id="L2817">        currentOffset += 2;</span>
<span class="nc" id="L2818">        break;</span>
      case 'D': // const_value_index, CONSTANT_Double
      case 'F': // const_value_index, CONSTANT_Float
      case 'I': // const_value_index, CONSTANT_Integer
      case 'J': // const_value_index, CONSTANT_Long
<span class="nc" id="L2823">        annotationVisitor.visit(</span>
<span class="nc" id="L2824">            elementName, readConst(readUnsignedShort(currentOffset), charBuffer));</span>
<span class="nc" id="L2825">        currentOffset += 2;</span>
<span class="nc" id="L2826">        break;</span>
      case 'S': // const_value_index, CONSTANT_Integer
<span class="nc" id="L2828">        annotationVisitor.visit(</span>
<span class="nc" id="L2829">            elementName, (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));</span>
<span class="nc" id="L2830">        currentOffset += 2;</span>
<span class="nc" id="L2831">        break;</span>

      case 'Z': // const_value_index, CONSTANT_Integer
<span class="nc" id="L2834">        annotationVisitor.visit(</span>
            elementName,
<span class="nc bnc" id="L2836" title="All 2 branches missed.">            readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]) == 0</span>
                ? Boolean.FALSE
                : Boolean.TRUE);
<span class="nc" id="L2839">        currentOffset += 2;</span>
<span class="nc" id="L2840">        break;</span>
      case 's': // const_value_index, CONSTANT_Utf8
<span class="fc" id="L2842">        annotationVisitor.visit(elementName, readUTF8(currentOffset, charBuffer));</span>
<span class="fc" id="L2843">        currentOffset += 2;</span>
<span class="fc" id="L2844">        break;</span>
      case 'e': // enum_const_value
<span class="fc" id="L2846">        annotationVisitor.visitEnum(</span>
            elementName,
<span class="fc" id="L2848">            readUTF8(currentOffset, charBuffer),</span>
<span class="fc" id="L2849">            readUTF8(currentOffset + 2, charBuffer));</span>
<span class="fc" id="L2850">        currentOffset += 4;</span>
<span class="fc" id="L2851">        break;</span>
      case 'c': // class_info
<span class="fc" id="L2853">        annotationVisitor.visit(elementName, Type.getType(readUTF8(currentOffset, charBuffer)));</span>
<span class="fc" id="L2854">        currentOffset += 2;</span>
<span class="fc" id="L2855">        break;</span>
      case '@': // annotation_value
<span class="fc" id="L2857">        currentOffset =</span>
<span class="fc" id="L2858">            readElementValues(</span>
<span class="fc" id="L2859">                annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)),</span>
                currentOffset + 2,
                true,
                charBuffer);
<span class="fc" id="L2863">        break;</span>
      case '[': // array_value
<span class="fc" id="L2865">        int numValues = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L2866">        currentOffset += 2;</span>
<span class="fc bfc" id="L2867" title="All 2 branches covered.">        if (numValues == 0) {</span>
<span class="fc" id="L2868">          return readElementValues(</span>
<span class="fc" id="L2869">              annotationVisitor.visitArray(elementName),</span>
              currentOffset - 2,
              /* named = */ false,
              charBuffer);
        }
<span class="pc bpc" id="L2874" title="8 of 9 branches missed.">        switch (classFileBuffer[currentOffset] &amp; 0xFF) {</span>
          case 'B':
<span class="nc" id="L2876">            byte[] byteValues = new byte[numValues];</span>
<span class="nc bnc" id="L2877" title="All 2 branches missed.">            for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc" id="L2878">              byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);</span>
<span class="nc" id="L2879">              currentOffset += 3;</span>
            }
<span class="nc" id="L2881">            annotationVisitor.visit(elementName, byteValues);</span>
<span class="nc" id="L2882">            break;</span>
          case 'Z':
<span class="nc" id="L2884">            boolean[] booleanValues = new boolean[numValues];</span>
<span class="nc bnc" id="L2885" title="All 2 branches missed.">            for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc bnc" id="L2886" title="All 2 branches missed.">              booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;</span>
<span class="nc" id="L2887">              currentOffset += 3;</span>
            }
<span class="nc" id="L2889">            annotationVisitor.visit(elementName, booleanValues);</span>
<span class="nc" id="L2890">            break;</span>
          case 'S':
<span class="nc" id="L2892">            short[] shortValues = new short[numValues];</span>
<span class="nc bnc" id="L2893" title="All 2 branches missed.">            for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc" id="L2894">              shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);</span>
<span class="nc" id="L2895">              currentOffset += 3;</span>
            }
<span class="nc" id="L2897">            annotationVisitor.visit(elementName, shortValues);</span>
<span class="nc" id="L2898">            break;</span>
          case 'C':
<span class="nc" id="L2900">            char[] charValues = new char[numValues];</span>
<span class="nc bnc" id="L2901" title="All 2 branches missed.">            for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc" id="L2902">              charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);</span>
<span class="nc" id="L2903">              currentOffset += 3;</span>
            }
<span class="nc" id="L2905">            annotationVisitor.visit(elementName, charValues);</span>
<span class="nc" id="L2906">            break;</span>
          case 'I':
<span class="nc" id="L2908">            int[] intValues = new int[numValues];</span>
<span class="nc bnc" id="L2909" title="All 2 branches missed.">            for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc" id="L2910">              intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);</span>
<span class="nc" id="L2911">              currentOffset += 3;</span>
            }
<span class="nc" id="L2913">            annotationVisitor.visit(elementName, intValues);</span>
<span class="nc" id="L2914">            break;</span>
          case 'J':
<span class="nc" id="L2916">            long[] longValues = new long[numValues];</span>
<span class="nc bnc" id="L2917" title="All 2 branches missed.">            for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc" id="L2918">              longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);</span>
<span class="nc" id="L2919">              currentOffset += 3;</span>
            }
<span class="nc" id="L2921">            annotationVisitor.visit(elementName, longValues);</span>
<span class="nc" id="L2922">            break;</span>
          case 'F':
<span class="nc" id="L2924">            float[] floatValues = new float[numValues];</span>
<span class="nc bnc" id="L2925" title="All 2 branches missed.">            for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc" id="L2926">              floatValues[i] =</span>
<span class="nc" id="L2927">                  Float.intBitsToFloat(</span>
<span class="nc" id="L2928">                      readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));</span>
<span class="nc" id="L2929">              currentOffset += 3;</span>
            }
<span class="nc" id="L2931">            annotationVisitor.visit(elementName, floatValues);</span>
<span class="nc" id="L2932">            break;</span>
          case 'D':
<span class="nc" id="L2934">            double[] doubleValues = new double[numValues];</span>
<span class="nc bnc" id="L2935" title="All 2 branches missed.">            for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc" id="L2936">              doubleValues[i] =</span>
<span class="nc" id="L2937">                  Double.longBitsToDouble(</span>
<span class="nc" id="L2938">                      readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));</span>
<span class="nc" id="L2939">              currentOffset += 3;</span>
            }
<span class="nc" id="L2941">            annotationVisitor.visit(elementName, doubleValues);</span>
<span class="nc" id="L2942">            break;</span>
          default:
<span class="fc" id="L2944">            currentOffset =</span>
<span class="fc" id="L2945">                readElementValues(</span>
<span class="fc" id="L2946">                    annotationVisitor.visitArray(elementName),</span>
                    currentOffset - 2,
                    /* named = */ false,
                    charBuffer);
<span class="fc" id="L2950">            break;</span>
        }
        break;
      default:
<span class="nc" id="L2954">        throw new IllegalArgumentException();</span>
    }
<span class="fc" id="L2956">    return currentOffset;</span>
  }

  // ----------------------------------------------------------------------------------------------
  // Methods to parse stack map frames
  // ----------------------------------------------------------------------------------------------

  /**
   * Computes the implicit frame of the method currently being parsed (as defined in the given
   * {@link Context}) and stores it in the given context.
   *
   * @param context information about the class being parsed.
   */
  private void computeImplicitFrame(final Context context) {
<span class="nc" id="L2970">    String methodDescriptor = context.currentMethodDescriptor;</span>
<span class="nc" id="L2971">    Object[] locals = context.currentFrameLocalTypes;</span>
<span class="nc" id="L2972">    int numLocal = 0;</span>
<span class="nc bnc" id="L2973" title="All 2 branches missed.">    if ((context.currentMethodAccessFlags &amp; Opcodes.ACC_STATIC) == 0) {</span>
<span class="nc bnc" id="L2974" title="All 2 branches missed.">      if (&quot;&lt;init&gt;&quot;.equals(context.currentMethodName)) {</span>
<span class="nc" id="L2975">        locals[numLocal++] = Opcodes.UNINITIALIZED_THIS;</span>
      } else {
<span class="nc" id="L2977">        locals[numLocal++] = readClass(header + 2, context.charBuffer);</span>
      }
    }
    // Parse the method descriptor, one argument type descriptor at each iteration. Start by
    // skipping the first method descriptor character, which is always '('.
<span class="nc" id="L2982">    int currentMethodDescritorOffset = 1;</span>
    while (true) {
<span class="nc" id="L2984">      int currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;</span>
<span class="nc bnc" id="L2985" title="All 7 branches missed.">      switch (methodDescriptor.charAt(currentMethodDescritorOffset++)) {</span>
        case 'Z':
        case 'C':
        case 'B':
        case 'S':
        case 'I':
<span class="nc" id="L2991">          locals[numLocal++] = Opcodes.INTEGER;</span>
<span class="nc" id="L2992">          break;</span>
        case 'F':
<span class="nc" id="L2994">          locals[numLocal++] = Opcodes.FLOAT;</span>
<span class="nc" id="L2995">          break;</span>
        case 'J':
<span class="nc" id="L2997">          locals[numLocal++] = Opcodes.LONG;</span>
<span class="nc" id="L2998">          break;</span>
        case 'D':
<span class="nc" id="L3000">          locals[numLocal++] = Opcodes.DOUBLE;</span>
<span class="nc" id="L3001">          break;</span>
        case '[':
<span class="nc bnc" id="L3003" title="All 2 branches missed.">          while (methodDescriptor.charAt(currentMethodDescritorOffset) == '[') {</span>
<span class="nc" id="L3004">            ++currentMethodDescritorOffset;</span>
          }
<span class="nc bnc" id="L3006" title="All 2 branches missed.">          if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {</span>
<span class="nc" id="L3007">            ++currentMethodDescritorOffset;</span>
<span class="nc bnc" id="L3008" title="All 2 branches missed.">            while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {</span>
<span class="nc" id="L3009">              ++currentMethodDescritorOffset;</span>
            }
          }
<span class="nc" id="L3012">          locals[numLocal++] =</span>
<span class="nc" id="L3013">              methodDescriptor.substring(</span>
                  currentArgumentDescriptorStartOffset, ++currentMethodDescritorOffset);
<span class="nc" id="L3015">          break;</span>
        case 'L':
<span class="nc bnc" id="L3017" title="All 2 branches missed.">          while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {</span>
<span class="nc" id="L3018">            ++currentMethodDescritorOffset;</span>
          }
<span class="nc" id="L3020">          locals[numLocal++] =</span>
<span class="nc" id="L3021">              methodDescriptor.substring(</span>
                  currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);
<span class="nc" id="L3023">          break;</span>
        default:
<span class="nc" id="L3025">          context.currentFrameLocalCount = numLocal;</span>
<span class="nc" id="L3026">          return;</span>
      }
<span class="nc" id="L3028">    }</span>
  }

  /**
   * Reads a JVMS 'stack_map_frame' structure and stores the result in the given {@link Context}
   * object. This method can also be used to read a full_frame structure, excluding its frame_type
   * field (this is used to parse the legacy StackMap attributes).
   *
   * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the
   *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure
   *     (excluding its frame_type field).
   * @param compressed true to read a 'stack_map_frame' structure, false to read a 'full_frame'
   *     structure without its frame_type field.
   * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.
   * @param context where the parsed stack map frame must be stored.
   * @return the end offset of the JVMS 'stack_map_frame' or 'full_frame' structure.
   */
  private int readStackMapFrame(
      final int stackMapFrameOffset,
      final boolean compressed,
      final boolean expand,
      final Context context) {
<span class="fc" id="L3050">    int currentOffset = stackMapFrameOffset;</span>
<span class="fc" id="L3051">    final char[] charBuffer = context.charBuffer;</span>
<span class="fc" id="L3052">    final Label[] labels = context.currentMethodLabels;</span>
    int frameType;
<span class="pc bpc" id="L3054" title="1 of 2 branches missed.">    if (compressed) {</span>
      // Read the frame_type field.
<span class="fc" id="L3056">      frameType = classFileBuffer[currentOffset++] &amp; 0xFF;</span>
    } else {
<span class="nc" id="L3058">      frameType = Frame.FULL_FRAME;</span>
<span class="nc" id="L3059">      context.currentFrameOffset = -1;</span>
    }
    int offsetDelta;
<span class="fc" id="L3062">    context.currentFrameLocalCountDelta = 0;</span>
<span class="pc bpc" id="L3063" title="1 of 2 branches missed.">    if (frameType &lt; Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {</span>
<span class="fc" id="L3064">      offsetDelta = frameType;</span>
<span class="fc" id="L3065">      context.currentFrameType = Opcodes.F_SAME;</span>
<span class="fc" id="L3066">      context.currentFrameStackCount = 0;</span>
<span class="nc bnc" id="L3067" title="All 2 branches missed.">    } else if (frameType &lt; Frame.RESERVED) {</span>
<span class="nc" id="L3068">      offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;</span>
<span class="nc" id="L3069">      currentOffset =</span>
<span class="nc" id="L3070">          readVerificationTypeInfo(</span>
              currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);
<span class="nc" id="L3072">      context.currentFrameType = Opcodes.F_SAME1;</span>
<span class="nc" id="L3073">      context.currentFrameStackCount = 1;</span>
<span class="nc bnc" id="L3074" title="All 2 branches missed.">    } else if (frameType &gt;= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {</span>
<span class="nc" id="L3075">      offsetDelta = readUnsignedShort(currentOffset);</span>
<span class="nc" id="L3076">      currentOffset += 2;</span>
<span class="nc bnc" id="L3077" title="All 2 branches missed.">      if (frameType == Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {</span>
<span class="nc" id="L3078">        currentOffset =</span>
<span class="nc" id="L3079">            readVerificationTypeInfo(</span>
                currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);
<span class="nc" id="L3081">        context.currentFrameType = Opcodes.F_SAME1;</span>
<span class="nc" id="L3082">        context.currentFrameStackCount = 1;</span>
<span class="nc bnc" id="L3083" title="All 4 branches missed.">      } else if (frameType &gt;= Frame.CHOP_FRAME &amp;&amp; frameType &lt; Frame.SAME_FRAME_EXTENDED) {</span>
<span class="nc" id="L3084">        context.currentFrameType = Opcodes.F_CHOP;</span>
<span class="nc" id="L3085">        context.currentFrameLocalCountDelta = Frame.SAME_FRAME_EXTENDED - frameType;</span>
<span class="nc" id="L3086">        context.currentFrameLocalCount -= context.currentFrameLocalCountDelta;</span>
<span class="nc" id="L3087">        context.currentFrameStackCount = 0;</span>
<span class="nc bnc" id="L3088" title="All 2 branches missed.">      } else if (frameType == Frame.SAME_FRAME_EXTENDED) {</span>
<span class="nc" id="L3089">        context.currentFrameType = Opcodes.F_SAME;</span>
<span class="nc" id="L3090">        context.currentFrameStackCount = 0;</span>
<span class="nc bnc" id="L3091" title="All 2 branches missed.">      } else if (frameType &lt; Frame.FULL_FRAME) {</span>
<span class="nc bnc" id="L3092" title="All 2 branches missed.">        int local = expand ? context.currentFrameLocalCount : 0;</span>
<span class="nc bnc" id="L3093" title="All 2 branches missed.">        for (int k = frameType - Frame.SAME_FRAME_EXTENDED; k &gt; 0; k--) {</span>
<span class="nc" id="L3094">          currentOffset =</span>
<span class="nc" id="L3095">              readVerificationTypeInfo(</span>
                  currentOffset, context.currentFrameLocalTypes, local++, charBuffer, labels);
        }
<span class="nc" id="L3098">        context.currentFrameType = Opcodes.F_APPEND;</span>
<span class="nc" id="L3099">        context.currentFrameLocalCountDelta = frameType - Frame.SAME_FRAME_EXTENDED;</span>
<span class="nc" id="L3100">        context.currentFrameLocalCount += context.currentFrameLocalCountDelta;</span>
<span class="nc" id="L3101">        context.currentFrameStackCount = 0;</span>
<span class="nc" id="L3102">      } else {</span>
<span class="nc" id="L3103">        final int numberOfLocals = readUnsignedShort(currentOffset);</span>
<span class="nc" id="L3104">        currentOffset += 2;</span>
<span class="nc" id="L3105">        context.currentFrameType = Opcodes.F_FULL;</span>
<span class="nc" id="L3106">        context.currentFrameLocalCountDelta = numberOfLocals;</span>
<span class="nc" id="L3107">        context.currentFrameLocalCount = numberOfLocals;</span>
<span class="nc bnc" id="L3108" title="All 2 branches missed.">        for (int local = 0; local &lt; numberOfLocals; ++local) {</span>
<span class="nc" id="L3109">          currentOffset =</span>
<span class="nc" id="L3110">              readVerificationTypeInfo(</span>
                  currentOffset, context.currentFrameLocalTypes, local, charBuffer, labels);
        }
<span class="nc" id="L3113">        final int numberOfStackItems = readUnsignedShort(currentOffset);</span>
<span class="nc" id="L3114">        currentOffset += 2;</span>
<span class="nc" id="L3115">        context.currentFrameStackCount = numberOfStackItems;</span>
<span class="nc bnc" id="L3116" title="All 2 branches missed.">        for (int stack = 0; stack &lt; numberOfStackItems; ++stack) {</span>
<span class="nc" id="L3117">          currentOffset =</span>
<span class="nc" id="L3118">              readVerificationTypeInfo(</span>
                  currentOffset, context.currentFrameStackTypes, stack, charBuffer, labels);
        }
<span class="nc" id="L3121">      }</span>
    } else {
<span class="nc" id="L3123">      throw new IllegalArgumentException();</span>
    }
<span class="fc" id="L3125">    context.currentFrameOffset += offsetDelta + 1;</span>
<span class="fc" id="L3126">    createLabel(context.currentFrameOffset, labels);</span>
<span class="fc" id="L3127">    return currentOffset;</span>
  }

  /**
   * Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given
   * array.
   *
   * @param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to
   *     read.
   * @param frame the array where the parsed type must be stored.
   * @param index the index in 'frame' where the parsed type must be stored.
   * @param charBuffer the buffer used to read strings in the constant pool.
   * @param labels the labels of the method currently being parsed, indexed by their offset. If the
   *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is
   *     stored in this array if it does not already exist.
   * @return the end offset of the JVMS 'verification_type_info' structure.
   */
  private int readVerificationTypeInfo(
      final int verificationTypeInfoOffset,
      final Object[] frame,
      final int index,
      final char[] charBuffer,
      final Label[] labels) {
<span class="nc" id="L3150">    int currentOffset = verificationTypeInfoOffset;</span>
<span class="nc" id="L3151">    int tag = classFileBuffer[currentOffset++] &amp; 0xFF;</span>
<span class="nc bnc" id="L3152" title="All 10 branches missed.">    switch (tag) {</span>
      case Frame.ITEM_TOP:
<span class="nc" id="L3154">        frame[index] = Opcodes.TOP;</span>
<span class="nc" id="L3155">        break;</span>
      case Frame.ITEM_INTEGER:
<span class="nc" id="L3157">        frame[index] = Opcodes.INTEGER;</span>
<span class="nc" id="L3158">        break;</span>
      case Frame.ITEM_FLOAT:
<span class="nc" id="L3160">        frame[index] = Opcodes.FLOAT;</span>
<span class="nc" id="L3161">        break;</span>
      case Frame.ITEM_DOUBLE:
<span class="nc" id="L3163">        frame[index] = Opcodes.DOUBLE;</span>
<span class="nc" id="L3164">        break;</span>
      case Frame.ITEM_LONG:
<span class="nc" id="L3166">        frame[index] = Opcodes.LONG;</span>
<span class="nc" id="L3167">        break;</span>
      case Frame.ITEM_NULL:
<span class="nc" id="L3169">        frame[index] = Opcodes.NULL;</span>
<span class="nc" id="L3170">        break;</span>
      case Frame.ITEM_UNINITIALIZED_THIS:
<span class="nc" id="L3172">        frame[index] = Opcodes.UNINITIALIZED_THIS;</span>
<span class="nc" id="L3173">        break;</span>
      case Frame.ITEM_OBJECT:
<span class="nc" id="L3175">        frame[index] = readClass(currentOffset, charBuffer);</span>
<span class="nc" id="L3176">        currentOffset += 2;</span>
<span class="nc" id="L3177">        break;</span>
      case Frame.ITEM_UNINITIALIZED:
<span class="nc" id="L3179">        frame[index] = createLabel(readUnsignedShort(currentOffset), labels);</span>
<span class="nc" id="L3180">        currentOffset += 2;</span>
<span class="nc" id="L3181">        break;</span>
      default:
<span class="nc" id="L3183">        throw new IllegalArgumentException();</span>
    }
<span class="nc" id="L3185">    return currentOffset;</span>
  }

  // ----------------------------------------------------------------------------------------------
  // Methods to parse attributes
  // ----------------------------------------------------------------------------------------------

  /**
   * Returns the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array
   * field entry.
   *
   * @return the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array
   *     field entry.
   */
  final int getFirstAttributeOffset() {
    // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes
    // each), as well as the interfaces array field (2 bytes per interface).
<span class="fc" id="L3202">    int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;</span>

    // Read the fields_count field.
<span class="fc" id="L3205">    int fieldsCount = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L3206">    currentOffset += 2;</span>
    // Skip the 'fields' array field.
<span class="fc bfc" id="L3208" title="All 2 branches covered.">    while (fieldsCount-- &gt; 0) {</span>
      // Invariant: currentOffset is the offset of a field_info structure.
      // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the
      // attributes_count field.
<span class="fc" id="L3212">      int attributesCount = readUnsignedShort(currentOffset + 6);</span>
<span class="fc" id="L3213">      currentOffset += 8;</span>
      // Skip the 'attributes' array field.
<span class="pc bpc" id="L3215" title="1 of 2 branches missed.">      while (attributesCount-- &gt; 0) {</span>
        // Invariant: currentOffset is the offset of an attribute_info structure.
        // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip
        // this many bytes, plus 6 for the attribute_name_index and attribute_length fields
        // (yielding the total size of the attribute_info structure).
<span class="nc" id="L3220">        currentOffset += 6 + readInt(currentOffset + 2);</span>
      }
<span class="fc" id="L3222">    }</span>

    // Skip the methods_count and 'methods' fields, using the same method as above.
<span class="fc" id="L3225">    int methodsCount = readUnsignedShort(currentOffset);</span>
<span class="fc" id="L3226">    currentOffset += 2;</span>
<span class="fc bfc" id="L3227" title="All 2 branches covered.">    while (methodsCount-- &gt; 0) {</span>
<span class="fc" id="L3228">      int attributesCount = readUnsignedShort(currentOffset + 6);</span>
<span class="fc" id="L3229">      currentOffset += 8;</span>
<span class="fc bfc" id="L3230" title="All 2 branches covered.">      while (attributesCount-- &gt; 0) {</span>
<span class="fc" id="L3231">        currentOffset += 6 + readInt(currentOffset + 2);</span>
      }
<span class="fc" id="L3233">    }</span>

    // Skip the ClassFile's attributes_count field.
<span class="fc" id="L3236">    return currentOffset + 2;</span>
  }

  /**
   * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.
   *
   * @param maxStringLength a conservative estimate of the maximum length of the strings contained
   *     in the constant pool of the class.
   * @return the offsets of the bootstrap methods.
   */
  private int[] readBootstrapMethodsAttribute(final int maxStringLength) {
<span class="nc" id="L3247">    char[] charBuffer = new char[maxStringLength];</span>
<span class="nc" id="L3248">    int currentAttributeOffset = getFirstAttributeOffset();</span>
<span class="nc" id="L3249">    int[] currentBootstrapMethodOffsets = null;</span>
<span class="nc bnc" id="L3250" title="All 2 branches missed.">    for (int i = readUnsignedShort(currentAttributeOffset - 2); i &gt; 0; --i) {</span>
      // Read the attribute_info's attribute_name and attribute_length fields.
<span class="nc" id="L3252">      String attributeName = readUTF8(currentAttributeOffset, charBuffer);</span>
<span class="nc" id="L3253">      int attributeLength = readInt(currentAttributeOffset + 2);</span>
<span class="nc" id="L3254">      currentAttributeOffset += 6;</span>
<span class="nc bnc" id="L3255" title="All 2 branches missed.">      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {</span>
        // Read the num_bootstrap_methods field and create an array of this size.
<span class="nc" id="L3257">        currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];</span>
        // Compute and store the offset of each 'bootstrap_methods' array field entry.
<span class="nc" id="L3259">        int currentBootstrapMethodOffset = currentAttributeOffset + 2;</span>
<span class="nc bnc" id="L3260" title="All 2 branches missed.">        for (int j = 0; j &lt; currentBootstrapMethodOffsets.length; ++j) {</span>
<span class="nc" id="L3261">          currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;</span>
          // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),
          // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).
<span class="nc" id="L3264">          currentBootstrapMethodOffset +=</span>
<span class="nc" id="L3265">              4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;</span>
        }
<span class="nc" id="L3267">        return currentBootstrapMethodOffsets;</span>
      }
<span class="nc" id="L3269">      currentAttributeOffset += attributeLength;</span>
    }
<span class="nc" id="L3271">    throw new IllegalArgumentException();</span>
  }

  /**
   * Reads a non standard JVMS 'attribute' structure in {@link #classFileBuffer}.
   *
   * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
   *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
   *     be parsed: its byte array value will be passed unchanged to the ClassWriter.
   * @param type the type of the attribute.
   * @param offset the start offset of the JVMS 'attribute' structure in {@link #classFileBuffer}.
   *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into
   *     account here.
   * @param length the length of the attribute's content (excluding the 6 attribute header bytes).
   * @param charBuffer the buffer to be used to read strings in the constant pool.
   * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link
   *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6
   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into
   *     account here.
   * @param labels the labels of the method's code, or {@literal null} if the attribute to be read
   *     is not a code attribute.
   * @return the attribute that has been read.
   */
  private Attribute readAttribute(
      final Attribute[] attributePrototypes,
      final String type,
      final int offset,
      final int length,
      final char[] charBuffer,
      final int codeAttributeOffset,
      final Label[] labels) {
<span class="nc bnc" id="L3302" title="All 2 branches missed.">    for (Attribute attributePrototype : attributePrototypes) {</span>
<span class="nc bnc" id="L3303" title="All 2 branches missed.">      if (attributePrototype.type.equals(type)) {</span>
<span class="nc" id="L3304">        return attributePrototype.read(</span>
            this, offset, length, charBuffer, codeAttributeOffset, labels);
      }
    }
<span class="nc" id="L3308">    return new Attribute(type).read(this, offset, length, null, -1, null);</span>
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods: low level parsing
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the number of entries in the class's constant pool table.
   *
   * @return the number of entries in the class's constant pool table.
   */
  public int getItemCount() {
<span class="nc" id="L3321">    return cpInfoOffsets.length;</span>
  }

  /**
   * Returns the start offset in this {@link ClassReader} of a JVMS 'cp_info' structure (i.e. a
   * constant pool entry), plus one. &lt;i&gt;This method is intended for {@link Attribute} sub classes,
   * and is normally not needed by class generators or adapters.&lt;/i&gt;
   *
   * @param constantPoolEntryIndex the index a constant pool entry in the class's constant pool
   *     table.
   * @return the start offset in this {@link ClassReader} of the corresponding JVMS 'cp_info'
   *     structure, plus one.
   */
  public int getItem(final int constantPoolEntryIndex) {
<span class="nc" id="L3335">    return cpInfoOffsets[constantPoolEntryIndex];</span>
  }

  /**
   * Returns a conservative estimate of the maximum length of the strings contained in the class's
   * constant pool table.
   *
   * @return a conservative estimate of the maximum length of the strings contained in the class's
   *     constant pool table.
   */
  public int getMaxStringLength() {
<span class="nc" id="L3346">    return maxStringLength;</span>
  }

  /**
   * Reads a byte value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link
   * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
   *
   * @param offset the start offset of the value to be read in this {@link ClassReader}.
   * @return the read value.
   */
  public int readByte(final int offset) {
<span class="fc" id="L3357">    return classFileBuffer[offset] &amp; 0xFF;</span>
  }

  /**
   * Reads an unsigned short value in this {@link ClassReader}. &lt;i&gt;This method is intended for
   * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
   *
   * @param offset the start index of the value to be read in this {@link ClassReader}.
   * @return the read value.
   */
  public int readUnsignedShort(final int offset) {
<span class="fc" id="L3368">    byte[] classBuffer = classFileBuffer;</span>
<span class="fc" id="L3369">    return ((classBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classBuffer[offset + 1] &amp; 0xFF);</span>
  }

  /**
   * Reads a signed short value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link
   * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
   *
   * @param offset the start offset of the value to be read in this {@link ClassReader}.
   * @return the read value.
   */
  public short readShort(final int offset) {
<span class="fc" id="L3380">    byte[] classBuffer = classFileBuffer;</span>
<span class="fc" id="L3381">    return (short) (((classBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classBuffer[offset + 1] &amp; 0xFF));</span>
  }

  /**
   * Reads a signed int value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link
   * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
   *
   * @param offset the start offset of the value to be read in this {@link ClassReader}.
   * @return the read value.
   */
  public int readInt(final int offset) {
<span class="fc" id="L3392">    byte[] classBuffer = classFileBuffer;</span>
<span class="fc" id="L3393">    return ((classBuffer[offset] &amp; 0xFF) &lt;&lt; 24)</span>
        | ((classBuffer[offset + 1] &amp; 0xFF) &lt;&lt; 16)
        | ((classBuffer[offset + 2] &amp; 0xFF) &lt;&lt; 8)
        | (classBuffer[offset + 3] &amp; 0xFF);
  }

  /**
   * Reads a signed long value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link
   * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
   *
   * @param offset the start offset of the value to be read in this {@link ClassReader}.
   * @return the read value.
   */
  public long readLong(final int offset) {
<span class="fc" id="L3407">    long l1 = readInt(offset);</span>
<span class="fc" id="L3408">    long l0 = readInt(offset + 4) &amp; 0xFFFFFFFFL;</span>
<span class="fc" id="L3409">    return (l1 &lt;&lt; 32) | l0;</span>
  }

  /**
   * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is
   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
   * adapters.&lt;/i&gt;
   *
   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
   *     value is the index of a CONSTANT_Utf8 entry in the class's constant pool table.
   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified CONSTANT_Utf8 entry.
   */
  // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
  public String readUTF8(final int offset, final char[] charBuffer) {
<span class="fc" id="L3425">    int constantPoolEntryIndex = readUnsignedShort(offset);</span>
<span class="fc bfc" id="L3426" title="All 4 branches covered.">    if (offset == 0 || constantPoolEntryIndex == 0) {</span>
<span class="fc" id="L3427">      return null;</span>
    }
<span class="fc" id="L3429">    return readUtf(constantPoolEntryIndex, charBuffer);</span>
  }

  /**
   * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.
   *
   * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pool
   *     table.
   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified CONSTANT_Utf8 entry.
   */
  final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {
<span class="fc" id="L3442">    String value = constantUtf8Values[constantPoolEntryIndex];</span>
<span class="fc bfc" id="L3443" title="All 2 branches covered.">    if (value != null) {</span>
<span class="fc" id="L3444">      return value;</span>
    }
<span class="fc" id="L3446">    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];</span>
<span class="fc" id="L3447">    return constantUtf8Values[constantPoolEntryIndex] =</span>
<span class="fc" id="L3448">        readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);</span>
  }

  /**
   * Reads an UTF8 string in {@link #classFileBuffer}.
   *
   * @param utfOffset the start offset of the UTF8 string to be read.
   * @param utfLength the length of the UTF8 string to be read.
   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified UTF8 string.
   */
  private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {
<span class="fc" id="L3461">    int currentOffset = utfOffset;</span>
<span class="fc" id="L3462">    int endOffset = currentOffset + utfLength;</span>
<span class="fc" id="L3463">    int strLength = 0;</span>
<span class="fc" id="L3464">    byte[] classBuffer = classFileBuffer;</span>
<span class="fc bfc" id="L3465" title="All 2 branches covered.">    while (currentOffset &lt; endOffset) {</span>
<span class="fc" id="L3466">      int currentByte = classBuffer[currentOffset++];</span>
<span class="pc bpc" id="L3467" title="1 of 2 branches missed.">      if ((currentByte &amp; 0x80) == 0) {</span>
<span class="fc" id="L3468">        charBuffer[strLength++] = (char) (currentByte &amp; 0x7F);</span>
<span class="nc bnc" id="L3469" title="All 2 branches missed.">      } else if ((currentByte &amp; 0xE0) == 0xC0) {</span>
<span class="nc" id="L3470">        charBuffer[strLength++] =</span>
            (char) (((currentByte &amp; 0x1F) &lt;&lt; 6) + (classBuffer[currentOffset++] &amp; 0x3F));
      } else {
<span class="nc" id="L3473">        charBuffer[strLength++] =</span>
            (char)
                (((currentByte &amp; 0xF) &lt;&lt; 12)
                    + ((classBuffer[currentOffset++] &amp; 0x3F) &lt;&lt; 6)
                    + (classBuffer[currentOffset++] &amp; 0x3F));
      }
<span class="fc" id="L3479">    }</span>
<span class="fc" id="L3480">    return new String(charBuffer, 0, strLength);</span>
  }

  /**
   * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
   * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. &lt;i&gt;This method is intended
   * for {@link Attribute} sub classes, and is normally not needed by class generators or
   * adapters.&lt;/i&gt;
   *
   * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose
   *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
   *     CONSTANT_Module or CONSTANT_Package entry in class's constant pool table.
   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified constant pool entry.
   */
  private String readStringish(final int offset, final char[] charBuffer) {
    // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry
    // designated by the first two bytes of this cp_info.
<span class="fc" id="L3499">    return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);</span>
  }

  /**
   * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is
   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
   * adapters.&lt;/i&gt;
   *
   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
   *     value is the index of a CONSTANT_Class entry in class's constant pool table.
   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified CONSTANT_Class entry.
   */
  public String readClass(final int offset, final char[] charBuffer) {
<span class="fc" id="L3514">    return readStringish(offset, charBuffer);</span>
  }

  /**
   * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is
   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
   * adapters.&lt;/i&gt;
   *
   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
   *     value is the index of a CONSTANT_Module entry in class's constant pool table.
   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified CONSTANT_Module entry.
   */
  public String readModule(final int offset, final char[] charBuffer) {
<span class="nc" id="L3529">    return readStringish(offset, charBuffer);</span>
  }

  /**
   * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is
   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
   * adapters.&lt;/i&gt;
   *
   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
   *     value is the index of a CONSTANT_Package entry in class's constant pool table.
   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified CONSTANT_Package entry.
   */
  public String readPackage(final int offset, final char[] charBuffer) {
<span class="nc" id="L3544">    return readStringish(offset, charBuffer);</span>
  }

  /**
   * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.
   *
   * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class's constant
   *     pool table.
   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.
   */
  private ConstantDynamic readConstantDynamic(
      final int constantPoolEntryIndex, final char[] charBuffer) {
<span class="nc" id="L3558">    ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];</span>
<span class="nc bnc" id="L3559" title="All 2 branches missed.">    if (constantDynamic != null) {</span>
<span class="nc" id="L3560">      return constantDynamic;</span>
    }
<span class="nc" id="L3562">    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];</span>
<span class="nc" id="L3563">    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];</span>
<span class="nc" id="L3564">    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);</span>
<span class="nc" id="L3565">    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);</span>
<span class="nc" id="L3566">    int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];</span>
<span class="nc" id="L3567">    Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);</span>
<span class="nc" id="L3568">    Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];</span>
<span class="nc" id="L3569">    bootstrapMethodOffset += 4;</span>
<span class="nc bnc" id="L3570" title="All 2 branches missed.">    for (int i = 0; i &lt; bootstrapMethodArguments.length; i++) {</span>
<span class="nc" id="L3571">      bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);</span>
<span class="nc" id="L3572">      bootstrapMethodOffset += 2;</span>
    }
<span class="nc" id="L3574">    return constantDynamicValues[constantPoolEntryIndex] =</span>
        new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);
  }

  /**
   * Reads a numeric or string constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is
   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
   * adapters.&lt;/i&gt;
   *
   * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,
   *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
   *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class's constant pool.
   * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},
   *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified
   *     constant pool entry.
   */
  public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {
<span class="fc" id="L3593">    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];</span>
<span class="pc bpc" id="L3594" title="7 of 10 branches missed.">    switch (classFileBuffer[cpInfoOffset - 1]) {</span>
      case Symbol.CONSTANT_INTEGER_TAG:
<span class="nc" id="L3596">        return readInt(cpInfoOffset);</span>
      case Symbol.CONSTANT_FLOAT_TAG:
<span class="nc" id="L3598">        return Float.intBitsToFloat(readInt(cpInfoOffset));</span>
      case Symbol.CONSTANT_LONG_TAG:
<span class="fc" id="L3600">        return readLong(cpInfoOffset);</span>
      case Symbol.CONSTANT_DOUBLE_TAG:
<span class="nc" id="L3602">        return Double.longBitsToDouble(readLong(cpInfoOffset));</span>
      case Symbol.CONSTANT_CLASS_TAG:
<span class="fc" id="L3604">        return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));</span>
      case Symbol.CONSTANT_STRING_TAG:
<span class="fc" id="L3606">        return readUTF8(cpInfoOffset, charBuffer);</span>
      case Symbol.CONSTANT_METHOD_TYPE_TAG:
<span class="nc" id="L3608">        return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));</span>
      case Symbol.CONSTANT_METHOD_HANDLE_TAG:
<span class="nc" id="L3610">        int referenceKind = readByte(cpInfoOffset);</span>
<span class="nc" id="L3611">        int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];</span>
<span class="nc" id="L3612">        int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];</span>
<span class="nc" id="L3613">        String owner = readClass(referenceCpInfoOffset, charBuffer);</span>
<span class="nc" id="L3614">        String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);</span>
<span class="nc" id="L3615">        String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);</span>
<span class="nc bnc" id="L3616" title="All 2 branches missed.">        boolean isInterface =</span>
            classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
<span class="nc" id="L3618">        return new Handle(referenceKind, owner, name, descriptor, isInterface);</span>
      case Symbol.CONSTANT_DYNAMIC_TAG:
<span class="nc" id="L3620">        return readConstantDynamic(constantPoolEntryIndex, charBuffer);</span>
      default:
<span class="nc" id="L3622">        throw new IllegalArgumentException();</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>