<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SymbolTable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-core</a> &gt; <a href="index.source.html" class="el_package">org.springframework.asm</a> &gt; <span class="el_source">SymbolTable.java</span></div><h1>SymbolTable.java</h1><pre class="source lang-java linenums">// ASM: a very small and fast Java bytecode manipulation framework
// Copyright (c) 2000-2011 INRIA, France Telecom
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.
package org.springframework.asm;

/**
 * The constant pool entries, the BootstrapMethods attribute entries and the (ASM specific) type
 * table entries of a class.
 *
 * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4&quot;&gt;JVMS
 *     4.4&lt;/a&gt;
 * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23&quot;&gt;JVMS
 *     4.7.23&lt;/a&gt;
 * @author Eric Bruneton
 */
final class SymbolTable {

  /**
   * The ClassWriter to which this SymbolTable belongs. This is only used to get access to {@link
   * ClassWriter#getCommonSuperClass} and to serialize custom attributes with {@link
   * Attribute#write}.
   */
  final ClassWriter classWriter;

  /**
   * The ClassReader from which this SymbolTable was constructed, or {@literal null} if it was
   * constructed from scratch.
   */
  private final ClassReader sourceClassReader;

  /** The major version number of the class to which this symbol table belongs. */
  private int majorVersion;

  /** The internal name of the class to which this symbol table belongs. */
  private String className;

  /**
   * The total number of {@link Entry} instances in {@link #entries}. This includes entries that are
   * accessible (recursively) via {@link Entry#next}.
   */
  private int entryCount;

  /**
   * A hash set of all the entries in this SymbolTable (this includes the constant pool entries, the
   * bootstrap method entries and the type table entries). Each {@link Entry} instance is stored at
   * the array index given by its hash code modulo the array size. If several entries must be stored
   * at the same array index, they are linked together via their {@link Entry#next} field. The
   * factory methods of this class make sure that this table does not contain duplicated entries.
   */
  private Entry[] entries;

  /**
   * The number of constant pool items in {@link #constantPool}, plus 1. The first constant pool
   * item has index 1, and long and double items count for two items.
   */
  private int constantPoolCount;

  /**
   * The content of the ClassFile's constant_pool JVMS structure corresponding to this SymbolTable.
   * The ClassFile's constant_pool_count field is &lt;i&gt;not&lt;/i&gt; included.
   */
  private ByteVector constantPool;

  /**
   * The number of bootstrap methods in {@link #bootstrapMethods}. Corresponds to the
   * BootstrapMethods_attribute's num_bootstrap_methods field value.
   */
  private int bootstrapMethodCount;

  /**
   * The content of the BootstrapMethods attribute 'bootstrap_methods' array corresponding to this
   * SymbolTable. Note that the first 6 bytes of the BootstrapMethods_attribute, and its
   * num_bootstrap_methods field, are &lt;i&gt;not&lt;/i&gt; included.
   */
  private ByteVector bootstrapMethods;

  /**
   * The actual number of elements in {@link #typeTable}. These elements are stored from index 0 to
   * typeCount (excluded). The other array entries are empty.
   */
  private int typeCount;

  /**
   * An ASM specific type table used to temporarily store internal names that will not necessarily
   * be stored in the constant pool. This type table is used by the control flow and data flow
   * analysis algorithm used to compute stack map frames from scratch. This array stores {@link
   * Symbol#TYPE_TAG} and {@link Symbol#UNINITIALIZED_TYPE_TAG}) Symbol. The type symbol at index
   * {@code i} has its {@link Symbol#index} equal to {@code i} (and vice versa).
   */
  private Entry[] typeTable;

  /**
   * Constructs a new, empty SymbolTable for the given ClassWriter.
   *
   * @param classWriter a ClassWriter.
   */
<span class="nc" id="L121">  SymbolTable(final ClassWriter classWriter) {</span>
<span class="nc" id="L122">    this.classWriter = classWriter;</span>
<span class="nc" id="L123">    this.sourceClassReader = null;</span>
<span class="nc" id="L124">    this.entries = new Entry[256];</span>
<span class="nc" id="L125">    this.constantPoolCount = 1;</span>
<span class="nc" id="L126">    this.constantPool = new ByteVector();</span>
<span class="nc" id="L127">  }</span>

  /**
   * Constructs a new SymbolTable for the given ClassWriter, initialized with the constant pool and
   * bootstrap methods of the given ClassReader.
   *
   * @param classWriter a ClassWriter.
   * @param classReader the ClassReader whose constant pool and bootstrap methods must be copied to
   *     initialize the SymbolTable.
   */
<span class="nc" id="L137">  SymbolTable(final ClassWriter classWriter, final ClassReader classReader) {</span>
<span class="nc" id="L138">    this.classWriter = classWriter;</span>
<span class="nc" id="L139">    this.sourceClassReader = classReader;</span>

    // Copy the constant pool binary content.
<span class="nc" id="L142">    byte[] inputBytes = classReader.classFileBuffer;</span>
<span class="nc" id="L143">    int constantPoolOffset = classReader.getItem(1) - 1;</span>
<span class="nc" id="L144">    int constantPoolLength = classReader.header - constantPoolOffset;</span>
<span class="nc" id="L145">    constantPoolCount = classReader.getItemCount();</span>
<span class="nc" id="L146">    constantPool = new ByteVector(constantPoolLength);</span>
<span class="nc" id="L147">    constantPool.putByteArray(inputBytes, constantPoolOffset, constantPoolLength);</span>

    // Add the constant pool items in the symbol table entries. Reserve enough space in 'entries' to
    // avoid too many hash set collisions (entries is not dynamically resized by the addConstant*
    // method calls below), and to account for bootstrap method entries.
<span class="nc" id="L152">    entries = new Entry[constantPoolCount * 2];</span>
<span class="nc" id="L153">    char[] charBuffer = new char[classReader.getMaxStringLength()];</span>
<span class="nc" id="L154">    boolean hasBootstrapMethods = false;</span>
<span class="nc" id="L155">    int itemIndex = 1;</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">    while (itemIndex &lt; constantPoolCount) {</span>
<span class="nc" id="L157">      int itemOffset = classReader.getItem(itemIndex);</span>
<span class="nc" id="L158">      int itemTag = inputBytes[itemOffset - 1];</span>
      int nameAndTypeItemOffset;
<span class="nc bnc" id="L160" title="All 9 branches missed.">      switch (itemTag) {</span>
        case Symbol.CONSTANT_FIELDREF_TAG:
        case Symbol.CONSTANT_METHODREF_TAG:
        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:
<span class="nc" id="L164">          nameAndTypeItemOffset =</span>
<span class="nc" id="L165">              classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));</span>
<span class="nc" id="L166">          addConstantMemberReference(</span>
              itemIndex,
              itemTag,
<span class="nc" id="L169">              classReader.readClass(itemOffset, charBuffer),</span>
<span class="nc" id="L170">              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),</span>
<span class="nc" id="L171">              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));</span>
<span class="nc" id="L172">          break;</span>
        case Symbol.CONSTANT_INTEGER_TAG:
        case Symbol.CONSTANT_FLOAT_TAG:
<span class="nc" id="L175">          addConstantIntegerOrFloat(itemIndex, itemTag, classReader.readInt(itemOffset));</span>
<span class="nc" id="L176">          break;</span>
        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
<span class="nc" id="L178">          addConstantNameAndType(</span>
              itemIndex,
<span class="nc" id="L180">              classReader.readUTF8(itemOffset, charBuffer),</span>
<span class="nc" id="L181">              classReader.readUTF8(itemOffset + 2, charBuffer));</span>
<span class="nc" id="L182">          break;</span>
        case Symbol.CONSTANT_LONG_TAG:
        case Symbol.CONSTANT_DOUBLE_TAG:
<span class="nc" id="L185">          addConstantLongOrDouble(itemIndex, itemTag, classReader.readLong(itemOffset));</span>
<span class="nc" id="L186">          break;</span>
        case Symbol.CONSTANT_UTF8_TAG:
<span class="nc" id="L188">          addConstantUtf8(itemIndex, classReader.readUtf(itemIndex, charBuffer));</span>
<span class="nc" id="L189">          break;</span>
        case Symbol.CONSTANT_METHOD_HANDLE_TAG:
<span class="nc" id="L191">          int memberRefItemOffset =</span>
<span class="nc" id="L192">              classReader.getItem(classReader.readUnsignedShort(itemOffset + 1));</span>
<span class="nc" id="L193">          nameAndTypeItemOffset =</span>
<span class="nc" id="L194">              classReader.getItem(classReader.readUnsignedShort(memberRefItemOffset + 2));</span>
<span class="nc" id="L195">          addConstantMethodHandle(</span>
              itemIndex,
<span class="nc" id="L197">              classReader.readByte(itemOffset),</span>
<span class="nc" id="L198">              classReader.readClass(memberRefItemOffset, charBuffer),</span>
<span class="nc" id="L199">              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),</span>
<span class="nc" id="L200">              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));</span>
<span class="nc" id="L201">          break;</span>
        case Symbol.CONSTANT_DYNAMIC_TAG:
        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
<span class="nc" id="L204">          hasBootstrapMethods = true;</span>
<span class="nc" id="L205">          nameAndTypeItemOffset =</span>
<span class="nc" id="L206">              classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));</span>
<span class="nc" id="L207">          addConstantDynamicOrInvokeDynamicReference(</span>
              itemTag,
              itemIndex,
<span class="nc" id="L210">              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),</span>
<span class="nc" id="L211">              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer),</span>
<span class="nc" id="L212">              classReader.readUnsignedShort(itemOffset));</span>
<span class="nc" id="L213">          break;</span>
        case Symbol.CONSTANT_STRING_TAG:
        case Symbol.CONSTANT_CLASS_TAG:
        case Symbol.CONSTANT_METHOD_TYPE_TAG:
        case Symbol.CONSTANT_MODULE_TAG:
        case Symbol.CONSTANT_PACKAGE_TAG:
<span class="nc" id="L219">          addConstantUtf8Reference(</span>
<span class="nc" id="L220">              itemIndex, itemTag, classReader.readUTF8(itemOffset, charBuffer));</span>
<span class="nc" id="L221">          break;</span>
        default:
<span class="nc" id="L223">          throw new IllegalArgumentException();</span>
      }
<span class="nc bnc" id="L225" title="All 4 branches missed.">      itemIndex +=</span>
          (itemTag == Symbol.CONSTANT_LONG_TAG || itemTag == Symbol.CONSTANT_DOUBLE_TAG) ? 2 : 1;
<span class="nc" id="L227">    }</span>

    // Copy the BootstrapMethods, if any.
<span class="nc bnc" id="L230" title="All 2 branches missed.">    if (hasBootstrapMethods) {</span>
<span class="nc" id="L231">      copyBootstrapMethods(classReader, charBuffer);</span>
    }
<span class="nc" id="L233">  }</span>

  /**
   * Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of
   * the SymbolTable.
   *
   * @param classReader the ClassReader whose bootstrap methods must be copied to initialize the
   *     SymbolTable.
   * @param charBuffer a buffer used to read strings in the constant pool.
   */
  private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) {
    // Find attributOffset of the 'bootstrap_methods' array.
<span class="nc" id="L245">    byte[] inputBytes = classReader.classFileBuffer;</span>
<span class="nc" id="L246">    int currentAttributeOffset = classReader.getFirstAttributeOffset();</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">    for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i &gt; 0; --i) {</span>
<span class="nc" id="L248">      String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {</span>
<span class="nc" id="L250">        bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6);</span>
<span class="nc" id="L251">        break;</span>
      }
<span class="nc" id="L253">      currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2);</span>
    }
<span class="nc bnc" id="L255" title="All 2 branches missed.">    if (bootstrapMethodCount &gt; 0) {</span>
      // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array.
<span class="nc" id="L257">      int bootstrapMethodsOffset = currentAttributeOffset + 8;</span>
<span class="nc" id="L258">      int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2;</span>
<span class="nc" id="L259">      bootstrapMethods = new ByteVector(bootstrapMethodsLength);</span>
<span class="nc" id="L260">      bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength);</span>

      // Add each bootstrap method in the symbol table entries.
<span class="nc" id="L263">      int currentOffset = bootstrapMethodsOffset;</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">      for (int i = 0; i &lt; bootstrapMethodCount; i++) {</span>
<span class="nc" id="L265">        int offset = currentOffset - bootstrapMethodsOffset;</span>
<span class="nc" id="L266">        int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset);</span>
<span class="nc" id="L267">        currentOffset += 2;</span>
<span class="nc" id="L268">        int numBootstrapArguments = classReader.readUnsignedShort(currentOffset);</span>
<span class="nc" id="L269">        currentOffset += 2;</span>
<span class="nc" id="L270">        int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode();</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        while (numBootstrapArguments-- &gt; 0) {</span>
<span class="nc" id="L272">          int bootstrapArgument = classReader.readUnsignedShort(currentOffset);</span>
<span class="nc" id="L273">          currentOffset += 2;</span>
<span class="nc" id="L274">          hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode();</span>
<span class="nc" id="L275">        }</span>
<span class="nc" id="L276">        add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode &amp; 0x7FFFFFFF));</span>
      }
    }
<span class="nc" id="L279">  }</span>

  /**
   * Returns the ClassReader from which this SymbolTable was constructed.
   *
   * @return the ClassReader from which this SymbolTable was constructed, or {@literal null} if it
   *     was constructed from scratch.
   */
  ClassReader getSource() {
<span class="nc" id="L288">    return sourceClassReader;</span>
  }

  /**
   * Returns the major version of the class to which this symbol table belongs.
   *
   * @return the major version of the class to which this symbol table belongs.
   */
  int getMajorVersion() {
<span class="nc" id="L297">    return majorVersion;</span>
  }

  /**
   * Returns the internal name of the class to which this symbol table belongs.
   *
   * @return the internal name of the class to which this symbol table belongs.
   */
  String getClassName() {
<span class="nc" id="L306">    return className;</span>
  }

  /**
   * Sets the major version and the name of the class to which this symbol table belongs. Also adds
   * the class name to the constant pool.
   *
   * @param majorVersion a major ClassFile version number.
   * @param className an internal class name.
   * @return the constant pool index of a new or already existing Symbol with the given class name.
   */
  int setMajorVersionAndClassName(final int majorVersion, final String className) {
<span class="nc" id="L318">    this.majorVersion = majorVersion;</span>
<span class="nc" id="L319">    this.className = className;</span>
<span class="nc" id="L320">    return addConstantClass(className).index;</span>
  }

  /**
   * Returns the number of items in this symbol table's constant_pool array (plus 1).
   *
   * @return the number of items in this symbol table's constant_pool array (plus 1).
   */
  int getConstantPoolCount() {
<span class="nc" id="L329">    return constantPoolCount;</span>
  }

  /**
   * Returns the length in bytes of this symbol table's constant_pool array.
   *
   * @return the length in bytes of this symbol table's constant_pool array.
   */
  int getConstantPoolLength() {
<span class="nc" id="L338">    return constantPool.length;</span>
  }

  /**
   * Puts this symbol table's constant_pool array in the given ByteVector, preceded by the
   * constant_pool_count value.
   *
   * @param output where the JVMS ClassFile's constant_pool array must be put.
   */
  void putConstantPool(final ByteVector output) {
<span class="nc" id="L348">    output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length);</span>
<span class="nc" id="L349">  }</span>

  /**
   * Returns the size in bytes of this symbol table's BootstrapMethods attribute. Also adds the
   * attribute name in the constant pool.
   *
   * @return the size in bytes of this symbol table's BootstrapMethods attribute.
   */
  int computeBootstrapMethodsSize() {
<span class="nc bnc" id="L358" title="All 2 branches missed.">    if (bootstrapMethods != null) {</span>
<span class="nc" id="L359">      addConstantUtf8(Constants.BOOTSTRAP_METHODS);</span>
<span class="nc" id="L360">      return 8 + bootstrapMethods.length;</span>
    } else {
<span class="nc" id="L362">      return 0;</span>
    }
  }

  /**
   * Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the
   * 6 attribute header bytes and the num_bootstrap_methods value.
   *
   * @param output where the JVMS BootstrapMethods attribute must be put.
   */
  void putBootstrapMethods(final ByteVector output) {
<span class="nc bnc" id="L373" title="All 2 branches missed.">    if (bootstrapMethods != null) {</span>
<span class="nc" id="L374">      output</span>
<span class="nc" id="L375">          .putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS))</span>
<span class="nc" id="L376">          .putInt(bootstrapMethods.length + 2)</span>
<span class="nc" id="L377">          .putShort(bootstrapMethodCount)</span>
<span class="nc" id="L378">          .putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);</span>
    }
<span class="nc" id="L380">  }</span>

  // -----------------------------------------------------------------------------------------------
  // Generic symbol table entries management.
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the list of entries which can potentially have the given hash code.
   *
   * @param hashCode a {@link Entry#hashCode} value.
   * @return the list of entries which can potentially have the given hash code. The list is stored
   *     via the {@link Entry#next} field.
   */
  private Entry get(final int hashCode) {
<span class="nc" id="L394">    return entries[hashCode % entries.length];</span>
  }

  /**
   * Puts the given entry in the {@link #entries} hash set. This method does &lt;i&gt;not&lt;/i&gt; check
   * whether {@link #entries} already contains a similar entry or not. {@link #entries} is resized
   * if necessary to avoid hash collisions (multiple entries needing to be stored at the same {@link
   * #entries} array index) as much as possible, with reasonable memory usage.
   *
   * @param entry an Entry (which must not already be contained in {@link #entries}).
   * @return the given entry
   */
  private Entry put(final Entry entry) {
<span class="nc bnc" id="L407" title="All 2 branches missed.">    if (entryCount &gt; (entries.length * 3) / 4) {</span>
<span class="nc" id="L408">      int currentCapacity = entries.length;</span>
<span class="nc" id="L409">      int newCapacity = currentCapacity * 2 + 1;</span>
<span class="nc" id="L410">      Entry[] newEntries = new Entry[newCapacity];</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">      for (int i = currentCapacity - 1; i &gt;= 0; --i) {</span>
<span class="nc" id="L412">        Entry currentEntry = entries[i];</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">        while (currentEntry != null) {</span>
<span class="nc" id="L414">          int newCurrentEntryIndex = currentEntry.hashCode % newCapacity;</span>
<span class="nc" id="L415">          Entry nextEntry = currentEntry.next;</span>
<span class="nc" id="L416">          currentEntry.next = newEntries[newCurrentEntryIndex];</span>
<span class="nc" id="L417">          newEntries[newCurrentEntryIndex] = currentEntry;</span>
<span class="nc" id="L418">          currentEntry = nextEntry;</span>
<span class="nc" id="L419">        }</span>
      }
<span class="nc" id="L421">      entries = newEntries;</span>
    }
<span class="nc" id="L423">    entryCount++;</span>
<span class="nc" id="L424">    int index = entry.hashCode % entries.length;</span>
<span class="nc" id="L425">    entry.next = entries[index];</span>
<span class="nc" id="L426">    return entries[index] = entry;</span>
  }

  /**
   * Adds the given entry in the {@link #entries} hash set. This method does &lt;i&gt;not&lt;/i&gt; check
   * whether {@link #entries} already contains a similar entry or not, and does &lt;i&gt;not&lt;/i&gt; resize
   * {@link #entries} if necessary.
   *
   * @param entry an Entry (which must not already be contained in {@link #entries}).
   */
  private void add(final Entry entry) {
<span class="nc" id="L437">    entryCount++;</span>
<span class="nc" id="L438">    int index = entry.hashCode % entries.length;</span>
<span class="nc" id="L439">    entry.next = entries[index];</span>
<span class="nc" id="L440">    entries[index] = entry;</span>
<span class="nc" id="L441">  }</span>

  // -----------------------------------------------------------------------------------------------
  // Constant pool entries management.
  // -----------------------------------------------------------------------------------------------

  /**
   * Adds a number or string constant to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value the value of the constant to be added to the constant pool. This parameter must be
   *     an {@link Integer}, {@link Byte}, {@link Character}, {@link Short}, {@link Boolean}, {@link
   *     Float}, {@link Long}, {@link Double}, {@link String}, {@link Type} or {@link Handle}.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstant(final Object value) {
<span class="nc bnc" id="L457" title="All 2 branches missed.">    if (value instanceof Integer) {</span>
<span class="nc" id="L458">      return addConstantInteger(((Integer) value).intValue());</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">    } else if (value instanceof Byte) {</span>
<span class="nc" id="L460">      return addConstantInteger(((Byte) value).intValue());</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">    } else if (value instanceof Character) {</span>
<span class="nc" id="L462">      return addConstantInteger(((Character) value).charValue());</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">    } else if (value instanceof Short) {</span>
<span class="nc" id="L464">      return addConstantInteger(((Short) value).intValue());</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">    } else if (value instanceof Boolean) {</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">      return addConstantInteger(((Boolean) value).booleanValue() ? 1 : 0);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">    } else if (value instanceof Float) {</span>
<span class="nc" id="L468">      return addConstantFloat(((Float) value).floatValue());</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">    } else if (value instanceof Long) {</span>
<span class="nc" id="L470">      return addConstantLong(((Long) value).longValue());</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">    } else if (value instanceof Double) {</span>
<span class="nc" id="L472">      return addConstantDouble(((Double) value).doubleValue());</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">    } else if (value instanceof String) {</span>
<span class="nc" id="L474">      return addConstantString((String) value);</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">    } else if (value instanceof Type) {</span>
<span class="nc" id="L476">      Type type = (Type) value;</span>
<span class="nc" id="L477">      int typeSort = type.getSort();</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">      if (typeSort == Type.OBJECT) {</span>
<span class="nc" id="L479">        return addConstantClass(type.getInternalName());</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">      } else if (typeSort == Type.METHOD) {</span>
<span class="nc" id="L481">        return addConstantMethodType(type.getDescriptor());</span>
      } else { // type is a primitive or array type.
<span class="nc" id="L483">        return addConstantClass(type.getDescriptor());</span>
      }
<span class="nc bnc" id="L485" title="All 2 branches missed.">    } else if (value instanceof Handle) {</span>
<span class="nc" id="L486">      Handle handle = (Handle) value;</span>
<span class="nc" id="L487">      return addConstantMethodHandle(</span>
<span class="nc" id="L488">          handle.getTag(),</span>
<span class="nc" id="L489">          handle.getOwner(),</span>
<span class="nc" id="L490">          handle.getName(),</span>
<span class="nc" id="L491">          handle.getDesc(),</span>
<span class="nc" id="L492">          handle.isInterface());</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">    } else if (value instanceof ConstantDynamic) {</span>
<span class="nc" id="L494">      ConstantDynamic constantDynamic = (ConstantDynamic) value;</span>
<span class="nc" id="L495">      return addConstantDynamic(</span>
<span class="nc" id="L496">          constantDynamic.getName(),</span>
<span class="nc" id="L497">          constantDynamic.getDescriptor(),</span>
<span class="nc" id="L498">          constantDynamic.getBootstrapMethod(),</span>
<span class="nc" id="L499">          constantDynamic.getBootstrapMethodArgumentsUnsafe());</span>
    } else {
<span class="nc" id="L501">      throw new IllegalArgumentException(&quot;value &quot; + value);</span>
    }
  }

  /**
   * Adds a CONSTANT_Class_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value the internal name of a class.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantClass(final String value) {
<span class="nc" id="L513">    return addConstantUtf8Reference(Symbol.CONSTANT_CLASS_TAG, value);</span>
  }

  /**
   * Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param owner the internal name of a class.
   * @param name a field name.
   * @param descriptor a field descriptor.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantFieldref(final String owner, final String name, final String descriptor) {
<span class="nc" id="L526">    return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);</span>
  }

  /**
   * Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this
   * symbol table. Does nothing if the constant pool already contains a similar item.
   *
   * @param owner the internal name of a class.
   * @param name a method name.
   * @param descriptor a method descriptor.
   * @param isInterface whether owner is an interface or not.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantMethodref(
      final String owner, final String name, final String descriptor, final boolean isInterface) {
<span class="nc bnc" id="L541" title="All 2 branches missed.">    int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG;</span>
<span class="nc" id="L542">    return addConstantMemberReference(tag, owner, name, descriptor);</span>
  }

  /**
   * Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to
   * the constant pool of this symbol table. Does nothing if the constant pool already contains a
   * similar item.
   *
   * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}
   *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.
   * @param owner the internal name of a class.
   * @param name a field or method name.
   * @param descriptor a field or method descriptor.
   * @return a new or already existing Symbol with the given value.
   */
  private Entry addConstantMemberReference(
      final int tag, final String owner, final String name, final String descriptor) {
<span class="nc" id="L559">    int hashCode = hash(tag, owner, name, descriptor);</span>
<span class="nc" id="L560">    Entry entry = get(hashCode);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">    while (entry != null) {</span>
<span class="nc bnc" id="L562" title="All 4 branches missed.">      if (entry.tag == tag</span>
          &amp;&amp; entry.hashCode == hashCode
<span class="nc bnc" id="L564" title="All 2 branches missed.">          &amp;&amp; entry.owner.equals(owner)</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">          &amp;&amp; entry.name.equals(name)</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">          &amp;&amp; entry.value.equals(descriptor)) {</span>
<span class="nc" id="L567">        return entry;</span>
      }
<span class="nc" id="L569">      entry = entry.next;</span>
    }
<span class="nc" id="L571">    constantPool.put122(</span>
<span class="nc" id="L572">        tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor));</span>
<span class="nc" id="L573">    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode));</span>
  }

  /**
   * Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info
   * to the constant pool of this symbol table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}
   *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.
   * @param owner the internal name of a class.
   * @param name a field or method name.
   * @param descriptor a field or method descriptor.
   */
  private void addConstantMemberReference(
      final int index,
      final int tag,
      final String owner,
      final String name,
      final String descriptor) {
<span class="nc" id="L593">    add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor)));</span>
<span class="nc" id="L594">  }</span>

  /**
   * Adds a CONSTANT_String_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value a string.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantString(final String value) {
<span class="nc" id="L604">    return addConstantUtf8Reference(Symbol.CONSTANT_STRING_TAG, value);</span>
  }

  /**
   * Adds a CONSTANT_Integer_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value an int.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantInteger(final int value) {
<span class="nc" id="L615">    return addConstantIntegerOrFloat(Symbol.CONSTANT_INTEGER_TAG, value);</span>
  }

  /**
   * Adds a CONSTANT_Float_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value a float.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantFloat(final float value) {
<span class="nc" id="L626">    return addConstantIntegerOrFloat(Symbol.CONSTANT_FLOAT_TAG, Float.floatToRawIntBits(value));</span>
  }

  /**
   * Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.
   * Does nothing if the constant pool already contains a similar item.
   *
   * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.
   * @param value an int or float.
   * @return a constant pool constant with the given tag and primitive values.
   */
  private Symbol addConstantIntegerOrFloat(final int tag, final int value) {
<span class="nc" id="L638">    int hashCode = hash(tag, value);</span>
<span class="nc" id="L639">    Entry entry = get(hashCode);</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">    while (entry != null) {</span>
<span class="nc bnc" id="L641" title="All 6 branches missed.">      if (entry.tag == tag &amp;&amp; entry.hashCode == hashCode &amp;&amp; entry.data == value) {</span>
<span class="nc" id="L642">        return entry;</span>
      }
<span class="nc" id="L644">      entry = entry.next;</span>
    }
<span class="nc" id="L646">    constantPool.putByte(tag).putInt(value);</span>
<span class="nc" id="L647">    return put(new Entry(constantPoolCount++, tag, value, hashCode));</span>
  }

  /**
   * Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol
   * table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.
   * @param value an int or float.
   */
  private void addConstantIntegerOrFloat(final int index, final int tag, final int value) {
<span class="nc" id="L659">    add(new Entry(index, tag, value, hash(tag, value)));</span>
<span class="nc" id="L660">  }</span>

  /**
   * Adds a CONSTANT_Long_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value a long.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantLong(final long value) {
<span class="nc" id="L670">    return addConstantLongOrDouble(Symbol.CONSTANT_LONG_TAG, value);</span>
  }

  /**
   * Adds a CONSTANT_Double_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value a double.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantDouble(final double value) {
<span class="nc" id="L681">    return addConstantLongOrDouble(Symbol.CONSTANT_DOUBLE_TAG, Double.doubleToRawLongBits(value));</span>
  }

  /**
   * Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.
   * Does nothing if the constant pool already contains a similar item.
   *
   * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.
   * @param value a long or double.
   * @return a constant pool constant with the given tag and primitive values.
   */
  private Symbol addConstantLongOrDouble(final int tag, final long value) {
<span class="nc" id="L693">    int hashCode = hash(tag, value);</span>
<span class="nc" id="L694">    Entry entry = get(hashCode);</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">    while (entry != null) {</span>
<span class="nc bnc" id="L696" title="All 6 branches missed.">      if (entry.tag == tag &amp;&amp; entry.hashCode == hashCode &amp;&amp; entry.data == value) {</span>
<span class="nc" id="L697">        return entry;</span>
      }
<span class="nc" id="L699">      entry = entry.next;</span>
    }
<span class="nc" id="L701">    int index = constantPoolCount;</span>
<span class="nc" id="L702">    constantPool.putByte(tag).putLong(value);</span>
<span class="nc" id="L703">    constantPoolCount += 2;</span>
<span class="nc" id="L704">    return put(new Entry(index, tag, value, hashCode));</span>
  }

  /**
   * Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol
   * table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.
   * @param value a long or double.
   */
  private void addConstantLongOrDouble(final int index, final int tag, final long value) {
<span class="nc" id="L716">    add(new Entry(index, tag, value, hash(tag, value)));</span>
<span class="nc" id="L717">  }</span>

  /**
   * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param name a field or method name.
   * @param descriptor a field or method descriptor.
   * @return a new or already existing Symbol with the given value.
   */
  int addConstantNameAndType(final String name, final String descriptor) {
<span class="nc" id="L728">    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;</span>
<span class="nc" id="L729">    int hashCode = hash(tag, name, descriptor);</span>
<span class="nc" id="L730">    Entry entry = get(hashCode);</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">    while (entry != null) {</span>
<span class="nc bnc" id="L732" title="All 4 branches missed.">      if (entry.tag == tag</span>
          &amp;&amp; entry.hashCode == hashCode
<span class="nc bnc" id="L734" title="All 2 branches missed.">          &amp;&amp; entry.name.equals(name)</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">          &amp;&amp; entry.value.equals(descriptor)) {</span>
<span class="nc" id="L736">        return entry.index;</span>
      }
<span class="nc" id="L738">      entry = entry.next;</span>
    }
<span class="nc" id="L740">    constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor));</span>
<span class="nc" id="L741">    return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index;</span>
  }

  /**
   * Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param name a field or method name.
   * @param descriptor a field or method descriptor.
   */
  private void addConstantNameAndType(final int index, final String name, final String descriptor) {
<span class="nc" id="L752">    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;</span>
<span class="nc" id="L753">    add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor)));</span>
<span class="nc" id="L754">  }</span>

  /**
   * Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value a string.
   * @return a new or already existing Symbol with the given value.
   */
  int addConstantUtf8(final String value) {
<span class="nc" id="L764">    int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);</span>
<span class="nc" id="L765">    Entry entry = get(hashCode);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">    while (entry != null) {</span>
<span class="nc bnc" id="L767" title="All 4 branches missed.">      if (entry.tag == Symbol.CONSTANT_UTF8_TAG</span>
          &amp;&amp; entry.hashCode == hashCode
<span class="nc bnc" id="L769" title="All 2 branches missed.">          &amp;&amp; entry.value.equals(value)) {</span>
<span class="nc" id="L770">        return entry.index;</span>
      }
<span class="nc" id="L772">      entry = entry.next;</span>
    }
<span class="nc" id="L774">    constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);</span>
<span class="nc" id="L775">    return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;</span>
  }

  /**
   * Adds a new CONSTANT_String_info to the constant pool of this symbol table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param value a string.
   */
  private void addConstantUtf8(final int index, final String value) {
<span class="nc" id="L785">    add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value)));</span>
<span class="nc" id="L786">  }</span>

  /**
   * Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if
   * the constant pool already contains a similar item.
   *
   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link
   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link
   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link
   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
   * @param owner the internal name of a class of interface.
   * @param name a field or method name.
   * @param descriptor a field or method descriptor.
   * @param isInterface whether owner is an interface or not.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantMethodHandle(
      final int referenceKind,
      final String owner,
      final String name,
      final String descriptor,
      final boolean isInterface) {
<span class="nc" id="L808">    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;</span>
    // Note that we don't need to include isInterface in the hash computation, because it is
    // redundant with owner (we can't have the same owner with different isInterface values).
<span class="nc" id="L811">    int hashCode = hash(tag, owner, name, descriptor, referenceKind);</span>
<span class="nc" id="L812">    Entry entry = get(hashCode);</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">    while (entry != null) {</span>
<span class="nc bnc" id="L814" title="All 6 branches missed.">      if (entry.tag == tag</span>
          &amp;&amp; entry.hashCode == hashCode
          &amp;&amp; entry.data == referenceKind
<span class="nc bnc" id="L817" title="All 2 branches missed.">          &amp;&amp; entry.owner.equals(owner)</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">          &amp;&amp; entry.name.equals(name)</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">          &amp;&amp; entry.value.equals(descriptor)) {</span>
<span class="nc" id="L820">        return entry;</span>
      }
<span class="nc" id="L822">      entry = entry.next;</span>
    }
<span class="nc bnc" id="L824" title="All 2 branches missed.">    if (referenceKind &lt;= Opcodes.H_PUTSTATIC) {</span>
<span class="nc" id="L825">      constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index);</span>
    } else {
<span class="nc" id="L827">      constantPool.put112(</span>
<span class="nc" id="L828">          tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index);</span>
    }
<span class="nc" id="L830">    return put(</span>
        new Entry(constantPoolCount++, tag, owner, name, descriptor, referenceKind, hashCode));
  }

  /**
   * Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link
   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link
   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link
   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
   * @param owner the internal name of a class of interface.
   * @param name a field or method name.
   * @param descriptor a field or method descriptor.
   */
  private void addConstantMethodHandle(
      final int index,
      final int referenceKind,
      final String owner,
      final String name,
      final String descriptor) {
<span class="nc" id="L852">    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;</span>
<span class="nc" id="L853">    int hashCode = hash(tag, owner, name, descriptor, referenceKind);</span>
<span class="nc" id="L854">    add(new Entry(index, tag, owner, name, descriptor, referenceKind, hashCode));</span>
<span class="nc" id="L855">  }</span>

  /**
   * Adds a CONSTANT_MethodType_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param methodDescriptor a method descriptor.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantMethodType(final String methodDescriptor) {
<span class="nc" id="L865">    return addConstantUtf8Reference(Symbol.CONSTANT_METHOD_TYPE_TAG, methodDescriptor);</span>
  }

  /**
   * Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related
   * bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant
   * pool already contains a similar item.
   *
   * @param name a method name.
   * @param descriptor a field descriptor.
   * @param bootstrapMethodHandle a bootstrap method handle.
   * @param bootstrapMethodArguments the bootstrap method arguments.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantDynamic(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
<span class="nc" id="L884">    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);</span>
<span class="nc" id="L885">    return addConstantDynamicOrInvokeDynamicReference(</span>
        Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);
  }

  /**
   * Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the
   * related bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param name a method name.
   * @param descriptor a method descriptor.
   * @param bootstrapMethodHandle a bootstrap method handle.
   * @param bootstrapMethodArguments the bootstrap method arguments.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantInvokeDynamic(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
<span class="nc" id="L905">    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);</span>
<span class="nc" id="L906">    return addConstantDynamicOrInvokeDynamicReference(</span>
        Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);
  }

  /**
   * Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol
   * table. Does nothing if the constant pool already contains a similar item.
   *
   * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link
   *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.
   * @param name a method name.
   * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for
   *     CONSTANT_INVOKE_DYNAMIC_TAG.
   * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.
   * @return a new or already existing Symbol with the given value.
   */
  private Symbol addConstantDynamicOrInvokeDynamicReference(
      final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {
<span class="nc" id="L924">    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);</span>
<span class="nc" id="L925">    Entry entry = get(hashCode);</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">    while (entry != null) {</span>
<span class="nc bnc" id="L927" title="All 6 branches missed.">      if (entry.tag == tag</span>
          &amp;&amp; entry.hashCode == hashCode
          &amp;&amp; entry.data == bootstrapMethodIndex
<span class="nc bnc" id="L930" title="All 2 branches missed.">          &amp;&amp; entry.name.equals(name)</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">          &amp;&amp; entry.value.equals(descriptor)) {</span>
<span class="nc" id="L932">        return entry;</span>
      }
<span class="nc" id="L934">      entry = entry.next;</span>
    }
<span class="nc" id="L936">    constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor));</span>
<span class="nc" id="L937">    return put(</span>
        new Entry(
            constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));
  }

  /**
   * Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this
   * symbol table.
   *
   * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link
   *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.
   * @param index the constant pool index of the new Symbol.
   * @param name a method name.
   * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for
   *     CONSTANT_INVOKE_DYNAMIC_TAG.
   * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.
   */
  private void addConstantDynamicOrInvokeDynamicReference(
      final int tag,
      final int index,
      final String name,
      final String descriptor,
      final int bootstrapMethodIndex) {
<span class="nc" id="L960">    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);</span>
<span class="nc" id="L961">    add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));</span>
<span class="nc" id="L962">  }</span>

  /**
   * Adds a CONSTANT_Module_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param moduleName a fully qualified name (using dots) of a module.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantModule(final String moduleName) {
<span class="nc" id="L972">    return addConstantUtf8Reference(Symbol.CONSTANT_MODULE_TAG, moduleName);</span>
  }

  /**
   * Adds a CONSTANT_Package_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param packageName the internal name of a package.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantPackage(final String packageName) {
<span class="nc" id="L983">    return addConstantUtf8Reference(Symbol.CONSTANT_PACKAGE_TAG, packageName);</span>
  }

  /**
   * Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,
   * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does
   * nothing if the constant pool already contains a similar item.
   *
   * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link
   *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link
   *     Symbol#CONSTANT_PACKAGE_TAG}.
   * @param value an internal class name, an arbitrary string, a method descriptor, a module or a
   *     package name, depending on tag.
   * @return a new or already existing Symbol with the given value.
   */
  private Symbol addConstantUtf8Reference(final int tag, final String value) {
<span class="nc" id="L999">    int hashCode = hash(tag, value);</span>
<span class="nc" id="L1000">    Entry entry = get(hashCode);</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">    while (entry != null) {</span>
<span class="nc bnc" id="L1002" title="All 6 branches missed.">      if (entry.tag == tag &amp;&amp; entry.hashCode == hashCode &amp;&amp; entry.value.equals(value)) {</span>
<span class="nc" id="L1003">        return entry;</span>
      }
<span class="nc" id="L1005">      entry = entry.next;</span>
    }
<span class="nc" id="L1007">    constantPool.put12(tag, addConstantUtf8(value));</span>
<span class="nc" id="L1008">    return put(new Entry(constantPoolCount++, tag, value, hashCode));</span>
  }

  /**
   * Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,
   * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link
   *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link
   *     Symbol#CONSTANT_PACKAGE_TAG}.
   * @param value an internal class name, an arbitrary string, a method descriptor, a module or a
   *     package name, depending on tag.
   */
  private void addConstantUtf8Reference(final int index, final int tag, final String value) {
<span class="nc" id="L1023">    add(new Entry(index, tag, value, hash(tag, value)));</span>
<span class="nc" id="L1024">  }</span>

  // -----------------------------------------------------------------------------------------------
  // Bootstrap method entries management.
  // -----------------------------------------------------------------------------------------------

  /**
   * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if
   * the BootstrapMethods already contains a similar bootstrap method.
   *
   * @param bootstrapMethodHandle a bootstrap method handle.
   * @param bootstrapMethodArguments the bootstrap method arguments.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addBootstrapMethod(
      final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {
<span class="nc" id="L1040">    ByteVector bootstrapMethodsAttribute = bootstrapMethods;</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">    if (bootstrapMethodsAttribute == null) {</span>
<span class="nc" id="L1042">      bootstrapMethodsAttribute = bootstrapMethods = new ByteVector();</span>
    }

    // The bootstrap method arguments can be Constant_Dynamic values, which reference other
    // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool
    // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified
    // while adding the given bootstrap method to it, in the rest of this method.
<span class="nc bnc" id="L1049" title="All 2 branches missed.">    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {</span>
<span class="nc" id="L1050">      addConstant(bootstrapMethodArgument);</span>
    }

    // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to
    // compare it with existing ones, and will be reverted below if there is already a similar
    // bootstrap method.
<span class="nc" id="L1056">    int bootstrapMethodOffset = bootstrapMethodsAttribute.length;</span>
<span class="nc" id="L1057">    bootstrapMethodsAttribute.putShort(</span>
<span class="nc" id="L1058">        addConstantMethodHandle(</span>
<span class="nc" id="L1059">                bootstrapMethodHandle.getTag(),</span>
<span class="nc" id="L1060">                bootstrapMethodHandle.getOwner(),</span>
<span class="nc" id="L1061">                bootstrapMethodHandle.getName(),</span>
<span class="nc" id="L1062">                bootstrapMethodHandle.getDesc(),</span>
<span class="nc" id="L1063">                bootstrapMethodHandle.isInterface())</span>
            .index);
<span class="nc" id="L1065">    int numBootstrapArguments = bootstrapMethodArguments.length;</span>
<span class="nc" id="L1066">    bootstrapMethodsAttribute.putShort(numBootstrapArguments);</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {</span>
<span class="nc" id="L1068">      bootstrapMethodsAttribute.putShort(addConstant(bootstrapMethodArgument).index);</span>
    }

    // Compute the length and the hash code of the bootstrap method.
<span class="nc" id="L1072">    int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset;</span>
<span class="nc" id="L1073">    int hashCode = bootstrapMethodHandle.hashCode();</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {</span>
<span class="nc" id="L1075">      hashCode ^= bootstrapMethodArgument.hashCode();</span>
    }
<span class="nc" id="L1077">    hashCode &amp;= 0x7FFFFFFF;</span>

    // Add the bootstrap method to the symbol table or revert the above changes.
<span class="nc" id="L1080">    return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode);</span>
  }

  /**
   * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if
   * the BootstrapMethods already contains a similar bootstrap method (more precisely, reverts the
   * content of {@link #bootstrapMethods} to remove the last, duplicate bootstrap method).
   *
   * @param offset the offset of the last bootstrap method in {@link #bootstrapMethods}, in bytes.
   * @param length the length of this bootstrap method in {@link #bootstrapMethods}, in bytes.
   * @param hashCode the hash code of this bootstrap method.
   * @return a new or already existing Symbol with the given value.
   */
  private Symbol addBootstrapMethod(final int offset, final int length, final int hashCode) {
<span class="nc" id="L1094">    final byte[] bootstrapMethodsData = bootstrapMethods.data;</span>
<span class="nc" id="L1095">    Entry entry = get(hashCode);</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">    while (entry != null) {</span>
<span class="nc bnc" id="L1097" title="All 4 branches missed.">      if (entry.tag == Symbol.BOOTSTRAP_METHOD_TAG &amp;&amp; entry.hashCode == hashCode) {</span>
<span class="nc" id="L1098">        int otherOffset = (int) entry.data;</span>
<span class="nc" id="L1099">        boolean isSameBootstrapMethod = true;</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">        for (int i = 0; i &lt; length; ++i) {</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">          if (bootstrapMethodsData[offset + i] != bootstrapMethodsData[otherOffset + i]) {</span>
<span class="nc" id="L1102">            isSameBootstrapMethod = false;</span>
<span class="nc" id="L1103">            break;</span>
          }
        }
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (isSameBootstrapMethod) {</span>
<span class="nc" id="L1107">          bootstrapMethods.length = offset; // Revert to old position.</span>
<span class="nc" id="L1108">          return entry;</span>
        }
      }
<span class="nc" id="L1111">      entry = entry.next;</span>
    }
<span class="nc" id="L1113">    return put(new Entry(bootstrapMethodCount++, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode));</span>
  }

  // -----------------------------------------------------------------------------------------------
  // Type table entries management.
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the type table element whose index is given.
   *
   * @param typeIndex a type table index.
   * @return the type table element whose index is given.
   */
  Symbol getType(final int typeIndex) {
<span class="nc" id="L1127">    return typeTable[typeIndex];</span>
  }

  /**
   * Adds a type in the type table of this symbol table. Does nothing if the type table already
   * contains a similar type.
   *
   * @param value an internal class name.
   * @return the index of a new or already existing type Symbol with the given value.
   */
  int addType(final String value) {
<span class="nc" id="L1138">    int hashCode = hash(Symbol.TYPE_TAG, value);</span>
<span class="nc" id="L1139">    Entry entry = get(hashCode);</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">    while (entry != null) {</span>
<span class="nc bnc" id="L1141" title="All 6 branches missed.">      if (entry.tag == Symbol.TYPE_TAG &amp;&amp; entry.hashCode == hashCode &amp;&amp; entry.value.equals(value)) {</span>
<span class="nc" id="L1142">        return entry.index;</span>
      }
<span class="nc" id="L1144">      entry = entry.next;</span>
    }
<span class="nc" id="L1146">    return addTypeInternal(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode));</span>
  }

  /**
   * Adds an {@link Frame#ITEM_UNINITIALIZED} type in the type table of this symbol table. Does
   * nothing if the type table already contains a similar type.
   *
   * @param value an internal class name.
   * @param bytecodeOffset the bytecode offset of the NEW instruction that created this {@link
   *     Frame#ITEM_UNINITIALIZED} type value.
   * @return the index of a new or already existing type Symbol with the given value.
   */
  int addUninitializedType(final String value, final int bytecodeOffset) {
<span class="nc" id="L1159">    int hashCode = hash(Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset);</span>
<span class="nc" id="L1160">    Entry entry = get(hashCode);</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">    while (entry != null) {</span>
<span class="nc bnc" id="L1162" title="All 6 branches missed.">      if (entry.tag == Symbol.UNINITIALIZED_TYPE_TAG</span>
          &amp;&amp; entry.hashCode == hashCode
          &amp;&amp; entry.data == bytecodeOffset
<span class="nc bnc" id="L1165" title="All 2 branches missed.">          &amp;&amp; entry.value.equals(value)) {</span>
<span class="nc" id="L1166">        return entry.index;</span>
      }
<span class="nc" id="L1168">      entry = entry.next;</span>
    }
<span class="nc" id="L1170">    return addTypeInternal(</span>
        new Entry(typeCount, Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset, hashCode));
  }

  /**
   * Adds a merged type in the type table of this symbol table. Does nothing if the type table
   * already contains a similar type.
   *
   * @param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type
   *     table.
   * @param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type
   *     table.
   * @return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,
   *     corresponding to the common super class of the given types.
   */
  int addMergedType(final int typeTableIndex1, final int typeTableIndex2) {
<span class="nc bnc" id="L1186" title="All 2 branches missed.">    long data =</span>
        typeTableIndex1 &lt; typeTableIndex2
            ? typeTableIndex1 | (((long) typeTableIndex2) &lt;&lt; 32)
            : typeTableIndex2 | (((long) typeTableIndex1) &lt;&lt; 32);
<span class="nc" id="L1190">    int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2);</span>
<span class="nc" id="L1191">    Entry entry = get(hashCode);</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">    while (entry != null) {</span>
<span class="nc bnc" id="L1193" title="All 6 branches missed.">      if (entry.tag == Symbol.MERGED_TYPE_TAG &amp;&amp; entry.hashCode == hashCode &amp;&amp; entry.data == data) {</span>
<span class="nc" id="L1194">        return entry.info;</span>
      }
<span class="nc" id="L1196">      entry = entry.next;</span>
    }
<span class="nc" id="L1198">    String type1 = typeTable[typeTableIndex1].value;</span>
<span class="nc" id="L1199">    String type2 = typeTable[typeTableIndex2].value;</span>
<span class="nc" id="L1200">    int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2));</span>
<span class="nc" id="L1201">    put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex;</span>
<span class="nc" id="L1202">    return commonSuperTypeIndex;</span>
  }

  /**
   * Adds the given type Symbol to {@link #typeTable}.
   *
   * @param entry a {@link Symbol#TYPE_TAG} or {@link Symbol#UNINITIALIZED_TYPE_TAG} type symbol.
   *     The index of this Symbol must be equal to the current value of {@link #typeCount}.
   * @return the index in {@link #typeTable} where the given type was added, which is also equal to
   *     entry's index by hypothesis.
   */
  private int addTypeInternal(final Entry entry) {
<span class="nc bnc" id="L1214" title="All 2 branches missed.">    if (typeTable == null) {</span>
<span class="nc" id="L1215">      typeTable = new Entry[16];</span>
    }
<span class="nc bnc" id="L1217" title="All 2 branches missed.">    if (typeCount == typeTable.length) {</span>
<span class="nc" id="L1218">      Entry[] newTypeTable = new Entry[2 * typeTable.length];</span>
<span class="nc" id="L1219">      System.arraycopy(typeTable, 0, newTypeTable, 0, typeTable.length);</span>
<span class="nc" id="L1220">      typeTable = newTypeTable;</span>
    }
<span class="nc" id="L1222">    typeTable[typeCount++] = entry;</span>
<span class="nc" id="L1223">    return put(entry).index;</span>
  }

  // -----------------------------------------------------------------------------------------------
  // Static helper methods to compute hash codes.
  // -----------------------------------------------------------------------------------------------

  private static int hash(final int tag, final int value) {
<span class="nc" id="L1231">    return 0x7FFFFFFF &amp; (tag + value);</span>
  }

  private static int hash(final int tag, final long value) {
<span class="nc" id="L1235">    return 0x7FFFFFFF &amp; (tag + (int) value + (int) (value &gt;&gt;&gt; 32));</span>
  }

  private static int hash(final int tag, final String value) {
<span class="nc" id="L1239">    return 0x7FFFFFFF &amp; (tag + value.hashCode());</span>
  }

  private static int hash(final int tag, final String value1, final int value2) {
<span class="nc" id="L1243">    return 0x7FFFFFFF &amp; (tag + value1.hashCode() + value2);</span>
  }

  private static int hash(final int tag, final String value1, final String value2) {
<span class="nc" id="L1247">    return 0x7FFFFFFF &amp; (tag + value1.hashCode() * value2.hashCode());</span>
  }

  private static int hash(
      final int tag, final String value1, final String value2, final int value3) {
<span class="nc" id="L1252">    return 0x7FFFFFFF &amp; (tag + value1.hashCode() * value2.hashCode() * (value3 + 1));</span>
  }

  private static int hash(
      final int tag, final String value1, final String value2, final String value3) {
<span class="nc" id="L1257">    return 0x7FFFFFFF &amp; (tag + value1.hashCode() * value2.hashCode() * value3.hashCode());</span>
  }

  private static int hash(
      final int tag,
      final String value1,
      final String value2,
      final String value3,
      final int value4) {
<span class="nc" id="L1266">    return 0x7FFFFFFF &amp; (tag + value1.hashCode() * value2.hashCode() * value3.hashCode() * value4);</span>
  }

  /**
   * An entry of a SymbolTable. This concrete and private subclass of {@link Symbol} adds two fields
   * which are only used inside SymbolTable, to implement hash sets of symbols (in order to avoid
   * duplicate symbols). See {@link #entries}.
   *
   * @author Eric Bruneton
   */
  private static class Entry extends Symbol {

    /** The hash code of this entry. */
    final int hashCode;

    /**
     * Another entry (and so on recursively) having the same hash code (modulo the size of {@link
     * #entries}) as this one.
     */
    Entry next;

    Entry(
        final int index,
        final int tag,
        final String owner,
        final String name,
        final String value,
        final long data,
        final int hashCode) {
<span class="nc" id="L1295">      super(index, tag, owner, name, value, data);</span>
<span class="nc" id="L1296">      this.hashCode = hashCode;</span>
<span class="nc" id="L1297">    }</span>

    Entry(final int index, final int tag, final String value, final int hashCode) {
<span class="nc" id="L1300">      super(index, tag, /* owner = */ null, /* name = */ null, value, /* data = */ 0);</span>
<span class="nc" id="L1301">      this.hashCode = hashCode;</span>
<span class="nc" id="L1302">    }</span>

    Entry(final int index, final int tag, final String value, final long data, final int hashCode) {
<span class="nc" id="L1305">      super(index, tag, /* owner = */ null, /* name = */ null, value, data);</span>
<span class="nc" id="L1306">      this.hashCode = hashCode;</span>
<span class="nc" id="L1307">    }</span>

    Entry(
        final int index, final int tag, final String name, final String value, final int hashCode) {
<span class="nc" id="L1311">      super(index, tag, /* owner = */ null, name, value, /* data = */ 0);</span>
<span class="nc" id="L1312">      this.hashCode = hashCode;</span>
<span class="nc" id="L1313">    }</span>

    Entry(final int index, final int tag, final long data, final int hashCode) {
<span class="nc" id="L1316">      super(index, tag, /* owner = */ null, /* name = */ null, /* value = */ null, data);</span>
<span class="nc" id="L1317">      this.hashCode = hashCode;</span>
<span class="nc" id="L1318">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>