<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReflectionUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-core</a> &gt; <a href="index.source.html" class="el_package">org.springframework.util</a> &gt; <span class="el_source">ReflectionUtils.java</span></div><h1>ReflectionUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.util;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.springframework.lang.Nullable;

/**
 * Simple utility class for working with the reflection API and handling
 * reflection exceptions.
 *
 * &lt;p&gt;Only intended for internal use.
 *
 * @author Juergen Hoeller
 * @author Rob Harrop
 * @author Rod Johnson
 * @author Costin Leau
 * @author Sam Brannen
 * @author Chris Beams
 * @since 1.2.2
 */
<span class="nc" id="L46">public abstract class ReflectionUtils {</span>

	/**
	 * Pre-built MethodFilter that matches all non-bridge non-synthetic methods
	 * which are not declared on {@code java.lang.Object}.
	 * @since 3.0.5
	 */
<span class="fc" id="L53">	public static final MethodFilter USER_DECLARED_METHODS =</span>
<span class="nc bnc" id="L54" title="All 4 branches missed.">			(method -&gt; !method.isBridge() &amp;&amp; !method.isSynthetic());</span>

	/**
	 * Pre-built FieldFilter that matches all non-static, non-final fields.
	 */
<span class="fc" id="L59">	public static final FieldFilter COPYABLE_FIELDS =</span>
<span class="fc bfc" id="L60" title="All 4 branches covered.">			(field -&gt; !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers())));</span>


	/**
	 * Naming prefix for CGLIB-renamed methods.
	 * @see #isCglibRenamedMethod
	 */
	private static final String CGLIB_RENAMED_METHOD_PREFIX = &quot;CGLIB$&quot;;

<span class="fc" id="L69">	private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];</span>

<span class="fc" id="L71">	private static final Method[] EMPTY_METHOD_ARRAY = new Method[0];</span>

<span class="fc" id="L73">	private static final Field[] EMPTY_FIELD_ARRAY = new Field[0];</span>

<span class="fc" id="L75">	private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];</span>


	/**
	 * Cache for {@link Class#getDeclaredMethods()} plus equivalent default methods
	 * from Java 8 based interfaces, allowing for fast iteration.
	 */
<span class="fc" id="L82">	private static final Map&lt;Class&lt;?&gt;, Method[]&gt; declaredMethodsCache = new ConcurrentReferenceHashMap&lt;&gt;(256);</span>

	/**
	 * Cache for {@link Class#getDeclaredFields()}, allowing for fast iteration.
	 */
<span class="fc" id="L87">	private static final Map&lt;Class&lt;?&gt;, Field[]&gt; declaredFieldsCache = new ConcurrentReferenceHashMap&lt;&gt;(256);</span>


	// Exception handling

	/**
	 * Handle the given reflection exception. Should only be called if no
	 * checked exception is expected to be thrown by the target method.
	 * &lt;p&gt;Throws the underlying RuntimeException or Error in case of an
	 * InvocationTargetException with such a root cause. Throws an
	 * IllegalStateException with an appropriate message or
	 * UndeclaredThrowableException otherwise.
	 * @param ex the reflection exception to handle
	 */
	public static void handleReflectionException(Exception ex) {
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">		if (ex instanceof NoSuchMethodException) {</span>
<span class="nc" id="L103">			throw new IllegalStateException(&quot;Method not found: &quot; + ex.getMessage());</span>
		}
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">		if (ex instanceof IllegalAccessException) {</span>
<span class="nc" id="L106">			throw new IllegalStateException(&quot;Could not access method: &quot; + ex.getMessage());</span>
		}
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">		if (ex instanceof InvocationTargetException) {</span>
<span class="nc" id="L109">			handleInvocationTargetException((InvocationTargetException) ex);</span>
		}
<span class="nc bnc" id="L111" title="All 2 branches missed.">		if (ex instanceof RuntimeException) {</span>
<span class="nc" id="L112">			throw (RuntimeException) ex;</span>
		}
<span class="nc" id="L114">		throw new UndeclaredThrowableException(ex);</span>
	}

	/**
	 * Handle the given invocation target exception. Should only be called if no
	 * checked exception is expected to be thrown by the target method.
	 * &lt;p&gt;Throws the underlying RuntimeException or Error in case of such a root
	 * cause. Throws an UndeclaredThrowableException otherwise.
	 * @param ex the invocation target exception to handle
	 */
	public static void handleInvocationTargetException(InvocationTargetException ex) {
<span class="nc" id="L125">		rethrowRuntimeException(ex.getTargetException());</span>
<span class="nc" id="L126">	}</span>

	/**
	 * Rethrow the given {@link Throwable exception}, which is presumably the
	 * &lt;em&gt;target exception&lt;/em&gt; of an {@link InvocationTargetException}.
	 * Should only be called if no checked exception is expected to be thrown
	 * by the target method.
	 * &lt;p&gt;Rethrows the underlying exception cast to a {@link RuntimeException} or
	 * {@link Error} if appropriate; otherwise, throws an
	 * {@link UndeclaredThrowableException}.
	 * @param ex the exception to rethrow
	 * @throws RuntimeException the rethrown exception
	 */
	public static void rethrowRuntimeException(Throwable ex) {
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">		if (ex instanceof RuntimeException) {</span>
<span class="fc" id="L141">			throw (RuntimeException) ex;</span>
		}
<span class="nc bnc" id="L143" title="All 2 branches missed.">		if (ex instanceof Error) {</span>
<span class="nc" id="L144">			throw (Error) ex;</span>
		}
<span class="nc" id="L146">		throw new UndeclaredThrowableException(ex);</span>
	}

	/**
	 * Rethrow the given {@link Throwable exception}, which is presumably the
	 * &lt;em&gt;target exception&lt;/em&gt; of an {@link InvocationTargetException}.
	 * Should only be called if no checked exception is expected to be thrown
	 * by the target method.
	 * &lt;p&gt;Rethrows the underlying exception cast to an {@link Exception} or
	 * {@link Error} if appropriate; otherwise, throws an
	 * {@link UndeclaredThrowableException}.
	 * @param ex the exception to rethrow
	 * @throws Exception the rethrown exception (in case of a checked exception)
	 */
	public static void rethrowException(Throwable ex) throws Exception {
<span class="nc bnc" id="L161" title="All 2 branches missed.">		if (ex instanceof Exception) {</span>
<span class="nc" id="L162">			throw (Exception) ex;</span>
		}
<span class="nc bnc" id="L164" title="All 2 branches missed.">		if (ex instanceof Error) {</span>
<span class="nc" id="L165">			throw (Error) ex;</span>
		}
<span class="nc" id="L167">		throw new UndeclaredThrowableException(ex);</span>
	}


	// Constructor handling

	/**
	 * Obtain an accessible constructor for the given class and parameters.
	 * @param clazz the clazz to check
	 * @param parameterTypes the parameter types of the desired constructor
	 * @return the constructor reference
	 * @throws NoSuchMethodException if no such constructor exists
	 * @since 5.0
	 */
	public static &lt;T&gt; Constructor&lt;T&gt; accessibleConstructor(Class&lt;T&gt; clazz, Class&lt;?&gt;... parameterTypes)
			throws NoSuchMethodException {

<span class="fc" id="L184">		Constructor&lt;T&gt; ctor = clazz.getDeclaredConstructor(parameterTypes);</span>
<span class="fc" id="L185">		makeAccessible(ctor);</span>
<span class="fc" id="L186">		return ctor;</span>
	}

	/**
	 * Make the given constructor accessible, explicitly setting it accessible
	 * if necessary. The {@code setAccessible(true)} method is only called
	 * when actually necessary, to avoid unnecessary conflicts with a JVM
	 * SecurityManager (if active).
	 * @param ctor the constructor to make accessible
	 * @see java.lang.reflect.Constructor#setAccessible
	 */
	@SuppressWarnings(&quot;deprecation&quot;)  // on JDK 9
	public static void makeAccessible(Constructor&lt;?&gt; ctor) {
<span class="fc bfc" id="L199" title="All 2 branches covered.">		if ((!Modifier.isPublic(ctor.getModifiers()) ||</span>
<span class="pc bpc" id="L200" title="1 of 4 branches missed.">				!Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) &amp;&amp; !ctor.isAccessible()) {</span>
<span class="fc" id="L201">			ctor.setAccessible(true);</span>
		}
<span class="fc" id="L203">	}</span>


	// Method handling

	/**
	 * Attempt to find a {@link Method} on the supplied class with the supplied name
	 * and no parameters. Searches all superclasses up to {@code Object}.
	 * &lt;p&gt;Returns {@code null} if no {@link Method} can be found.
	 * @param clazz the class to introspect
	 * @param name the name of the method
	 * @return the Method object, or {@code null} if none found
	 */
	@Nullable
	public static Method findMethod(Class&lt;?&gt; clazz, String name) {
<span class="fc" id="L218">		return findMethod(clazz, name, EMPTY_CLASS_ARRAY);</span>
	}

	/**
	 * Attempt to find a {@link Method} on the supplied class with the supplied name
	 * and parameter types. Searches all superclasses up to {@code Object}.
	 * &lt;p&gt;Returns {@code null} if no {@link Method} can be found.
	 * @param clazz the class to introspect
	 * @param name the name of the method
	 * @param paramTypes the parameter types of the method
	 * (may be {@code null} to indicate any signature)
	 * @return the Method object, or {@code null} if none found
	 */
	@Nullable
	public static Method findMethod(Class&lt;?&gt; clazz, String name, @Nullable Class&lt;?&gt;... paramTypes) {
<span class="fc" id="L233">		Assert.notNull(clazz, &quot;Class must not be null&quot;);</span>
<span class="fc" id="L234">		Assert.notNull(name, &quot;Method name must not be null&quot;);</span>
<span class="fc" id="L235">		Class&lt;?&gt; searchType = clazz;</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">		while (searchType != null) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">			Method[] methods = searchType.isInterface() ?</span>
<span class="fc" id="L238">					searchType.getMethods() :</span>
<span class="fc" id="L239">					getDeclaredMethods(searchType, false);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">			for (Method method : methods) {</span>
<span class="pc bpc" id="L241" title="1 of 4 branches missed.">				if (name.equals(method.getName()) &amp;&amp;</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">						(paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {</span>
<span class="fc" id="L243">					return method;</span>
				}
			}
<span class="fc" id="L246">			searchType = searchType.getSuperclass();</span>
<span class="fc" id="L247">		}</span>
<span class="nc" id="L248">		return null;</span>
	}

	/**
	 * Invoke the specified {@link Method} against the supplied target object with no arguments.
	 * The target object can be {@code null} when invoking a static {@link Method}.
	 * &lt;p&gt;Thrown exceptions are handled via a call to {@link #handleReflectionException}.
	 * @param method the method to invoke
	 * @param target the target object to invoke the method on
	 * @return the invocation result, if any
	 * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])
	 */
	@Nullable
	public static Object invokeMethod(Method method, @Nullable Object target) {
<span class="fc" id="L262">		return invokeMethod(method, target, EMPTY_OBJECT_ARRAY);</span>
	}

	/**
	 * Invoke the specified {@link Method} against the supplied target object with the
	 * supplied arguments. The target object can be {@code null} when invoking a
	 * static {@link Method}.
	 * &lt;p&gt;Thrown exceptions are handled via a call to {@link #handleReflectionException}.
	 * @param method the method to invoke
	 * @param target the target object to invoke the method on
	 * @param args the invocation arguments (may be {@code null})
	 * @return the invocation result, if any
	 */
	@Nullable
	public static Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args) {
		try {
<span class="fc" id="L278">			return method.invoke(target, args);</span>
		}
<span class="fc" id="L280">		catch (Exception ex) {</span>
<span class="nc" id="L281">			handleReflectionException(ex);</span>
		}
<span class="nc" id="L283">		throw new IllegalStateException(&quot;Should never get here&quot;);</span>
	}

	/**
	 * Determine whether the given method explicitly declares the given
	 * exception or one of its superclasses, which means that an exception
	 * of that type can be propagated as-is within a reflective invocation.
	 * @param method the declaring method
	 * @param exceptionType the exception to throw
	 * @return {@code true} if the exception can be thrown as-is;
	 * {@code false} if it needs to be wrapped
	 */
	public static boolean declaresException(Method method, Class&lt;?&gt; exceptionType) {
<span class="fc" id="L296">		Assert.notNull(method, &quot;Method must not be null&quot;);</span>
<span class="fc" id="L297">		Class&lt;?&gt;[] declaredExceptions = method.getExceptionTypes();</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">		for (Class&lt;?&gt; declaredException : declaredExceptions) {</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">			if (declaredException.isAssignableFrom(exceptionType)) {</span>
<span class="fc" id="L300">				return true;</span>
			}
		}
<span class="fc" id="L303">		return false;</span>
	}

	/**
	 * Perform the given callback operation on all matching methods of the given
	 * class, as locally declared or equivalent thereof (such as default methods
	 * on Java 8 based interfaces that the given class implements).
	 * @param clazz the class to introspect
	 * @param mc the callback to invoke for each method
	 * @throws IllegalStateException if introspection fails
	 * @since 4.2
	 * @see #doWithMethods
	 */
	public static void doWithLocalMethods(Class&lt;?&gt; clazz, MethodCallback mc) {
<span class="fc" id="L317">		Method[] methods = getDeclaredMethods(clazz, false);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">		for (Method method : methods) {</span>
			try {
<span class="fc" id="L320">				mc.doWith(method);</span>
			}
<span class="nc" id="L322">			catch (IllegalAccessException ex) {</span>
<span class="nc" id="L323">				throw new IllegalStateException(&quot;Not allowed to access method '&quot; + method.getName() + &quot;': &quot; + ex);</span>
<span class="fc" id="L324">			}</span>
		}
<span class="fc" id="L326">	}</span>

	/**
	 * Perform the given callback operation on all matching methods of the given
	 * class and superclasses.
	 * &lt;p&gt;The same named method occurring on subclass and superclass will appear
	 * twice, unless excluded by a {@link MethodFilter}.
	 * @param clazz the class to introspect
	 * @param mc the callback to invoke for each method
	 * @throws IllegalStateException if introspection fails
	 * @see #doWithMethods(Class, MethodCallback, MethodFilter)
	 */
	public static void doWithMethods(Class&lt;?&gt; clazz, MethodCallback mc) {
<span class="fc" id="L339">		doWithMethods(clazz, mc, null);</span>
<span class="fc" id="L340">	}</span>

	/**
	 * Perform the given callback operation on all matching methods of the given
	 * class and superclasses (or given interface and super-interfaces).
	 * &lt;p&gt;The same named method occurring on subclass and superclass will appear
	 * twice, unless excluded by the specified {@link MethodFilter}.
	 * @param clazz the class to introspect
	 * @param mc the callback to invoke for each method
	 * @param mf the filter that determines the methods to apply the callback to
	 * @throws IllegalStateException if introspection fails
	 */
	public static void doWithMethods(Class&lt;?&gt; clazz, MethodCallback mc, @Nullable MethodFilter mf) {
		// Keep backing up the inheritance hierarchy.
<span class="fc" id="L354">		Method[] methods = getDeclaredMethods(clazz, false);</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">		for (Method method : methods) {</span>
<span class="fc bfc" id="L356" title="All 4 branches covered.">			if (mf != null &amp;&amp; !mf.matches(method)) {</span>
<span class="fc" id="L357">				continue;</span>
			}
			try {
<span class="fc" id="L360">				mc.doWith(method);</span>
			}
<span class="nc" id="L362">			catch (IllegalAccessException ex) {</span>
<span class="nc" id="L363">				throw new IllegalStateException(&quot;Not allowed to access method '&quot; + method.getName() + &quot;': &quot; + ex);</span>
<span class="fc" id="L364">			}</span>
		}
<span class="pc bpc" id="L366" title="3 of 6 branches missed.">		if (clazz.getSuperclass() != null &amp;&amp; (mf != USER_DECLARED_METHODS || clazz.getSuperclass() != Object.class)) {</span>
<span class="fc" id="L367">			doWithMethods(clazz.getSuperclass(), mc, mf);</span>
		}
<span class="fc bfc" id="L369" title="All 2 branches covered.">		else if (clazz.isInterface()) {</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">			for (Class&lt;?&gt; superIfc : clazz.getInterfaces()) {</span>
<span class="fc" id="L371">				doWithMethods(superIfc, mc, mf);</span>
			}
		}
<span class="fc" id="L374">	}</span>

	/**
	 * Get all declared methods on the leaf class and all superclasses.
	 * Leaf class methods are included first.
	 * @param leafClass the class to introspect
	 * @throws IllegalStateException if introspection fails
	 */
	public static Method[] getAllDeclaredMethods(Class&lt;?&gt; leafClass) {
<span class="fc" id="L383">		final List&lt;Method&gt; methods = new ArrayList&lt;&gt;(32);</span>
<span class="fc" id="L384">		doWithMethods(leafClass, methods::add);</span>
<span class="fc" id="L385">		return methods.toArray(EMPTY_METHOD_ARRAY);</span>
	}

	/**
	 * Get the unique set of declared methods on the leaf class and all superclasses.
	 * Leaf class methods are included first and while traversing the superclass hierarchy
	 * any methods found with signatures matching a method already included are filtered out.
	 * @param leafClass the class to introspect
	 * @throws IllegalStateException if introspection fails
	 */
	public static Method[] getUniqueDeclaredMethods(Class&lt;?&gt; leafClass) {
<span class="fc" id="L396">		return getUniqueDeclaredMethods(leafClass, null);</span>
	}

	/**
	 * Get the unique set of declared methods on the leaf class and all superclasses.
	 * Leaf class methods are included first and while traversing the superclass hierarchy
	 * any methods found with signatures matching a method already included are filtered out.
	 * @param leafClass the class to introspect
	 * @param mf the filter that determines the methods to take into account
	 * @throws IllegalStateException if introspection fails
	 * @since 5.2
	 */
	public static Method[] getUniqueDeclaredMethods(Class&lt;?&gt; leafClass, @Nullable MethodFilter mf) {
<span class="fc" id="L409">		final List&lt;Method&gt; methods = new ArrayList&lt;&gt;(32);</span>
<span class="fc" id="L410">		doWithMethods(leafClass, method -&gt; {</span>
<span class="fc" id="L411">			boolean knownSignature = false;</span>
<span class="fc" id="L412">			Method methodBeingOverriddenWithCovariantReturnType = null;</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">			for (Method existingMethod : methods) {</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">				if (method.getName().equals(existingMethod.getName()) &amp;&amp;</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">						Arrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {</span>
					// Is this a covariant return type situation?
<span class="fc bfc" id="L417" title="All 2 branches covered.">					if (existingMethod.getReturnType() != method.getReturnType() &amp;&amp;</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">							existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {</span>
<span class="fc" id="L419">						methodBeingOverriddenWithCovariantReturnType = existingMethod;</span>
					}
					else {
<span class="fc" id="L422">						knownSignature = true;</span>
					}
<span class="fc" id="L424">					break;</span>
				}
<span class="fc" id="L426">			}</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">			if (methodBeingOverriddenWithCovariantReturnType != null) {</span>
<span class="fc" id="L428">				methods.remove(methodBeingOverriddenWithCovariantReturnType);</span>
			}
<span class="pc bpc" id="L430" title="1 of 4 branches missed.">			if (!knownSignature &amp;&amp; !isCglibRenamedMethod(method)) {</span>
<span class="fc" id="L431">				methods.add(method);</span>
			}
<span class="fc" id="L433">		}, mf);</span>
<span class="fc" id="L434">		return methods.toArray(EMPTY_METHOD_ARRAY);</span>
	}

	/**
	 * Variant of {@link Class#getDeclaredMethods()} that uses a local cache in
	 * order to avoid the JVM's SecurityManager check and new Method instances.
	 * In addition, it also includes Java 8 default methods from locally
	 * implemented interfaces, since those are effectively to be treated just
	 * like declared methods.
	 * @param clazz the class to introspect
	 * @return the cached array of methods
	 * @throws IllegalStateException if introspection fails
	 * @since 5.2
	 * @see Class#getDeclaredMethods()
	 */
	public static Method[] getDeclaredMethods(Class&lt;?&gt; clazz) {
<span class="fc" id="L450">		return getDeclaredMethods(clazz, true);</span>
	}

	private static Method[] getDeclaredMethods(Class&lt;?&gt; clazz, boolean defensive) {
<span class="fc" id="L454">		Assert.notNull(clazz, &quot;Class must not be null&quot;);</span>
<span class="fc" id="L455">		Method[] result = declaredMethodsCache.get(clazz);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">		if (result == null) {</span>
			try {
<span class="fc" id="L458">				Method[] declaredMethods = clazz.getDeclaredMethods();</span>
<span class="fc" id="L459">				List&lt;Method&gt; defaultMethods = findConcreteMethodsOnInterfaces(clazz);</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">				if (defaultMethods != null) {</span>
<span class="fc" id="L461">					result = new Method[declaredMethods.length + defaultMethods.size()];</span>
<span class="fc" id="L462">					System.arraycopy(declaredMethods, 0, result, 0, declaredMethods.length);</span>
<span class="fc" id="L463">					int index = declaredMethods.length;</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">					for (Method defaultMethod : defaultMethods) {</span>
<span class="fc" id="L465">						result[index] = defaultMethod;</span>
<span class="fc" id="L466">						index++;</span>
<span class="fc" id="L467">					}</span>
<span class="fc" id="L468">				}</span>
				else {
<span class="fc" id="L470">					result = declaredMethods;</span>
				}
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">				declaredMethodsCache.put(clazz, (result.length == 0 ? EMPTY_METHOD_ARRAY : result));</span>
			}
<span class="nc" id="L474">			catch (Throwable ex) {</span>
<span class="nc" id="L475">				throw new IllegalStateException(&quot;Failed to introspect Class [&quot; + clazz.getName() +</span>
<span class="nc" id="L476">						&quot;] from ClassLoader [&quot; + clazz.getClassLoader() + &quot;]&quot;, ex);</span>
<span class="fc" id="L477">			}</span>
		}
<span class="pc bpc" id="L479" title="1 of 4 branches missed.">		return (result.length == 0 || !defensive) ? result : result.clone();</span>
	}

	@Nullable
	private static List&lt;Method&gt; findConcreteMethodsOnInterfaces(Class&lt;?&gt; clazz) {
<span class="fc" id="L484">		List&lt;Method&gt; result = null;</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">		for (Class&lt;?&gt; ifc : clazz.getInterfaces()) {</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">			for (Method ifcMethod : ifc.getMethods()) {</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">				if (!Modifier.isAbstract(ifcMethod.getModifiers())) {</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">					if (result == null) {</span>
<span class="fc" id="L489">						result = new ArrayList&lt;&gt;();</span>
					}
<span class="fc" id="L491">					result.add(ifcMethod);</span>
				}
			}
		}
<span class="fc" id="L495">		return result;</span>
	}

	/**
	 * Determine whether the given method is an &quot;equals&quot; method.
	 * @see java.lang.Object#equals(Object)
	 */
	public static boolean isEqualsMethod(@Nullable Method method) {
<span class="pc bpc" id="L503" title="1 of 4 branches missed.">		if (method == null || !method.getName().equals(&quot;equals&quot;)) {</span>
<span class="fc" id="L504">			return false;</span>
		}
<span class="fc" id="L506">		Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span>
<span class="pc bpc" id="L507" title="2 of 4 branches missed.">		return (paramTypes.length == 1 &amp;&amp; paramTypes[0] == Object.class);</span>
	}

	/**
	 * Determine whether the given method is a &quot;hashCode&quot; method.
	 * @see java.lang.Object#hashCode()
	 */
	public static boolean isHashCodeMethod(@Nullable Method method) {
<span class="pc bpc" id="L515" title="2 of 6 branches missed.">		return (method != null &amp;&amp; method.getName().equals(&quot;hashCode&quot;) &amp;&amp; method.getParameterCount() == 0);</span>
	}

	/**
	 * Determine whether the given method is a &quot;toString&quot; method.
	 * @see java.lang.Object#toString()
	 */
	public static boolean isToStringMethod(@Nullable Method method) {
<span class="pc bpc" id="L523" title="2 of 6 branches missed.">		return (method != null &amp;&amp; method.getName().equals(&quot;toString&quot;) &amp;&amp; method.getParameterCount() == 0);</span>
	}

	/**
	 * Determine whether the given method is originally declared by {@link java.lang.Object}.
	 */
	public static boolean isObjectMethod(@Nullable Method method) {
<span class="nc bnc" id="L530" title="All 2 branches missed.">		if (method == null) {</span>
<span class="nc" id="L531">			return false;</span>
		}
		try {
<span class="nc" id="L534">			Object.class.getDeclaredMethod(method.getName(), method.getParameterTypes());</span>
<span class="nc" id="L535">			return true;</span>
		}
<span class="nc" id="L537">		catch (Exception ex) {</span>
<span class="nc" id="L538">			return false;</span>
		}
	}

	/**
	 * Determine whether the given method is a CGLIB 'renamed' method,
	 * following the pattern &quot;CGLIB$methodName$0&quot;.
	 * @param renamedMethod the method to check
	 */
	public static boolean isCglibRenamedMethod(Method renamedMethod) {
<span class="fc" id="L548">		String name = renamedMethod.getName();</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">		if (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {</span>
<span class="fc" id="L550">			int i = name.length() - 1;</span>
<span class="pc bpc" id="L551" title="1 of 4 branches missed.">			while (i &gt;= 0 &amp;&amp; Character.isDigit(name.charAt(i))) {</span>
<span class="fc" id="L552">				i--;</span>
			}
<span class="pc bpc" id="L554" title="1 of 6 branches missed.">			return (i &gt; CGLIB_RENAMED_METHOD_PREFIX.length() &amp;&amp; (i &lt; name.length() - 1) &amp;&amp; name.charAt(i) == '$');</span>
		}
<span class="fc" id="L556">		return false;</span>
	}

	/**
	 * Make the given method accessible, explicitly setting it accessible if
	 * necessary. The {@code setAccessible(true)} method is only called
	 * when actually necessary, to avoid unnecessary conflicts with a JVM
	 * SecurityManager (if active).
	 * @param method the method to make accessible
	 * @see java.lang.reflect.Method#setAccessible
	 */
	@SuppressWarnings(&quot;deprecation&quot;)  // on JDK 9
	public static void makeAccessible(Method method) {
<span class="fc bfc" id="L569" title="All 2 branches covered.">		if ((!Modifier.isPublic(method.getModifiers()) ||</span>
<span class="fc bfc" id="L570" title="All 4 branches covered.">				!Modifier.isPublic(method.getDeclaringClass().getModifiers())) &amp;&amp; !method.isAccessible()) {</span>
<span class="fc" id="L571">			method.setAccessible(true);</span>
		}
<span class="fc" id="L573">	}</span>


	// Field handling

	/**
	 * Attempt to find a {@link Field field} on the supplied {@link Class} with the
	 * supplied {@code name}. Searches all superclasses up to {@link Object}.
	 * @param clazz the class to introspect
	 * @param name the name of the field
	 * @return the corresponding Field object, or {@code null} if not found
	 */
	@Nullable
	public static Field findField(Class&lt;?&gt; clazz, String name) {
<span class="fc" id="L587">		return findField(clazz, name, null);</span>
	}

	/**
	 * Attempt to find a {@link Field field} on the supplied {@link Class} with the
	 * supplied {@code name} and/or {@link Class type}. Searches all superclasses
	 * up to {@link Object}.
	 * @param clazz the class to introspect
	 * @param name the name of the field (may be {@code null} if type is specified)
	 * @param type the type of the field (may be {@code null} if name is specified)
	 * @return the corresponding Field object, or {@code null} if not found
	 */
	@Nullable
	public static Field findField(Class&lt;?&gt; clazz, @Nullable String name, @Nullable Class&lt;?&gt; type) {
<span class="fc" id="L601">		Assert.notNull(clazz, &quot;Class must not be null&quot;);</span>
<span class="pc bpc" id="L602" title="3 of 4 branches missed.">		Assert.isTrue(name != null || type != null, &quot;Either name or type of the field must be specified&quot;);</span>
<span class="fc" id="L603">		Class&lt;?&gt; searchType = clazz;</span>
<span class="pc bpc" id="L604" title="1 of 4 branches missed.">		while (Object.class != searchType &amp;&amp; searchType != null) {</span>
<span class="fc" id="L605">			Field[] fields = getDeclaredFields(searchType);</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">			for (Field field : fields) {</span>
<span class="pc bpc" id="L607" title="1 of 6 branches missed.">				if ((name == null || name.equals(field.getName())) &amp;&amp;</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">						(type == null || type.equals(field.getType()))) {</span>
<span class="fc" id="L609">					return field;</span>
				}
			}
<span class="fc" id="L612">			searchType = searchType.getSuperclass();</span>
<span class="fc" id="L613">		}</span>
<span class="fc" id="L614">		return null;</span>
	}

	/**
	 * Set the field represented by the supplied {@link Field field object} on the
	 * specified {@link Object target object} to the specified {@code value}.
	 * In accordance with {@link Field#set(Object, Object)} semantics, the new value
	 * is automatically unwrapped if the underlying field has a primitive type.
	 * &lt;p&gt;Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.
	 * @param field the field to set
	 * @param target the target object on which to set the field
	 * @param value the value to set (may be {@code null})
	 */
	public static void setField(Field field, @Nullable Object target, @Nullable Object value) {
		try {
<span class="fc" id="L629">			field.set(target, value);</span>
		}
<span class="nc" id="L631">		catch (IllegalAccessException ex) {</span>
<span class="nc" id="L632">			handleReflectionException(ex);</span>
<span class="nc" id="L633">			throw new IllegalStateException(</span>
<span class="nc" id="L634">					&quot;Unexpected reflection exception - &quot; + ex.getClass().getName() + &quot;: &quot; + ex.getMessage());</span>
<span class="fc" id="L635">		}</span>
<span class="fc" id="L636">	}</span>

	/**
	 * Get the field represented by the supplied {@link Field field object} on the
	 * specified {@link Object target object}. In accordance with {@link Field#get(Object)}
	 * semantics, the returned value is automatically wrapped if the underlying field
	 * has a primitive type.
	 * &lt;p&gt;Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.
	 * @param field the field to get
	 * @param target the target object from which to get the field
	 * @return the field's current value
	 */
	@Nullable
	public static Object getField(Field field, @Nullable Object target) {
		try {
<span class="nc" id="L651">			return field.get(target);</span>
		}
<span class="nc" id="L653">		catch (IllegalAccessException ex) {</span>
<span class="nc" id="L654">			handleReflectionException(ex);</span>
<span class="nc" id="L655">			throw new IllegalStateException(</span>
<span class="nc" id="L656">					&quot;Unexpected reflection exception - &quot; + ex.getClass().getName() + &quot;: &quot; + ex.getMessage());</span>
		}
	}

	/**
	 * Invoke the given callback on all locally declared fields in the given class.
	 * @param clazz the target class to analyze
	 * @param fc the callback to invoke for each field
	 * @throws IllegalStateException if introspection fails
	 * @since 4.2
	 * @see #doWithFields
	 */
	public static void doWithLocalFields(Class&lt;?&gt; clazz, FieldCallback fc) {
<span class="nc bnc" id="L669" title="All 2 branches missed.">		for (Field field : getDeclaredFields(clazz)) {</span>
			try {
<span class="nc" id="L671">				fc.doWith(field);</span>
			}
<span class="nc" id="L673">			catch (IllegalAccessException ex) {</span>
<span class="nc" id="L674">				throw new IllegalStateException(&quot;Not allowed to access field '&quot; + field.getName() + &quot;': &quot; + ex);</span>
<span class="nc" id="L675">			}</span>
		}
<span class="nc" id="L677">	}</span>

	/**
	 * Invoke the given callback on all fields in the target class, going up the
	 * class hierarchy to get all declared fields.
	 * @param clazz the target class to analyze
	 * @param fc the callback to invoke for each field
	 * @throws IllegalStateException if introspection fails
	 */
	public static void doWithFields(Class&lt;?&gt; clazz, FieldCallback fc) {
<span class="nc" id="L687">		doWithFields(clazz, fc, null);</span>
<span class="nc" id="L688">	}</span>

	/**
	 * Invoke the given callback on all fields in the target class, going up the
	 * class hierarchy to get all declared fields.
	 * @param clazz the target class to analyze
	 * @param fc the callback to invoke for each field
	 * @param ff the filter that determines the fields to apply the callback to
	 * @throws IllegalStateException if introspection fails
	 */
	public static void doWithFields(Class&lt;?&gt; clazz, FieldCallback fc, @Nullable FieldFilter ff) {
		// Keep backing up the inheritance hierarchy.
<span class="fc" id="L700">		Class&lt;?&gt; targetClass = clazz;</span>
		do {
<span class="fc" id="L702">			Field[] fields = getDeclaredFields(targetClass);</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">			for (Field field : fields) {</span>
<span class="pc bpc" id="L704" title="1 of 4 branches missed.">				if (ff != null &amp;&amp; !ff.matches(field)) {</span>
<span class="fc" id="L705">					continue;</span>
				}
				try {
<span class="fc" id="L708">					fc.doWith(field);</span>
				}
<span class="nc" id="L710">				catch (IllegalAccessException ex) {</span>
<span class="nc" id="L711">					throw new IllegalStateException(&quot;Not allowed to access field '&quot; + field.getName() + &quot;': &quot; + ex);</span>
<span class="fc" id="L712">				}</span>
			}
<span class="fc" id="L714">			targetClass = targetClass.getSuperclass();</span>
		}
<span class="pc bpc" id="L716" title="1 of 4 branches missed.">		while (targetClass != null &amp;&amp; targetClass != Object.class);</span>
<span class="fc" id="L717">	}</span>

	/**
	 * This variant retrieves {@link Class#getDeclaredFields()} from a local cache
	 * in order to avoid the JVM's SecurityManager check and defensive array copying.
	 * @param clazz the class to introspect
	 * @return the cached array of fields
	 * @throws IllegalStateException if introspection fails
	 * @see Class#getDeclaredFields()
	 */
	private static Field[] getDeclaredFields(Class&lt;?&gt; clazz) {
<span class="fc" id="L728">		Assert.notNull(clazz, &quot;Class must not be null&quot;);</span>
<span class="fc" id="L729">		Field[] result = declaredFieldsCache.get(clazz);</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">		if (result == null) {</span>
			try {
<span class="fc" id="L732">				result = clazz.getDeclaredFields();</span>
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">				declaredFieldsCache.put(clazz, (result.length == 0 ? EMPTY_FIELD_ARRAY : result));</span>
			}
<span class="nc" id="L735">			catch (Throwable ex) {</span>
<span class="nc" id="L736">				throw new IllegalStateException(&quot;Failed to introspect Class [&quot; + clazz.getName() +</span>
<span class="nc" id="L737">						&quot;] from ClassLoader [&quot; + clazz.getClassLoader() + &quot;]&quot;, ex);</span>
<span class="fc" id="L738">			}</span>
		}
<span class="fc" id="L740">		return result;</span>
	}

	/**
	 * Given the source object and the destination, which must be the same class
	 * or a subclass, copy all fields, including inherited fields. Designed to
	 * work on objects with public no-arg constructors.
	 * @throws IllegalStateException if introspection fails
	 */
	public static void shallowCopyFieldState(final Object src, final Object dest) {
<span class="fc" id="L750">		Assert.notNull(src, &quot;Source for field copy cannot be null&quot;);</span>
<span class="fc" id="L751">		Assert.notNull(dest, &quot;Destination for field copy cannot be null&quot;);</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">		if (!src.getClass().isAssignableFrom(dest.getClass())) {</span>
<span class="fc" id="L753">			throw new IllegalArgumentException(&quot;Destination class [&quot; + dest.getClass().getName() +</span>
<span class="fc" id="L754">					&quot;] must be same or subclass as source class [&quot; + src.getClass().getName() + &quot;]&quot;);</span>
		}
<span class="fc" id="L756">		doWithFields(src.getClass(), field -&gt; {</span>
<span class="fc" id="L757">			makeAccessible(field);</span>
<span class="fc" id="L758">			Object srcValue = field.get(src);</span>
<span class="fc" id="L759">			field.set(dest, srcValue);</span>
<span class="fc" id="L760">		}, COPYABLE_FIELDS);</span>
<span class="fc" id="L761">	}</span>

	/**
	 * Determine whether the given field is a &quot;public static final&quot; constant.
	 * @param field the field to check
	 */
	public static boolean isPublicStaticFinal(Field field) {
<span class="fc" id="L768">		int modifiers = field.getModifiers();</span>
<span class="pc bpc" id="L769" title="3 of 6 branches missed.">		return (Modifier.isPublic(modifiers) &amp;&amp; Modifier.isStatic(modifiers) &amp;&amp; Modifier.isFinal(modifiers));</span>
	}

	/**
	 * Make the given field accessible, explicitly setting it accessible if
	 * necessary. The {@code setAccessible(true)} method is only called
	 * when actually necessary, to avoid unnecessary conflicts with a JVM
	 * SecurityManager (if active).
	 * @param field the field to make accessible
	 * @see java.lang.reflect.Field#setAccessible
	 */
	@SuppressWarnings(&quot;deprecation&quot;)  // on JDK 9
	public static void makeAccessible(Field field) {
<span class="fc bfc" id="L782" title="All 2 branches covered.">		if ((!Modifier.isPublic(field.getModifiers()) ||</span>
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">				!Modifier.isPublic(field.getDeclaringClass().getModifiers()) ||</span>
<span class="pc bpc" id="L784" title="1 of 4 branches missed.">				Modifier.isFinal(field.getModifiers())) &amp;&amp; !field.isAccessible()) {</span>
<span class="fc" id="L785">			field.setAccessible(true);</span>
		}
<span class="fc" id="L787">	}</span>


	// Cache handling

	/**
	 * Clear the internal method/field cache.
	 * @since 4.2.4
	 */
	public static void clearCache() {
<span class="nc" id="L797">		declaredMethodsCache.clear();</span>
<span class="nc" id="L798">		declaredFieldsCache.clear();</span>
<span class="nc" id="L799">	}</span>


	/**
	 * Action to take on each method.
	 */
	@FunctionalInterface
	public interface MethodCallback {

		/**
		 * Perform an operation using the given method.
		 * @param method the method to operate on
		 */
		void doWith(Method method) throws IllegalArgumentException, IllegalAccessException;
	}


	/**
	 * Callback optionally used to filter methods to be operated on by a method callback.
	 */
	@FunctionalInterface
	public interface MethodFilter {

		/**
		 * Determine whether the given method matches.
		 * @param method the method to check
		 */
		boolean matches(Method method);
	}


	/**
	 * Callback interface invoked on each field in the hierarchy.
	 */
	@FunctionalInterface
	public interface FieldCallback {

		/**
		 * Perform an operation using the given field.
		 * @param field the field to operate on
		 */
		void doWith(Field field) throws IllegalArgumentException, IllegalAccessException;
	}


	/**
	 * Callback optionally used to filter fields to be operated on by a field callback.
	 */
	@FunctionalInterface
	public interface FieldFilter {

		/**
		 * Determine whether the given field matches.
		 * @param field the field to check
		 */
		boolean matches(Field field);
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>