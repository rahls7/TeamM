<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AnnotatedElementUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-core</a> &gt; <a href="index.source.html" class="el_package">org.springframework.core.annotation</a> &gt; <span class="el_source">AnnotatedElementUtils.java</span></div><h1>AnnotatedElementUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.annotation;

import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.core.BridgeMethodResolver;
import org.springframework.core.annotation.MergedAnnotation.MapValues;
import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;
import org.springframework.lang.Nullable;
import org.springframework.util.MultiValueMap;

/**
 * General utility methods for finding annotations, meta-annotations, and
 * repeatable annotations on {@link AnnotatedElement AnnotatedElements}.
 *
 * &lt;p&gt;{@code AnnotatedElementUtils} defines the public API for Spring's
 * meta-annotation programming model with support for &lt;em&gt;annotation attribute
 * overrides&lt;/em&gt;. If you do not need support for annotation attribute
 * overrides, consider using {@link AnnotationUtils} instead.
 *
 * &lt;p&gt;Note that the features of this class are not provided by the JDK's
 * introspection facilities themselves.
 *
 * &lt;h3&gt;Annotation Attribute Overrides&lt;/h3&gt;
 * &lt;p&gt;Support for meta-annotations with &lt;em&gt;attribute overrides&lt;/em&gt; in
 * &lt;em&gt;composed annotations&lt;/em&gt; is provided by all variants of the
 * {@code getMergedAnnotationAttributes()}, {@code getMergedAnnotation()},
 * {@code getAllMergedAnnotations()}, {@code getMergedRepeatableAnnotations()},
 * {@code findMergedAnnotationAttributes()}, {@code findMergedAnnotation()},
 * {@code findAllMergedAnnotations()}, and {@code findMergedRepeatableAnnotations()}
 * methods.
 *
 * &lt;h3&gt;Find vs. Get Semantics&lt;/h3&gt;
 * &lt;p&gt;The search algorithms used by methods in this class follow either
 * &lt;em&gt;find&lt;/em&gt; or &lt;em&gt;get&lt;/em&gt; semantics. Consult the javadocs for each
 * individual method for details on which search algorithm is used.
 *
 * &lt;p&gt;&lt;strong&gt;Get semantics&lt;/strong&gt; are limited to searching for annotations
 * that are either &lt;em&gt;present&lt;/em&gt; on an {@code AnnotatedElement} (i.e. declared
 * locally or {@linkplain java.lang.annotation.Inherited inherited}) or declared
 * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the {@code AnnotatedElement}.
 *
 * &lt;p&gt;&lt;strong&gt;Find semantics&lt;/strong&gt; are much more exhaustive, providing
 * &lt;em&gt;get semantics&lt;/em&gt; plus support for the following:
 *
 * &lt;ul&gt;
 * &lt;li&gt;Searching on interfaces, if the annotated element is a class
 * &lt;li&gt;Searching on superclasses, if the annotated element is a class
 * &lt;li&gt;Resolving bridged methods, if the annotated element is a method
 * &lt;li&gt;Searching on methods in interfaces, if the annotated element is a method
 * &lt;li&gt;Searching on methods in superclasses, if the annotated element is a method
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Support for {@code @Inherited}&lt;/h3&gt;
 * &lt;p&gt;Methods following &lt;em&gt;get semantics&lt;/em&gt; will honor the contract of Java's
 * {@link java.lang.annotation.Inherited @Inherited} annotation except that locally
 * declared annotations (including custom composed annotations) will be favored over
 * inherited annotations. In contrast, methods following &lt;em&gt;find semantics&lt;/em&gt;
 * will completely ignore the presence of {@code @Inherited} since the &lt;em&gt;find&lt;/em&gt;
 * search algorithm manually traverses type and method hierarchies and thereby
 * implicitly supports annotation inheritance without a need for {@code @Inherited}.
 *
 * @author Phillip Webb
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @since 4.0
 * @see AliasFor
 * @see AnnotationAttributes
 * @see AnnotationUtils
 * @see BridgeMethodResolver
 */
<span class="nc" id="L93">public abstract class AnnotatedElementUtils {</span>

	/**
	 * Build an adapted {@link AnnotatedElement} for the given annotations,
	 * typically for use with other methods on {@link AnnotatedElementUtils}.
	 * @param annotations the annotations to expose through the {@code AnnotatedElement}
	 * @since 4.3
	 */
	public static AnnotatedElement forAnnotations(Annotation... annotations) {
<span class="fc" id="L102">		return new AnnotatedElementForAnnotations(annotations);</span>
	}

	/**
	 * Get the fully qualified class names of all meta-annotation types
	 * &lt;em&gt;present&lt;/em&gt; on the annotation (of the specified {@code annotationType})
	 * on the supplied {@link AnnotatedElement}.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationType the annotation type on which to find meta-annotations
	 * @return the names of all meta-annotations present on the annotation,
	 * or {@code null} if not found
	 * @since 4.2
	 * @see #getMetaAnnotationTypes(AnnotatedElement, String)
	 * @see #hasMetaAnnotationTypes
	 */
	public static Set&lt;String&gt; getMetaAnnotationTypes(AnnotatedElement element,
			Class&lt;? extends Annotation&gt; annotationType) {

<span class="fc" id="L122">		return getMetaAnnotationTypes(element, element.getAnnotation(annotationType));</span>
	}

	/**
	 * Get the fully qualified class names of all meta-annotation
	 * types &lt;em&gt;present&lt;/em&gt; on the annotation (of the specified
	 * {@code annotationName}) on the supplied {@link AnnotatedElement}.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation
	 * type on which to find meta-annotations
	 * @return the names of all meta-annotations present on the annotation,
	 * or an empty set if none found
	 * @see #getMetaAnnotationTypes(AnnotatedElement, Class)
	 * @see #hasMetaAnnotationTypes
	 */
	public static Set&lt;String&gt; getMetaAnnotationTypes(AnnotatedElement element, String annotationName) {
<span class="pc bfc" id="L140" title="All 2 branches covered.">		for (Annotation annotation : element.getAnnotations()) {</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">			if (annotation.annotationType().getName().equals(annotationName)) {</span>
<span class="fc" id="L142">				return getMetaAnnotationTypes(element, annotation);</span>
			}
		}
<span class="fc" id="L145">		return Collections.emptySet();</span>
	}

	private static Set&lt;String&gt; getMetaAnnotationTypes(AnnotatedElement element, @Nullable Annotation annotation) {
<span class="fc bfc" id="L149" title="All 2 branches covered.">		if (annotation == null) {</span>
<span class="fc" id="L150">			return Collections.emptySet();</span>
		}
<span class="fc" id="L152">		return getAnnotations(annotation.annotationType()).stream()</span>
<span class="fc" id="L153">				.map(mergedAnnotation -&gt; mergedAnnotation.getType().getName())</span>
<span class="fc" id="L154">				.collect(Collectors.toCollection(LinkedHashSet::new));</span>
	}

	/**
	 * Determine if the supplied {@link AnnotatedElement} is annotated with
	 * a &lt;em&gt;composed annotation&lt;/em&gt; that is meta-annotated with an
	 * annotation of the specified {@code annotationType}.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationType the meta-annotation type to find
	 * @return {@code true} if a matching meta-annotation is present
	 * @since 4.2.3
	 * @see #getMetaAnnotationTypes
	 */
	public static boolean hasMetaAnnotationTypes(AnnotatedElement element, Class&lt;? extends Annotation&gt; annotationType) {
<span class="nc" id="L170">		return getAnnotations(element).stream(annotationType).anyMatch(MergedAnnotation::isMetaPresent);</span>
	}

	/**
	 * Determine if the supplied {@link AnnotatedElement} is annotated with a
	 * &lt;em&gt;composed annotation&lt;/em&gt; that is meta-annotated with an annotation
	 * of the specified {@code annotationName}.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the
	 * meta-annotation type to find
	 * @return {@code true} if a matching meta-annotation is present
	 * @see #getMetaAnnotationTypes
	 */
	public static boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName) {
<span class="fc" id="L186">		return getAnnotations(element).stream(annotationName).anyMatch(MergedAnnotation::isMetaPresent);</span>
	}

	/**
	 * Determine if an annotation of the specified {@code annotationType}
	 * is &lt;em&gt;present&lt;/em&gt; on the supplied {@link AnnotatedElement} or
	 * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the specified element.
	 * &lt;p&gt;If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}
	 * will return a non-null value.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @return {@code true} if a matching annotation is present
	 * @since 4.2.3
	 * @see #hasAnnotation(AnnotatedElement, Class)
	 */
	public static boolean isAnnotated(AnnotatedElement element,Class&lt;? extends Annotation&gt; annotationType) {
		// Shortcut: directly present on the element, with no processing needed?
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">		if (AnnotationFilter.PLAIN.matches(annotationType)) {</span>
<span class="nc" id="L206">			return element.isAnnotationPresent(annotationType);</span>
		}
		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {</span>
<span class="nc" id="L210">			return false;</span>
		}
		// Exhaustive retrieval of merged annotations...
<span class="fc" id="L213">		return getAnnotations(element).isPresent(annotationType);</span>
	}

	/**
	 * Determine if an annotation of the specified {@code annotationName} is
	 * &lt;em&gt;present&lt;/em&gt; on the supplied {@link AnnotatedElement} or within the
	 * annotation hierarchy &lt;em&gt;above&lt;/em&gt; the specified element.
	 * &lt;p&gt;If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}
	 * will return a non-null value.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @return {@code true} if a matching annotation is present
	 */
	public static boolean isAnnotated(AnnotatedElement element, String annotationName) {
<span class="fc" id="L229">		return getAnnotations(element).isPresent(annotationName);</span>
	}

	/**
	 * Get the first annotation of the specified {@code annotationType} within
	 * the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element} and
	 * merge that annotation's attributes with &lt;em&gt;matching&lt;/em&gt; attributes from
	 * annotations in lower levels of the annotation hierarchy.
	 * &lt;p&gt;{@link AliasFor @AliasFor} semantics are fully supported, both
	 * within a single annotation and within the annotation hierarchy.
	 * &lt;p&gt;This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)}.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found
	 * @since 4.2
	 * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #getMergedAnnotation(AnnotatedElement, Class)
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 */
	@Nullable
	public static AnnotationAttributes getMergedAnnotationAttributes(
			AnnotatedElement element, Class&lt;? extends Annotation&gt; annotationType) {

<span class="fc" id="L253">		MergedAnnotation&lt;?&gt; mergedAnnotation = getAnnotations(element)</span>
<span class="fc" id="L254">				.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());</span>
<span class="fc" id="L255">		return getAnnotationAttributes(mergedAnnotation, false, false);</span>
	}

	/**
	 * Get the first annotation of the specified {@code annotationName} within
	 * the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element} and
	 * merge that annotation's attributes with &lt;em&gt;matching&lt;/em&gt; attributes from
	 * annotations in lower levels of the annotation hierarchy.
	 * &lt;p&gt;{@link AliasFor @AliasFor} semantics are fully supported, both
	 * within a single annotation and within the annotation hierarchy.
	 * &lt;p&gt;This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)},
	 * supplying {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found
	 * @since 4.2
	 * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #getAllAnnotationAttributes(AnnotatedElement, String)
	 */
	@Nullable
	public static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,
			String annotationName) {

<span class="fc" id="L280">		return getMergedAnnotationAttributes(element, annotationName, false, false);</span>
	}

	/**
	 * Get the first annotation of the specified {@code annotationName} within
	 * the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element} and
	 * merge that annotation's attributes with &lt;em&gt;matching&lt;/em&gt; attributes from
	 * annotations in lower levels of the annotation hierarchy.
	 * &lt;p&gt;Attributes from lower levels in the annotation hierarchy override attributes
	 * of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are
	 * fully supported, both within a single annotation and within the annotation hierarchy.
	 * &lt;p&gt;In contrast to {@link #getAllAnnotationAttributes}, the search algorithm used by
	 * this method will stop searching the annotation hierarchy once the first annotation
	 * of the specified {@code annotationName} has been found. As a consequence,
	 * additional annotations of the specified {@code annotationName} will be ignored.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @param classValuesAsString whether to convert Class references into Strings or to
	 * preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances
	 * into {@code AnnotationAttributes} maps or to preserve them as Annotation instances
	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found
	 * @since 4.2
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 */
	@Nullable
	public static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,
			String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {

<span class="fc" id="L313">		MergedAnnotation&lt;?&gt; mergedAnnotation = getAnnotations(element)</span>
<span class="fc" id="L314">				.get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());</span>
<span class="fc" id="L315">		return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);</span>
	}

	/**
	 * Get the first annotation of the specified {@code annotationType} within
	 * the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element},
	 * merge that annotation's attributes with &lt;em&gt;matching&lt;/em&gt; attributes from
	 * annotations in lower levels of the annotation hierarchy, and synthesize
	 * the result back into an annotation of the specified {@code annotationType}.
	 * &lt;p&gt;{@link AliasFor @AliasFor} semantics are fully supported, both
	 * within a single annotation and within the annotation hierarchy.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @return the merged, synthesized {@code Annotation}, or {@code null} if not found
	 * @since 4.2
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 */
	@Nullable
	public static &lt;A extends Annotation&gt; A getMergedAnnotation(AnnotatedElement element, Class&lt;A&gt; annotationType) {
		// Shortcut: directly present on the element, with no merging needed?
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">		if (AnnotationFilter.PLAIN.matches(annotationType)) {</span>
<span class="nc" id="L336">			return element.getDeclaredAnnotation(annotationType);</span>
		}
		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {</span>
<span class="nc" id="L340">			return null;</span>
		}
		// Exhaustive retrieval of merged annotations...
<span class="fc" id="L343">		return getAnnotations(element)</span>
<span class="fc" id="L344">				.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())</span>
<span class="fc" id="L345">				.synthesize(MergedAnnotation::isPresent).orElse(null);</span>
	}

	/**
	 * Get &lt;strong&gt;all&lt;/strong&gt; annotations of the specified {@code annotationType}
	 * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * &lt;em&gt;matching&lt;/em&gt; attributes from annotations in lower levels of the annotation
	 * hierarchy and synthesize the results back into an annotation of the specified
	 * {@code annotationType}.
	 * &lt;p&gt;{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationType the annotation type to find (never {@code null})
	 * @return the set of all merged, synthesized {@code Annotations} found,
	 * or an empty set if none were found
	 * @since 4.3
	 * @see #getMergedAnnotation(AnnotatedElement, Class)
	 * @see #getAllAnnotationAttributes(AnnotatedElement, String)
	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)
	 */
	public static &lt;A extends Annotation&gt; Set&lt;A&gt; getAllMergedAnnotations(
			AnnotatedElement element, Class&lt;A&gt; annotationType) {

<span class="fc" id="L371">		return getAnnotations(element).stream(annotationType)</span>
<span class="fc" id="L372">				.collect(MergedAnnotationCollectors.toAnnotationSet());</span>
	}

	/**
	 * Get &lt;strong&gt;all&lt;/strong&gt; annotations of the specified {@code annotationTypes}
	 * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * &lt;em&gt;matching&lt;/em&gt; attributes from annotations in lower levels of the
	 * annotation hierarchy and synthesize the results back into an annotation
	 * of the corresponding {@code annotationType}.
	 * &lt;p&gt;{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationTypes the annotation types to find
	 * @return the set of all merged, synthesized {@code Annotations} found,
	 * or an empty set if none were found
	 * @since 5.1
	 * @see #getAllMergedAnnotations(AnnotatedElement, Class)
	 */
	public static Set&lt;Annotation&gt; getAllMergedAnnotations(AnnotatedElement element,
			Set&lt;Class&lt;? extends Annotation&gt;&gt; annotationTypes) {

<span class="nc" id="L396">		return getAnnotations(element).stream()</span>
<span class="nc" id="L397">				.filter(MergedAnnotationPredicates.typeIn(annotationTypes))</span>
<span class="nc" id="L398">				.collect(MergedAnnotationCollectors.toAnnotationSet());</span>
	}

	/**
	 * Get all &lt;em&gt;repeatable annotations&lt;/em&gt; of the specified {@code annotationType}
	 * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * &lt;em&gt;matching&lt;/em&gt; attributes from annotations in lower levels of the annotation
	 * hierarchy and synthesize the results back into an annotation of the specified
	 * {@code annotationType}.
	 * &lt;p&gt;The container type that holds the repeatable annotations will be looked up
	 * via {@link java.lang.annotation.Repeatable}.
	 * &lt;p&gt;{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationType the annotation type to find (never {@code null})
	 * @return the set of all merged repeatable {@code Annotations} found,
	 * or an empty set if none were found
	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}
	 * is {@code null}, or if the container type cannot be resolved
	 * @since 4.3
	 * @see #getMergedAnnotation(AnnotatedElement, Class)
	 * @see #getAllMergedAnnotations(AnnotatedElement, Class)
	 * @see #getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)
	 */
	public static &lt;A extends Annotation&gt; Set&lt;A&gt; getMergedRepeatableAnnotations(
			AnnotatedElement element, Class&lt;A&gt; annotationType) {

<span class="fc" id="L428">		return getMergedRepeatableAnnotations(element, annotationType, null);</span>
	}

	/**
	 * Get all &lt;em&gt;repeatable annotations&lt;/em&gt; of the specified {@code annotationType}
	 * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * &lt;em&gt;matching&lt;/em&gt; attributes from annotations in lower levels of the annotation
	 * hierarchy and synthesize the results back into an annotation of the specified
	 * {@code annotationType}.
	 * &lt;p&gt;{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationType the annotation type to find (never {@code null})
	 * @param containerType the type of the container that holds the annotations;
	 * may be {@code null} if the container type should be looked up via
	 * {@link java.lang.annotation.Repeatable}
	 * @return the set of all merged repeatable {@code Annotations} found,
	 * or an empty set if none were found
	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}
	 * is {@code null}, or if the container type cannot be resolved
	 * @throws AnnotationConfigurationException if the supplied {@code containerType}
	 * is not a valid container annotation for the supplied {@code annotationType}
	 * @since 4.3
	 * @see #getMergedAnnotation(AnnotatedElement, Class)
	 * @see #getAllMergedAnnotations(AnnotatedElement, Class)
	 */
	public static &lt;A extends Annotation&gt; Set&lt;A&gt; getMergedRepeatableAnnotations(
			AnnotatedElement element, Class&lt;A&gt; annotationType,
			@Nullable Class&lt;? extends Annotation&gt; containerType) {

<span class="fc" id="L461">		return getRepeatableAnnotations(element, containerType, annotationType)</span>
<span class="fc" id="L462">				.stream(annotationType)</span>
<span class="fc" id="L463">				.collect(MergedAnnotationCollectors.toAnnotationSet());</span>
	}

	/**
	 * Get the annotation attributes of &lt;strong&gt;all&lt;/strong&gt; annotations of the specified
	 * {@code annotationName} in the annotation hierarchy above the supplied
	 * {@link AnnotatedElement} and store the results in a {@link MultiValueMap}.
	 * &lt;p&gt;Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},
	 * this method does &lt;em&gt;not&lt;/em&gt; support attribute overrides.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation
	 * attributes from all annotations found, or {@code null} if not found
	 * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 */
	@Nullable
	public static MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(
			AnnotatedElement element, String annotationName) {

<span class="fc" id="L484">		return getAllAnnotationAttributes(element, annotationName, false, false);</span>
	}

	/**
	 * Get the annotation attributes of &lt;strong&gt;all&lt;/strong&gt; annotations of
	 * the specified {@code annotationName} in the annotation hierarchy above
	 * the supplied {@link AnnotatedElement} and store the results in a
	 * {@link MultiValueMap}.
	 * &lt;p&gt;Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},
	 * this method does &lt;em&gt;not&lt;/em&gt; support attribute overrides.
	 * &lt;p&gt;This method follows &lt;em&gt;get semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @param classValuesAsString whether to convert Class references into Strings or to
	 * preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into
	 * {@code AnnotationAttributes} maps or to preserve them as Annotation instances
	 * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation
	 * attributes from all annotations found, or {@code null} if not found
	 */
	@Nullable
	public static MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(AnnotatedElement element,
			String annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {

<span class="fc" id="L509">		MapValues[] mapValues = MapValues.of(classValuesAsString, nestedAnnotationsAsMap);</span>
<span class="fc" id="L510">		return getAnnotations(element).stream(annotationName)</span>
<span class="fc" id="L511">				.filter(MergedAnnotationPredicates.unique(AnnotatedElementUtils::parentAndType))</span>
<span class="fc" id="L512">				.map(MergedAnnotation::withNonMergedAttributes)</span>
<span class="fc" id="L513">				.collect(MergedAnnotationCollectors.toMultiValueMap(AnnotatedElementUtils::nullIfEmpty, mapValues));</span>
	}

	/**
	 * Determine if an annotation of the specified {@code annotationType}
	 * is &lt;em&gt;available&lt;/em&gt; on the supplied {@link AnnotatedElement} or
	 * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the specified element.
	 * &lt;p&gt;If this method returns {@code true}, then {@link #findMergedAnnotationAttributes}
	 * will return a non-null value.
	 * &lt;p&gt;This method follows &lt;em&gt;find semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @return {@code true} if a matching annotation is present
	 * @since 4.3
	 * @see #isAnnotated(AnnotatedElement, Class)
	 */
	public static boolean hasAnnotation(AnnotatedElement element, Class&lt;? extends Annotation&gt; annotationType) {
		// Shortcut: directly present on the element, with no processing needed?
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">		if (AnnotationFilter.PLAIN.matches(annotationType)) {</span>
<span class="nc" id="L533">			return element.isAnnotationPresent(annotationType);</span>
		}
		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {</span>
<span class="nc" id="L537">			return false;</span>
		}
		// Exhaustive retrieval of merged annotations...
<span class="fc" id="L540">		return findAnnotations(element).isPresent(annotationType);</span>
	}

	/**
	 * Find the first annotation of the specified {@code annotationType} within
	 * the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element} and
	 * merge that annotation's attributes with &lt;em&gt;matching&lt;/em&gt; attributes from
	 * annotations in lower levels of the annotation hierarchy.
	 * &lt;p&gt;Attributes from lower levels in the annotation hierarchy override
	 * attributes of the same name from higher levels, and
	 * {@link AliasFor @AliasFor} semantics are fully supported, both
	 * within a single annotation and within the annotation hierarchy.
	 * &lt;p&gt;In contrast to {@link #getAllAnnotationAttributes}, the search algorithm
	 * used by this method will stop searching the annotation hierarchy once the
	 * first annotation of the specified {@code annotationType} has been found.
	 * As a consequence, additional annotations of the specified
	 * {@code annotationType} will be ignored.
	 * &lt;p&gt;This method follows &lt;em&gt;find semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @param classValuesAsString whether to convert Class references into
	 * Strings or to preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into
	 * {@code AnnotationAttributes} maps or to preserve them as Annotation instances
	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found
	 * @since 4.2
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 */
	@Nullable
	public static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,
			Class&lt;? extends Annotation&gt; annotationType, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {

<span class="nc" id="L574">		MergedAnnotation&lt;?&gt; mergedAnnotation = findAnnotations(element)</span>
<span class="nc" id="L575">				.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());</span>
<span class="nc" id="L576">		return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);</span>
	}

	/**
	 * Find the first annotation of the specified {@code annotationName} within
	 * the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element} and
	 * merge that annotation's attributes with &lt;em&gt;matching&lt;/em&gt; attributes from
	 * annotations in lower levels of the annotation hierarchy.
	 * &lt;p&gt;Attributes from lower levels in the annotation hierarchy override
	 * attributes of the same name from higher levels, and
	 * {@link AliasFor @AliasFor} semantics are fully supported, both
	 * within a single annotation and within the annotation hierarchy.
	 * &lt;p&gt;In contrast to {@link #getAllAnnotationAttributes}, the search
	 * algorithm used by this method will stop searching the annotation
	 * hierarchy once the first annotation of the specified
	 * {@code annotationName} has been found. As a consequence, additional
	 * annotations of the specified {@code annotationName} will be ignored.
	 * &lt;p&gt;This method follows &lt;em&gt;find semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @param classValuesAsString whether to convert Class references into Strings or to
	 * preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into
	 * {@code AnnotationAttributes} maps or to preserve them as Annotation instances
	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found
	 * @since 4.2
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 */
	@Nullable
	public static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,
			String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {

<span class="fc" id="L610">		MergedAnnotation&lt;?&gt; mergedAnnotation = findAnnotations(element)</span>
<span class="fc" id="L611">				.get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());</span>
<span class="fc" id="L612">		return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);</span>
	}

	/**
	 * Find the first annotation of the specified {@code annotationType} within
	 * the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element},
	 * merge that annotation's attributes with &lt;em&gt;matching&lt;/em&gt; attributes from
	 * annotations in lower levels of the annotation hierarchy, and synthesize
	 * the result back into an annotation of the specified {@code annotationType}.
	 * &lt;p&gt;{@link AliasFor @AliasFor} semantics are fully supported, both
	 * within a single annotation and within the annotation hierarchy.
	 * &lt;p&gt;This method follows &lt;em&gt;find semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @return the merged, synthesized {@code Annotation}, or {@code null} if not found
	 * @since 4.2
	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)
	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)
	 */
	@Nullable
	public static &lt;A extends Annotation&gt; A findMergedAnnotation(AnnotatedElement element, Class&lt;A&gt; annotationType) {
		// Shortcut: directly present on the element, with no merging needed?
<span class="fc bfc" id="L636" title="All 2 branches covered.">		if (AnnotationFilter.PLAIN.matches(annotationType)) {</span>
<span class="fc" id="L637">			return element.getDeclaredAnnotation(annotationType);</span>
		}
		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {</span>
<span class="nc" id="L641">			return null;</span>
		}
		// Exhaustive retrieval of merged annotations...
<span class="fc" id="L644">		return findAnnotations(element)</span>
<span class="fc" id="L645">				.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())</span>
<span class="fc" id="L646">				.synthesize(MergedAnnotation::isPresent).orElse(null);</span>
	}

	/**
	 * Find &lt;strong&gt;all&lt;/strong&gt; annotations of the specified {@code annotationType}
	 * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * &lt;em&gt;matching&lt;/em&gt; attributes from annotations in lower levels of the annotation
	 * hierarchy and synthesize the results back into an annotation of the specified
	 * {@code annotationType}.
	 * &lt;p&gt;{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * &lt;p&gt;This method follows &lt;em&gt;find semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationType the annotation type to find (never {@code null})
	 * @return the set of all merged, synthesized {@code Annotations} found,
	 * or an empty set if none were found
	 * @since 4.3
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #getAllMergedAnnotations(AnnotatedElement, Class)
	 */
	public static &lt;A extends Annotation&gt; Set&lt;A&gt; findAllMergedAnnotations(AnnotatedElement element, Class&lt;A&gt; annotationType) {
<span class="fc" id="L669">		return findAnnotations(element).stream(annotationType)</span>
<span class="fc" id="L670">				.sorted(highAggregateIndexesFirst())</span>
<span class="fc" id="L671">				.collect(MergedAnnotationCollectors.toAnnotationSet());</span>
	}

	/**
	 * Find &lt;strong&gt;all&lt;/strong&gt; annotations of the specified {@code annotationTypes}
	 * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * &lt;em&gt;matching&lt;/em&gt; attributes from annotations in lower levels of the
	 * annotation hierarchy and synthesize the results back into an annotation
	 * of the corresponding {@code annotationType}.
	 * &lt;p&gt;{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * &lt;p&gt;This method follows &lt;em&gt;find semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationTypes the annotation types to find
	 * @return the set of all merged, synthesized {@code Annotations} found,
	 * or an empty set if none were found
	 * @since 5.1
	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)
	 */
	public static Set&lt;Annotation&gt; findAllMergedAnnotations(AnnotatedElement element, Set&lt;Class&lt;? extends Annotation&gt;&gt; annotationTypes) {
<span class="nc" id="L693">		return findAnnotations(element).stream()</span>
<span class="nc" id="L694">				.filter(MergedAnnotationPredicates.typeIn(annotationTypes))</span>
<span class="nc" id="L695">				.sorted(highAggregateIndexesFirst())</span>
<span class="nc" id="L696">				.collect(MergedAnnotationCollectors.toAnnotationSet());</span>
	}

	/**
	 * Find all &lt;em&gt;repeatable annotations&lt;/em&gt; of the specified {@code annotationType}
	 * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * &lt;em&gt;matching&lt;/em&gt; attributes from annotations in lower levels of the annotation
	 * hierarchy and synthesize the results back into an annotation of the specified
	 * {@code annotationType}.
	 * &lt;p&gt;The container type that holds the repeatable annotations will be looked up
	 * via {@link java.lang.annotation.Repeatable}.
	 * &lt;p&gt;{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * &lt;p&gt;This method follows &lt;em&gt;find semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationType the annotation type to find (never {@code null})
	 * @return the set of all merged repeatable {@code Annotations} found,
	 * or an empty set if none were found
	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}
	 * is {@code null}, or if the container type cannot be resolved
	 * @since 4.3
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)
	 * @see #findMergedRepeatableAnnotations(AnnotatedElement, Class, Class)
	 */
	public static &lt;A extends Annotation&gt; Set&lt;A&gt; findMergedRepeatableAnnotations(AnnotatedElement element,
			Class&lt;A&gt; annotationType) {

<span class="fc" id="L726">		return findMergedRepeatableAnnotations(element, annotationType, null);</span>
	}

	/**
	 * Find all &lt;em&gt;repeatable annotations&lt;/em&gt; of the specified {@code annotationType}
	 * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * &lt;em&gt;matching&lt;/em&gt; attributes from annotations in lower levels of the annotation
	 * hierarchy and synthesize the results back into an annotation of the specified
	 * {@code annotationType}.
	 * &lt;p&gt;{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * &lt;p&gt;This method follows &lt;em&gt;find semantics&lt;/em&gt; as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationType the annotation type to find (never {@code null})
	 * @param containerType the type of the container that holds the annotations;
	 * may be {@code null} if the container type should be looked up via
	 * {@link java.lang.annotation.Repeatable}
	 * @return the set of all merged repeatable {@code Annotations} found,
	 * or an empty set if none were found
	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}
	 * is {@code null}, or if the container type cannot be resolved
	 * @throws AnnotationConfigurationException if the supplied {@code containerType}
	 * is not a valid container annotation for the supplied {@code annotationType}
	 * @since 4.3
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)
	 */
	public static &lt;A extends Annotation&gt; Set&lt;A&gt; findMergedRepeatableAnnotations(AnnotatedElement element,
			Class&lt;A&gt; annotationType, @Nullable Class&lt;? extends Annotation&gt; containerType) {

<span class="fc" id="L758">		return findRepeatableAnnotations(element, containerType, annotationType)</span>
<span class="fc" id="L759">				.stream(annotationType)</span>
<span class="fc" id="L760">				.sorted(highAggregateIndexesFirst())</span>
<span class="fc" id="L761">				.collect(MergedAnnotationCollectors.toAnnotationSet());</span>
	}

	private static MergedAnnotations getAnnotations(AnnotatedElement element) {
<span class="fc" id="L765">		return MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS,</span>
<span class="fc" id="L766">				RepeatableContainers.none(), AnnotationFilter.PLAIN);</span>
	}

	private static MergedAnnotations getRepeatableAnnotations(AnnotatedElement element,
			@Nullable Class&lt;? extends Annotation&gt; containerType, Class&lt;? extends Annotation&gt; annotationType) {

<span class="fc" id="L772">		RepeatableContainers repeatableContainers = RepeatableContainers.of(annotationType, containerType);</span>
<span class="fc" id="L773">		return MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS,</span>
				repeatableContainers, AnnotationFilter.PLAIN);
	}

	private static MergedAnnotations findAnnotations(AnnotatedElement element) {
<span class="fc" id="L778">		return MergedAnnotations.from(element, SearchStrategy.EXHAUSTIVE,</span>
<span class="fc" id="L779">				RepeatableContainers.none(), AnnotationFilter.PLAIN);</span>
	}

	private static MergedAnnotations findRepeatableAnnotations(AnnotatedElement element,
			@Nullable Class&lt;? extends Annotation&gt; containerType, Class&lt;? extends Annotation&gt; annotationType) {

<span class="fc" id="L785">		RepeatableContainers repeatableContainers = RepeatableContainers.of(annotationType, containerType);</span>
<span class="fc" id="L786">		return MergedAnnotations.from(element, SearchStrategy.EXHAUSTIVE,</span>
				repeatableContainers, AnnotationFilter.PLAIN);
	}

	private static Object parentAndType(MergedAnnotation&lt;Annotation&gt; annotation) {
<span class="fc bfc" id="L791" title="All 2 branches covered.">		if (annotation.getParent() == null) {</span>
<span class="fc" id="L792">			return annotation.getType().getName();</span>
		}
<span class="fc" id="L794">		return annotation.getParent().getType().getName() + &quot;:&quot; + annotation.getParent().getType().getName();</span>
	}

	@Nullable
	private static MultiValueMap&lt;String, Object&gt; nullIfEmpty(MultiValueMap&lt;String, Object&gt; map) {
<span class="fc bfc" id="L799" title="All 2 branches covered.">		return (map.isEmpty() ? null : map);</span>
	}

	private static &lt;A extends Annotation&gt; Comparator&lt;MergedAnnotation&lt;A&gt;&gt; highAggregateIndexesFirst() {
<span class="fc" id="L803">		return Comparator.&lt;MergedAnnotation&lt;A&gt;&gt; comparingInt(</span>
<span class="fc" id="L804">				MergedAnnotation::getAggregateIndex).reversed();</span>
	}

	@Nullable
	private static AnnotationAttributes getAnnotationAttributes(MergedAnnotation&lt;?&gt; annotation,
			boolean classValuesAsString, boolean nestedAnnotationsAsMap) {

<span class="fc bfc" id="L811" title="All 2 branches covered.">		if (!annotation.isPresent()) {</span>
<span class="fc" id="L812">			return null;</span>
		}
<span class="fc" id="L814">		return annotation.asMap(mergedAnnotation -&gt; new AnnotationAttributes(mergedAnnotation.getType()),</span>
<span class="fc" id="L815">				MapValues.of(classValuesAsString, nestedAnnotationsAsMap));</span>
	}


	/**
	 * Adapted {@link AnnotatedElement} that hold specific annotations.
	 */
	private static class AnnotatedElementForAnnotations implements AnnotatedElement {

		private final Annotation[] annotations;

<span class="fc" id="L826">		AnnotatedElementForAnnotations(Annotation... annotations) {</span>
<span class="fc" id="L827">			this.annotations = annotations;</span>
<span class="fc" id="L828">		}</span>

		@Override
		@SuppressWarnings(&quot;unchecked&quot;)
		@Nullable
		public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="nc bnc" id="L834" title="All 2 branches missed.">			for (Annotation annotation : this.annotations) {</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">				if (annotation.annotationType() == annotationClass) {</span>
<span class="nc" id="L836">					return (T) annotation;</span>
				}
			}
<span class="nc" id="L839">			return null;</span>
		}

		@Override
		public Annotation[] getAnnotations() {
<span class="nc" id="L844">			return this.annotations.clone();</span>
		}

		@Override
		public Annotation[] getDeclaredAnnotations() {
<span class="fc" id="L849">			return this.annotations.clone();</span>
		}

	};

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>