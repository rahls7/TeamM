<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CodeFlow.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-expression</a> &gt; <a href="index.source.html" class="el_package">org.springframework.expression.spel</a> &gt; <span class="el_source">CodeFlow.java</span></div><h1>CodeFlow.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.expression.spel;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

import org.springframework.asm.ClassWriter;
import org.springframework.asm.MethodVisitor;
import org.springframework.asm.Opcodes;
import org.springframework.lang.Nullable;
import org.springframework.util.CollectionUtils;

/**
 * Manages the class being generated by the compilation process.
 *
 * &lt;p&gt;Records intermediate compilation state as the bytecode is generated.
 * Also includes various bytecode generation helper functions.
 *
 * @author Andy Clement
 * @author Juergen Hoeller
 * @since 4.1
 */
public class CodeFlow implements Opcodes {

	/**
	 * Name of the class being generated. Typically used when generating code
	 * that accesses freshly generated fields on the generated type.
	 */
	private final String className;

	/**
	 * The current class being generated.
	 */
	private final ClassWriter classWriter;

	/**
	 * Record the type of what is on top of the bytecode stack (i.e. the type of the
	 * output from the previous expression component). New scopes are used to evaluate
	 * sub-expressions like the expressions for the argument values in a method invocation
	 * expression.
	 */
	private final Deque&lt;List&lt;String&gt;&gt; compilationScopes;

	/**
	 * As SpEL ast nodes are called to generate code for the main evaluation method
	 * they can register to add a field to this class. Any registered FieldAdders
	 * will be called after the main evaluation function has finished being generated.
	 */
	@Nullable
	private List&lt;FieldAdder&gt; fieldAdders;

	/**
	 * As SpEL ast nodes are called to generate code for the main evaluation method
	 * they can register to add code to a static initializer in the class. Any
	 * registered ClinitAdders will be called after the main evaluation function
	 * has finished being generated.
	 */
	@Nullable
	private List&lt;ClinitAdder&gt; clinitAdders;

	/**
	 * When code generation requires holding a value in a class level field, this
	 * is used to track the next available field id (used as a name suffix).
	 */
<span class="fc" id="L84">	private int nextFieldId = 1;</span>

	/**
	 * When code generation requires an intermediate variable within a method,
	 * this method records the next available variable (variable 0 is 'this').
	 */
<span class="fc" id="L90">	private int nextFreeVariableId = 1;</span>


	/**
	 * Construct a new {@code CodeFlow} for the given class.
	 * @param className the name of the class
	 * @param classWriter the corresponding ASM {@code ClassWriter}
	 */
<span class="fc" id="L98">	public CodeFlow(String className, ClassWriter classWriter) {</span>
<span class="fc" id="L99">		this.className = className;</span>
<span class="fc" id="L100">		this.classWriter = classWriter;</span>
<span class="fc" id="L101">		this.compilationScopes = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L102">		this.compilationScopes.add(new ArrayList&lt;String&gt;());</span>
<span class="fc" id="L103">	}</span>


	/**
	 * Push the byte code to load the target (i.e. what was passed as the first argument
	 * to CompiledExpression.getValue(target, context))
	 * @param mv the visitor into which the load instruction should be inserted
	 */
	public void loadTarget(MethodVisitor mv) {
<span class="fc" id="L112">		mv.visitVarInsn(ALOAD, 1);</span>
<span class="fc" id="L113">	}</span>

	/**
	 * Push the bytecode to load the EvaluationContext (the second parameter passed to
	 * the compiled expression method).
	 * @param mv the visitor into which the load instruction should be inserted
	 * @since 4.3.4
	 */
	public void loadEvaluationContext(MethodVisitor mv) {
<span class="fc" id="L122">		mv.visitVarInsn(ALOAD, 2);</span>
<span class="fc" id="L123">	}</span>

	/**
	 * Record the descriptor for the most recently evaluated expression element.
	 * @param descriptor type descriptor for most recently evaluated element
	 */
	public void pushDescriptor(@Nullable String descriptor) {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">		if (descriptor != null) {</span>
<span class="fc" id="L131">			this.compilationScopes.element().add(descriptor);</span>
		}
<span class="fc" id="L133">	}</span>

	/**
	 * Enter a new compilation scope, usually due to nested expression evaluation. For
	 * example when the arguments for a method invocation expression are being evaluated,
	 * each argument will be evaluated in a new scope.
	 */
	public void enterCompilationScope() {
<span class="fc" id="L141">		this.compilationScopes.push(new ArrayList&lt;&gt;());</span>
<span class="fc" id="L142">	}</span>

	/**
	 * Exit a compilation scope, usually after a nested expression has been evaluated. For
	 * example after an argument for a method invocation has been evaluated this method
	 * returns us to the previous (outer) scope.
	 */
	public void exitCompilationScope() {
<span class="fc" id="L150">		this.compilationScopes.pop();</span>
<span class="fc" id="L151">	}</span>

	/**
	 * Return the descriptor for the item currently on top of the stack (in the current scope).
	 */
	@Nullable
	public String lastDescriptor() {
<span class="fc" id="L158">		return CollectionUtils.lastElement(this.compilationScopes.peek());</span>
	}

	/**
	 * If the codeflow shows the last expression evaluated to java.lang.Boolean then
	 * insert the necessary instructions to unbox that to a boolean primitive.
	 * @param mv the visitor into which new instructions should be inserted
	 */
	public void unboxBooleanIfNecessary(MethodVisitor mv) {
<span class="fc bfc" id="L167" title="All 2 branches covered.">		if (&quot;Ljava/lang/Boolean&quot;.equals(lastDescriptor())) {</span>
<span class="fc" id="L168">			mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Boolean&quot;, &quot;booleanValue&quot;, &quot;()Z&quot;, false);</span>
		}
<span class="fc" id="L170">	}</span>

	/**
	 * Called after the main expression evaluation method has been generated, this
	 * method will callback any registered FieldAdders or ClinitAdders to add any
	 * extra information to the class representing the compiled expression.
	 */
	public void finish() {
<span class="fc bfc" id="L178" title="All 2 branches covered.">		if (this.fieldAdders != null) {</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">			for (FieldAdder fieldAdder : this.fieldAdders) {</span>
<span class="fc" id="L180">				fieldAdder.generateField(this.classWriter, this);</span>
<span class="fc" id="L181">			}</span>
		}
<span class="fc bfc" id="L183" title="All 2 branches covered.">		if (this.clinitAdders != null) {</span>
<span class="fc" id="L184">			MethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);</span>
<span class="fc" id="L185">			mv.visitCode();</span>
<span class="fc" id="L186">			this.nextFreeVariableId = 0;  // to 0 because there is no 'this' in a clinit</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">			for (ClinitAdder clinitAdder : this.clinitAdders) {</span>
<span class="fc" id="L188">				clinitAdder.generateCode(mv, this);</span>
<span class="fc" id="L189">			}</span>
<span class="fc" id="L190">			mv.visitInsn(RETURN);</span>
<span class="fc" id="L191">			mv.visitMaxs(0,0);  // not supplied due to COMPUTE_MAXS</span>
<span class="fc" id="L192">			mv.visitEnd();</span>
		}
<span class="fc" id="L194">	}</span>

	/**
	 * Register a FieldAdder which will add a new field to the generated
	 * class to support the code produced by an ast nodes primary
	 * generateCode() method.
	 */
	public void registerNewField(FieldAdder fieldAdder) {
<span class="fc bfc" id="L202" title="All 2 branches covered.">		if (this.fieldAdders == null) {</span>
<span class="fc" id="L203">			this.fieldAdders = new ArrayList&lt;&gt;();</span>
		}
<span class="fc" id="L205">		this.fieldAdders.add(fieldAdder);</span>
<span class="fc" id="L206">	}</span>

	/**
	 * Register a ClinitAdder which will add code to the static
	 * initializer in the generated class to support the code
	 * produced by an ast nodes primary generateCode() method.
	 */
	public void registerNewClinit(ClinitAdder clinitAdder) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">		if (this.clinitAdders == null) {</span>
<span class="fc" id="L215">			this.clinitAdders = new ArrayList&lt;&gt;();</span>
		}
<span class="fc" id="L217">		this.clinitAdders.add(clinitAdder);</span>
<span class="fc" id="L218">	}</span>

	public int nextFieldId() {
<span class="fc" id="L221">		return this.nextFieldId++;</span>
	}

	public int nextFreeVariableId() {
<span class="nc" id="L225">		return this.nextFreeVariableId++;</span>
	}

	public String getClassName() {
<span class="fc" id="L229">		return this.className;</span>
	}


	/**
	 * Insert any necessary cast and value call to convert from a boxed type to a
	 * primitive value.
	 * @param mv the method visitor into which instructions should be inserted
	 * @param ch the primitive type desired as output
	 * @param stackDescriptor the descriptor of the type on top of the stack
	 */
	public static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">		if (stackDescriptor == null) {</span>
<span class="nc" id="L242">			return;</span>
		}
<span class="pc bpc" id="L244" title="7 of 9 branches missed.">		switch (ch) {</span>
			case 'Z':
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">				if (!stackDescriptor.equals(&quot;Ljava/lang/Boolean&quot;)) {</span>
<span class="nc" id="L247">					mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Boolean&quot;);</span>
				}
<span class="fc" id="L249">				mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Boolean&quot;, &quot;booleanValue&quot;, &quot;()Z&quot;, false);</span>
<span class="fc" id="L250">				break;</span>
			case 'B':
<span class="nc bnc" id="L252" title="All 2 branches missed.">				if (!stackDescriptor.equals(&quot;Ljava/lang/Byte&quot;)) {</span>
<span class="nc" id="L253">					mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Byte&quot;);</span>
				}
<span class="nc" id="L255">				mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Byte&quot;, &quot;byteValue&quot;, &quot;()B&quot;, false);</span>
<span class="nc" id="L256">				break;</span>
			case 'C':
<span class="nc bnc" id="L258" title="All 2 branches missed.">				if (!stackDescriptor.equals(&quot;Ljava/lang/Character&quot;)) {</span>
<span class="nc" id="L259">					mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Character&quot;);</span>
				}
<span class="nc" id="L261">				mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Character&quot;, &quot;charValue&quot;, &quot;()C&quot;, false);</span>
<span class="nc" id="L262">				break;</span>
			case 'D':
<span class="nc bnc" id="L264" title="All 2 branches missed.">				if (!stackDescriptor.equals(&quot;Ljava/lang/Double&quot;)) {</span>
<span class="nc" id="L265">					mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Double&quot;);</span>
				}
<span class="nc" id="L267">				mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Double&quot;, &quot;doubleValue&quot;, &quot;()D&quot;, false);</span>
<span class="nc" id="L268">				break;</span>
			case 'F':
<span class="nc bnc" id="L270" title="All 2 branches missed.">				if (!stackDescriptor.equals(&quot;Ljava/lang/Float&quot;)) {</span>
<span class="nc" id="L271">					mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Float&quot;);</span>
				}
<span class="nc" id="L273">				mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Float&quot;, &quot;floatValue&quot;, &quot;()F&quot;, false);</span>
<span class="nc" id="L274">				break;</span>
			case 'I':
<span class="fc bfc" id="L276" title="All 2 branches covered.">				if (!stackDescriptor.equals(&quot;Ljava/lang/Integer&quot;)) {</span>
<span class="fc" id="L277">					mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Integer&quot;);</span>
				}
<span class="fc" id="L279">				mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Integer&quot;, &quot;intValue&quot;, &quot;()I&quot;, false);</span>
<span class="fc" id="L280">				break;</span>
			case 'J':
<span class="nc bnc" id="L282" title="All 2 branches missed.">				if (!stackDescriptor.equals(&quot;Ljava/lang/Long&quot;)) {</span>
<span class="nc" id="L283">					mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Long&quot;);</span>
				}
<span class="nc" id="L285">				mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Long&quot;, &quot;longValue&quot;, &quot;()J&quot;, false);</span>
<span class="nc" id="L286">				break;</span>
			case 'S':
<span class="nc bnc" id="L288" title="All 2 branches missed.">				if (!stackDescriptor.equals(&quot;Ljava/lang/Short&quot;)) {</span>
<span class="nc" id="L289">					mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Short&quot;);</span>
				}
<span class="nc" id="L291">				mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Short&quot;, &quot;shortValue&quot;, &quot;()S&quot;, false);</span>
<span class="nc" id="L292">				break;</span>
			default:
<span class="nc" id="L294">				throw new IllegalArgumentException(&quot;Unboxing should not be attempted for descriptor '&quot; + ch + &quot;'&quot;);</span>
		}
<span class="fc" id="L296">	}</span>

	/**
	 * For numbers, use the appropriate method on the number to convert it to the primitive type requested.
	 * @param mv the method visitor into which instructions should be inserted
	 * @param targetDescriptor the primitive type desired as output
	 * @param stackDescriptor the descriptor of the type on top of the stack
	 */
	public static void insertUnboxNumberInsns(
			MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {

<span class="pc bpc" id="L307" title="1 of 2 branches missed.">		if (stackDescriptor == null) {</span>
<span class="nc" id="L308">			return;</span>
		}

<span class="pc bpc" id="L311" title="1 of 5 branches missed.">		switch (targetDescriptor) {</span>
			case 'D':
<span class="fc bfc" id="L313" title="All 2 branches covered.">				if (stackDescriptor.equals(&quot;Ljava/lang/Object&quot;)) {</span>
<span class="fc" id="L314">					mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Number&quot;);</span>
				}
<span class="fc" id="L316">				mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Number&quot;, &quot;doubleValue&quot;, &quot;()D&quot;, false);</span>
<span class="fc" id="L317">				break;</span>
			case 'F':
<span class="fc bfc" id="L319" title="All 2 branches covered.">				if (stackDescriptor.equals(&quot;Ljava/lang/Object&quot;)) {</span>
<span class="fc" id="L320">					mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Number&quot;);</span>
				}
<span class="fc" id="L322">				mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Number&quot;, &quot;floatValue&quot;, &quot;()F&quot;, false);</span>
<span class="fc" id="L323">				break;</span>
			case 'J':
<span class="fc bfc" id="L325" title="All 2 branches covered.">				if (stackDescriptor.equals(&quot;Ljava/lang/Object&quot;)) {</span>
<span class="fc" id="L326">					mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Number&quot;);</span>
				}
<span class="fc" id="L328">				mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Number&quot;, &quot;longValue&quot;, &quot;()J&quot;, false);</span>
<span class="fc" id="L329">				break;</span>
			case 'I':
<span class="fc bfc" id="L331" title="All 2 branches covered.">				if (stackDescriptor.equals(&quot;Ljava/lang/Object&quot;)) {</span>
<span class="fc" id="L332">					mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Number&quot;);</span>
				}
<span class="fc" id="L334">				mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Number&quot;, &quot;intValue&quot;, &quot;()I&quot;, false);</span>
<span class="fc" id="L335">				break;</span>
			// does not handle Z, B, C, S
			default:
<span class="nc" id="L338">				throw new IllegalArgumentException(&quot;Unboxing should not be attempted for descriptor '&quot; + targetDescriptor + &quot;'&quot;);</span>
		}
<span class="fc" id="L340">	}</span>

	/**
	 * Insert any necessary numeric conversion bytecodes based upon what is on the stack and the desired target type.
	 * @param mv the method visitor into which instructions should be placed
	 * @param targetDescriptor the (primitive) descriptor of the target type
	 * @param stackDescriptor the descriptor of the operand on top of the stack
	 */
	public static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">		if (CodeFlow.isPrimitive(stackDescriptor)) {</span>
<span class="fc" id="L350">			char stackTop = stackDescriptor.charAt(0);</span>
<span class="pc bpc" id="L351" title="1 of 8 branches missed.">			if (stackTop == 'I' || stackTop == 'B' || stackTop == 'S' || stackTop == 'C') {</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">				if (targetDescriptor == 'D') {</span>
<span class="fc" id="L353">					mv.visitInsn(I2D);</span>
				}
<span class="fc bfc" id="L355" title="All 2 branches covered.">				else if (targetDescriptor == 'F') {</span>
<span class="fc" id="L356">					mv.visitInsn(I2F);</span>
				}
<span class="fc bfc" id="L358" title="All 2 branches covered.">				else if (targetDescriptor == 'J') {</span>
<span class="fc" id="L359">					mv.visitInsn(I2L);</span>
				}
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">				else if (targetDescriptor == 'I') {</span>
					// nop
				}
				else {
<span class="nc" id="L365">					throw new IllegalStateException(&quot;Cannot get from &quot; + stackTop + &quot; to &quot; + targetDescriptor);</span>
				}
			}
<span class="fc bfc" id="L368" title="All 2 branches covered.">			else if (stackTop == 'J') {</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">				if (targetDescriptor == 'D') {</span>
<span class="fc" id="L370">					mv.visitInsn(L2D);</span>
				}
<span class="fc bfc" id="L372" title="All 2 branches covered.">				else if (targetDescriptor == 'F') {</span>
<span class="fc" id="L373">					mv.visitInsn(L2F);</span>
				}
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">				else if (targetDescriptor == 'J') {</span>
					// nop
				}
<span class="nc bnc" id="L378" title="All 2 branches missed.">				else if (targetDescriptor == 'I') {</span>
<span class="nc" id="L379">					mv.visitInsn(L2I);</span>
				}
				else {
<span class="nc" id="L382">					throw new IllegalStateException(&quot;Cannot get from &quot; + stackTop + &quot; to &quot; + targetDescriptor);</span>
				}
			}
<span class="fc bfc" id="L385" title="All 2 branches covered.">			else if (stackTop == 'F') {</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">				if (targetDescriptor == 'D') {</span>
<span class="fc" id="L387">					mv.visitInsn(F2D);</span>
				}
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">				else if (targetDescriptor == 'F') {</span>
					// nop
				}
<span class="nc bnc" id="L392" title="All 2 branches missed.">				else if (targetDescriptor == 'J') {</span>
<span class="nc" id="L393">					mv.visitInsn(F2L);</span>
				}
<span class="nc bnc" id="L395" title="All 2 branches missed.">				else if (targetDescriptor == 'I') {</span>
<span class="nc" id="L396">					mv.visitInsn(F2I);</span>
				}
				else {
<span class="nc" id="L399">					throw new IllegalStateException(&quot;Cannot get from &quot; + stackTop + &quot; to &quot; + targetDescriptor);</span>
				}
			}
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">			else if (stackTop == 'D') {</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">				if (targetDescriptor == 'D') {</span>
					// nop
				}
<span class="nc bnc" id="L406" title="All 2 branches missed.">				else if (targetDescriptor == 'F') {</span>
<span class="nc" id="L407">					mv.visitInsn(D2F);</span>
				}
<span class="nc bnc" id="L409" title="All 2 branches missed.">				else if (targetDescriptor == 'J') {</span>
<span class="nc" id="L410">					mv.visitInsn(D2L);</span>
				}
<span class="nc bnc" id="L412" title="All 2 branches missed.">				else if (targetDescriptor == 'I') {</span>
<span class="nc" id="L413">					mv.visitInsn(D2I);</span>
				}
				else {
<span class="nc" id="L416">					throw new IllegalStateException(&quot;Cannot get from &quot; + stackDescriptor + &quot; to &quot; + targetDescriptor);</span>
				}
			}
		}
<span class="fc" id="L420">	}</span>


	/**
	 * Create the JVM signature descriptor for a method. This consists of the descriptors
	 * for the method parameters surrounded with parentheses, followed by the
	 * descriptor for the return type. Note the descriptors here are JVM descriptors,
	 * unlike the other descriptor forms the compiler is using which do not include the
	 * trailing semicolon.
	 * @param method the method
	 * @return a String signature descriptor (e.g. &quot;(ILjava/lang/String;)V&quot;)
	 */
	public static String createSignatureDescriptor(Method method) {
<span class="fc" id="L433">		Class&lt;?&gt;[] params = method.getParameterTypes();</span>
<span class="fc" id="L434">		StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L435">		sb.append(&quot;(&quot;);</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">		for (Class&lt;?&gt; param : params) {</span>
<span class="fc" id="L437">			sb.append(toJvmDescriptor(param));</span>
		}
<span class="fc" id="L439">		sb.append(&quot;)&quot;);</span>
<span class="fc" id="L440">		sb.append(toJvmDescriptor(method.getReturnType()));</span>
<span class="fc" id="L441">		return sb.toString();</span>
	}

	/**
	 * Create the JVM signature descriptor for a constructor. This consists of the
	 * descriptors for the constructor parameters surrounded with parentheses, followed by
	 * the descriptor for the return type, which is always &quot;V&quot;. Note the
	 * descriptors here are JVM descriptors, unlike the other descriptor forms the
	 * compiler is using which do not include the trailing semicolon.
	 * @param ctor the constructor
	 * @return a String signature descriptor (e.g. &quot;(ILjava/lang/String;)V&quot;)
	 */
	public static String createSignatureDescriptor(Constructor&lt;?&gt; ctor) {
<span class="fc" id="L454">		Class&lt;?&gt;[] params = ctor.getParameterTypes();</span>
<span class="fc" id="L455">		StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L456">		sb.append(&quot;(&quot;);</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">		for (Class&lt;?&gt; param : params) {</span>
<span class="fc" id="L458">			sb.append(toJvmDescriptor(param));</span>
		}
<span class="fc" id="L460">		sb.append(&quot;)V&quot;);</span>
<span class="fc" id="L461">		return sb.toString();</span>
	}

	/**
	 * Determine the JVM descriptor for a specified class. Unlike the other descriptors
	 * used in the compilation process, this is the one the JVM wants, so this one
	 * includes any necessary trailing semicolon (e.g. Ljava/lang/String; rather than
	 * Ljava/lang/String)
	 * @param clazz a class
	 * @return the JVM descriptor for the class
	 */
	public static String toJvmDescriptor(Class&lt;?&gt; clazz) {
<span class="fc" id="L473">		StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">		if (clazz.isArray()) {</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">			while (clazz.isArray()) {</span>
<span class="fc" id="L476">				sb.append(&quot;[&quot;);</span>
<span class="fc" id="L477">				clazz = clazz.getComponentType();</span>
			}
		}
<span class="fc bfc" id="L480" title="All 2 branches covered.">		if (clazz.isPrimitive()) {</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">			if (clazz == Boolean.TYPE) {</span>
<span class="fc" id="L482">				sb.append('Z');</span>
			}
<span class="fc bfc" id="L484" title="All 2 branches covered.">			else if (clazz == Byte.TYPE) {</span>
<span class="fc" id="L485">				sb.append('B');</span>
			}
<span class="fc bfc" id="L487" title="All 2 branches covered.">			else if (clazz == Character.TYPE) {</span>
<span class="fc" id="L488">				sb.append('C');</span>
			}
<span class="fc bfc" id="L490" title="All 2 branches covered.">			else if (clazz == Double.TYPE) {</span>
<span class="fc" id="L491">				sb.append('D');</span>
			}
<span class="fc bfc" id="L493" title="All 2 branches covered.">			else if (clazz == Float.TYPE) {</span>
<span class="fc" id="L494">				sb.append('F');</span>
			}
<span class="fc bfc" id="L496" title="All 2 branches covered.">			else if (clazz == Integer.TYPE) {</span>
<span class="fc" id="L497">				sb.append('I');</span>
			}
<span class="fc bfc" id="L499" title="All 2 branches covered.">			else if (clazz == Long.TYPE) {</span>
<span class="fc" id="L500">				sb.append('J');</span>
			}
<span class="fc bfc" id="L502" title="All 2 branches covered.">			else if (clazz == Short.TYPE) {</span>
<span class="fc" id="L503">				sb.append('S');</span>
			}
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">			else if (clazz == Void.TYPE) {</span>
<span class="fc" id="L506">				sb.append('V');</span>
			}
		}
		else {
<span class="fc" id="L510">			sb.append(&quot;L&quot;);</span>
<span class="fc" id="L511">			sb.append(clazz.getName().replace('.', '/'));</span>
<span class="fc" id="L512">			sb.append(&quot;;&quot;);</span>
		}
<span class="fc" id="L514">		return sb.toString();</span>
	}

	/**
	 * Determine the descriptor for an object instance (or {@code null}).
	 * @param value an object (possibly {@code null})
	 * @return the type descriptor for the object
	 * (descriptor is &quot;Ljava/lang/Object&quot; for {@code null} value)
	 */
	public static String toDescriptorFromObject(@Nullable Object value) {
<span class="fc bfc" id="L524" title="All 2 branches covered.">		if (value == null) {</span>
<span class="fc" id="L525">			return &quot;Ljava/lang/Object&quot;;</span>
		}
		else {
<span class="fc" id="L528">			return toDescriptor(value.getClass());</span>
		}
	}

	/**
	 * Determine whether the descriptor is for a boolean primitive or boolean reference type.
	 * @param descriptor type descriptor
	 * @return {@code true} if the descriptor is boolean compatible
	 */
	public static boolean isBooleanCompatible(@Nullable String descriptor) {
<span class="pc bpc" id="L538" title="2 of 6 branches missed.">		return (descriptor != null &amp;&amp; (descriptor.equals(&quot;Z&quot;) || descriptor.equals(&quot;Ljava/lang/Boolean&quot;)));</span>
	}

	/**
	 * Determine whether the descriptor is for a primitive type.
	 * @param descriptor type descriptor
	 * @return {@code true} if a primitive type
	 */
	public static boolean isPrimitive(@Nullable String descriptor) {
<span class="fc bfc" id="L547" title="All 4 branches covered.">		return (descriptor != null &amp;&amp; descriptor.length() == 1);</span>
	}

	/**
	 * Determine whether the descriptor is for a primitive array (e.g. &quot;[[I&quot;).
	 * @param descriptor the descriptor for a possible primitive array
	 * @return {@code true} if the descriptor a primitive array
	 */
	public static boolean isPrimitiveArray(@Nullable String descriptor) {
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">		if (descriptor == null) {</span>
<span class="nc" id="L557">			return false;</span>
		}
<span class="fc" id="L559">		boolean primitive = true;</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">		for (int i = 0, max = descriptor.length(); i &lt; max; i++) {</span>
<span class="fc" id="L561">			char ch = descriptor.charAt(i);</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">			if (ch == '[') {</span>
<span class="fc" id="L563">				continue;</span>
			}
<span class="fc bfc" id="L565" title="All 2 branches covered.">			primitive = (ch != 'L');</span>
<span class="fc" id="L566">			break;</span>
		}
<span class="fc" id="L568">		return primitive;</span>
	}

	/**
	 * Determine whether boxing/unboxing can get from one type to the other.
	 * Assumes at least one of the types is in boxed form (i.e. single char descriptor).
	 * @return {@code true} if it is possible to get (via boxing) from one descriptor to the other
	 */
	public static boolean areBoxingCompatible(String desc1, String desc2) {
<span class="fc bfc" id="L577" title="All 2 branches covered.">		if (desc1.equals(desc2)) {</span>
<span class="fc" id="L578">			return true;</span>
		}
<span class="fc bfc" id="L580" title="All 2 branches covered.">		if (desc1.length() == 1) {</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">			if (desc1.equals(&quot;Z&quot;)) {</span>
<span class="fc" id="L582">				return desc2.equals(&quot;Ljava/lang/Boolean&quot;);</span>
			}
<span class="fc bfc" id="L584" title="All 2 branches covered.">			else if (desc1.equals(&quot;D&quot;)) {</span>
<span class="fc" id="L585">				return desc2.equals(&quot;Ljava/lang/Double&quot;);</span>
			}
<span class="fc bfc" id="L587" title="All 2 branches covered.">			else if (desc1.equals(&quot;F&quot;)) {</span>
<span class="fc" id="L588">				return desc2.equals(&quot;Ljava/lang/Float&quot;);</span>
			}
<span class="fc bfc" id="L590" title="All 2 branches covered.">			else if (desc1.equals(&quot;I&quot;)) {</span>
<span class="fc" id="L591">				return desc2.equals(&quot;Ljava/lang/Integer&quot;);</span>
			}
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">			else if (desc1.equals(&quot;J&quot;)) {</span>
<span class="fc" id="L594">				return desc2.equals(&quot;Ljava/lang/Long&quot;);</span>
			}
		}
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">		else if (desc2.length() == 1) {</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">			if (desc2.equals(&quot;Z&quot;)) {</span>
<span class="fc" id="L599">				return desc1.equals(&quot;Ljava/lang/Boolean&quot;);</span>
			}
<span class="fc bfc" id="L601" title="All 2 branches covered.">			else if (desc2.equals(&quot;D&quot;)) {</span>
<span class="fc" id="L602">				return desc1.equals(&quot;Ljava/lang/Double&quot;);</span>
			}
<span class="fc bfc" id="L604" title="All 2 branches covered.">			else if (desc2.equals(&quot;F&quot;)) {</span>
<span class="fc" id="L605">				return desc1.equals(&quot;Ljava/lang/Float&quot;);</span>
			}
<span class="fc bfc" id="L607" title="All 2 branches covered.">			else if (desc2.equals(&quot;I&quot;)) {</span>
<span class="fc" id="L608">				return desc1.equals(&quot;Ljava/lang/Integer&quot;);</span>
			}
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">			else if (desc2.equals(&quot;J&quot;)) {</span>
<span class="fc" id="L611">				return desc1.equals(&quot;Ljava/lang/Long&quot;);</span>
			}
		}
<span class="nc" id="L614">		return false;</span>
	}

	/**
	 * Determine if the supplied descriptor is for a supported number type or boolean. The
	 * compilation process only (currently) supports certain number types. These are
	 * double, float, long and int.
	 * @param descriptor the descriptor for a type
	 * @return {@code true} if the descriptor is for a supported numeric type or boolean
	 */
	public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">		if (descriptor == null) {</span>
<span class="nc" id="L626">			return false;</span>
		}
<span class="fc bfc" id="L628" title="All 2 branches covered.">		if (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {</span>
<span class="fc" id="L629">			return true;</span>
		}
<span class="fc bfc" id="L631" title="All 4 branches covered.">		return (&quot;Z&quot;.equals(descriptor) || descriptor.equals(&quot;Ljava/lang/Boolean&quot;));</span>
	}

	/**
	 * Determine if the supplied descriptor is for a supported number. The compilation
	 * process only (currently) supports certain number types. These are double, float,
	 * long and int.
	 * @param descriptor the descriptor for a type
	 * @return {@code true} if the descriptor is for a supported numeric type
	 */
	public static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">		if (descriptor == null) {</span>
<span class="nc" id="L643">			return false;</span>
		}
<span class="fc bfc" id="L645" title="All 2 branches covered.">		if (descriptor.length() == 1) {</span>
<span class="fc" id="L646">			return &quot;DFIJ&quot;.contains(descriptor);</span>
		}
<span class="fc bfc" id="L648" title="All 2 branches covered.">		if (descriptor.startsWith(&quot;Ljava/lang/&quot;)) {</span>
<span class="fc" id="L649">			String name = descriptor.substring(&quot;Ljava/lang/&quot;.length());</span>
<span class="fc bfc" id="L650" title="All 8 branches covered.">			if (name.equals(&quot;Double&quot;) || name.equals(&quot;Float&quot;) || name.equals(&quot;Integer&quot;) || name.equals(&quot;Long&quot;)) {</span>
<span class="fc" id="L651">				return true;</span>
			}
		}
<span class="fc" id="L654">		return false;</span>
	}

	/**
	 * Determine whether the given number is to be considered as an integer
	 * for the purposes of a numeric operation at the bytecode level.
	 * @param number the number to check
	 * @return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte}
	 */
	public static boolean isIntegerForNumericOp(Number number) {
<span class="pc bpc" id="L664" title="1 of 6 branches missed.">		return (number instanceof Integer || number instanceof Short || number instanceof Byte);</span>
	}

	/**
	 * Convert a type descriptor to the single character primitive descriptor.
	 * @param descriptor a descriptor for a type that should have a primitive representation
	 * @return the single character descriptor for a primitive input descriptor
	 */
	public static char toPrimitiveTargetDesc(String descriptor) {
<span class="fc bfc" id="L673" title="All 2 branches covered.">		if (descriptor.length() == 1) {</span>
<span class="fc" id="L674">			return descriptor.charAt(0);</span>
		}
<span class="fc bfc" id="L676" title="All 2 branches covered.">		else if (descriptor.equals(&quot;Ljava/lang/Boolean&quot;)) {</span>
<span class="fc" id="L677">			return 'Z';</span>
		}
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">		else if (descriptor.equals(&quot;Ljava/lang/Byte&quot;)) {</span>
<span class="nc" id="L680">			return 'B';</span>
		}
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">		else if (descriptor.equals(&quot;Ljava/lang/Character&quot;)) {</span>
<span class="nc" id="L683">			return 'C';</span>
		}
<span class="fc bfc" id="L685" title="All 2 branches covered.">		else if (descriptor.equals(&quot;Ljava/lang/Double&quot;)) {</span>
<span class="fc" id="L686">			return 'D';</span>
		}
<span class="fc bfc" id="L688" title="All 2 branches covered.">		else if (descriptor.equals(&quot;Ljava/lang/Float&quot;)) {</span>
<span class="fc" id="L689">			return 'F';</span>
		}
<span class="fc bfc" id="L691" title="All 2 branches covered.">		else if (descriptor.equals(&quot;Ljava/lang/Integer&quot;)) {</span>
<span class="fc" id="L692">			return 'I';</span>
		}
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">		else if (descriptor.equals(&quot;Ljava/lang/Long&quot;)) {</span>
<span class="fc" id="L695">			return 'J';</span>
		}
<span class="nc bnc" id="L697" title="All 2 branches missed.">		else if (descriptor.equals(&quot;Ljava/lang/Short&quot;)) {</span>
<span class="nc" id="L698">			return 'S';</span>
		}
		else {
<span class="nc" id="L701">			throw new IllegalStateException(&quot;No primitive for '&quot; + descriptor + &quot;'&quot;);</span>
		}
	}

	/**
	 * Insert the appropriate CHECKCAST instruction for the supplied descriptor.
	 * @param mv the target visitor into which the instruction should be inserted
	 * @param descriptor the descriptor of the type to cast to
	 */
	public static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {
<span class="pc bpc" id="L711" title="2 of 4 branches missed.">		if (descriptor != null &amp;&amp; descriptor.length() != 1) {</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">			if (descriptor.charAt(0) == '[') {</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">				if (isPrimitiveArray(descriptor)) {</span>
<span class="fc" id="L714">					mv.visitTypeInsn(CHECKCAST, descriptor);</span>
				}
				else {
<span class="fc" id="L717">					mv.visitTypeInsn(CHECKCAST, descriptor + &quot;;&quot;);</span>
				}
			}
			else {
<span class="fc bfc" id="L721" title="All 2 branches covered.">				if (!descriptor.equals(&quot;Ljava/lang/Object&quot;)) {</span>
					// This is chopping off the 'L' to leave us with &quot;java/lang/String&quot;
<span class="fc" id="L723">					mv.visitTypeInsn(CHECKCAST, descriptor.substring(1));</span>
				}
			}
		}
<span class="fc" id="L727">	}</span>

	/**
	 * Determine the appropriate boxing instruction for a specific type (if it needs
	 * boxing) and insert the instruction into the supplied visitor.
	 * @param mv the target visitor for the new instructions
	 * @param descriptor the descriptor of a type that may or may not need boxing
	 */
	public static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {
<span class="pc bpc" id="L736" title="1 of 4 branches missed.">		if (descriptor != null &amp;&amp; descriptor.length() == 1) {</span>
<span class="fc" id="L737">			insertBoxIfNecessary(mv, descriptor.charAt(0));</span>
		}
<span class="fc" id="L739">	}</span>

	/**
	 * Determine the appropriate boxing instruction for a specific type (if it needs
	 * boxing) and insert the instruction into the supplied visitor.
	 * @param mv the target visitor for the new instructions
	 * @param ch the descriptor of the type that might need boxing
	 */
	public static void insertBoxIfNecessary(MethodVisitor mv, char ch) {
<span class="pc bpc" id="L748" title="1 of 10 branches missed.">		switch (ch) {</span>
			case 'Z':
<span class="fc" id="L750">				mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Boolean&quot;, &quot;valueOf&quot;, &quot;(Z)Ljava/lang/Boolean;&quot;, false);</span>
<span class="fc" id="L751">				break;</span>
			case 'B':
<span class="fc" id="L753">				mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Byte&quot;, &quot;valueOf&quot;, &quot;(B)Ljava/lang/Byte;&quot;, false);</span>
<span class="fc" id="L754">				break;</span>
			case 'C':
<span class="fc" id="L756">				mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Character&quot;, &quot;valueOf&quot;, &quot;(C)Ljava/lang/Character;&quot;, false);</span>
<span class="fc" id="L757">				break;</span>
			case 'D':
<span class="fc" id="L759">				mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Double&quot;, &quot;valueOf&quot;, &quot;(D)Ljava/lang/Double;&quot;, false);</span>
<span class="fc" id="L760">				break;</span>
			case 'F':
<span class="fc" id="L762">				mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Float&quot;, &quot;valueOf&quot;, &quot;(F)Ljava/lang/Float;&quot;, false);</span>
<span class="fc" id="L763">				break;</span>
			case 'I':
<span class="fc" id="L765">				mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Integer&quot;, &quot;valueOf&quot;, &quot;(I)Ljava/lang/Integer;&quot;, false);</span>
<span class="fc" id="L766">				break;</span>
			case 'J':
<span class="fc" id="L768">				mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Long&quot;, &quot;valueOf&quot;, &quot;(J)Ljava/lang/Long;&quot;, false);</span>
<span class="fc" id="L769">				break;</span>
			case 'S':
<span class="fc" id="L771">				mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Short&quot;, &quot;valueOf&quot;, &quot;(S)Ljava/lang/Short;&quot;, false);</span>
<span class="fc" id="L772">				break;</span>
			case 'L':
			case 'V':
			case '[':
				// no box needed
<span class="fc" id="L777">				break;</span>
			default:
<span class="nc" id="L779">				throw new IllegalArgumentException(&quot;Boxing should not be attempted for descriptor '&quot; + ch + &quot;'&quot;);</span>
		}
<span class="fc" id="L781">	}</span>

	/**
	 * Deduce the descriptor for a type. Descriptors are like JVM type names but missing the
	 * trailing ';' so for Object the descriptor is &quot;Ljava/lang/Object&quot; for int it is &quot;I&quot;.
	 * @param type the type (may be primitive) for which to determine the descriptor
	 * @return the descriptor
	 */
	public static String toDescriptor(Class&lt;?&gt; type) {
<span class="fc" id="L790">		String name = type.getName();</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">		if (type.isPrimitive()) {</span>
<span class="pc bpc" id="L792" title="1 of 6 branches missed.">			switch (name.length()) {</span>
				case 3:
<span class="fc" id="L794">					return &quot;I&quot;;</span>
				case 4:
<span class="fc bfc" id="L796" title="All 2 branches covered.">					if (name.equals(&quot;byte&quot;)) {</span>
<span class="fc" id="L797">						return &quot;B&quot;;</span>
					}
<span class="fc bfc" id="L799" title="All 2 branches covered.">					else if (name.equals(&quot;char&quot;)) {</span>
<span class="fc" id="L800">						return &quot;C&quot;;</span>
					}
<span class="fc bfc" id="L802" title="All 2 branches covered.">					else if (name.equals(&quot;long&quot;)) {</span>
<span class="fc" id="L803">						return &quot;J&quot;;</span>
					}
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">					else if (name.equals(&quot;void&quot;)) {</span>
<span class="fc" id="L806">						return &quot;V&quot;;</span>
					}
					break;
				case 5:
<span class="fc bfc" id="L810" title="All 2 branches covered.">					if (name.equals(&quot;float&quot;)) {</span>
<span class="fc" id="L811">						return &quot;F&quot;;</span>
					}
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">					else if (name.equals(&quot;short&quot;)) {</span>
<span class="fc" id="L814">						return &quot;S&quot;;</span>
					}
					break;
				case 6:
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">					if (name.equals(&quot;double&quot;)) {</span>
<span class="fc" id="L819">						return &quot;D&quot;;</span>
					}
					break;
				case 7:
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">					if (name.equals(&quot;boolean&quot;)) {</span>
<span class="fc" id="L824">						return &quot;Z&quot;;</span>
					}
<span class="nc" id="L826">					break;</span>
			}
		}
		else {
<span class="fc bfc" id="L830" title="All 2 branches covered.">			if (name.charAt(0) != '[') {</span>
<span class="fc" id="L831">				return &quot;L&quot; + type.getName().replace('.', '/');</span>
			}
			else {
<span class="fc bfc" id="L834" title="All 2 branches covered.">				if (name.endsWith(&quot;;&quot;)) {</span>
<span class="fc" id="L835">					return name.substring(0, name.length() - 1).replace('.', '/');</span>
				}
				else {
<span class="fc" id="L838">					return name;  // array has primitive component type</span>
				}
			}
		}
<span class="nc" id="L842">		return &quot;&quot;;</span>
	}

	/**
	 * Create an array of descriptors representing the parameter types for the supplied
	 * method. Returns a zero sized array if there are no parameters.
	 * @param method a Method
	 * @return a String array of descriptors, one entry for each method parameter
	 */
	public static String[] toParamDescriptors(Method method) {
<span class="nc" id="L852">		return toDescriptors(method.getParameterTypes());</span>
	}

	/**
	 * Create an array of descriptors representing the parameter types for the supplied
	 * constructor. Returns a zero sized array if there are no parameters.
	 * @param ctor a Constructor
	 * @return a String array of descriptors, one entry for each constructor parameter
	 */
	public static String[] toParamDescriptors(Constructor&lt;?&gt; ctor) {
<span class="nc" id="L862">		return toDescriptors(ctor.getParameterTypes());</span>
	}

	/**
	 * Create an array of descriptors from an array of classes.
	 * @param types the input array of classes
	 * @return an array of descriptors
	 */
	public static String[] toDescriptors(Class&lt;?&gt;[] types) {
<span class="fc" id="L871">		int typesCount = types.length;</span>
<span class="fc" id="L872">		String[] descriptors = new String[typesCount];</span>
<span class="fc bfc" id="L873" title="All 2 branches covered.">		for (int p = 0; p &lt; typesCount; p++) {</span>
<span class="fc" id="L874">			descriptors[p] = toDescriptor(types[p]);</span>
		}
<span class="fc" id="L876">		return descriptors;</span>
	}

	/**
	 * Create the optimal instruction for loading a number on the stack.
	 * @param mv where to insert the bytecode
	 * @param value the value to be loaded
	 */
	public static void insertOptimalLoad(MethodVisitor mv, int value) {
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">		if (value &lt; 6) {</span>
<span class="fc" id="L886">			mv.visitInsn(ICONST_0+value);</span>
		}
<span class="nc bnc" id="L888" title="All 2 branches missed.">		else if (value &lt; Byte.MAX_VALUE) {</span>
<span class="nc" id="L889">			mv.visitIntInsn(BIPUSH, value);</span>
		}
<span class="nc bnc" id="L891" title="All 2 branches missed.">		else if (value &lt; Short.MAX_VALUE) {</span>
<span class="nc" id="L892">			mv.visitIntInsn(SIPUSH, value);</span>
		}
		else {
<span class="nc" id="L895">			mv.visitLdcInsn(value);</span>
		}
<span class="fc" id="L897">	}</span>

	/**
	 * Produce appropriate bytecode to store a stack item in an array. The
	 * instruction to use varies depending on whether the type
	 * is a primitive or reference type.
	 * @param mv where to insert the bytecode
	 * @param arrayElementType the type of the array elements
	 */
	public static void insertArrayStore(MethodVisitor mv, String arrayElementType) {
<span class="fc bfc" id="L907" title="All 2 branches covered.">		if (arrayElementType.length()==1) {</span>
<span class="pc bpc" id="L908" title="1 of 9 branches missed.">			switch (arrayElementType.charAt(0)) {</span>
				case 'I':
<span class="fc" id="L910">					mv.visitInsn(IASTORE);</span>
<span class="fc" id="L911">					break;</span>
				case 'J':
<span class="fc" id="L913">					mv.visitInsn(LASTORE);</span>
<span class="fc" id="L914">					break;</span>
				case 'F':
<span class="fc" id="L916">					mv.visitInsn(FASTORE);</span>
<span class="fc" id="L917">					break;</span>
				case 'D':
<span class="fc" id="L919">					mv.visitInsn(DASTORE);</span>
<span class="fc" id="L920">					break;</span>
				case 'B':
<span class="fc" id="L922">					mv.visitInsn(BASTORE);</span>
<span class="fc" id="L923">					break;</span>
				case 'C':
<span class="fc" id="L925">					mv.visitInsn(CASTORE);</span>
<span class="fc" id="L926">					break;</span>
				case 'S':
<span class="fc" id="L928">					mv.visitInsn(SASTORE);</span>
<span class="fc" id="L929">					break;</span>
				case 'Z':
<span class="fc" id="L931">					mv.visitInsn(BASTORE);</span>
<span class="fc" id="L932">					break;</span>
				default:
<span class="nc" id="L934">					throw new IllegalArgumentException(</span>
<span class="nc" id="L935">							&quot;Unexpected arraytype &quot; + arrayElementType.charAt(0));</span>
			}
		}
		else {
<span class="fc" id="L939">			mv.visitInsn(AASTORE);</span>
		}
<span class="fc" id="L941">	}</span>

	/**
	 * Determine the appropriate T tag to use for the NEWARRAY bytecode.
	 * @param arraytype the array primitive component type
	 * @return the T tag to use for NEWARRAY
	 */
	public static int arrayCodeFor(String arraytype) {
<span class="pc bpc" id="L949" title="1 of 9 branches missed.">		switch (arraytype.charAt(0)) {</span>
<span class="fc" id="L950">			case 'I': return T_INT;</span>
<span class="fc" id="L951">			case 'J': return T_LONG;</span>
<span class="fc" id="L952">			case 'F': return T_FLOAT;</span>
<span class="fc" id="L953">			case 'D': return T_DOUBLE;</span>
<span class="fc" id="L954">			case 'B': return T_BYTE;</span>
<span class="fc" id="L955">			case 'C': return T_CHAR;</span>
<span class="fc" id="L956">			case 'S': return T_SHORT;</span>
<span class="fc" id="L957">			case 'Z': return T_BOOLEAN;</span>
			default:
<span class="nc" id="L959">				throw new IllegalArgumentException(&quot;Unexpected arraytype &quot; + arraytype.charAt(0));</span>
		}
	}

	/**
	 * Return if the supplied array type has a core component reference type.
	 */
	public static boolean isReferenceTypeArray(String arraytype) {
<span class="fc" id="L967">		int length = arraytype.length();</span>
<span class="pc bpc" id="L968" title="1 of 2 branches missed.">		for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L969">			char ch = arraytype.charAt(i);</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">			if (ch == '[') {</span>
<span class="fc" id="L971">				continue;</span>
			}
<span class="fc bfc" id="L973" title="All 2 branches covered.">			return (ch == 'L');</span>
		}
<span class="nc" id="L975">		return false;</span>
	}

	/**
	 * Produce the correct bytecode to build an array. The opcode to use and the
	 * signature to pass along with the opcode can vary depending on the signature
	 * of the array type.
	 * @param mv the methodvisitor into which code should be inserted
	 * @param size the size of the array
	 * @param arraytype the type of the array
	 */
	public static void insertNewArrayCode(MethodVisitor mv, int size, String arraytype) {
<span class="fc" id="L987">		insertOptimalLoad(mv, size);</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">		if (arraytype.length() == 1) {</span>
<span class="fc" id="L989">			mv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arraytype));</span>
		}
		else {
<span class="fc bfc" id="L992" title="All 2 branches covered.">			if (arraytype.charAt(0) == '[') {</span>
				// Handling the nested array case here.
				// If vararg is [[I then we want [I and not [I;
<span class="fc bfc" id="L995" title="All 2 branches covered.">				if (CodeFlow.isReferenceTypeArray(arraytype)) {</span>
<span class="fc" id="L996">					mv.visitTypeInsn(ANEWARRAY, arraytype + &quot;;&quot;);</span>
				}
				else {
<span class="fc" id="L999">					mv.visitTypeInsn(ANEWARRAY, arraytype);</span>
				}
			}
			else {
<span class="fc" id="L1003">				mv.visitTypeInsn(ANEWARRAY, arraytype.substring(1));</span>
			}
		}
<span class="fc" id="L1006">	}</span>

	/**
	 * For use in mathematical operators, handles converting from a (possibly boxed)
	 * number on the stack to a primitive numeric type.
	 * &lt;p&gt;For example, from a Integer to a double, just need to call 'Number.doubleValue()'
	 * but from an int to a double, need to use the bytecode 'i2d'.
	 * @param mv the method visitor when instructions should be appended
	 * @param stackDescriptor a descriptor of the operand on the stack
	 * @param targetDescriptor a primitive type descriptor
	 */
	public static void insertNumericUnboxOrPrimitiveTypeCoercion(
			MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {

<span class="fc bfc" id="L1020" title="All 2 branches covered.">		if (!CodeFlow.isPrimitive(stackDescriptor)) {</span>
<span class="fc" id="L1021">			CodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor);</span>
		}
		else {
<span class="fc" id="L1024">			CodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor);</span>
		}
<span class="fc" id="L1026">	}</span>

	public static String toBoxedDescriptor(String primitiveDescriptor) {
<span class="pc bpc" id="L1029" title="3 of 9 branches missed.">		switch (primitiveDescriptor.charAt(0)) {</span>
<span class="fc" id="L1030">			case 'I': return &quot;Ljava/lang/Integer&quot;;</span>
<span class="fc" id="L1031">			case 'J': return &quot;Ljava/lang/Long&quot;;</span>
<span class="fc" id="L1032">			case 'F': return &quot;Ljava/lang/Float&quot;;</span>
<span class="fc" id="L1033">			case 'D': return &quot;Ljava/lang/Double&quot;;</span>
<span class="nc" id="L1034">			case 'B': return &quot;Ljava/lang/Byte&quot;;</span>
<span class="nc" id="L1035">			case 'C': return &quot;Ljava/lang/Character&quot;;</span>
<span class="fc" id="L1036">			case 'S': return &quot;Ljava/lang/Short&quot;;</span>
<span class="fc" id="L1037">			case 'Z': return &quot;Ljava/lang/Boolean&quot;;</span>
			default:
<span class="nc" id="L1039">				throw new IllegalArgumentException(&quot;Unexpected non primitive descriptor &quot; + primitiveDescriptor);</span>
		}
	}


	/**
	 * Interface used to generate fields.
	 */
	@FunctionalInterface
	public interface FieldAdder {

		void generateField(ClassWriter cw, CodeFlow codeflow);
	}


	/**
	 * Interface used to generate {@code clinit} static initializer blocks.
	 */
	@FunctionalInterface
	public interface ClinitAdder {

		void generateCode(MethodVisitor mv, CodeFlow codeflow);
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>