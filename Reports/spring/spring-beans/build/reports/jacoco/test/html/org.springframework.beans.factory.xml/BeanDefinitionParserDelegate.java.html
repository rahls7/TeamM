<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeanDefinitionParserDelegate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-beans</a> &gt; <a href="index.source.html" class="el_package">org.springframework.beans.factory.xml</a> &gt; <span class="el_source">BeanDefinitionParserDelegate.java</span></div><h1>BeanDefinitionParserDelegate.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.beans.factory.xml;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import org.springframework.beans.BeanMetadataAttribute;
import org.springframework.beans.BeanMetadataAttributeAccessor;
import org.springframework.beans.PropertyValue;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanDefinitionHolder;
import org.springframework.beans.factory.config.ConstructorArgumentValues;
import org.springframework.beans.factory.config.RuntimeBeanNameReference;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.config.TypedStringValue;
import org.springframework.beans.factory.parsing.BeanEntry;
import org.springframework.beans.factory.parsing.ConstructorArgumentEntry;
import org.springframework.beans.factory.parsing.ParseState;
import org.springframework.beans.factory.parsing.PropertyEntry;
import org.springframework.beans.factory.parsing.QualifierEntry;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.AutowireCandidateQualifier;
import org.springframework.beans.factory.support.BeanDefinitionDefaults;
import org.springframework.beans.factory.support.BeanDefinitionReaderUtils;
import org.springframework.beans.factory.support.LookupOverride;
import org.springframework.beans.factory.support.ManagedArray;
import org.springframework.beans.factory.support.ManagedList;
import org.springframework.beans.factory.support.ManagedMap;
import org.springframework.beans.factory.support.ManagedProperties;
import org.springframework.beans.factory.support.ManagedSet;
import org.springframework.beans.factory.support.MethodOverrides;
import org.springframework.beans.factory.support.ReplaceOverride;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.CollectionUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.util.PatternMatchUtils;
import org.springframework.util.StringUtils;
import org.springframework.util.xml.DomUtils;

/**
 * Stateful delegate class used to parse XML bean definitions.
 * Intended for use by both the main parser and any extension
 * {@link BeanDefinitionParser BeanDefinitionParsers} or
 * {@link BeanDefinitionDecorator BeanDefinitionDecorators}.
 *
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @author Rod Johnson
 * @author Mark Fisher
 * @author Gary Russell
 * @since 2.0
 * @see ParserContext
 * @see DefaultBeanDefinitionDocumentReader
 */
public class BeanDefinitionParserDelegate {

	public static final String BEANS_NAMESPACE_URI = &quot;http://www.springframework.org/schema/beans&quot;;

	public static final String MULTI_VALUE_ATTRIBUTE_DELIMITERS = &quot;,; &quot;;

	/**
	 * Value of a T/F attribute that represents true.
	 * Anything else represents false. Case seNsItive.
	 */
	public static final String TRUE_VALUE = &quot;true&quot;;

	public static final String FALSE_VALUE = &quot;false&quot;;

	public static final String DEFAULT_VALUE = &quot;default&quot;;

	public static final String DESCRIPTION_ELEMENT = &quot;description&quot;;

	public static final String AUTOWIRE_NO_VALUE = &quot;no&quot;;

	public static final String AUTOWIRE_BY_NAME_VALUE = &quot;byName&quot;;

	public static final String AUTOWIRE_BY_TYPE_VALUE = &quot;byType&quot;;

	public static final String AUTOWIRE_CONSTRUCTOR_VALUE = &quot;constructor&quot;;

	public static final String AUTOWIRE_AUTODETECT_VALUE = &quot;autodetect&quot;;

	public static final String NAME_ATTRIBUTE = &quot;name&quot;;

	public static final String BEAN_ELEMENT = &quot;bean&quot;;

	public static final String META_ELEMENT = &quot;meta&quot;;

	public static final String ID_ATTRIBUTE = &quot;id&quot;;

	public static final String PARENT_ATTRIBUTE = &quot;parent&quot;;

	public static final String CLASS_ATTRIBUTE = &quot;class&quot;;

	public static final String ABSTRACT_ATTRIBUTE = &quot;abstract&quot;;

	public static final String SCOPE_ATTRIBUTE = &quot;scope&quot;;

	private static final String SINGLETON_ATTRIBUTE = &quot;singleton&quot;;

	public static final String LAZY_INIT_ATTRIBUTE = &quot;lazy-init&quot;;

	public static final String AUTOWIRE_ATTRIBUTE = &quot;autowire&quot;;

	public static final String AUTOWIRE_CANDIDATE_ATTRIBUTE = &quot;autowire-candidate&quot;;

	public static final String PRIMARY_ATTRIBUTE = &quot;primary&quot;;

	public static final String DEPENDS_ON_ATTRIBUTE = &quot;depends-on&quot;;

	public static final String INIT_METHOD_ATTRIBUTE = &quot;init-method&quot;;

	public static final String DESTROY_METHOD_ATTRIBUTE = &quot;destroy-method&quot;;

	public static final String FACTORY_METHOD_ATTRIBUTE = &quot;factory-method&quot;;

	public static final String FACTORY_BEAN_ATTRIBUTE = &quot;factory-bean&quot;;

	public static final String CONSTRUCTOR_ARG_ELEMENT = &quot;constructor-arg&quot;;

	public static final String INDEX_ATTRIBUTE = &quot;index&quot;;

	public static final String TYPE_ATTRIBUTE = &quot;type&quot;;

	public static final String VALUE_TYPE_ATTRIBUTE = &quot;value-type&quot;;

	public static final String KEY_TYPE_ATTRIBUTE = &quot;key-type&quot;;

	public static final String PROPERTY_ELEMENT = &quot;property&quot;;

	public static final String REF_ATTRIBUTE = &quot;ref&quot;;

	public static final String VALUE_ATTRIBUTE = &quot;value&quot;;

	public static final String LOOKUP_METHOD_ELEMENT = &quot;lookup-method&quot;;

	public static final String REPLACED_METHOD_ELEMENT = &quot;replaced-method&quot;;

	public static final String REPLACER_ATTRIBUTE = &quot;replacer&quot;;

	public static final String ARG_TYPE_ELEMENT = &quot;arg-type&quot;;

	public static final String ARG_TYPE_MATCH_ATTRIBUTE = &quot;match&quot;;

	public static final String REF_ELEMENT = &quot;ref&quot;;

	public static final String IDREF_ELEMENT = &quot;idref&quot;;

	public static final String BEAN_REF_ATTRIBUTE = &quot;bean&quot;;

	public static final String PARENT_REF_ATTRIBUTE = &quot;parent&quot;;

	public static final String VALUE_ELEMENT = &quot;value&quot;;

	public static final String NULL_ELEMENT = &quot;null&quot;;

	public static final String ARRAY_ELEMENT = &quot;array&quot;;

	public static final String LIST_ELEMENT = &quot;list&quot;;

	public static final String SET_ELEMENT = &quot;set&quot;;

	public static final String MAP_ELEMENT = &quot;map&quot;;

	public static final String ENTRY_ELEMENT = &quot;entry&quot;;

	public static final String KEY_ELEMENT = &quot;key&quot;;

	public static final String KEY_ATTRIBUTE = &quot;key&quot;;

	public static final String KEY_REF_ATTRIBUTE = &quot;key-ref&quot;;

	public static final String VALUE_REF_ATTRIBUTE = &quot;value-ref&quot;;

	public static final String PROPS_ELEMENT = &quot;props&quot;;

	public static final String PROP_ELEMENT = &quot;prop&quot;;

	public static final String MERGE_ATTRIBUTE = &quot;merge&quot;;

	public static final String QUALIFIER_ELEMENT = &quot;qualifier&quot;;

	public static final String QUALIFIER_ATTRIBUTE_ELEMENT = &quot;attribute&quot;;

	public static final String DEFAULT_LAZY_INIT_ATTRIBUTE = &quot;default-lazy-init&quot;;

	public static final String DEFAULT_MERGE_ATTRIBUTE = &quot;default-merge&quot;;

	public static final String DEFAULT_AUTOWIRE_ATTRIBUTE = &quot;default-autowire&quot;;

	public static final String DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE = &quot;default-autowire-candidates&quot;;

	public static final String DEFAULT_INIT_METHOD_ATTRIBUTE = &quot;default-init-method&quot;;

	public static final String DEFAULT_DESTROY_METHOD_ATTRIBUTE = &quot;default-destroy-method&quot;;


<span class="fc" id="L228">	protected final Log logger = LogFactory.getLog(getClass());</span>

	private final XmlReaderContext readerContext;

<span class="fc" id="L232">	private final DocumentDefaultsDefinition defaults = new DocumentDefaultsDefinition();</span>

<span class="fc" id="L234">	private final ParseState parseState = new ParseState();</span>

	/**
	 * Stores all used bean names so we can enforce uniqueness on a per
	 * beans-element basis. Duplicate bean ids/names may not exist within the
	 * same level of beans element nesting, but may be duplicated across levels.
	 */
<span class="fc" id="L241">	private final Set&lt;String&gt; usedNames = new HashSet&lt;&gt;();</span>


	/**
	 * Create a new BeanDefinitionParserDelegate associated with the supplied
	 * {@link XmlReaderContext}.
	 */
<span class="fc" id="L248">	public BeanDefinitionParserDelegate(XmlReaderContext readerContext) {</span>
<span class="fc" id="L249">		Assert.notNull(readerContext, &quot;XmlReaderContext must not be null&quot;);</span>
<span class="fc" id="L250">		this.readerContext = readerContext;</span>
<span class="fc" id="L251">	}</span>


	/**
	 * Get the {@link XmlReaderContext} associated with this helper instance.
	 */
	public final XmlReaderContext getReaderContext() {
<span class="nc" id="L258">		return this.readerContext;</span>
	}

	/**
	 * Invoke the {@link org.springframework.beans.factory.parsing.SourceExtractor}
	 * to pull the source metadata from the supplied {@link Element}.
	 */
	@Nullable
	protected Object extractSource(Element ele) {
<span class="fc" id="L267">		return this.readerContext.extractSource(ele);</span>
	}

	/**
	 * Report an error with the given message for the given source element.
	 */
	protected void error(String message, Node source) {
<span class="nc" id="L274">		this.readerContext.error(message, source, this.parseState.snapshot());</span>
<span class="nc" id="L275">	}</span>

	/**
	 * Report an error with the given message for the given source element.
	 */
	protected void error(String message, Element source) {
<span class="fc" id="L281">		this.readerContext.error(message, source, this.parseState.snapshot());</span>
<span class="fc" id="L282">	}</span>

	/**
	 * Report an error with the given message for the given source element.
	 */
	protected void error(String message, Element source, Throwable cause) {
<span class="nc" id="L288">		this.readerContext.error(message, source, this.parseState.snapshot(), cause);</span>
<span class="nc" id="L289">	}</span>


	/**
	 * Initialize the default settings assuming a {@code null} parent delegate.
	 */
	public void initDefaults(Element root) {
<span class="nc" id="L296">		initDefaults(root, null);</span>
<span class="nc" id="L297">	}</span>

	/**
	 * Initialize the default lazy-init, autowire, dependency check settings,
	 * init-method, destroy-method and merge settings. Support nested 'beans'
	 * element use cases by falling back to the given parent in case the
	 * defaults are not explicitly set locally.
	 * @see #populateDefaults(DocumentDefaultsDefinition, DocumentDefaultsDefinition, org.w3c.dom.Element)
	 * @see #getDefaults()
	 */
	public void initDefaults(Element root, @Nullable BeanDefinitionParserDelegate parent) {
<span class="fc bfc" id="L308" title="All 2 branches covered.">		populateDefaults(this.defaults, (parent != null ? parent.defaults : null), root);</span>
<span class="fc" id="L309">		this.readerContext.fireDefaultsRegistered(this.defaults);</span>
<span class="fc" id="L310">	}</span>

	/**
	 * Populate the given DocumentDefaultsDefinition instance with the default lazy-init,
	 * autowire, dependency check settings, init-method, destroy-method and merge settings.
	 * Support nested 'beans' element use cases by falling back to {@code parentDefaults}
	 * in case the defaults are not explicitly set locally.
	 * @param defaults the defaults to populate
	 * @param parentDefaults the parent BeanDefinitionParserDelegate (if any) defaults to fall back to
	 * @param root the root element of the current bean definition document (or nested beans element)
	 */
	protected void populateDefaults(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root) {
<span class="fc" id="L322">		String lazyInit = root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">		if (isDefaultValue(lazyInit)) {</span>
			// Potentially inherited from outer &lt;beans&gt; sections, otherwise falling back to false.
<span class="fc bfc" id="L325" title="All 2 branches covered.">			lazyInit = (parentDefaults != null ? parentDefaults.getLazyInit() : FALSE_VALUE);</span>
		}
<span class="fc" id="L327">		defaults.setLazyInit(lazyInit);</span>

<span class="fc" id="L329">		String merge = root.getAttribute(DEFAULT_MERGE_ATTRIBUTE);</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">		if (isDefaultValue(merge)) {</span>
			// Potentially inherited from outer &lt;beans&gt; sections, otherwise falling back to false.
<span class="fc bfc" id="L332" title="All 2 branches covered.">			merge = (parentDefaults != null ? parentDefaults.getMerge() : FALSE_VALUE);</span>
		}
<span class="fc" id="L334">		defaults.setMerge(merge);</span>

<span class="fc" id="L336">		String autowire = root.getAttribute(DEFAULT_AUTOWIRE_ATTRIBUTE);</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">		if (isDefaultValue(autowire)) {</span>
			// Potentially inherited from outer &lt;beans&gt; sections, otherwise falling back to 'no'.
<span class="fc bfc" id="L339" title="All 2 branches covered.">			autowire = (parentDefaults != null ? parentDefaults.getAutowire() : AUTOWIRE_NO_VALUE);</span>
		}
<span class="fc" id="L341">		defaults.setAutowire(autowire);</span>

<span class="fc bfc" id="L343" title="All 2 branches covered.">		if (root.hasAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE)) {</span>
<span class="fc" id="L344">			defaults.setAutowireCandidates(root.getAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE));</span>
		}
<span class="fc bfc" id="L346" title="All 2 branches covered.">		else if (parentDefaults != null) {</span>
<span class="fc" id="L347">			defaults.setAutowireCandidates(parentDefaults.getAutowireCandidates());</span>
		}

<span class="fc bfc" id="L350" title="All 2 branches covered.">		if (root.hasAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE)) {</span>
<span class="fc" id="L351">			defaults.setInitMethod(root.getAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE));</span>
		}
<span class="fc bfc" id="L353" title="All 2 branches covered.">		else if (parentDefaults != null) {</span>
<span class="fc" id="L354">			defaults.setInitMethod(parentDefaults.getInitMethod());</span>
		}

<span class="fc bfc" id="L357" title="All 2 branches covered.">		if (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) {</span>
<span class="fc" id="L358">			defaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));</span>
		}
<span class="fc bfc" id="L360" title="All 2 branches covered.">		else if (parentDefaults != null) {</span>
<span class="fc" id="L361">			defaults.setDestroyMethod(parentDefaults.getDestroyMethod());</span>
		}

<span class="fc" id="L364">		defaults.setSource(this.readerContext.extractSource(root));</span>
<span class="fc" id="L365">	}</span>

	/**
	 * Return the defaults definition object.
	 */
	public DocumentDefaultsDefinition getDefaults() {
<span class="fc" id="L371">		return this.defaults;</span>
	}

	/**
	 * Return the default settings for bean definitions as indicated within
	 * the attributes of the top-level {@code &lt;beans/&gt;} element.
	 */
	public BeanDefinitionDefaults getBeanDefinitionDefaults() {
<span class="nc" id="L379">		BeanDefinitionDefaults bdd = new BeanDefinitionDefaults();</span>
<span class="nc" id="L380">		bdd.setLazyInit(&quot;TRUE&quot;.equalsIgnoreCase(this.defaults.getLazyInit()));</span>
<span class="nc" id="L381">		bdd.setAutowireMode(getAutowireMode(DEFAULT_VALUE));</span>
<span class="nc" id="L382">		bdd.setInitMethodName(this.defaults.getInitMethod());</span>
<span class="nc" id="L383">		bdd.setDestroyMethodName(this.defaults.getDestroyMethod());</span>
<span class="nc" id="L384">		return bdd;</span>
	}

	/**
	 * Return any patterns provided in the 'default-autowire-candidates'
	 * attribute of the top-level {@code &lt;beans/&gt;} element.
	 */
	@Nullable
	public String[] getAutowireCandidatePatterns() {
<span class="nc" id="L393">		String candidatePattern = this.defaults.getAutowireCandidates();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">		return (candidatePattern != null ? StringUtils.commaDelimitedListToStringArray(candidatePattern) : null);</span>
	}


	/**
	 * Parses the supplied {@code &lt;bean&gt;} element. May return {@code null}
	 * if there were errors during parse. Errors are reported to the
	 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
	 */
	@Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
<span class="fc" id="L405">		return parseBeanDefinitionElement(ele, null);</span>
	}

	/**
	 * Parses the supplied {@code &lt;bean&gt;} element. May return {@code null}
	 * if there were errors during parse. Errors are reported to the
	 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
	 */
	@Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
<span class="fc" id="L415">		String id = ele.getAttribute(ID_ATTRIBUTE);</span>
<span class="fc" id="L416">		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span>

<span class="fc" id="L418">		List&lt;String&gt; aliases = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">		if (StringUtils.hasLength(nameAttr)) {</span>
<span class="fc" id="L420">			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span>
<span class="fc" id="L421">			aliases.addAll(Arrays.asList(nameArr));</span>
		}

<span class="fc" id="L424">		String beanName = id;</span>
<span class="fc bfc" id="L425" title="All 4 branches covered.">		if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {</span>
<span class="fc" id="L426">			beanName = aliases.remove(0);</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">			if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L428">				logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName +</span>
						&quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);
			}
		}

<span class="fc bfc" id="L433" title="All 2 branches covered.">		if (containingBean == null) {</span>
<span class="fc" id="L434">			checkNameUniqueness(beanName, aliases, ele);</span>
		}

<span class="fc" id="L437">		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">		if (beanDefinition != null) {</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">			if (!StringUtils.hasText(beanName)) {</span>
				try {
<span class="fc bfc" id="L441" title="All 2 branches covered.">					if (containingBean != null) {</span>
<span class="fc" id="L442">						beanName = BeanDefinitionReaderUtils.generateBeanName(</span>
<span class="fc" id="L443">								beanDefinition, this.readerContext.getRegistry(), true);</span>
					}
					else {
<span class="fc" id="L446">						beanName = this.readerContext.generateBeanName(beanDefinition);</span>
						// Register an alias for the plain bean class name, if still possible,
						// if the generator returned the class name plus a suffix.
						// This is expected for Spring 1.2/2.0 backwards compatibility.
<span class="fc" id="L450">						String beanClassName = beanDefinition.getBeanClassName();</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">						if (beanClassName != null &amp;&amp;</span>
<span class="pc bpc" id="L452" title="2 of 4 branches missed.">								beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">								!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {</span>
<span class="fc" id="L454">							aliases.add(beanClassName);</span>
						}
					}
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">					if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L458">						logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; +</span>
								&quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
					}
				}
<span class="nc" id="L462">				catch (Exception ex) {</span>
<span class="nc" id="L463">					error(ex.getMessage(), ele);</span>
<span class="nc" id="L464">					return null;</span>
<span class="fc" id="L465">				}</span>
			}
<span class="fc" id="L467">			String[] aliasesArray = StringUtils.toStringArray(aliases);</span>
<span class="fc" id="L468">			return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span>
		}

<span class="nc" id="L471">		return null;</span>
	}

	/**
	 * Validate that the specified bean name and aliases have not been used already
	 * within the current level of beans element nesting.
	 */
	protected void checkNameUniqueness(String beanName, List&lt;String&gt; aliases, Element beanElement) {
<span class="fc" id="L479">		String foundName = null;</span>

<span class="fc bfc" id="L481" title="All 4 branches covered.">		if (StringUtils.hasText(beanName) &amp;&amp; this.usedNames.contains(beanName)) {</span>
<span class="fc" id="L482">			foundName = beanName;</span>
		}
<span class="fc bfc" id="L484" title="All 2 branches covered.">		if (foundName == null) {</span>
<span class="fc" id="L485">			foundName = CollectionUtils.findFirstMatch(this.usedNames, aliases);</span>
		}
<span class="fc bfc" id="L487" title="All 2 branches covered.">		if (foundName != null) {</span>
<span class="nc" id="L488">			error(&quot;Bean name '&quot; + foundName + &quot;' is already used in this &lt;beans&gt; element&quot;, beanElement);</span>
		}

<span class="fc" id="L491">		this.usedNames.add(beanName);</span>
<span class="fc" id="L492">		this.usedNames.addAll(aliases);</span>
<span class="fc" id="L493">	}</span>

	/**
	 * Parse the bean definition itself, without regard to name or aliases. May return
	 * {@code null} if problems occurred during the parsing of the bean definition.
	 */
	@Nullable
	public AbstractBeanDefinition parseBeanDefinitionElement(
			Element ele, String beanName, @Nullable BeanDefinition containingBean) {

<span class="fc" id="L503">		this.parseState.push(new BeanEntry(beanName));</span>

<span class="fc" id="L505">		String className = null;</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">		if (ele.hasAttribute(CLASS_ATTRIBUTE)) {</span>
<span class="fc" id="L507">			className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span>
		}
<span class="fc" id="L509">		String parent = null;</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">		if (ele.hasAttribute(PARENT_ATTRIBUTE)) {</span>
<span class="fc" id="L511">			parent = ele.getAttribute(PARENT_ATTRIBUTE);</span>
		}

		try {
<span class="fc" id="L515">			AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span>

<span class="fc" id="L517">			parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span>
<span class="fc" id="L518">			bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span>

<span class="fc" id="L520">			parseMetaElements(ele, bd);</span>
<span class="fc" id="L521">			parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span>
<span class="fc" id="L522">			parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span>

<span class="fc" id="L524">			parseConstructorArgElements(ele, bd);</span>
<span class="fc" id="L525">			parsePropertyElements(ele, bd);</span>
<span class="fc" id="L526">			parseQualifierElements(ele, bd);</span>

<span class="fc" id="L528">			bd.setResource(this.readerContext.getResource());</span>
<span class="fc" id="L529">			bd.setSource(extractSource(ele));</span>

<span class="fc" id="L531">			return bd;</span>
		}
<span class="nc" id="L533">		catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L534">			error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</span>
		}
<span class="nc" id="L536">		catch (NoClassDefFoundError err) {</span>
<span class="nc" id="L537">			error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</span>
		}
<span class="nc" id="L539">		catch (Throwable ex) {</span>
<span class="nc" id="L540">			error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</span>
		}
		finally {
<span class="fc" id="L543">			this.parseState.pop();</span>
		}

<span class="nc" id="L546">		return null;</span>
	}

	/**
	 * Apply the attributes of the given bean element to the given bean * definition.
	 * @param ele bean declaration element
	 * @param beanName bean name
	 * @param containingBean containing bean definition
	 * @return a bean definition initialized according to the bean element attributes
	 */
	public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,
			@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {

<span class="pc bpc" id="L559" title="1 of 2 branches missed.">		if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {</span>
<span class="nc" id="L560">			error(&quot;Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration&quot;, ele);</span>
		}
<span class="fc bfc" id="L562" title="All 2 branches covered.">		else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {</span>
<span class="fc" id="L563">			bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span>
		}
<span class="fc bfc" id="L565" title="All 2 branches covered.">		else if (containingBean != null) {</span>
			// Take default from containing bean in case of an inner bean definition.
<span class="fc" id="L567">			bd.setScope(containingBean.getScope());</span>
		}

<span class="fc bfc" id="L570" title="All 2 branches covered.">		if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {</span>
<span class="fc" id="L571">			bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span>
		}

<span class="fc" id="L574">		String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">		if (isDefaultValue(lazyInit)) {</span>
<span class="fc" id="L576">			lazyInit = this.defaults.getLazyInit();</span>
		}
<span class="fc" id="L578">		bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span>

<span class="fc" id="L580">		String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span>
<span class="fc" id="L581">		bd.setAutowireMode(getAutowireMode(autowire));</span>

<span class="pc bpc" id="L583" title="1 of 2 branches missed.">		if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {</span>
<span class="nc" id="L584">			String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span>
<span class="nc" id="L585">			bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span>
		}

<span class="fc" id="L588">		String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">		if (isDefaultValue(autowireCandidate)) {</span>
<span class="fc" id="L590">			String candidatePattern = this.defaults.getAutowireCandidates();</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">			if (candidatePattern != null) {</span>
<span class="fc" id="L592">				String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);</span>
<span class="fc" id="L593">				bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span>
			}
<span class="fc" id="L595">		}</span>
		else {
<span class="fc" id="L597">			bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span>
		}

<span class="fc bfc" id="L600" title="All 2 branches covered.">		if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {</span>
<span class="fc" id="L601">			bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span>
		}

<span class="fc bfc" id="L604" title="All 2 branches covered.">		if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {</span>
<span class="fc" id="L605">			String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span>
<span class="fc" id="L606">			bd.setInitMethodName(initMethodName);</span>
<span class="fc" id="L607">		}</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">		else if (this.defaults.getInitMethod() != null) {</span>
<span class="fc" id="L609">			bd.setInitMethodName(this.defaults.getInitMethod());</span>
<span class="fc" id="L610">			bd.setEnforceInitMethod(false);</span>
		}

<span class="fc bfc" id="L613" title="All 2 branches covered.">		if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {</span>
<span class="fc" id="L614">			String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span>
<span class="fc" id="L615">			bd.setDestroyMethodName(destroyMethodName);</span>
<span class="fc" id="L616">		}</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">		else if (this.defaults.getDestroyMethod() != null) {</span>
<span class="fc" id="L618">			bd.setDestroyMethodName(this.defaults.getDestroyMethod());</span>
<span class="fc" id="L619">			bd.setEnforceDestroyMethod(false);</span>
		}

<span class="fc bfc" id="L622" title="All 2 branches covered.">		if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {</span>
<span class="fc" id="L623">			bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span>
		}
<span class="fc bfc" id="L625" title="All 2 branches covered.">		if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {</span>
<span class="fc" id="L626">			bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span>
		}

<span class="fc" id="L629">		return bd;</span>
	}

	/**
	 * Create a bean definition for the given class name and parent name.
	 * @param className the name of the bean class
	 * @param parentName the name of the bean's parent bean
	 * @return the newly created bean definition
	 * @throws ClassNotFoundException if bean class resolution was attempted but failed
	 */
	protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)
			throws ClassNotFoundException {

<span class="fc" id="L642">		return BeanDefinitionReaderUtils.createBeanDefinition(</span>
<span class="fc" id="L643">				parentName, className, this.readerContext.getBeanClassLoader());</span>
	}

	public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
<span class="fc" id="L647">		NodeList nl = ele.getChildNodes();</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">		for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="fc" id="L649">			Node node = nl.item(i);</span>
<span class="fc bfc" id="L650" title="All 4 branches covered.">			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) {</span>
<span class="fc" id="L651">				Element metaElement = (Element) node;</span>
<span class="fc" id="L652">				String key = metaElement.getAttribute(KEY_ATTRIBUTE);</span>
<span class="fc" id="L653">				String value = metaElement.getAttribute(VALUE_ATTRIBUTE);</span>
<span class="fc" id="L654">				BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);</span>
<span class="fc" id="L655">				attribute.setSource(extractSource(metaElement));</span>
<span class="fc" id="L656">				attributeAccessor.addMetadataAttribute(attribute);</span>
			}
		}
<span class="fc" id="L659">	}</span>

	@SuppressWarnings(&quot;deprecation&quot;)
	public int getAutowireMode(String attValue) {
<span class="fc" id="L663">		String att = attValue;</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">		if (isDefaultValue(att)) {</span>
<span class="fc" id="L665">			att = this.defaults.getAutowire();</span>
		}
<span class="fc" id="L667">		int autowire = AbstractBeanDefinition.AUTOWIRE_NO;</span>
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">		if (AUTOWIRE_BY_NAME_VALUE.equals(att)) {</span>
<span class="nc" id="L669">			autowire = AbstractBeanDefinition.AUTOWIRE_BY_NAME;</span>
		}
<span class="fc bfc" id="L671" title="All 2 branches covered.">		else if (AUTOWIRE_BY_TYPE_VALUE.equals(att)) {</span>
<span class="fc" id="L672">			autowire = AbstractBeanDefinition.AUTOWIRE_BY_TYPE;</span>
		}
<span class="fc bfc" id="L674" title="All 2 branches covered.">		else if (AUTOWIRE_CONSTRUCTOR_VALUE.equals(att)) {</span>
<span class="fc" id="L675">			autowire = AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR;</span>
		}
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">		else if (AUTOWIRE_AUTODETECT_VALUE.equals(att)) {</span>
<span class="nc" id="L678">			autowire = AbstractBeanDefinition.AUTOWIRE_AUTODETECT;</span>
		}
		// Else leave default value.
<span class="fc" id="L681">		return autowire;</span>
	}

	/**
	 * Parse constructor-arg sub-elements of the given bean element.
	 */
	public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {
<span class="fc" id="L688">		NodeList nl = beanEle.getChildNodes();</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">		for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="fc" id="L690">			Node node = nl.item(i);</span>
<span class="fc bfc" id="L691" title="All 4 branches covered.">			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {</span>
<span class="fc" id="L692">				parseConstructorArgElement((Element) node, bd);</span>
			}
		}
<span class="fc" id="L695">	}</span>

	/**
	 * Parse property sub-elements of the given bean element.
	 */
	public void parsePropertyElements(Element beanEle, BeanDefinition bd) {
<span class="fc" id="L701">		NodeList nl = beanEle.getChildNodes();</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">		for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="fc" id="L703">			Node node = nl.item(i);</span>
<span class="fc bfc" id="L704" title="All 4 branches covered.">			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) {</span>
<span class="fc" id="L705">				parsePropertyElement((Element) node, bd);</span>
			}
		}
<span class="fc" id="L708">	}</span>

	/**
	 * Parse qualifier sub-elements of the given bean element.
	 */
	public void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) {
<span class="fc" id="L714">		NodeList nl = beanEle.getChildNodes();</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">		for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="fc" id="L716">			Node node = nl.item(i);</span>
<span class="pc bpc" id="L717" title="1 of 4 branches missed.">			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ELEMENT)) {</span>
<span class="nc" id="L718">				parseQualifierElement((Element) node, bd);</span>
			}
		}
<span class="fc" id="L721">	}</span>

	/**
	 * Parse lookup-override sub-elements of the given bean element.
	 */
	public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {
<span class="fc" id="L727">		NodeList nl = beanEle.getChildNodes();</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">		for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="fc" id="L729">			Node node = nl.item(i);</span>
<span class="fc bfc" id="L730" title="All 4 branches covered.">			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {</span>
<span class="fc" id="L731">				Element ele = (Element) node;</span>
<span class="fc" id="L732">				String methodName = ele.getAttribute(NAME_ATTRIBUTE);</span>
<span class="fc" id="L733">				String beanRef = ele.getAttribute(BEAN_ELEMENT);</span>
<span class="fc" id="L734">				LookupOverride override = new LookupOverride(methodName, beanRef);</span>
<span class="fc" id="L735">				override.setSource(extractSource(ele));</span>
<span class="fc" id="L736">				overrides.addOverride(override);</span>
			}
		}
<span class="fc" id="L739">	}</span>

	/**
	 * Parse replaced-method sub-elements of the given bean element.
	 */
	public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {
<span class="fc" id="L745">		NodeList nl = beanEle.getChildNodes();</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">		for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="fc" id="L747">			Node node = nl.item(i);</span>
<span class="pc bpc" id="L748" title="1 of 4 branches missed.">			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {</span>
<span class="nc" id="L749">				Element replacedMethodEle = (Element) node;</span>
<span class="nc" id="L750">				String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);</span>
<span class="nc" id="L751">				String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);</span>
<span class="nc" id="L752">				ReplaceOverride replaceOverride = new ReplaceOverride(name, callback);</span>
				// Look for arg-type match elements.
<span class="nc" id="L754">				List&lt;Element&gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">				for (Element argTypeEle : argTypeEles) {</span>
<span class="nc" id="L756">					String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">					match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">					if (StringUtils.hasText(match)) {</span>
<span class="nc" id="L759">						replaceOverride.addTypeIdentifier(match);</span>
					}
<span class="nc" id="L761">				}</span>
<span class="nc" id="L762">				replaceOverride.setSource(extractSource(replacedMethodEle));</span>
<span class="nc" id="L763">				overrides.addOverride(replaceOverride);</span>
			}
		}
<span class="fc" id="L766">	}</span>

	/**
	 * Parse a constructor-arg element.
	 */
	public void parseConstructorArgElement(Element ele, BeanDefinition bd) {
<span class="fc" id="L772">		String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);</span>
<span class="fc" id="L773">		String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);</span>
<span class="fc" id="L774">		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">		if (StringUtils.hasLength(indexAttr)) {</span>
			try {
<span class="fc" id="L777">				int index = Integer.parseInt(indexAttr);</span>
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">				if (index &lt; 0) {</span>
<span class="nc" id="L779">					error(&quot;'index' cannot be lower than 0&quot;, ele);</span>
				}
				else {
					try {
<span class="fc" id="L783">						this.parseState.push(new ConstructorArgumentEntry(index));</span>
<span class="fc" id="L784">						Object value = parsePropertyValue(ele, bd, null);</span>
<span class="fc" id="L785">						ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">						if (StringUtils.hasLength(typeAttr)) {</span>
<span class="fc" id="L787">							valueHolder.setType(typeAttr);</span>
						}
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">						if (StringUtils.hasLength(nameAttr)) {</span>
<span class="nc" id="L790">							valueHolder.setName(nameAttr);</span>
						}
<span class="fc" id="L792">						valueHolder.setSource(extractSource(ele));</span>
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">						if (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {</span>
<span class="nc" id="L794">							error(&quot;Ambiguous constructor-arg entries for index &quot; + index, ele);</span>
						}
						else {
<span class="fc" id="L797">							bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</span>
						}
					}
					finally {
<span class="fc" id="L801">						this.parseState.pop();</span>
					}
				}
			}
<span class="nc" id="L805">			catch (NumberFormatException ex) {</span>
<span class="nc" id="L806">				error(&quot;Attribute 'index' of tag 'constructor-arg' must be an integer&quot;, ele);</span>
<span class="pc" id="L807">			}</span>
		}
		else {
			try {
<span class="fc" id="L811">				this.parseState.push(new ConstructorArgumentEntry());</span>
<span class="fc" id="L812">				Object value = parsePropertyValue(ele, bd, null);</span>
<span class="fc" id="L813">				ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">				if (StringUtils.hasLength(typeAttr)) {</span>
<span class="fc" id="L815">					valueHolder.setType(typeAttr);</span>
				}
<span class="fc bfc" id="L817" title="All 2 branches covered.">				if (StringUtils.hasLength(nameAttr)) {</span>
<span class="fc" id="L818">					valueHolder.setName(nameAttr);</span>
				}
<span class="fc" id="L820">				valueHolder.setSource(extractSource(ele));</span>
<span class="fc" id="L821">				bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</span>
			}
			finally {
<span class="fc" id="L824">				this.parseState.pop();</span>
			}
		}
<span class="fc" id="L827">	}</span>

	/**
	 * Parse a property element.
	 */
	public void parsePropertyElement(Element ele, BeanDefinition bd) {
<span class="fc" id="L833">		String propertyName = ele.getAttribute(NAME_ATTRIBUTE);</span>
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">		if (!StringUtils.hasLength(propertyName)) {</span>
<span class="nc" id="L835">			error(&quot;Tag 'property' must have a 'name' attribute&quot;, ele);</span>
<span class="nc" id="L836">			return;</span>
		}
<span class="fc" id="L838">		this.parseState.push(new PropertyEntry(propertyName));</span>
		try {
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">			if (bd.getPropertyValues().contains(propertyName)) {</span>
<span class="nc" id="L841">				error(&quot;Multiple 'property' definitions for property '&quot; + propertyName + &quot;'&quot;, ele);</span>
<span class="nc" id="L842">				return;</span>
			}
<span class="fc" id="L844">			Object val = parsePropertyValue(ele, bd, propertyName);</span>
<span class="fc" id="L845">			PropertyValue pv = new PropertyValue(propertyName, val);</span>
<span class="fc" id="L846">			parseMetaElements(ele, pv);</span>
<span class="fc" id="L847">			pv.setSource(extractSource(ele));</span>
<span class="fc" id="L848">			bd.getPropertyValues().addPropertyValue(pv);</span>
		}
		finally {
<span class="fc" id="L851">			this.parseState.pop();</span>
		}
<span class="fc" id="L853">	}</span>

	/**
	 * Parse a qualifier element.
	 */
	public void parseQualifierElement(Element ele, AbstractBeanDefinition bd) {
<span class="nc" id="L859">		String typeName = ele.getAttribute(TYPE_ATTRIBUTE);</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">		if (!StringUtils.hasLength(typeName)) {</span>
<span class="nc" id="L861">			error(&quot;Tag 'qualifier' must have a 'type' attribute&quot;, ele);</span>
<span class="nc" id="L862">			return;</span>
		}
<span class="nc" id="L864">		this.parseState.push(new QualifierEntry(typeName));</span>
		try {
<span class="nc" id="L866">			AutowireCandidateQualifier qualifier = new AutowireCandidateQualifier(typeName);</span>
<span class="nc" id="L867">			qualifier.setSource(extractSource(ele));</span>
<span class="nc" id="L868">			String value = ele.getAttribute(VALUE_ATTRIBUTE);</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">			if (StringUtils.hasLength(value)) {</span>
<span class="nc" id="L870">				qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);</span>
			}
<span class="nc" id="L872">			NodeList nl = ele.getChildNodes();</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">			for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="nc" id="L874">				Node node = nl.item(i);</span>
<span class="nc bnc" id="L875" title="All 4 branches missed.">				if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) {</span>
<span class="nc" id="L876">					Element attributeEle = (Element) node;</span>
<span class="nc" id="L877">					String attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE);</span>
<span class="nc" id="L878">					String attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE);</span>
<span class="nc bnc" id="L879" title="All 4 branches missed.">					if (StringUtils.hasLength(attributeName) &amp;&amp; StringUtils.hasLength(attributeValue)) {</span>
<span class="nc" id="L880">						BeanMetadataAttribute attribute = new BeanMetadataAttribute(attributeName, attributeValue);</span>
<span class="nc" id="L881">						attribute.setSource(extractSource(attributeEle));</span>
<span class="nc" id="L882">						qualifier.addMetadataAttribute(attribute);</span>
<span class="nc" id="L883">					}</span>
					else {
<span class="nc" id="L885">						error(&quot;Qualifier 'attribute' tag must have a 'name' and 'value'&quot;, attributeEle);</span>
<span class="nc" id="L886">						return;</span>
					}
				}
			}
<span class="nc" id="L890">			bd.addQualifier(qualifier);</span>
		}
		finally {
<span class="nc" id="L893">			this.parseState.pop();</span>
		}
<span class="nc" id="L895">	}</span>

	/**
	 * Get the value of a property element. May be a list etc.
	 * Also used for constructor arguments, &quot;propertyName&quot; being null in this case.
	 */
	@Nullable
	public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {
<span class="fc bfc" id="L903" title="All 2 branches covered.">		String elementName = (propertyName != null ?</span>
				&quot;&lt;property&gt; element for property '&quot; + propertyName + &quot;'&quot; :
				&quot;&lt;constructor-arg&gt; element&quot;);

		// Should only have one child element: ref, value, list, etc.
<span class="fc" id="L908">		NodeList nl = ele.getChildNodes();</span>
<span class="fc" id="L909">		Element subElement = null;</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">		for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="fc" id="L911">			Node node = nl.item(i);</span>
<span class="fc bfc" id="L912" title="All 4 branches covered.">			if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">					!nodeNameEquals(node, META_ELEMENT)) {</span>
				// Child element is what we're looking for.
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">				if (subElement != null) {</span>
<span class="nc" id="L916">					error(elementName + &quot; must not contain more than one sub-element&quot;, ele);</span>
				}
				else {
<span class="fc" id="L919">					subElement = (Element) node;</span>
				}
			}
		}

<span class="fc" id="L924">		boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);</span>
<span class="fc" id="L925">		boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);</span>
<span class="pc bpc" id="L926" title="2 of 10 branches missed.">		if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</span>
				((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) {
<span class="nc" id="L928">			error(elementName +</span>
					&quot; is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element&quot;, ele);
		}

<span class="fc bfc" id="L932" title="All 2 branches covered.">		if (hasRefAttribute) {</span>
<span class="fc" id="L933">			String refName = ele.getAttribute(REF_ATTRIBUTE);</span>
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">			if (!StringUtils.hasText(refName)) {</span>
<span class="nc" id="L935">				error(elementName + &quot; contains empty 'ref' attribute&quot;, ele);</span>
			}
<span class="fc" id="L937">			RuntimeBeanReference ref = new RuntimeBeanReference(refName);</span>
<span class="fc" id="L938">			ref.setSource(extractSource(ele));</span>
<span class="fc" id="L939">			return ref;</span>
		}
<span class="fc bfc" id="L941" title="All 2 branches covered.">		else if (hasValueAttribute) {</span>
<span class="fc" id="L942">			TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span>
<span class="fc" id="L943">			valueHolder.setSource(extractSource(ele));</span>
<span class="fc" id="L944">			return valueHolder;</span>
		}
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">		else if (subElement != null) {</span>
<span class="fc" id="L947">			return parsePropertySubElement(subElement, bd);</span>
		}
		else {
			// Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.
<span class="nc" id="L951">			error(elementName + &quot; must specify a ref or value&quot;, ele);</span>
<span class="nc" id="L952">			return null;</span>
		}
	}

	@Nullable
	public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) {
<span class="fc" id="L958">		return parsePropertySubElement(ele, bd, null);</span>
	}

	/**
	 * Parse a value, ref or collection sub-element of a property or
	 * constructor-arg element.
	 * @param ele subelement of property element; we don't know which yet
	 * @param defaultValueType the default type (class name) for any
	 * {@code &lt;value&gt;} tag that might be created
	 */
	@Nullable
	public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) {
<span class="fc bfc" id="L970" title="All 2 branches covered.">		if (!isDefaultNamespace(ele)) {</span>
<span class="fc" id="L971">			return parseNestedCustomElement(ele, bd);</span>
		}
<span class="fc bfc" id="L973" title="All 2 branches covered.">		else if (nodeNameEquals(ele, BEAN_ELEMENT)) {</span>
<span class="fc" id="L974">			BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);</span>
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">			if (nestedBd != null) {</span>
<span class="fc" id="L976">				nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span>
			}
<span class="fc" id="L978">			return nestedBd;</span>
		}
<span class="fc bfc" id="L980" title="All 2 branches covered.">		else if (nodeNameEquals(ele, REF_ELEMENT)) {</span>
			// A generic reference to any name of any bean.
<span class="fc" id="L982">			String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);</span>
<span class="fc" id="L983">			boolean toParent = false;</span>
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">			if (!StringUtils.hasLength(refName)) {</span>
				// A reference to the id of another bean in a parent context.
<span class="nc" id="L986">				refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);</span>
<span class="nc" id="L987">				toParent = true;</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">				if (!StringUtils.hasLength(refName)) {</span>
<span class="nc" id="L989">					error(&quot;'bean' or 'parent' is required for &lt;ref&gt; element&quot;, ele);</span>
<span class="nc" id="L990">					return null;</span>
				}
			}
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">			if (!StringUtils.hasText(refName)) {</span>
<span class="nc" id="L994">				error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);</span>
<span class="nc" id="L995">				return null;</span>
			}
<span class="fc" id="L997">			RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);</span>
<span class="fc" id="L998">			ref.setSource(extractSource(ele));</span>
<span class="fc" id="L999">			return ref;</span>
		}
<span class="fc bfc" id="L1001" title="All 2 branches covered.">		else if (nodeNameEquals(ele, IDREF_ELEMENT)) {</span>
<span class="fc" id="L1002">			return parseIdRefElement(ele);</span>
		}
<span class="fc bfc" id="L1004" title="All 2 branches covered.">		else if (nodeNameEquals(ele, VALUE_ELEMENT)) {</span>
<span class="fc" id="L1005">			return parseValueElement(ele, defaultValueType);</span>
		}
<span class="fc bfc" id="L1007" title="All 2 branches covered.">		else if (nodeNameEquals(ele, NULL_ELEMENT)) {</span>
			// It's a distinguished null value. Let's wrap it in a TypedStringValue
			// object in order to preserve the source location.
<span class="fc" id="L1010">			TypedStringValue nullHolder = new TypedStringValue(null);</span>
<span class="fc" id="L1011">			nullHolder.setSource(extractSource(ele));</span>
<span class="fc" id="L1012">			return nullHolder;</span>
		}
<span class="fc bfc" id="L1014" title="All 2 branches covered.">		else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {</span>
<span class="fc" id="L1015">			return parseArrayElement(ele, bd);</span>
		}
<span class="fc bfc" id="L1017" title="All 2 branches covered.">		else if (nodeNameEquals(ele, LIST_ELEMENT)) {</span>
<span class="fc" id="L1018">			return parseListElement(ele, bd);</span>
		}
<span class="fc bfc" id="L1020" title="All 2 branches covered.">		else if (nodeNameEquals(ele, SET_ELEMENT)) {</span>
<span class="fc" id="L1021">			return parseSetElement(ele, bd);</span>
		}
<span class="fc bfc" id="L1023" title="All 2 branches covered.">		else if (nodeNameEquals(ele, MAP_ELEMENT)) {</span>
<span class="fc" id="L1024">			return parseMapElement(ele, bd);</span>
		}
<span class="pc bpc" id="L1026" title="1 of 2 branches missed.">		else if (nodeNameEquals(ele, PROPS_ELEMENT)) {</span>
<span class="fc" id="L1027">			return parsePropsElement(ele);</span>
		}
		else {
<span class="nc" id="L1030">			error(&quot;Unknown property sub-element: [&quot; + ele.getNodeName() + &quot;]&quot;, ele);</span>
<span class="nc" id="L1031">			return null;</span>
		}
	}

	/**
	 * Return a typed String value Object for the given 'idref' element.
	 */
	@Nullable
	public Object parseIdRefElement(Element ele) {
		// A generic reference to any name of any bean.
<span class="fc" id="L1041">		String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);</span>
<span class="pc bpc" id="L1042" title="1 of 2 branches missed.">		if (!StringUtils.hasLength(refName)) {</span>
<span class="nc" id="L1043">			error(&quot;'bean' is required for &lt;idref&gt; element&quot;, ele);</span>
<span class="nc" id="L1044">			return null;</span>
		}
<span class="pc bpc" id="L1046" title="1 of 2 branches missed.">		if (!StringUtils.hasText(refName)) {</span>
<span class="nc" id="L1047">			error(&quot;&lt;idref&gt; element contains empty target attribute&quot;, ele);</span>
<span class="nc" id="L1048">			return null;</span>
		}
<span class="fc" id="L1050">		RuntimeBeanNameReference ref = new RuntimeBeanNameReference(refName);</span>
<span class="fc" id="L1051">		ref.setSource(extractSource(ele));</span>
<span class="fc" id="L1052">		return ref;</span>
	}

	/**
	 * Return a typed String value Object for the given value element.
	 */
	public Object parseValueElement(Element ele, @Nullable String defaultTypeName) {
		// It's a literal value.
<span class="fc" id="L1060">		String value = DomUtils.getTextValue(ele);</span>
<span class="fc" id="L1061">		String specifiedTypeName = ele.getAttribute(TYPE_ATTRIBUTE);</span>
<span class="fc" id="L1062">		String typeName = specifiedTypeName;</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">		if (!StringUtils.hasText(typeName)) {</span>
<span class="fc" id="L1064">			typeName = defaultTypeName;</span>
		}
		try {
<span class="fc" id="L1067">			TypedStringValue typedValue = buildTypedStringValue(value, typeName);</span>
<span class="fc" id="L1068">			typedValue.setSource(extractSource(ele));</span>
<span class="fc" id="L1069">			typedValue.setSpecifiedTypeName(specifiedTypeName);</span>
<span class="fc" id="L1070">			return typedValue;</span>
		}
<span class="nc" id="L1072">		catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L1073">			error(&quot;Type class [&quot; + typeName + &quot;] not found for &lt;value&gt; element&quot;, ele, ex);</span>
<span class="nc" id="L1074">			return value;</span>
		}
	}

	/**
	 * Build a typed String value Object for the given raw value.
	 * @see org.springframework.beans.factory.config.TypedStringValue
	 */
	protected TypedStringValue buildTypedStringValue(String value, @Nullable String targetTypeName)
			throws ClassNotFoundException {

<span class="fc" id="L1085">		ClassLoader classLoader = this.readerContext.getBeanClassLoader();</span>
		TypedStringValue typedValue;
<span class="fc bfc" id="L1087" title="All 2 branches covered.">		if (!StringUtils.hasText(targetTypeName)) {</span>
<span class="fc" id="L1088">			typedValue = new TypedStringValue(value);</span>
		}
<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">		else if (classLoader != null) {</span>
<span class="nc" id="L1091">			Class&lt;?&gt; targetType = ClassUtils.forName(targetTypeName, classLoader);</span>
<span class="nc" id="L1092">			typedValue = new TypedStringValue(value, targetType);</span>
<span class="nc" id="L1093">		}</span>
		else {
<span class="fc" id="L1095">			typedValue = new TypedStringValue(value, targetTypeName);</span>
		}
<span class="fc" id="L1097">		return typedValue;</span>
	}

	/**
	 * Parse an array element.
	 */
	public Object parseArrayElement(Element arrayEle, @Nullable BeanDefinition bd) {
<span class="fc" id="L1104">		String elementType = arrayEle.getAttribute(VALUE_TYPE_ATTRIBUTE);</span>
<span class="fc" id="L1105">		NodeList nl = arrayEle.getChildNodes();</span>
<span class="fc" id="L1106">		ManagedArray target = new ManagedArray(elementType, nl.getLength());</span>
<span class="fc" id="L1107">		target.setSource(extractSource(arrayEle));</span>
<span class="fc" id="L1108">		target.setElementTypeName(elementType);</span>
<span class="fc" id="L1109">		target.setMergeEnabled(parseMergeAttribute(arrayEle));</span>
<span class="fc" id="L1110">		parseCollectionElements(nl, target, bd, elementType);</span>
<span class="fc" id="L1111">		return target;</span>
	}

	/**
	 * Parse a list element.
	 */
	public List&lt;Object&gt; parseListElement(Element collectionEle, @Nullable BeanDefinition bd) {
<span class="fc" id="L1118">		String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);</span>
<span class="fc" id="L1119">		NodeList nl = collectionEle.getChildNodes();</span>
<span class="fc" id="L1120">		ManagedList&lt;Object&gt; target = new ManagedList&lt;&gt;(nl.getLength());</span>
<span class="fc" id="L1121">		target.setSource(extractSource(collectionEle));</span>
<span class="fc" id="L1122">		target.setElementTypeName(defaultElementType);</span>
<span class="fc" id="L1123">		target.setMergeEnabled(parseMergeAttribute(collectionEle));</span>
<span class="fc" id="L1124">		parseCollectionElements(nl, target, bd, defaultElementType);</span>
<span class="fc" id="L1125">		return target;</span>
	}

	/**
	 * Parse a set element.
	 */
	public Set&lt;Object&gt; parseSetElement(Element collectionEle, @Nullable BeanDefinition bd) {
<span class="fc" id="L1132">		String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);</span>
<span class="fc" id="L1133">		NodeList nl = collectionEle.getChildNodes();</span>
<span class="fc" id="L1134">		ManagedSet&lt;Object&gt; target = new ManagedSet&lt;&gt;(nl.getLength());</span>
<span class="fc" id="L1135">		target.setSource(extractSource(collectionEle));</span>
<span class="fc" id="L1136">		target.setElementTypeName(defaultElementType);</span>
<span class="fc" id="L1137">		target.setMergeEnabled(parseMergeAttribute(collectionEle));</span>
<span class="fc" id="L1138">		parseCollectionElements(nl, target, bd, defaultElementType);</span>
<span class="fc" id="L1139">		return target;</span>
	}

	protected void parseCollectionElements(
			NodeList elementNodes, Collection&lt;Object&gt; target, @Nullable BeanDefinition bd, String defaultElementType) {

<span class="fc bfc" id="L1145" title="All 2 branches covered.">		for (int i = 0; i &lt; elementNodes.getLength(); i++) {</span>
<span class="fc" id="L1146">			Node node = elementNodes.item(i);</span>
<span class="fc bfc" id="L1147" title="All 4 branches covered.">			if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) {</span>
<span class="fc" id="L1148">				target.add(parsePropertySubElement((Element) node, bd, defaultElementType));</span>
			}
		}
<span class="fc" id="L1151">	}</span>

	/**
	 * Parse a map element.
	 */
	public Map&lt;Object, Object&gt; parseMapElement(Element mapEle, @Nullable BeanDefinition bd) {
<span class="fc" id="L1157">		String defaultKeyType = mapEle.getAttribute(KEY_TYPE_ATTRIBUTE);</span>
<span class="fc" id="L1158">		String defaultValueType = mapEle.getAttribute(VALUE_TYPE_ATTRIBUTE);</span>

<span class="fc" id="L1160">		List&lt;Element&gt; entryEles = DomUtils.getChildElementsByTagName(mapEle, ENTRY_ELEMENT);</span>
<span class="fc" id="L1161">		ManagedMap&lt;Object, Object&gt; map = new ManagedMap&lt;&gt;(entryEles.size());</span>
<span class="fc" id="L1162">		map.setSource(extractSource(mapEle));</span>
<span class="fc" id="L1163">		map.setKeyTypeName(defaultKeyType);</span>
<span class="fc" id="L1164">		map.setValueTypeName(defaultValueType);</span>
<span class="fc" id="L1165">		map.setMergeEnabled(parseMergeAttribute(mapEle));</span>

<span class="fc bfc" id="L1167" title="All 2 branches covered.">		for (Element entryEle : entryEles) {</span>
			// Should only have one value child element: ref, value, list, etc.
			// Optionally, there might be a key child element.
<span class="fc" id="L1170">			NodeList entrySubNodes = entryEle.getChildNodes();</span>
<span class="fc" id="L1171">			Element keyEle = null;</span>
<span class="fc" id="L1172">			Element valueEle = null;</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">			for (int j = 0; j &lt; entrySubNodes.getLength(); j++) {</span>
<span class="fc" id="L1174">				Node node = entrySubNodes.item(j);</span>
<span class="fc bfc" id="L1175" title="All 2 branches covered.">				if (node instanceof Element) {</span>
<span class="fc" id="L1176">					Element candidateEle = (Element) node;</span>
<span class="fc bfc" id="L1177" title="All 2 branches covered.">					if (nodeNameEquals(candidateEle, KEY_ELEMENT)) {</span>
<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">						if (keyEle != null) {</span>
<span class="nc" id="L1179">							error(&quot;&lt;entry&gt; element is only allowed to contain one &lt;key&gt; sub-element&quot;, entryEle);</span>
						}
						else {
<span class="fc" id="L1182">							keyEle = candidateEle;</span>
						}
					}
					else {
						// Child element is what we're looking for.
<span class="fc bfc" id="L1187" title="All 2 branches covered.">						if (nodeNameEquals(candidateEle, DESCRIPTION_ELEMENT)) {</span>
							// the element is a &lt;description&gt; -&gt; ignore it
						}
<span class="pc bpc" id="L1190" title="1 of 2 branches missed.">						else if (valueEle != null) {</span>
<span class="nc" id="L1191">							error(&quot;&lt;entry&gt; element must not contain more than one value sub-element&quot;, entryEle);</span>
						}
						else {
<span class="fc" id="L1194">							valueEle = candidateEle;</span>
						}
					}
				}
			}

			// Extract key from attribute or sub-element.
<span class="fc" id="L1201">			Object key = null;</span>
<span class="fc" id="L1202">			boolean hasKeyAttribute = entryEle.hasAttribute(KEY_ATTRIBUTE);</span>
<span class="fc" id="L1203">			boolean hasKeyRefAttribute = entryEle.hasAttribute(KEY_REF_ATTRIBUTE);</span>
<span class="pc bpc" id="L1204" title="2 of 10 branches missed.">			if ((hasKeyAttribute &amp;&amp; hasKeyRefAttribute) ||</span>
					(hasKeyAttribute || hasKeyRefAttribute) &amp;&amp; keyEle != null) {
<span class="nc" id="L1206">				error(&quot;&lt;entry&gt; element is only allowed to contain either &quot; +</span>
						&quot;a 'key' attribute OR a 'key-ref' attribute OR a &lt;key&gt; sub-element&quot;, entryEle);
			}
<span class="fc bfc" id="L1209" title="All 2 branches covered.">			if (hasKeyAttribute) {</span>
<span class="fc" id="L1210">				key = buildTypedStringValueForMap(entryEle.getAttribute(KEY_ATTRIBUTE), defaultKeyType, entryEle);</span>
			}
<span class="fc bfc" id="L1212" title="All 2 branches covered.">			else if (hasKeyRefAttribute) {</span>
<span class="fc" id="L1213">				String refName = entryEle.getAttribute(KEY_REF_ATTRIBUTE);</span>
<span class="pc bpc" id="L1214" title="1 of 2 branches missed.">				if (!StringUtils.hasText(refName)) {</span>
<span class="nc" id="L1215">					error(&quot;&lt;entry&gt; element contains empty 'key-ref' attribute&quot;, entryEle);</span>
				}
<span class="fc" id="L1217">				RuntimeBeanReference ref = new RuntimeBeanReference(refName);</span>
<span class="fc" id="L1218">				ref.setSource(extractSource(entryEle));</span>
<span class="fc" id="L1219">				key = ref;</span>
<span class="fc" id="L1220">			}</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">			else if (keyEle != null) {</span>
<span class="fc" id="L1222">				key = parseKeyElement(keyEle, bd, defaultKeyType);</span>
			}
			else {
<span class="fc" id="L1225">				error(&quot;&lt;entry&gt; element must specify a key&quot;, entryEle);</span>
			}

			// Extract value from attribute or sub-element.
<span class="fc" id="L1229">			Object value = null;</span>
<span class="fc" id="L1230">			boolean hasValueAttribute = entryEle.hasAttribute(VALUE_ATTRIBUTE);</span>
<span class="fc" id="L1231">			boolean hasValueRefAttribute = entryEle.hasAttribute(VALUE_REF_ATTRIBUTE);</span>
<span class="fc" id="L1232">			boolean hasValueTypeAttribute = entryEle.hasAttribute(VALUE_TYPE_ATTRIBUTE);</span>
<span class="pc bpc" id="L1233" title="2 of 10 branches missed.">			if ((hasValueAttribute &amp;&amp; hasValueRefAttribute) ||</span>
					(hasValueAttribute || hasValueRefAttribute) &amp;&amp; valueEle != null) {
<span class="nc" id="L1235">				error(&quot;&lt;entry&gt; element is only allowed to contain either &quot; +</span>
						&quot;'value' attribute OR 'value-ref' attribute OR &lt;value&gt; sub-element&quot;, entryEle);
			}
<span class="pc bpc" id="L1238" title="3 of 12 branches missed.">			if ((hasValueTypeAttribute &amp;&amp; hasValueRefAttribute) ||</span>
				(hasValueTypeAttribute &amp;&amp; !hasValueAttribute) ||
					(hasValueTypeAttribute &amp;&amp; valueEle != null)) {
<span class="nc" id="L1241">				error(&quot;&lt;entry&gt; element is only allowed to contain a 'value-type' &quot; +</span>
						&quot;attribute when it has a 'value' attribute&quot;, entryEle);
			}
<span class="fc bfc" id="L1244" title="All 2 branches covered.">			if (hasValueAttribute) {</span>
<span class="fc" id="L1245">				String valueType = entryEle.getAttribute(VALUE_TYPE_ATTRIBUTE);</span>
<span class="fc bfc" id="L1246" title="All 2 branches covered.">				if (!StringUtils.hasText(valueType)) {</span>
<span class="fc" id="L1247">					valueType = defaultValueType;</span>
				}
<span class="fc" id="L1249">				value = buildTypedStringValueForMap(entryEle.getAttribute(VALUE_ATTRIBUTE), valueType, entryEle);</span>
<span class="fc" id="L1250">			}</span>
<span class="fc bfc" id="L1251" title="All 2 branches covered.">			else if (hasValueRefAttribute) {</span>
<span class="fc" id="L1252">				String refName = entryEle.getAttribute(VALUE_REF_ATTRIBUTE);</span>
<span class="pc bpc" id="L1253" title="1 of 2 branches missed.">				if (!StringUtils.hasText(refName)) {</span>
<span class="nc" id="L1254">					error(&quot;&lt;entry&gt; element contains empty 'value-ref' attribute&quot;, entryEle);</span>
				}
<span class="fc" id="L1256">				RuntimeBeanReference ref = new RuntimeBeanReference(refName);</span>
<span class="fc" id="L1257">				ref.setSource(extractSource(entryEle));</span>
<span class="fc" id="L1258">				value = ref;</span>
<span class="fc" id="L1259">			}</span>
<span class="fc bfc" id="L1260" title="All 2 branches covered.">			else if (valueEle != null) {</span>
<span class="fc" id="L1261">				value = parsePropertySubElement(valueEle, bd, defaultValueType);</span>
			}
			else {
<span class="fc" id="L1264">				error(&quot;&lt;entry&gt; element must specify a value&quot;, entryEle);</span>
			}

			// Add final key and value to the Map.
<span class="fc" id="L1268">			map.put(key, value);</span>
<span class="fc" id="L1269">		}</span>

<span class="fc" id="L1271">		return map;</span>
	}

	/**
	 * Build a typed String value Object for the given raw value.
	 * @see org.springframework.beans.factory.config.TypedStringValue
	 */
	protected final Object buildTypedStringValueForMap(String value, String defaultTypeName, Element entryEle) {
		try {
<span class="fc" id="L1280">			TypedStringValue typedValue = buildTypedStringValue(value, defaultTypeName);</span>
<span class="fc" id="L1281">			typedValue.setSource(extractSource(entryEle));</span>
<span class="fc" id="L1282">			return typedValue;</span>
		}
<span class="nc" id="L1284">		catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L1285">			error(&quot;Type class [&quot; + defaultTypeName + &quot;] not found for Map key/value type&quot;, entryEle, ex);</span>
<span class="nc" id="L1286">			return value;</span>
		}
	}

	/**
	 * Parse a key sub-element of a map element.
	 */
	@Nullable
	protected Object parseKeyElement(Element keyEle, @Nullable BeanDefinition bd, String defaultKeyTypeName) {
<span class="fc" id="L1295">		NodeList nl = keyEle.getChildNodes();</span>
<span class="fc" id="L1296">		Element subElement = null;</span>
<span class="fc bfc" id="L1297" title="All 2 branches covered.">		for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="fc" id="L1298">			Node node = nl.item(i);</span>
<span class="fc bfc" id="L1299" title="All 2 branches covered.">			if (node instanceof Element) {</span>
				// Child element is what we're looking for.
<span class="pc bpc" id="L1301" title="1 of 2 branches missed.">				if (subElement != null) {</span>
<span class="nc" id="L1302">					error(&quot;&lt;key&gt; element must not contain more than one value sub-element&quot;, keyEle);</span>
				}
				else {
<span class="fc" id="L1305">					subElement = (Element) node;</span>
				}
			}
		}
<span class="pc bpc" id="L1309" title="1 of 2 branches missed.">		if (subElement == null) {</span>
<span class="nc" id="L1310">			return null;</span>
		}
<span class="fc" id="L1312">		return parsePropertySubElement(subElement, bd, defaultKeyTypeName);</span>
	}

	/**
	 * Parse a props element.
	 */
	public Properties parsePropsElement(Element propsEle) {
<span class="fc" id="L1319">		ManagedProperties props = new ManagedProperties();</span>
<span class="fc" id="L1320">		props.setSource(extractSource(propsEle));</span>
<span class="fc" id="L1321">		props.setMergeEnabled(parseMergeAttribute(propsEle));</span>

<span class="fc" id="L1323">		List&lt;Element&gt; propEles = DomUtils.getChildElementsByTagName(propsEle, PROP_ELEMENT);</span>
<span class="fc bfc" id="L1324" title="All 2 branches covered.">		for (Element propEle : propEles) {</span>
<span class="fc" id="L1325">			String key = propEle.getAttribute(KEY_ATTRIBUTE);</span>
			// Trim the text value to avoid unwanted whitespace
			// caused by typical XML formatting.
<span class="fc" id="L1328">			String value = DomUtils.getTextValue(propEle).trim();</span>
<span class="fc" id="L1329">			TypedStringValue keyHolder = new TypedStringValue(key);</span>
<span class="fc" id="L1330">			keyHolder.setSource(extractSource(propEle));</span>
<span class="fc" id="L1331">			TypedStringValue valueHolder = new TypedStringValue(value);</span>
<span class="fc" id="L1332">			valueHolder.setSource(extractSource(propEle));</span>
<span class="fc" id="L1333">			props.put(keyHolder, valueHolder);</span>
<span class="fc" id="L1334">		}</span>

<span class="fc" id="L1336">		return props;</span>
	}

	/**
	 * Parse the merge attribute of a collection element, if any.
	 */
	public boolean parseMergeAttribute(Element collectionElement) {
<span class="fc" id="L1343">		String value = collectionElement.getAttribute(MERGE_ATTRIBUTE);</span>
<span class="fc bfc" id="L1344" title="All 2 branches covered.">		if (isDefaultValue(value)) {</span>
<span class="fc" id="L1345">			value = this.defaults.getMerge();</span>
		}
<span class="fc" id="L1347">		return TRUE_VALUE.equals(value);</span>
	}

	@Nullable
	public BeanDefinition parseCustomElement(Element ele) {
<span class="fc" id="L1352">		return parseCustomElement(ele, null);</span>
	}

	@Nullable
	public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {
<span class="fc" id="L1357">		String namespaceUri = getNamespaceURI(ele);</span>
<span class="pc bpc" id="L1358" title="1 of 2 branches missed.">		if (namespaceUri == null) {</span>
<span class="nc" id="L1359">			return null;</span>
		}
<span class="fc" id="L1361">		NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span>
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">		if (handler == null) {</span>
<span class="nc" id="L1363">			error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);</span>
<span class="nc" id="L1364">			return null;</span>
		}
<span class="fc" id="L1366">		return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));</span>
	}

	public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder definitionHolder) {
<span class="fc" id="L1370">		return decorateBeanDefinitionIfRequired(ele, definitionHolder, null);</span>
	}

	public BeanDefinitionHolder decorateBeanDefinitionIfRequired(
			Element ele, BeanDefinitionHolder definitionHolder, @Nullable BeanDefinition containingBd) {

<span class="fc" id="L1376">		BeanDefinitionHolder finalDefinition = definitionHolder;</span>

		// Decorate based on custom attributes first.
<span class="fc" id="L1379">		NamedNodeMap attributes = ele.getAttributes();</span>
<span class="fc bfc" id="L1380" title="All 2 branches covered.">		for (int i = 0; i &lt; attributes.getLength(); i++) {</span>
<span class="fc" id="L1381">			Node node = attributes.item(i);</span>
<span class="fc" id="L1382">			finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);</span>
		}

		// Decorate based on custom nested elements.
<span class="fc" id="L1386">		NodeList children = ele.getChildNodes();</span>
<span class="fc bfc" id="L1387" title="All 2 branches covered.">		for (int i = 0; i &lt; children.getLength(); i++) {</span>
<span class="fc" id="L1388">			Node node = children.item(i);</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">			if (node.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="fc" id="L1390">				finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);</span>
			}
		}
<span class="fc" id="L1393">		return finalDefinition;</span>
	}

	public BeanDefinitionHolder decorateIfRequired(
			Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {

<span class="fc" id="L1399">		String namespaceUri = getNamespaceURI(node);</span>
<span class="fc bfc" id="L1400" title="All 4 branches covered.">		if (namespaceUri != null &amp;&amp; !isDefaultNamespace(namespaceUri)) {</span>
<span class="fc" id="L1401">			NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span>
<span class="fc bfc" id="L1402" title="All 2 branches covered.">			if (handler != null) {</span>
<span class="fc" id="L1403">				BeanDefinitionHolder decorated =</span>
<span class="fc" id="L1404">						handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));</span>
<span class="pc bpc" id="L1405" title="1 of 2 branches missed.">				if (decorated != null) {</span>
<span class="fc" id="L1406">					return decorated;</span>
				}
<span class="nc" id="L1408">			}</span>
<span class="pc bpc" id="L1409" title="1 of 2 branches missed.">			else if (namespaceUri.startsWith(&quot;http://www.springframework.org/&quot;)) {</span>
<span class="nc" id="L1410">				error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, node);</span>
			}
			else {
				// A custom namespace, not to be handled by Spring - maybe &quot;xml:...&quot;.
<span class="pc bpc" id="L1414" title="1 of 2 branches missed.">				if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L1415">					logger.debug(&quot;No Spring NamespaceHandler found for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;);</span>
				}
			}
		}
<span class="fc" id="L1419">		return originalDef;</span>
	}

	@Nullable
	private BeanDefinitionHolder parseNestedCustomElement(Element ele, @Nullable BeanDefinition containingBd) {
<span class="fc" id="L1424">		BeanDefinition innerDefinition = parseCustomElement(ele, containingBd);</span>
<span class="pc bpc" id="L1425" title="1 of 2 branches missed.">		if (innerDefinition == null) {</span>
<span class="nc" id="L1426">			error(&quot;Incorrect usage of element '&quot; + ele.getNodeName() + &quot;' in a nested manner. &quot; +</span>
					&quot;This tag cannot be used nested inside &lt;property&gt;.&quot;, ele);
<span class="nc" id="L1428">			return null;</span>
		}
<span class="fc" id="L1430">		String id = ele.getNodeName() + BeanDefinitionReaderUtils.GENERATED_BEAN_NAME_SEPARATOR +</span>
<span class="fc" id="L1431">				ObjectUtils.getIdentityHexString(innerDefinition);</span>
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">		if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L1433">			logger.trace(&quot;Using generated bean name [&quot; + id +</span>
<span class="nc" id="L1434">					&quot;] for nested custom element '&quot; + ele.getNodeName() + &quot;'&quot;);</span>
		}
<span class="fc" id="L1436">		return new BeanDefinitionHolder(innerDefinition, id);</span>
	}


	/**
	 * Get the namespace URI for the supplied node.
	 * &lt;p&gt;The default implementation uses {@link Node#getNamespaceURI}.
	 * Subclasses may override the default implementation to provide a
	 * different namespace identification mechanism.
	 * @param node the node
	 */
	@Nullable
	public String getNamespaceURI(Node node) {
<span class="fc" id="L1449">		return node.getNamespaceURI();</span>
	}

	/**
	 * Get the local name for the supplied {@link Node}.
	 * &lt;p&gt;The default implementation calls {@link Node#getLocalName}.
	 * Subclasses may override the default implementation to provide a
	 * different mechanism for getting the local name.
	 * @param node the {@code Node}
	 */
	public String getLocalName(Node node) {
<span class="fc" id="L1460">		return node.getLocalName();</span>
	}

	/**
	 * Determine whether the name of the supplied node is equal to the supplied name.
	 * &lt;p&gt;The default implementation checks the supplied desired name against both
	 * {@link Node#getNodeName()} and {@link Node#getLocalName()}.
	 * &lt;p&gt;Subclasses may override the default implementation to provide a different
	 * mechanism for comparing node names.
	 * @param node the node to compare
	 * @param desiredName the name to check for
	 */
	public boolean nodeNameEquals(Node node, String desiredName) {
<span class="fc bfc" id="L1473" title="All 4 branches covered.">		return desiredName.equals(node.getNodeName()) || desiredName.equals(getLocalName(node));</span>
	}

	public boolean isDefaultNamespace(@Nullable String namespaceUri) {
<span class="fc bfc" id="L1477" title="All 4 branches covered.">		return (!StringUtils.hasLength(namespaceUri) || BEANS_NAMESPACE_URI.equals(namespaceUri));</span>
	}

	public boolean isDefaultNamespace(Node node) {
<span class="fc" id="L1481">		return isDefaultNamespace(getNamespaceURI(node));</span>
	}

	private boolean isDefaultValue(String value) {
<span class="fc bfc" id="L1485" title="All 4 branches covered.">		return (DEFAULT_VALUE.equals(value) || &quot;&quot;.equals(value));</span>
	}

	private boolean isCandidateElement(Node node) {
<span class="pc bpc" id="L1489" title="1 of 6 branches missed.">		return (node instanceof Element &amp;&amp; (isDefaultNamespace(node) || !isDefaultNamespace(node.getParentNode())));</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>