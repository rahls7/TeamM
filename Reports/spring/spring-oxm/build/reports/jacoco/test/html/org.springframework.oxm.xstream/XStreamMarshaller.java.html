<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XStreamMarshaller.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-oxm</a> &gt; <a href="index.source.html" class="el_package">org.springframework.oxm.xstream</a> &gt; <span class="el_source">XStreamMarshaller.java</span></div><h1>XStreamMarshaller.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.oxm.xstream;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.lang.reflect.Constructor;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLEventWriter;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.stream.StreamSource;

import com.thoughtworks.xstream.MarshallingStrategy;
import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.ConversionException;
import com.thoughtworks.xstream.converters.Converter;
import com.thoughtworks.xstream.converters.ConverterLookup;
import com.thoughtworks.xstream.converters.ConverterMatcher;
import com.thoughtworks.xstream.converters.ConverterRegistry;
import com.thoughtworks.xstream.converters.DataHolder;
import com.thoughtworks.xstream.converters.SingleValueConverter;
import com.thoughtworks.xstream.converters.reflection.ReflectionProvider;
import com.thoughtworks.xstream.core.ClassLoaderReference;
import com.thoughtworks.xstream.core.DefaultConverterLookup;
import com.thoughtworks.xstream.core.util.CompositeClassLoader;
import com.thoughtworks.xstream.io.HierarchicalStreamDriver;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import com.thoughtworks.xstream.io.StreamException;
import com.thoughtworks.xstream.io.naming.NameCoder;
import com.thoughtworks.xstream.io.xml.CompactWriter;
import com.thoughtworks.xstream.io.xml.DomReader;
import com.thoughtworks.xstream.io.xml.DomWriter;
import com.thoughtworks.xstream.io.xml.QNameMap;
import com.thoughtworks.xstream.io.xml.SaxWriter;
import com.thoughtworks.xstream.io.xml.StaxReader;
import com.thoughtworks.xstream.io.xml.StaxWriter;
import com.thoughtworks.xstream.io.xml.XmlFriendlyNameCoder;
import com.thoughtworks.xstream.io.xml.XppDriver;
import com.thoughtworks.xstream.mapper.CannotResolveClassException;
import com.thoughtworks.xstream.mapper.Mapper;
import com.thoughtworks.xstream.mapper.MapperWrapper;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.ContentHandler;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.ext.LexicalHandler;

import org.springframework.beans.factory.BeanClassLoaderAware;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.lang.Nullable;
import org.springframework.oxm.MarshallingFailureException;
import org.springframework.oxm.UncategorizedMappingException;
import org.springframework.oxm.UnmarshallingFailureException;
import org.springframework.oxm.XmlMappingException;
import org.springframework.oxm.support.AbstractMarshaller;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;
import org.springframework.util.xml.StaxUtils;

/**
 * Implementation of the {@code Marshaller} interface for XStream.
 *
 * &lt;p&gt;By default, XStream does not require any further configuration and can (un)marshal
 * any class on the classpath. As such, it is &lt;b&gt;not recommended to use the
 * {@code XStreamMarshaller} to unmarshal XML from external sources&lt;/b&gt; (i.e. the Web),
 * as this can result in &lt;b&gt;security vulnerabilities&lt;/b&gt;. If you do use the
 * {@code XStreamMarshaller} to unmarshal external XML, set the
 * {@link #setSupportedClasses(Class[]) supportedClasses} and
 * {@link #setConverters(ConverterMatcher[]) converters} properties (possibly using
 * a {@link CatchAllConverter}) or override the {@link #customizeXStream(XStream)}
 * method to make sure it only accepts the classes you want it to support.
 *
 * &lt;p&gt;Due to XStream's API, it is required to set the encoding used for writing to
 * OutputStreams. It defaults to {@code UTF-8}.
 *
 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; XStream is an XML serialization library, not a data binding library.
 * Therefore, it has limited namespace support. As such, it is rather unsuitable for
 * usage within Web Services.
 *
 * &lt;p&gt;This marshaller requires XStream 1.4.5 or higher, as of Spring 4.3.
 * Note that {@link XStream} construction has been reworked in 4.0, with the
 * stream driver and the class loader getting passed into XStream itself now.
 *
 * @author Peter Meijer
 * @author Arjen Poutsma
 * @author Juergen Hoeller
 * @since 3.0
 */
<span class="fc" id="L117">public class XStreamMarshaller extends AbstractMarshaller implements BeanClassLoaderAware, InitializingBean {</span>

	/**
	 * The default encoding used for stream access: UTF-8.
	 */
	public static final String DEFAULT_ENCODING = &quot;UTF-8&quot;;


	@Nullable
	private ReflectionProvider reflectionProvider;

	@Nullable
	private HierarchicalStreamDriver streamDriver;

	@Nullable
	private HierarchicalStreamDriver defaultDriver;

	@Nullable
	private Mapper mapper;

	@Nullable
	private Class&lt;? extends MapperWrapper&gt;[] mapperWrappers;

<span class="fc" id="L140">	private ConverterLookup converterLookup = new DefaultConverterLookup();</span>

<span class="fc" id="L142">	private ConverterRegistry converterRegistry = (ConverterRegistry) this.converterLookup;</span>

	@Nullable
	private ConverterMatcher[] converters;

	@Nullable
	private MarshallingStrategy marshallingStrategy;

	@Nullable
	private Integer mode;

	@Nullable
	private Map&lt;String, ?&gt; aliases;

	@Nullable
	private Map&lt;String, ?&gt; aliasesByType;

	@Nullable
	private Map&lt;String, String&gt; fieldAliases;

	@Nullable
	private Class&lt;?&gt;[] useAttributeForTypes;

	@Nullable
	private Map&lt;?, ?&gt; useAttributeFor;

	@Nullable
	private Map&lt;Class&lt;?&gt;, String&gt; implicitCollections;

	@Nullable
	private Map&lt;Class&lt;?&gt;, String&gt; omittedFields;

	@Nullable
	private Class&lt;?&gt;[] annotatedClasses;

	private boolean autodetectAnnotations;

<span class="fc" id="L179">	private String encoding = DEFAULT_ENCODING;</span>

<span class="fc" id="L181">	private NameCoder nameCoder = new XmlFriendlyNameCoder();</span>

	@Nullable
	private Class&lt;?&gt;[] supportedClasses;

<span class="fc" id="L186">	private ClassLoader beanClassLoader = new CompositeClassLoader();</span>

	@Nullable
	private XStream xstream;


	/**
	 * Set a custom XStream {@link ReflectionProvider} to use.
	 * @since 4.0
	 */
	public void setReflectionProvider(ReflectionProvider reflectionProvider) {
<span class="nc" id="L197">		this.reflectionProvider = reflectionProvider;</span>
<span class="nc" id="L198">	}</span>

	/**
	 * Set a XStream {@link HierarchicalStreamDriver} to be used for readers and writers.
	 * &lt;p&gt;As of Spring 4.0, this stream driver will also be passed to the {@link XStream}
	 * constructor and therefore used by streaming-related native API methods themselves.
	 */
	public void setStreamDriver(HierarchicalStreamDriver streamDriver) {
<span class="fc" id="L206">		this.streamDriver = streamDriver;</span>
<span class="fc" id="L207">		this.defaultDriver = streamDriver;</span>
<span class="fc" id="L208">	}</span>

	private HierarchicalStreamDriver getDefaultDriver() {
<span class="fc bfc" id="L211" title="All 2 branches covered.">		if (this.defaultDriver == null) {</span>
<span class="fc" id="L212">			this.defaultDriver = new XppDriver();</span>
		}
<span class="fc" id="L214">		return this.defaultDriver;</span>
	}

	/**
	 * Set a custom XStream {@link Mapper} to use.
	 * @since 4.0
	 */
	public void setMapper(Mapper mapper) {
<span class="nc" id="L222">		this.mapper = mapper;</span>
<span class="nc" id="L223">	}</span>

	/**
	 * Set one or more custom XStream {@link MapperWrapper} classes.
	 * Each of those classes needs to have a constructor with a single argument
	 * of type {@link Mapper} or {@link MapperWrapper}.
	 * @since 4.0
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public void setMapperWrappers(Class&lt;? extends MapperWrapper&gt;... mapperWrappers) {
<span class="nc" id="L233">		this.mapperWrappers = mapperWrappers;</span>
<span class="nc" id="L234">	}</span>

	/**
	 * Set a custom XStream {@link ConverterLookup} to use.
	 * Also used as {@link ConverterRegistry} if the given reference implements it as well.
	 * @since 4.0
	 * @see DefaultConverterLookup
	 */
	public void setConverterLookup(ConverterLookup converterLookup) {
<span class="nc" id="L243">		this.converterLookup = converterLookup;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">		if (converterLookup instanceof ConverterRegistry) {</span>
<span class="nc" id="L245">			this.converterRegistry = (ConverterRegistry) converterLookup;</span>
		}
<span class="nc" id="L247">	}</span>

	/**
	 * Set a custom XStream {@link ConverterRegistry} to use.
	 * @since 4.0
	 * @see #setConverterLookup
	 * @see DefaultConverterLookup
	 */
	public void setConverterRegistry(ConverterRegistry converterRegistry) {
<span class="nc" id="L256">		this.converterRegistry = converterRegistry;</span>
<span class="nc" id="L257">	}</span>

	/**
	 * Set the {@code Converters} or {@code SingleValueConverters} to be registered
	 * with the {@code XStream} instance.
	 * @see Converter
	 * @see SingleValueConverter
	 */
	public void setConverters(ConverterMatcher... converters) {
<span class="fc" id="L266">		this.converters = converters;</span>
<span class="fc" id="L267">	}</span>

	/**
	 * Set a custom XStream {@link MarshallingStrategy} to use.
	 * @since 4.0
	 */
	public void setMarshallingStrategy(MarshallingStrategy marshallingStrategy) {
<span class="nc" id="L274">		this.marshallingStrategy = marshallingStrategy;</span>
<span class="nc" id="L275">	}</span>

	/**
	 * Set the XStream mode to use.
	 * @see XStream#ID_REFERENCES
	 * @see XStream#NO_REFERENCES
	 */
	public void setMode(int mode) {
<span class="nc" id="L283">		this.mode = mode;</span>
<span class="nc" id="L284">	}</span>

	/**
	 * Set the alias/type map, consisting of string aliases mapped to classes.
	 * &lt;p&gt;Keys are aliases; values are either {@code Class} instances, or String class names.
	 * @see XStream#alias(String, Class)
	 */
	public void setAliases(Map&lt;String, ?&gt; aliases) {
<span class="fc" id="L292">		this.aliases = aliases;</span>
<span class="fc" id="L293">	}</span>

	/**
	 * Set the &lt;em&gt;aliases by type&lt;/em&gt; map, consisting of string aliases mapped to classes.
	 * &lt;p&gt;Any class that is assignable to this type will be aliased to the same name.
	 * Keys are aliases; values are either {@code Class} instances, or String class names.
	 * @see XStream#aliasType(String, Class)
	 */
	public void setAliasesByType(Map&lt;String, ?&gt; aliasesByType) {
<span class="nc" id="L302">		this.aliasesByType = aliasesByType;</span>
<span class="nc" id="L303">	}</span>

	/**
	 * Set the field alias/type map, consisting of field names.
	 * @see XStream#aliasField(String, Class, String)
	 */
	public void setFieldAliases(Map&lt;String, String&gt; fieldAliases) {
<span class="fc" id="L310">		this.fieldAliases = fieldAliases;</span>
<span class="fc" id="L311">	}</span>

	/**
	 * Set types to use XML attributes for.
	 * @see XStream#useAttributeFor(Class)
	 */
	public void setUseAttributeForTypes(Class&lt;?&gt;... useAttributeForTypes) {
<span class="fc" id="L318">		this.useAttributeForTypes = useAttributeForTypes;</span>
<span class="fc" id="L319">	}</span>

	/**
	 * Set the types to use XML attributes for. The given map can contain
	 * either {@code &lt;String, Class&gt;} pairs, in which case
	 * {@link XStream#useAttributeFor(String, Class)} is called.
	 * Alternatively, the map can contain {@code &lt;Class, String&gt;}
	 * or {@code &lt;Class, List&lt;String&gt;&gt;} pairs, which results
	 * in {@link XStream#useAttributeFor(Class, String)} calls.
	 */
	public void setUseAttributeFor(Map&lt;?, ?&gt; useAttributeFor) {
<span class="fc" id="L330">		this.useAttributeFor = useAttributeFor;</span>
<span class="fc" id="L331">	}</span>

	/**
	 * Specify implicit collection fields, as a Map consisting of {@code Class} instances
	 * mapped to comma separated collection field names.
	 * @see XStream#addImplicitCollection(Class, String)
	 */
	public void setImplicitCollections(Map&lt;Class&lt;?&gt;, String&gt; implicitCollections) {
<span class="fc" id="L339">		this.implicitCollections = implicitCollections;</span>
<span class="fc" id="L340">	}</span>

	/**
	 * Specify omitted fields, as a Map consisting of {@code Class} instances
	 * mapped to comma separated field names.
	 * @see XStream#omitField(Class, String)
	 */
	public void setOmittedFields(Map&lt;Class&lt;?&gt;, String&gt; omittedFields) {
<span class="fc" id="L348">		this.omittedFields = omittedFields;</span>
<span class="fc" id="L349">	}</span>

	/**
	 * Set annotated classes for which aliases will be read from class-level annotation metadata.
	 * @see XStream#processAnnotations(Class[])
	 */
	public void setAnnotatedClasses(Class&lt;?&gt;... annotatedClasses) {
<span class="fc" id="L356">		this.annotatedClasses = annotatedClasses;</span>
<span class="fc" id="L357">	}</span>

	/**
	 * Activate XStream's autodetection mode.
	 * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: Autodetection implies that the XStream instance is being configured while
	 * it is processing the XML streams, and thus introduces a potential concurrency problem.
	 * @see XStream#autodetectAnnotations(boolean)
	 */
	public void setAutodetectAnnotations(boolean autodetectAnnotations) {
<span class="nc" id="L366">		this.autodetectAnnotations = autodetectAnnotations;</span>
<span class="nc" id="L367">	}</span>

	/**
	 * Set the encoding to be used for stream access.
	 * @see #DEFAULT_ENCODING
	 */
	public void setEncoding(String encoding) {
<span class="nc" id="L374">		this.encoding = encoding;</span>
<span class="nc" id="L375">	}</span>

	@Override
	protected String getDefaultEncoding() {
<span class="nc" id="L379">		return this.encoding;</span>
	}

	/**
	 * Set a custom XStream {@link NameCoder} to use.
	 * The default is an {@link XmlFriendlyNameCoder}.
	 * @since 4.0.4
	 */
	public void setNameCoder(NameCoder nameCoder) {
<span class="nc" id="L388">		this.nameCoder = nameCoder;</span>
<span class="nc" id="L389">	}</span>

	/**
	 * Set the classes supported by this marshaller.
	 * &lt;p&gt;If this property is empty (the default), all classes are supported.
	 * @see #supports(Class)
	 */
	public void setSupportedClasses(Class&lt;?&gt;... supportedClasses) {
<span class="nc" id="L397">		this.supportedClasses = supportedClasses;</span>
<span class="nc" id="L398">	}</span>

	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
<span class="nc" id="L402">		this.beanClassLoader = classLoader;</span>
<span class="nc" id="L403">	}</span>


	@Override
	public void afterPropertiesSet() {
<span class="nc" id="L408">		this.xstream = buildXStream();</span>
<span class="nc" id="L409">	}</span>

	/**
	 * Build the native XStream delegate to be used by this marshaller,
	 * delegating to {@link #constructXStream()}, {@link #configureXStream}
	 * and {@link #customizeXStream}.
	 */
	protected XStream buildXStream() {
<span class="fc" id="L417">		XStream xstream = constructXStream();</span>
<span class="fc" id="L418">		configureXStream(xstream);</span>
<span class="fc" id="L419">		customizeXStream(xstream);</span>
<span class="fc" id="L420">		return xstream;</span>
	}

	/**
	 * Construct an XStream instance, either using one of the
	 * standard constructors or creating a custom subclass.
	 * @return the {@code XStream} instance
	 */
	protected XStream constructXStream() {
<span class="fc" id="L429">		return new XStream(this.reflectionProvider, getDefaultDriver(), new ClassLoaderReference(this.beanClassLoader),</span>
<span class="fc" id="L430">				this.mapper, this.converterLookup, this.converterRegistry) {</span>
			@Override
			protected MapperWrapper wrapMapper(MapperWrapper next) {
<span class="fc" id="L433">				MapperWrapper mapperToWrap = next;</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">				if (mapperWrappers != null) {</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">					for (Class&lt;? extends MapperWrapper&gt; mapperWrapper : mapperWrappers) {</span>
						Constructor&lt;? extends MapperWrapper&gt; ctor;
						try {
<span class="nc" id="L438">							ctor = mapperWrapper.getConstructor(Mapper.class);</span>
						}
<span class="nc" id="L440">						catch (NoSuchMethodException ex) {</span>
							try {
<span class="nc" id="L442">								ctor = mapperWrapper.getConstructor(MapperWrapper.class);</span>
							}
<span class="nc" id="L444">							catch (NoSuchMethodException ex2) {</span>
<span class="nc" id="L445">								throw new IllegalStateException(&quot;No appropriate MapperWrapper constructor found: &quot; + mapperWrapper);</span>
<span class="nc" id="L446">							}</span>
<span class="nc" id="L447">						}</span>
						try {
<span class="nc" id="L449">							mapperToWrap = ctor.newInstance(mapperToWrap);</span>
						}
<span class="nc" id="L451">						catch (Throwable ex) {</span>
<span class="nc" id="L452">							throw new IllegalStateException(&quot;Failed to construct MapperWrapper: &quot; + mapperWrapper);</span>
<span class="nc" id="L453">						}</span>
					}
				}
<span class="fc" id="L456">				return mapperToWrap;</span>
			}
		};
	}

	/**
	 * Configure the XStream instance with this marshaller's bean properties.
	 * @param xstream the {@code XStream} instance
	 */
	protected void configureXStream(XStream xstream) {
<span class="fc bfc" id="L466" title="All 2 branches covered.">		if (this.converters != null) {</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">			for (int i = 0; i &lt; this.converters.length; i++) {</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">				if (this.converters[i] instanceof Converter) {</span>
<span class="fc" id="L469">					xstream.registerConverter((Converter) this.converters[i], i);</span>
				}
<span class="nc bnc" id="L471" title="All 2 branches missed.">				else if (this.converters[i] instanceof SingleValueConverter) {</span>
<span class="nc" id="L472">					xstream.registerConverter((SingleValueConverter) this.converters[i], i);</span>
				}
				else {
<span class="nc" id="L475">					throw new IllegalArgumentException(&quot;Invalid ConverterMatcher [&quot; + this.converters[i] + &quot;]&quot;);</span>
				}
			}
		}

<span class="pc bpc" id="L480" title="1 of 2 branches missed.">		if (this.marshallingStrategy != null) {</span>
<span class="nc" id="L481">			xstream.setMarshallingStrategy(this.marshallingStrategy);</span>
		}
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">		if (this.mode != null) {</span>
<span class="nc" id="L484">			xstream.setMode(this.mode);</span>
		}

		try {
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">			if (this.aliases != null) {</span>
<span class="fc" id="L489">				Map&lt;String, Class&lt;?&gt;&gt; classMap = toClassMap(this.aliases);</span>
<span class="fc" id="L490">				classMap.forEach(xstream::alias);</span>
			}
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">			if (this.aliasesByType != null) {</span>
<span class="nc" id="L493">				Map&lt;String, Class&lt;?&gt;&gt; classMap = toClassMap(this.aliasesByType);</span>
<span class="nc" id="L494">				classMap.forEach(xstream::aliasType);</span>
			}
<span class="fc bfc" id="L496" title="All 2 branches covered.">			if (this.fieldAliases != null) {</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">				for (Map.Entry&lt;String, String&gt; entry : this.fieldAliases.entrySet()) {</span>
<span class="fc" id="L498">					String alias = entry.getValue();</span>
<span class="fc" id="L499">					String field = entry.getKey();</span>
<span class="fc" id="L500">					int idx = field.lastIndexOf('.');</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">					if (idx != -1) {</span>
<span class="fc" id="L502">						String className = field.substring(0, idx);</span>
<span class="fc" id="L503">						Class&lt;?&gt; clazz = ClassUtils.forName(className, this.beanClassLoader);</span>
<span class="fc" id="L504">						String fieldName = field.substring(idx + 1);</span>
<span class="fc" id="L505">						xstream.aliasField(alias, clazz, fieldName);</span>
<span class="fc" id="L506">					}</span>
					else {
<span class="nc" id="L508">						throw new IllegalArgumentException(&quot;Field name [&quot; + field + &quot;] does not contain '.'&quot;);</span>
					}
<span class="fc" id="L510">				}</span>
			}
		}
<span class="nc" id="L513">		catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L514">			throw new IllegalStateException(&quot;Failed to load specified alias class&quot;, ex);</span>
<span class="fc" id="L515">		}</span>

<span class="fc bfc" id="L517" title="All 2 branches covered.">		if (this.useAttributeForTypes != null) {</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">			for (Class&lt;?&gt; type : this.useAttributeForTypes) {</span>
<span class="fc" id="L519">				xstream.useAttributeFor(type);</span>
			}
		}
<span class="fc bfc" id="L522" title="All 2 branches covered.">		if (this.useAttributeFor != null) {</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">			for (Map.Entry&lt;?, ?&gt; entry : this.useAttributeFor.entrySet()) {</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">				if (entry.getKey() instanceof String) {</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">					if (entry.getValue() instanceof Class) {</span>
<span class="fc" id="L526">						xstream.useAttributeFor((String) entry.getKey(), (Class&lt;?&gt;) entry.getValue());</span>
					}
					else {
<span class="nc" id="L529">						throw new IllegalArgumentException(</span>
								&quot;'useAttributesFor' takes Map&lt;String, Class&gt; when using a map key of type String&quot;);
					}
				}
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">				else if (entry.getKey() instanceof Class) {</span>
<span class="fc" id="L534">					Class&lt;?&gt; key = (Class&lt;?&gt;) entry.getKey();</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">					if (entry.getValue() instanceof String) {</span>
<span class="fc" id="L536">						xstream.useAttributeFor(key, (String) entry.getValue());</span>
					}
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">					else if (entry.getValue() instanceof List) {</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L540">						List&lt;Object&gt; listValue = (List&lt;Object&gt;) entry.getValue();</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">						for (Object element : listValue) {</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">							if (element instanceof String) {</span>
<span class="fc" id="L543">								xstream.useAttributeFor(key, (String) element);</span>
							}
<span class="fc" id="L545">						}</span>
<span class="fc" id="L546">					}</span>
					else {
<span class="nc" id="L548">						throw new IllegalArgumentException(&quot;'useAttributesFor' property takes either Map&lt;Class, String&gt; &quot; +</span>
								&quot;or Map&lt;Class, List&lt;String&gt;&gt; when using a map key of type Class&quot;);
					}
<span class="fc" id="L551">				}</span>
				else {
<span class="nc" id="L553">					throw new IllegalArgumentException(</span>
							&quot;'useAttributesFor' property takes either a map key of type String or Class&quot;);
				}
<span class="fc" id="L556">			}</span>
		}

<span class="fc bfc" id="L559" title="All 2 branches covered.">		if (this.implicitCollections != null) {</span>
<span class="fc" id="L560">			this.implicitCollections.forEach((key, fields) -&gt; {</span>
<span class="fc" id="L561">				String[] collectionFields = StringUtils.commaDelimitedListToStringArray(fields);</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">				for (String collectionField : collectionFields) {</span>
<span class="fc" id="L563">					xstream.addImplicitCollection(key, collectionField);</span>
				}
<span class="fc" id="L565">			});</span>
		}
<span class="fc bfc" id="L567" title="All 2 branches covered.">		if (this.omittedFields != null) {</span>
<span class="fc" id="L568">			this.omittedFields.forEach((key, value) -&gt; {</span>
<span class="fc" id="L569">				String[] fields = StringUtils.commaDelimitedListToStringArray(value);</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">				for (String field : fields) {</span>
<span class="fc" id="L571">					xstream.omitField(key, field);</span>
				}
<span class="fc" id="L573">			});</span>
		}

<span class="fc bfc" id="L576" title="All 2 branches covered.">		if (this.annotatedClasses != null) {</span>
<span class="fc" id="L577">			xstream.processAnnotations(this.annotatedClasses);</span>
		}
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">		if (this.autodetectAnnotations) {</span>
<span class="nc" id="L580">			xstream.autodetectAnnotations(true);</span>
		}
<span class="fc" id="L582">	}</span>

	private Map&lt;String, Class&lt;?&gt;&gt; toClassMap(Map&lt;String, ?&gt; map) throws ClassNotFoundException {
<span class="fc" id="L585">		Map&lt;String, Class&lt;?&gt;&gt; result = new LinkedHashMap&lt;&gt;(map.size());</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">		for (Map.Entry&lt;String, ?&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L587">			String key = entry.getKey();</span>
<span class="fc" id="L588">			Object value = entry.getValue();</span>
			Class&lt;?&gt; type;
<span class="fc bfc" id="L590" title="All 2 branches covered.">			if (value instanceof Class) {</span>
<span class="fc" id="L591">				type = (Class&lt;?&gt;) value;</span>
			}
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">			else if (value instanceof String) {</span>
<span class="fc" id="L594">				String className = (String) value;</span>
<span class="fc" id="L595">				type = ClassUtils.forName(className, this.beanClassLoader);</span>
<span class="fc" id="L596">			}</span>
			else {
<span class="nc" id="L598">				throw new IllegalArgumentException(&quot;Unknown value [&quot; + value + &quot;] - expected String or Class&quot;);</span>
			}
<span class="fc" id="L600">			result.put(key, type);</span>
<span class="fc" id="L601">		}</span>
<span class="fc" id="L602">		return result;</span>
	}

	/**
	 * Template to allow for customizing the given {@link XStream}.
	 * &lt;p&gt;The default implementation is empty.
	 * @param xstream the {@code XStream} instance
	 */
	protected void customizeXStream(XStream xstream) {
<span class="fc" id="L611">	}</span>

	/**
	 * Return the native XStream delegate used by this marshaller.
	 * &lt;p&gt;&lt;b&gt;NOTE: This method has been marked as final as of Spring 4.0.&lt;/b&gt;
	 * It can be used to access the fully configured XStream for marshalling
	 * but not configuration purposes anymore.
	 */
	public final XStream getXStream() {
<span class="fc bfc" id="L620" title="All 2 branches covered.">		if (this.xstream == null) {</span>
<span class="fc" id="L621">			this.xstream = buildXStream();</span>
		}
<span class="fc" id="L623">		return this.xstream;</span>
	}


	@Override
	public boolean supports(Class&lt;?&gt; clazz) {
<span class="nc bnc" id="L629" title="All 2 branches missed.">		if (ObjectUtils.isEmpty(this.supportedClasses)) {</span>
<span class="nc" id="L630">			return true;</span>
		}
		else {
<span class="nc bnc" id="L633" title="All 2 branches missed.">			for (Class&lt;?&gt; supportedClass : this.supportedClasses) {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">				if (supportedClass.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L635">					return true;</span>
				}
			}
<span class="nc" id="L638">			return false;</span>
		}
	}


	// Marshalling

	@Override
	protected void marshalDomNode(Object graph, Node node) throws XmlMappingException {
		HierarchicalStreamWriter streamWriter;
<span class="fc bfc" id="L648" title="All 2 branches covered.">		if (node instanceof Document) {</span>
<span class="fc" id="L649">			streamWriter = new DomWriter((Document) node, this.nameCoder);</span>
		}
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">		else if (node instanceof Element) {</span>
<span class="fc" id="L652">			streamWriter = new DomWriter((Element) node, node.getOwnerDocument(), this.nameCoder);</span>
		}
		else {
<span class="nc" id="L655">			throw new IllegalArgumentException(&quot;DOMResult contains neither Document nor Element&quot;);</span>
		}
<span class="fc" id="L657">		doMarshal(graph, streamWriter, null);</span>
<span class="fc" id="L658">	}</span>

	@Override
	protected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter) throws XmlMappingException {
<span class="fc" id="L662">		ContentHandler contentHandler = StaxUtils.createContentHandler(eventWriter);</span>
<span class="fc" id="L663">		LexicalHandler lexicalHandler = null;</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">		if (contentHandler instanceof LexicalHandler) {</span>
<span class="fc" id="L665">			lexicalHandler = (LexicalHandler) contentHandler;</span>
		}
<span class="fc" id="L667">		marshalSaxHandlers(graph, contentHandler, lexicalHandler);</span>
<span class="fc" id="L668">	}</span>

	@Override
	protected void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter) throws XmlMappingException {
		try {
<span class="fc" id="L673">			doMarshal(graph, new StaxWriter(new QNameMap(), streamWriter, this.nameCoder), null);</span>
		}
<span class="nc" id="L675">		catch (XMLStreamException ex) {</span>
<span class="nc" id="L676">			throw convertXStreamException(ex, true);</span>
<span class="fc" id="L677">		}</span>
<span class="fc" id="L678">	}</span>

	@Override
	protected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)
			throws XmlMappingException {

<span class="fc" id="L684">		SaxWriter saxWriter = new SaxWriter(this.nameCoder);</span>
<span class="fc" id="L685">		saxWriter.setContentHandler(contentHandler);</span>
<span class="fc" id="L686">		doMarshal(graph, saxWriter, null);</span>
<span class="fc" id="L687">	}</span>

	@Override
	public void marshalOutputStream(Object graph, OutputStream outputStream) throws XmlMappingException, IOException {
<span class="fc" id="L691">		marshalOutputStream(graph, outputStream, null);</span>
<span class="fc" id="L692">	}</span>

	public void marshalOutputStream(Object graph, OutputStream outputStream, @Nullable DataHolder dataHolder)
			throws XmlMappingException, IOException {

<span class="pc bpc" id="L697" title="1 of 2 branches missed.">		if (this.streamDriver != null) {</span>
<span class="nc" id="L698">			doMarshal(graph, this.streamDriver.createWriter(outputStream), dataHolder);</span>
		}
		else {
<span class="fc" id="L701">			marshalWriter(graph, new OutputStreamWriter(outputStream, this.encoding), dataHolder);</span>
		}
<span class="fc" id="L703">	}</span>

	@Override
	public void marshalWriter(Object graph, Writer writer) throws XmlMappingException, IOException {
<span class="fc" id="L707">		marshalWriter(graph, writer, null);</span>
<span class="fc" id="L708">	}</span>

	public void marshalWriter(Object graph, Writer writer, @Nullable DataHolder dataHolder)
			throws XmlMappingException, IOException {

<span class="fc bfc" id="L713" title="All 2 branches covered.">		if (this.streamDriver != null) {</span>
<span class="fc" id="L714">			doMarshal(graph, this.streamDriver.createWriter(writer), dataHolder);</span>
		}
		else {
<span class="fc" id="L717">			doMarshal(graph, new CompactWriter(writer), dataHolder);</span>
		}
<span class="fc" id="L719">	}</span>

	/**
	 * Marshals the given graph to the given XStream HierarchicalStreamWriter.
	 * Converts exceptions using {@link #convertXStreamException}.
	 */
	private void doMarshal(Object graph, HierarchicalStreamWriter streamWriter, @Nullable DataHolder dataHolder) {
		try {
<span class="fc" id="L727">			getXStream().marshal(graph, streamWriter, dataHolder);</span>
		}
<span class="nc" id="L729">		catch (Exception ex) {</span>
<span class="nc" id="L730">			throw convertXStreamException(ex, true);</span>
		}
		finally {
			try {
<span class="fc" id="L734">				streamWriter.flush();</span>
			}
<span class="nc" id="L736">			catch (Exception ex) {</span>
<span class="nc" id="L737">				logger.debug(&quot;Could not flush HierarchicalStreamWriter&quot;, ex);</span>
<span class="fc" id="L738">			}</span>
		}
<span class="fc" id="L740">	}</span>


	// Unmarshalling

	@Override
	protected Object unmarshalStreamSource(StreamSource streamSource) throws XmlMappingException, IOException {
<span class="fc bfc" id="L747" title="All 2 branches covered.">		if (streamSource.getInputStream() != null) {</span>
<span class="fc" id="L748">			return unmarshalInputStream(streamSource.getInputStream());</span>
		}
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">		else if (streamSource.getReader() != null) {</span>
<span class="fc" id="L751">			return unmarshalReader(streamSource.getReader());</span>
		}
		else {
<span class="nc" id="L754">			throw new IllegalArgumentException(&quot;StreamSource contains neither InputStream nor Reader&quot;);</span>
		}
	}

	@Override
	protected Object unmarshalDomNode(Node node) throws XmlMappingException {
		HierarchicalStreamReader streamReader;
<span class="pc bpc" id="L761" title="1 of 2 branches missed.">		if (node instanceof Document) {</span>
<span class="fc" id="L762">			streamReader = new DomReader((Document) node, this.nameCoder);</span>
		}
<span class="nc bnc" id="L764" title="All 2 branches missed.">		else if (node instanceof Element) {</span>
<span class="nc" id="L765">			streamReader = new DomReader((Element) node, this.nameCoder);</span>
		}
		else {
<span class="nc" id="L768">			throw new IllegalArgumentException(&quot;DOMSource contains neither Document nor Element&quot;);</span>
		}
<span class="fc" id="L770">		return doUnmarshal(streamReader, null);</span>
	}

	@Override
	protected Object unmarshalXmlEventReader(XMLEventReader eventReader) throws XmlMappingException {
		try {
<span class="nc" id="L776">			XMLStreamReader streamReader = StaxUtils.createEventStreamReader(eventReader);</span>
<span class="nc" id="L777">			return unmarshalXmlStreamReader(streamReader);</span>
		}
<span class="nc" id="L779">		catch (XMLStreamException ex) {</span>
<span class="nc" id="L780">			throw convertXStreamException(ex, false);</span>
		}
	}

	@Override
	protected Object unmarshalXmlStreamReader(XMLStreamReader streamReader) throws XmlMappingException {
<span class="fc" id="L786">		return doUnmarshal(new StaxReader(new QNameMap(), streamReader, this.nameCoder), null);</span>
	}

	@Override
	protected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)
			throws XmlMappingException, IOException {

<span class="nc" id="L793">		throw new UnsupportedOperationException(</span>
				&quot;XStreamMarshaller does not support unmarshalling using SAX XMLReaders&quot;);
	}

	@Override
	public Object unmarshalInputStream(InputStream inputStream) throws XmlMappingException, IOException {
<span class="fc" id="L799">		return unmarshalInputStream(inputStream, null);</span>
	}

	public Object unmarshalInputStream(InputStream inputStream, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">		if (this.streamDriver != null) {</span>
<span class="nc" id="L804">			return doUnmarshal(this.streamDriver.createReader(inputStream), dataHolder);</span>
		}
		else {
<span class="fc" id="L807">			return unmarshalReader(new InputStreamReader(inputStream, this.encoding), dataHolder);</span>
		}
	}

	@Override
	public Object unmarshalReader(Reader reader) throws XmlMappingException, IOException {
<span class="fc" id="L813">		return unmarshalReader(reader, null);</span>
	}

	public Object unmarshalReader(Reader reader, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {
<span class="fc" id="L817">		return doUnmarshal(getDefaultDriver().createReader(reader), dataHolder);</span>
	}

	/**
	 * Unmarshals the given graph to the given XStream HierarchicalStreamWriter.
	 * Converts exceptions using {@link #convertXStreamException}.
	 */
	private Object doUnmarshal(HierarchicalStreamReader streamReader, @Nullable DataHolder dataHolder) {
		try {
<span class="fc" id="L826">			return getXStream().unmarshal(streamReader, null, dataHolder);</span>
		}
<span class="nc" id="L828">		catch (Exception ex) {</span>
<span class="nc" id="L829">			throw convertXStreamException(ex, false);</span>
		}
	}


	/**
	 * Convert the given XStream exception to an appropriate exception from the
	 * {@code org.springframework.oxm} hierarchy.
	 * &lt;p&gt;A boolean flag is used to indicate whether this exception occurs during marshalling or
	 * unmarshalling, since XStream itself does not make this distinction in its exception hierarchy.
	 * @param ex the XStream exception that occurred
	 * @param marshalling indicates whether the exception occurs during marshalling ({@code true}),
	 * or unmarshalling ({@code false})
	 * @return the corresponding {@code XmlMappingException}
	 */
	protected XmlMappingException convertXStreamException(Exception ex, boolean marshalling) {
<span class="nc bnc" id="L845" title="All 6 branches missed.">		if (ex instanceof StreamException || ex instanceof CannotResolveClassException ||</span>
				ex instanceof ConversionException) {
<span class="nc bnc" id="L847" title="All 2 branches missed.">			if (marshalling) {</span>
<span class="nc" id="L848">				return new MarshallingFailureException(&quot;XStream marshalling exception&quot;,  ex);</span>
			}
			else {
<span class="nc" id="L851">				return new UnmarshallingFailureException(&quot;XStream unmarshalling exception&quot;, ex);</span>
			}
		}
		else {
			// fallback
<span class="nc" id="L856">			return new UncategorizedMappingException(&quot;Unknown XStream exception&quot;, ex);</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>