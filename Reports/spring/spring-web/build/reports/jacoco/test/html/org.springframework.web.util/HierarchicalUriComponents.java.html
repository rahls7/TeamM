<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HierarchicalUriComponents.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-web</a> &gt; <a href="index.source.html" class="el_package">org.springframework.web.util</a> &gt; <span class="el_source">HierarchicalUriComponents.java</span></div><h1>HierarchicalUriComponents.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.util;

import java.io.ByteArrayOutputStream;
import java.io.Serializable;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.UnaryOperator;

import org.springframework.lang.NonNull;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;

/**
 * Extension of {@link UriComponents} for hierarchical URIs.
 *
 * @author Arjen Poutsma
 * @author Juergen Hoeller
 * @author Rossen Stoyanchev
 * @author Phillip Webb
 * @since 3.1.3
 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-1.2.3&quot;&gt;Hierarchical URIs&lt;/a&gt;
 */
@SuppressWarnings(&quot;serial&quot;)
final class HierarchicalUriComponents extends UriComponents {

	private static final char PATH_DELIMITER = '/';

	private static final String PATH_DELIMITER_STRING = &quot;/&quot;;

<span class="fc" id="L58">	private static final MultiValueMap&lt;String, String&gt; EMPTY_QUERY_PARAMS =</span>
<span class="fc" id="L59">			CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap&lt;&gt;());</span>


	/**
	 * Represents an empty path.
	 */
<span class="fc" id="L65">	static final PathComponent NULL_PATH_COMPONENT = new PathComponent() {</span>
		@Override
		public String getPath() {
<span class="fc" id="L68">			return &quot;&quot;;</span>
		}
		@Override
		public List&lt;String&gt; getPathSegments() {
<span class="fc" id="L72">			return Collections.emptyList();</span>
		}
		@Override
		public PathComponent encode(BiFunction&lt;String, Type, String&gt; encoder) {
<span class="fc" id="L76">			return this;</span>
		}
		@Override
		public void verify() {
<span class="fc" id="L80">		}</span>
		@Override
		public PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator&lt;String&gt; encoder) {
<span class="fc" id="L83">			return this;</span>
		}
		@Override
		public void copyToUriComponentsBuilder(UriComponentsBuilder builder) {
<span class="nc" id="L87">		}</span>
		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L90" title="All 2 branches missed.">			return (this == other);</span>
		}
		@Override
		public int hashCode() {
<span class="nc" id="L94">			return getClass().hashCode();</span>
		}
	};


	@Nullable
	private final String userInfo;

	@Nullable
	private final String host;

	@Nullable
	private final String port;

	private final PathComponent path;

	private final MultiValueMap&lt;String, String&gt; queryParams;

	private final EncodeState encodeState;

	@Nullable
	private UnaryOperator&lt;String&gt; variableEncoder;


	/**
	 * Package-private constructor. All arguments are optional, and can be {@code null}.
	 * @param scheme the scheme
	 * @param userInfo the user info
	 * @param host the host
	 * @param port the port
	 * @param path the path
	 * @param query the query parameters
	 * @param fragment the fragment
	 * @param encoded whether the components are already encoded
	 */
	HierarchicalUriComponents(@Nullable String scheme, @Nullable String fragment, @Nullable String userInfo,
			@Nullable String host, @Nullable String port, @Nullable PathComponent path,
			@Nullable MultiValueMap&lt;String, String&gt; query, boolean encoded) {

<span class="fc" id="L133">		super(scheme, fragment);</span>

<span class="fc" id="L135">		this.userInfo = userInfo;</span>
<span class="fc" id="L136">		this.host = host;</span>
<span class="fc" id="L137">		this.port = port;</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">		this.path = path != null ? path : NULL_PATH_COMPONENT;</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">		this.queryParams = query != null ? CollectionUtils.unmodifiableMultiValueMap(query) : EMPTY_QUERY_PARAMS;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">		this.encodeState = encoded ? EncodeState.FULLY_ENCODED : EncodeState.RAW;</span>

		// Check for illegal characters..
<span class="fc bfc" id="L143" title="All 2 branches covered.">		if (encoded) {</span>
<span class="fc" id="L144">			verify();</span>
		}
<span class="fc" id="L146">	}</span>

	private HierarchicalUriComponents(@Nullable String scheme, @Nullable String fragment,
			@Nullable String userInfo, @Nullable String host, @Nullable String port,
			PathComponent path, MultiValueMap&lt;String, String&gt; queryParams,
			EncodeState encodeState, @Nullable UnaryOperator&lt;String&gt; variableEncoder) {

<span class="fc" id="L153">		super(scheme, fragment);</span>

<span class="fc" id="L155">		this.userInfo = userInfo;</span>
<span class="fc" id="L156">		this.host = host;</span>
<span class="fc" id="L157">		this.port = port;</span>
<span class="fc" id="L158">		this.path = path;</span>
<span class="fc" id="L159">		this.queryParams = queryParams;</span>
<span class="fc" id="L160">		this.encodeState = encodeState;</span>
<span class="fc" id="L161">		this.variableEncoder = variableEncoder;</span>
<span class="fc" id="L162">	}</span>


	// Component getters

	@Override
	@Nullable
	public String getSchemeSpecificPart() {
<span class="nc" id="L170">		return null;</span>
	}

	@Override
	@Nullable
	public String getUserInfo() {
<span class="fc" id="L176">		return this.userInfo;</span>
	}

	@Override
	@Nullable
	public String getHost() {
<span class="fc" id="L182">		return this.host;</span>
	}

	@Override
	public int getPort() {
<span class="fc bfc" id="L187" title="All 2 branches covered.">		if (this.port == null) {</span>
<span class="fc" id="L188">			return -1;</span>
		}
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">		else if (this.port.contains(&quot;{&quot;)) {</span>
<span class="nc" id="L191">			throw new IllegalStateException(</span>
					&quot;The port contains a URI variable but has not been expanded yet: &quot; + this.port);
		}
<span class="fc" id="L194">		return Integer.parseInt(this.port);</span>
	}

	@Override
	@NonNull
	public String getPath() {
<span class="fc" id="L200">		return this.path.getPath();</span>
	}

	@Override
	public List&lt;String&gt; getPathSegments() {
<span class="fc" id="L205">		return this.path.getPathSegments();</span>
	}

	@Override
	@Nullable
	public String getQuery() {
<span class="fc bfc" id="L211" title="All 2 branches covered.">		if (!this.queryParams.isEmpty()) {</span>
<span class="fc" id="L212">			StringBuilder queryBuilder = new StringBuilder();</span>
<span class="fc" id="L213">			this.queryParams.forEach((name, values) -&gt; {</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">				if (CollectionUtils.isEmpty(values)) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">					if (queryBuilder.length() != 0) {</span>
<span class="nc" id="L216">						queryBuilder.append('&amp;');</span>
					}
<span class="nc" id="L218">					queryBuilder.append(name);</span>
				}
				else {
<span class="fc bfc" id="L221" title="All 2 branches covered.">					for (Object value : values) {</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">						if (queryBuilder.length() != 0) {</span>
<span class="fc" id="L223">							queryBuilder.append('&amp;');</span>
						}
<span class="fc" id="L225">						queryBuilder.append(name);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">						if (value != null) {</span>
<span class="fc" id="L227">							queryBuilder.append('=').append(value.toString());</span>
						}
<span class="fc" id="L229">					}</span>
				}
<span class="fc" id="L231">			});</span>
<span class="fc" id="L232">			return queryBuilder.toString();</span>
		}
		else {
<span class="fc" id="L235">			return null;</span>
		}
	}

	/**
	 * Return the map of query parameters. Empty if no query has been set.
	 */
	@Override
	public MultiValueMap&lt;String, String&gt; getQueryParams() {
<span class="fc" id="L244">		return this.queryParams;</span>
	}


	// Encoding

	/**
	 * Identical to {@link #encode()} but skipping over URI variable placeholders.
	 * Also {@link #variableEncoder} is initialized with the given charset for
	 * use later when URI variables are expanded.
	 */
	HierarchicalUriComponents encodeTemplate(Charset charset) {
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">		if (this.encodeState.isEncoded()) {</span>
<span class="nc" id="L257">			return this;</span>
		}

		// Remember the charset to encode URI variables later..
<span class="fc" id="L261">		this.variableEncoder = value -&gt; encodeUriComponent(value, charset, Type.URI);</span>

<span class="fc" id="L263">		UriTemplateEncoder encoder = new UriTemplateEncoder(charset);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">		String schemeTo = (getScheme() != null ? encoder.apply(getScheme(), Type.SCHEME) : null);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">		String fragmentTo = (getFragment() != null ? encoder.apply(getFragment(), Type.FRAGMENT) : null);</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">		String userInfoTo = (getUserInfo() != null ? encoder.apply(getUserInfo(), Type.USER_INFO) : null);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">		String hostTo = (getHost() != null ? encoder.apply(getHost(), getHostType()) : null);</span>
<span class="fc" id="L268">		PathComponent pathTo = this.path.encode(encoder);</span>
<span class="fc" id="L269">		MultiValueMap&lt;String, String&gt; queryParamsTo = encodeQueryParams(encoder);</span>

<span class="fc" id="L271">		return new HierarchicalUriComponents(schemeTo, fragmentTo, userInfoTo,</span>
				hostTo, this.port, pathTo, queryParamsTo, EncodeState.TEMPLATE_ENCODED, this.variableEncoder);
	}

	@Override
	public HierarchicalUriComponents encode(Charset charset) {
<span class="fc bfc" id="L277" title="All 2 branches covered.">		if (this.encodeState.isEncoded()) {</span>
<span class="fc" id="L278">			return this;</span>
		}
<span class="fc" id="L280">		String scheme = getScheme();</span>
<span class="fc" id="L281">		String fragment = getFragment();</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">		String schemeTo = (scheme != null ? encodeUriComponent(scheme, charset, Type.SCHEME) : null);</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">		String fragmentTo = (fragment != null ? encodeUriComponent(fragment, charset, Type.FRAGMENT) : null);</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">		String userInfoTo = (this.userInfo != null ? encodeUriComponent(this.userInfo, charset, Type.USER_INFO) : null);</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">		String hostTo = (this.host != null ? encodeUriComponent(this.host, charset, getHostType()) : null);</span>
<span class="fc" id="L286">		BiFunction&lt;String, Type, String&gt; encoder = (s, type) -&gt; encodeUriComponent(s, charset, type);</span>
<span class="fc" id="L287">		PathComponent pathTo = this.path.encode(encoder);</span>
<span class="fc" id="L288">		MultiValueMap&lt;String, String&gt; queryParamsTo = encodeQueryParams(encoder);</span>

<span class="fc" id="L290">		return new HierarchicalUriComponents(schemeTo, fragmentTo, userInfoTo,</span>
				hostTo, this.port, pathTo, queryParamsTo, EncodeState.FULLY_ENCODED, null);
	}

	private MultiValueMap&lt;String, String&gt; encodeQueryParams(BiFunction&lt;String, Type, String&gt; encoder) {
<span class="fc" id="L295">		int size = this.queryParams.size();</span>
<span class="fc" id="L296">		MultiValueMap&lt;String, String&gt; result = new LinkedMultiValueMap&lt;&gt;(size);</span>
<span class="fc" id="L297">		this.queryParams.forEach((key, values) -&gt; {</span>
<span class="fc" id="L298">			String name = encoder.apply(key, Type.QUERY_PARAM);</span>
<span class="fc" id="L299">			List&lt;String&gt; encodedValues = new ArrayList&lt;&gt;(values.size());</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">			for (String value : values) {</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">				encodedValues.add(value != null ? encoder.apply(value, Type.QUERY_PARAM) : null);</span>
<span class="fc" id="L302">			}</span>
<span class="fc" id="L303">			result.put(name, encodedValues);</span>
<span class="fc" id="L304">		});</span>
<span class="fc" id="L305">		return CollectionUtils.unmodifiableMultiValueMap(result);</span>
	}

	/**
	 * Encode the given source into an encoded String using the rules specified
	 * by the given component and with the given options.
	 * @param source the source String
	 * @param encoding the encoding of the source String
	 * @param type the URI component for the source
	 * @return the encoded URI
	 * @throws IllegalArgumentException when the given value is not a valid URI component
	 */
	static String encodeUriComponent(String source, String encoding, Type type) {
<span class="nc" id="L318">		return encodeUriComponent(source, Charset.forName(encoding), type);</span>
	}

	/**
	 * Encode the given source into an encoded String using the rules specified
	 * by the given component and with the given options.
	 * @param source the source String
	 * @param charset the encoding of the source String
	 * @param type the URI component for the source
	 * @return the encoded URI
	 * @throws IllegalArgumentException when the given value is not a valid URI component
	 */
	static String encodeUriComponent(String source, Charset charset, Type type) {
<span class="fc bfc" id="L331" title="All 2 branches covered.">		if (!StringUtils.hasLength(source)) {</span>
<span class="fc" id="L332">			return source;</span>
		}
<span class="fc" id="L334">		Assert.notNull(charset, &quot;Charset must not be null&quot;);</span>
<span class="fc" id="L335">		Assert.notNull(type, &quot;Type must not be null&quot;);</span>

<span class="fc" id="L337">		byte[] bytes = source.getBytes(charset);</span>
<span class="fc" id="L338">		ByteArrayOutputStream bos = new ByteArrayOutputStream(bytes.length);</span>
<span class="fc" id="L339">		boolean changed = false;</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">		for (byte b : bytes) {</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">			if (b &lt; 0) {</span>
<span class="fc" id="L342">				b += 256;</span>
			}
<span class="fc bfc" id="L344" title="All 2 branches covered.">			if (type.isAllowed(b)) {</span>
<span class="fc" id="L345">				bos.write(b);</span>
			}
			else {
<span class="fc" id="L348">				bos.write('%');</span>
<span class="fc" id="L349">				char hex1 = Character.toUpperCase(Character.forDigit((b &gt;&gt; 4) &amp; 0xF, 16));</span>
<span class="fc" id="L350">				char hex2 = Character.toUpperCase(Character.forDigit(b &amp; 0xF, 16));</span>
<span class="fc" id="L351">				bos.write(hex1);</span>
<span class="fc" id="L352">				bos.write(hex2);</span>
<span class="fc" id="L353">				changed = true;</span>
			}
		}
<span class="fc bfc" id="L356" title="All 2 branches covered.">		return (changed ? new String(bos.toByteArray(), charset) : source);</span>
	}

	private Type getHostType() {
<span class="fc bfc" id="L360" title="All 4 branches covered.">		return (this.host != null &amp;&amp; this.host.startsWith(&quot;[&quot;) ? Type.HOST_IPV6 : Type.HOST_IPV4);</span>
	}

	// Verifying

	/**
	 * Check if any of the URI components contain any illegal characters.
	 * @throws IllegalArgumentException if any component has illegal characters
	 */
	private void verify() {
<span class="fc" id="L370">		verifyUriComponent(getScheme(), Type.SCHEME);</span>
<span class="fc" id="L371">		verifyUriComponent(this.userInfo, Type.USER_INFO);</span>
<span class="fc" id="L372">		verifyUriComponent(this.host, getHostType());</span>
<span class="fc" id="L373">		this.path.verify();</span>
<span class="fc" id="L374">		this.queryParams.forEach((key, values) -&gt; {</span>
<span class="fc" id="L375">			verifyUriComponent(key, Type.QUERY_PARAM);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">			for (String value : values) {</span>
<span class="fc" id="L377">				verifyUriComponent(value, Type.QUERY_PARAM);</span>
<span class="fc" id="L378">			}</span>
<span class="fc" id="L379">		});</span>
<span class="fc" id="L380">		verifyUriComponent(getFragment(), Type.FRAGMENT);</span>
<span class="fc" id="L381">	}</span>

	private static void verifyUriComponent(@Nullable String source, Type type) {
<span class="fc bfc" id="L384" title="All 2 branches covered.">		if (source == null) {</span>
<span class="fc" id="L385">			return;</span>
		}
<span class="fc" id="L387">		int length = source.length();</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">		for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L389">			char ch = source.charAt(i);</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">			if (ch == '%') {</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">				if ((i + 2) &lt; length) {</span>
<span class="fc" id="L392">					char hex1 = source.charAt(i + 1);</span>
<span class="fc" id="L393">					char hex2 = source.charAt(i + 2);</span>
<span class="fc" id="L394">					int u = Character.digit(hex1, 16);</span>
<span class="fc" id="L395">					int l = Character.digit(hex2, 16);</span>
<span class="pc bpc" id="L396" title="1 of 4 branches missed.">					if (u == -1 || l == -1) {</span>
<span class="fc" id="L397">						throw new IllegalArgumentException(&quot;Invalid encoded sequence \&quot;&quot; +</span>
<span class="fc" id="L398">								source.substring(i) + &quot;\&quot;&quot;);</span>
					}
<span class="fc" id="L400">					i += 2;</span>
<span class="fc" id="L401">				}</span>
				else {
<span class="nc" id="L403">					throw new IllegalArgumentException(&quot;Invalid encoded sequence \&quot;&quot; +</span>
<span class="nc" id="L404">							source.substring(i) + &quot;\&quot;&quot;);</span>
				}
			}
<span class="fc bfc" id="L407" title="All 2 branches covered.">			else if (!type.isAllowed(ch)) {</span>
<span class="fc" id="L408">				throw new IllegalArgumentException(&quot;Invalid character '&quot; + ch + &quot;' for &quot; +</span>
<span class="fc" id="L409">						type.name() + &quot; in \&quot;&quot; + source + &quot;\&quot;&quot;);</span>
			}
		}
<span class="fc" id="L412">	}</span>


	// Expanding

	@Override
	protected HierarchicalUriComponents expandInternal(UriTemplateVariables uriVariables) {

<span class="fc bfc" id="L420" title="All 2 branches covered.">		Assert.state(!this.encodeState.equals(EncodeState.FULLY_ENCODED),</span>
				&quot;URI components already encoded, and could not possibly contain '{' or '}'.&quot;);

		// Array-based vars rely on the below order..

<span class="fc" id="L425">		String schemeTo = expandUriComponent(getScheme(), uriVariables, this.variableEncoder);</span>
<span class="fc" id="L426">		String userInfoTo = expandUriComponent(this.userInfo, uriVariables, this.variableEncoder);</span>
<span class="fc" id="L427">		String hostTo = expandUriComponent(this.host, uriVariables, this.variableEncoder);</span>
<span class="fc" id="L428">		String portTo = expandUriComponent(this.port, uriVariables, this.variableEncoder);</span>
<span class="fc" id="L429">		PathComponent pathTo = this.path.expand(uriVariables, this.variableEncoder);</span>
<span class="fc" id="L430">		MultiValueMap&lt;String, String&gt; queryParamsTo = expandQueryParams(uriVariables);</span>
<span class="fc" id="L431">		String fragmentTo = expandUriComponent(getFragment(), uriVariables, this.variableEncoder);</span>

<span class="fc" id="L433">		return new HierarchicalUriComponents(schemeTo, fragmentTo, userInfoTo,</span>
				hostTo, portTo, pathTo, queryParamsTo, this.encodeState, this.variableEncoder);
	}

	private MultiValueMap&lt;String, String&gt; expandQueryParams(UriTemplateVariables variables) {
<span class="fc" id="L438">		int size = this.queryParams.size();</span>
<span class="fc" id="L439">		MultiValueMap&lt;String, String&gt; result = new LinkedMultiValueMap&lt;&gt;(size);</span>
<span class="fc" id="L440">		UriTemplateVariables queryVariables = new QueryUriTemplateVariables(variables);</span>
<span class="fc" id="L441">		this.queryParams.forEach((key, values) -&gt; {</span>
<span class="fc" id="L442">			String name = expandUriComponent(key, queryVariables, this.variableEncoder);</span>
<span class="fc" id="L443">			List&lt;String&gt; expandedValues = new ArrayList&lt;&gt;(values.size());</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">			for (String value : values) {</span>
<span class="fc" id="L445">				expandedValues.add(expandUriComponent(value, queryVariables, this.variableEncoder));</span>
<span class="fc" id="L446">			}</span>
<span class="fc" id="L447">			result.put(name, expandedValues);</span>
<span class="fc" id="L448">		});</span>
<span class="fc" id="L449">		return CollectionUtils.unmodifiableMultiValueMap(result);</span>
	}

	@Override
	public UriComponents normalize() {
<span class="fc" id="L454">		String normalizedPath = StringUtils.cleanPath(getPath());</span>
<span class="fc" id="L455">		FullPathComponent path = new FullPathComponent(normalizedPath);</span>
<span class="fc" id="L456">		return new HierarchicalUriComponents(getScheme(), getFragment(), this.userInfo, this.host, this.port,</span>
				path, this.queryParams, this.encodeState, this.variableEncoder);
	}


	// Other functionality

	@Override
	public String toUriString() {
<span class="fc" id="L465">		StringBuilder uriBuilder = new StringBuilder();</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">		if (getScheme() != null) {</span>
<span class="fc" id="L467">			uriBuilder.append(getScheme()).append(':');</span>
		}
<span class="pc bpc" id="L469" title="1 of 4 branches missed.">		if (this.userInfo != null || this.host != null) {</span>
<span class="fc" id="L470">			uriBuilder.append(&quot;//&quot;);</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">			if (this.userInfo != null) {</span>
<span class="nc" id="L472">				uriBuilder.append(this.userInfo).append('@');</span>
			}
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">			if (this.host != null) {</span>
<span class="fc" id="L475">				uriBuilder.append(this.host);</span>
			}
<span class="fc bfc" id="L477" title="All 2 branches covered.">			if (getPort() != -1) {</span>
<span class="fc" id="L478">				uriBuilder.append(':').append(this.port);</span>
			}
		}
<span class="fc" id="L481">		String path = getPath();</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">		if (StringUtils.hasLength(path)) {</span>
<span class="fc bfc" id="L483" title="All 4 branches covered.">			if (uriBuilder.length() != 0 &amp;&amp; path.charAt(0) != PATH_DELIMITER) {</span>
<span class="fc" id="L484">				uriBuilder.append(PATH_DELIMITER);</span>
			}
<span class="fc" id="L486">			uriBuilder.append(path);</span>
		}
<span class="fc" id="L488">		String query = getQuery();</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">		if (query != null) {</span>
<span class="fc" id="L490">			uriBuilder.append('?').append(query);</span>
		}
<span class="fc bfc" id="L492" title="All 2 branches covered.">		if (getFragment() != null) {</span>
<span class="fc" id="L493">			uriBuilder.append('#').append(getFragment());</span>
		}
<span class="fc" id="L495">		return uriBuilder.toString();</span>
	}

	@Override
	public URI toUri() {
		try {
<span class="fc bfc" id="L501" title="All 2 branches covered.">			if (this.encodeState.isEncoded()) {</span>
<span class="fc" id="L502">				return new URI(toUriString());</span>
			}
			else {
<span class="fc" id="L505">				String path = getPath();</span>
<span class="pc bpc" id="L506" title="1 of 4 branches missed.">				if (StringUtils.hasLength(path) &amp;&amp; path.charAt(0) != PATH_DELIMITER) {</span>
					// Only prefix the path delimiter if something exists before it
<span class="pc bpc" id="L508" title="3 of 8 branches missed.">					if (getScheme() != null || getUserInfo() != null || getHost() != null || getPort() != -1) {</span>
<span class="fc" id="L509">						path = PATH_DELIMITER + path;</span>
					}
				}
<span class="fc" id="L512">				return new URI(getScheme(), getUserInfo(), getHost(), getPort(), path, getQuery(), getFragment());</span>
			}
		}
<span class="nc" id="L515">		catch (URISyntaxException ex) {</span>
<span class="nc" id="L516">			throw new IllegalStateException(&quot;Could not create URI object: &quot; + ex.getMessage(), ex);</span>
		}
	}

	@Override
	protected void copyToUriComponentsBuilder(UriComponentsBuilder builder) {
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">		if (getScheme() != null) {</span>
<span class="nc" id="L523">			builder.scheme(getScheme());</span>
		}
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">		if (getUserInfo() != null) {</span>
<span class="nc" id="L526">			builder.userInfo(getUserInfo());</span>
		}
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">		if (getHost() != null) {</span>
<span class="nc" id="L529">			builder.host(getHost());</span>
		}
		// Avoid parsing the port, may have URI variable..
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">		if (this.port != null) {</span>
<span class="nc" id="L533">			builder.port(this.port);</span>
		}
<span class="fc" id="L535">		this.path.copyToUriComponentsBuilder(builder);</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">		if (!getQueryParams().isEmpty()) {</span>
<span class="fc" id="L537">			builder.queryParams(getQueryParams());</span>
		}
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">		if (getFragment() != null) {</span>
<span class="nc" id="L540">			builder.fragment(getFragment());</span>
		}
<span class="fc" id="L542">	}</span>


	@Override
	public boolean equals(Object other) {
<span class="fc bfc" id="L547" title="All 2 branches covered.">		if (this == other) {</span>
<span class="fc" id="L548">			return true;</span>
		}
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">		if (!(other instanceof HierarchicalUriComponents)) {</span>
<span class="nc" id="L551">			return false;</span>
		}
<span class="fc" id="L553">		HierarchicalUriComponents otherComp = (HierarchicalUriComponents) other;</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">		return (ObjectUtils.nullSafeEquals(getScheme(), otherComp.getScheme()) &amp;&amp;</span>
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">				ObjectUtils.nullSafeEquals(getUserInfo(), otherComp.getUserInfo()) &amp;&amp;</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">				ObjectUtils.nullSafeEquals(getHost(), otherComp.getHost()) &amp;&amp;</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">				getPort() == otherComp.getPort() &amp;&amp;</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">				this.path.equals(otherComp.path) &amp;&amp;</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">				this.queryParams.equals(otherComp.queryParams) &amp;&amp;</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">				ObjectUtils.nullSafeEquals(getFragment(), otherComp.getFragment()));</span>
	}

	@Override
	public int hashCode() {
<span class="nc" id="L565">		int result = ObjectUtils.nullSafeHashCode(getScheme());</span>
<span class="nc" id="L566">		result = 31 * result + ObjectUtils.nullSafeHashCode(this.userInfo);</span>
<span class="nc" id="L567">		result = 31 * result + ObjectUtils.nullSafeHashCode(this.host);</span>
<span class="nc" id="L568">		result = 31 * result + ObjectUtils.nullSafeHashCode(this.port);</span>
<span class="nc" id="L569">		result = 31 * result + this.path.hashCode();</span>
<span class="nc" id="L570">		result = 31 * result + this.queryParams.hashCode();</span>
<span class="nc" id="L571">		result = 31 * result + ObjectUtils.nullSafeHashCode(getFragment());</span>
<span class="nc" id="L572">		return result;</span>
	}


	// Nested types

	/**
	 * Enumeration used to identify the allowed characters per URI component.
	 * &lt;p&gt;Contains methods to indicate whether a given character is valid in a specific URI component.
	 * @see &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;
	 */
<span class="fc" id="L583">	enum Type {</span>

<span class="fc" id="L585">		SCHEME {</span>
			@Override
			public boolean isAllowed(int c) {
<span class="pc bpc" id="L588" title="1 of 10 branches missed.">				return isAlpha(c) || isDigit(c) || '+' == c || '-' == c || '.' == c;</span>
			}
		},
<span class="fc" id="L591">		AUTHORITY {</span>
			@Override
			public boolean isAllowed(int c) {
<span class="nc bnc" id="L594" title="All 8 branches missed.">				return isUnreserved(c) || isSubDelimiter(c) || ':' == c || '@' == c;</span>
			}
		},
<span class="fc" id="L597">		USER_INFO {</span>
			@Override
			public boolean isAllowed(int c) {
<span class="pc bpc" id="L600" title="1 of 6 branches missed.">				return isUnreserved(c) || isSubDelimiter(c) || ':' == c;</span>
			}
		},
<span class="fc" id="L603">		HOST_IPV4 {</span>
			@Override
			public boolean isAllowed(int c) {
<span class="pc bpc" id="L606" title="1 of 4 branches missed.">				return isUnreserved(c) || isSubDelimiter(c);</span>
			}
		},
<span class="fc" id="L609">		HOST_IPV6 {</span>
			@Override
			public boolean isAllowed(int c) {
<span class="pc bpc" id="L612" title="1 of 10 branches missed.">				return isUnreserved(c) || isSubDelimiter(c) || '[' == c || ']' == c || ':' == c;</span>
			}
		},
<span class="fc" id="L615">		PORT {</span>
			@Override
			public boolean isAllowed(int c) {
<span class="fc" id="L618">				return isDigit(c);</span>
			}
		},
<span class="fc" id="L621">		PATH {</span>
			@Override
			public boolean isAllowed(int c) {
<span class="fc bfc" id="L624" title="All 4 branches covered.">				return isPchar(c) || '/' == c;</span>
			}
		},
<span class="fc" id="L627">		PATH_SEGMENT {</span>
			@Override
			public boolean isAllowed(int c) {
<span class="fc" id="L630">				return isPchar(c);</span>
			}
		},
<span class="fc" id="L633">		QUERY {</span>
			@Override
			public boolean isAllowed(int c) {
<span class="pc bpc" id="L636" title="1 of 6 branches missed.">				return isPchar(c) || '/' == c || '?' == c;</span>
			}
		},
<span class="fc" id="L639">		QUERY_PARAM {</span>
			@Override
			public boolean isAllowed(int c) {
<span class="pc bpc" id="L642" title="1 of 4 branches missed.">				if ('=' == c || '&amp;' == c) {</span>
<span class="fc" id="L643">					return false;</span>
				}
				else {
<span class="pc bpc" id="L646" title="2 of 6 branches missed.">					return isPchar(c) || '/' == c || '?' == c;</span>
				}
			}
		},
<span class="fc" id="L650">		FRAGMENT {</span>
			@Override
			public boolean isAllowed(int c) {
<span class="pc bpc" id="L653" title="1 of 6 branches missed.">				return isPchar(c) || '/' == c || '?' == c;</span>
			}
		},
<span class="fc" id="L656">		URI {</span>
			@Override
			public boolean isAllowed(int c) {
<span class="fc" id="L659">				return isUnreserved(c);</span>
			}
		};

		/**
		 * Indicates whether the given character is allowed in this URI component.
		 * @return {@code true} if the character is allowed; {@code false} otherwise
		 */
		public abstract boolean isAllowed(int c);

		/**
		 * Indicates whether the given character is in the {@code ALPHA} set.
		 * @see &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986, appendix A&lt;/a&gt;
		 */
		protected boolean isAlpha(int c) {
<span class="fc bfc" id="L674" title="All 8 branches covered.">			return (c &gt;= 'a' &amp;&amp; c &lt;= 'z' || c &gt;= 'A' &amp;&amp; c &lt;= 'Z');</span>
		}

		/**
		 * Indicates whether the given character is in the {@code DIGIT} set.
		 * @see &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986, appendix A&lt;/a&gt;
		 */
		protected boolean isDigit(int c) {
<span class="fc bfc" id="L682" title="All 4 branches covered.">			return (c &gt;= '0' &amp;&amp; c &lt;= '9');</span>
		}

		/**
		 * Indicates whether the given character is in the {@code gen-delims} set.
		 * @see &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986, appendix A&lt;/a&gt;
		 */
		protected boolean isGenericDelimiter(int c) {
<span class="nc bnc" id="L690" title="All 14 branches missed.">			return (':' == c || '/' == c || '?' == c || '#' == c || '[' == c || ']' == c || '@' == c);</span>
		}

		/**
		 * Indicates whether the given character is in the {@code sub-delims} set.
		 * @see &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986, appendix A&lt;/a&gt;
		 */
		protected boolean isSubDelimiter(int c) {
<span class="pc bpc" id="L698" title="6 of 22 branches missed.">			return ('!' == c || '$' == c || '&amp;' == c || '\'' == c || '(' == c || ')' == c || '*' == c || '+' == c ||</span>
					',' == c || ';' == c || '=' == c);
		}

		/**
		 * Indicates whether the given character is in the {@code reserved} set.
		 * @see &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986, appendix A&lt;/a&gt;
		 */
		protected boolean isReserved(int c) {
<span class="nc bnc" id="L707" title="All 4 branches missed.">			return (isGenericDelimiter(c) || isSubDelimiter(c));</span>
		}

		/**
		 * Indicates whether the given character is in the {@code unreserved} set.
		 * @see &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986, appendix A&lt;/a&gt;
		 */
		protected boolean isUnreserved(int c) {
<span class="pc bpc" id="L715" title="1 of 12 branches missed.">			return (isAlpha(c) || isDigit(c) || '-' == c || '.' == c || '_' == c || '~' == c);</span>
		}

		/**
		 * Indicates whether the given character is in the {@code pchar} set.
		 * @see &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986, appendix A&lt;/a&gt;
		 */
		protected boolean isPchar(int c) {
<span class="pc bpc" id="L723" title="1 of 8 branches missed.">			return (isUnreserved(c) || isSubDelimiter(c) || ':' == c || '@' == c);</span>
		}
	}


<span class="fc" id="L728">	private enum EncodeState {</span>

		/**
		 * Not encoded.
		 */
<span class="fc" id="L733">		RAW,</span>

		/**
		 * URI vars expanded first and then each URI component encoded by
		 * quoting only illegal characters within that URI component.
		 */
<span class="fc" id="L739">		FULLY_ENCODED,</span>

		/**
		 * URI template encoded first by quoting illegal characters only, and
		 * then URI vars encoded more strictly when expanded, by quoting both
		 * illegal chars and chars with reserved meaning.
 		 */
<span class="fc" id="L746">		TEMPLATE_ENCODED;</span>


		public boolean isEncoded() {
<span class="pc bpc" id="L750" title="1 of 4 branches missed.">			return this.equals(FULLY_ENCODED) || this.equals(TEMPLATE_ENCODED);</span>
		}
	}


	private static class UriTemplateEncoder	implements BiFunction&lt;String, Type, String&gt; {

		private final Charset charset;

<span class="fc" id="L759">		private final StringBuilder currentLiteral = new StringBuilder();</span>

<span class="fc" id="L761">		private final StringBuilder currentVariable = new StringBuilder();</span>

<span class="fc" id="L763">		private final StringBuilder output = new StringBuilder();</span>


<span class="fc" id="L766">		public UriTemplateEncoder(Charset charset) {</span>
<span class="fc" id="L767">			this.charset = charset;</span>
<span class="fc" id="L768">		}</span>


		@Override
		public String apply(String source, Type type) {

			// Only URI variable (nothing to encode)..
<span class="fc bfc" id="L775" title="All 6 branches covered.">			if (source.length() &gt; 1 &amp;&amp; source.charAt(0) == '{' &amp;&amp; source.charAt(source.length() -1) == '}') {</span>
<span class="fc" id="L776">				return source;</span>
			}

			// Only literal (encode full source)..
<span class="fc bfc" id="L780" title="All 2 branches covered.">			if (source.indexOf('{') == -1) {</span>
<span class="fc" id="L781">				return encodeUriComponent(source, this.charset, type);</span>
			}

			// Mixed literal parts and URI variables, maybe (encode literal parts only)..
<span class="fc" id="L785">			int level = 0;</span>
<span class="fc" id="L786">			clear(this.currentLiteral);</span>
<span class="fc" id="L787">			clear(this.currentVariable);</span>
<span class="fc" id="L788">			clear(this.output);</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">			for (char c : source.toCharArray()) {</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">				if (c == '{') {</span>
<span class="fc" id="L791">					level++;</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">					if (level == 1) {</span>
<span class="fc" id="L793">						encodeAndAppendCurrentLiteral(type);</span>
					}
				}
<span class="pc bpc" id="L796" title="1 of 4 branches missed.">				if (c == '}' &amp;&amp; level &gt; 0) {</span>
<span class="fc" id="L797">					level--;</span>
<span class="fc" id="L798">					this.currentVariable.append('}');</span>
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">					if (level == 0) {</span>
<span class="fc" id="L800">						this.output.append(this.currentVariable);</span>
<span class="fc" id="L801">						clear(this.currentVariable);</span>
					}
				}
<span class="fc bfc" id="L804" title="All 2 branches covered.">				else if (level &gt; 0) {</span>
<span class="fc" id="L805">					this.currentVariable.append(c);</span>
				}
				else {
<span class="fc" id="L808">					this.currentLiteral.append(c);</span>
				}
			}
<span class="fc bfc" id="L811" title="All 2 branches covered.">			if (level &gt; 0) {</span>
<span class="fc" id="L812">				this.currentLiteral.append(this.currentVariable);</span>
			}
<span class="fc" id="L814">			encodeAndAppendCurrentLiteral(type);</span>
<span class="fc" id="L815">			return this.output.toString();</span>
		}

		private void encodeAndAppendCurrentLiteral(Type type) {
<span class="fc" id="L819">			this.output.append(encodeUriComponent(this.currentLiteral.toString(), this.charset, type));</span>
<span class="fc" id="L820">			clear(this.currentLiteral);</span>
<span class="fc" id="L821">		}</span>

		private void clear(StringBuilder sb) {
<span class="fc" id="L824">			sb.delete(0, sb.length());</span>
<span class="fc" id="L825">		}</span>
	}


	/**
	 * Defines the contract for path (segments).
	 */
	interface PathComponent extends Serializable {

		String getPath();

		List&lt;String&gt; getPathSegments();

		PathComponent encode(BiFunction&lt;String, Type, String&gt; encoder);

		void verify();

		PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator&lt;String&gt; encoder);

		void copyToUriComponentsBuilder(UriComponentsBuilder builder);
	}


	/**
	 * Represents a path backed by a String.
	 */
	static final class FullPathComponent implements PathComponent {

		private final String path;

<span class="fc" id="L855">		public FullPathComponent(@Nullable String path) {</span>
<span class="pc bpc" id="L856" title="1 of 2 branches missed.">			this.path = (path != null ? path : &quot;&quot;);</span>
<span class="fc" id="L857">		}</span>

		@Override
		public String getPath() {
<span class="fc" id="L861">			return this.path;</span>
		}

		@Override
		public List&lt;String&gt; getPathSegments() {
<span class="fc" id="L866">			String[] segments = StringUtils.tokenizeToStringArray(getPath(), PATH_DELIMITER_STRING);</span>
<span class="fc" id="L867">			return Collections.unmodifiableList(Arrays.asList(segments));</span>
		}

		@Override
		public PathComponent encode(BiFunction&lt;String, Type, String&gt; encoder) {
<span class="fc" id="L872">			String encodedPath = encoder.apply(getPath(), Type.PATH);</span>
<span class="fc" id="L873">			return new FullPathComponent(encodedPath);</span>
		}

		@Override
		public void verify() {
<span class="fc" id="L878">			verifyUriComponent(getPath(), Type.PATH);</span>
<span class="fc" id="L879">		}</span>

		@Override
		public PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator&lt;String&gt; encoder) {
<span class="fc" id="L883">			String expandedPath = expandUriComponent(getPath(), uriVariables, encoder);</span>
<span class="fc" id="L884">			return new FullPathComponent(expandedPath);</span>
		}

		@Override
		public void copyToUriComponentsBuilder(UriComponentsBuilder builder) {
<span class="fc" id="L889">			builder.path(getPath());</span>
<span class="fc" id="L890">		}</span>

		@Override
		public boolean equals(Object other) {
<span class="pc bpc" id="L894" title="2 of 4 branches missed.">			return (this == other || (other instanceof FullPathComponent &amp;&amp;</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">					getPath().equals(((FullPathComponent) other).getPath())));</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L900">			return getPath().hashCode();</span>
		}
	}


	/**
	 * Represents a path backed by a String list (i.e. path segments).
	 */
	static final class PathSegmentComponent implements PathComponent {

		private final List&lt;String&gt; pathSegments;

<span class="fc" id="L912">		public PathSegmentComponent(List&lt;String&gt; pathSegments) {</span>
<span class="fc" id="L913">			Assert.notNull(pathSegments, &quot;List must not be null&quot;);</span>
<span class="fc" id="L914">			this.pathSegments = Collections.unmodifiableList(new ArrayList&lt;&gt;(pathSegments));</span>
<span class="fc" id="L915">		}</span>

		@Override
		public String getPath() {
<span class="fc" id="L919">			StringBuilder pathBuilder = new StringBuilder();</span>
<span class="fc" id="L920">			pathBuilder.append(PATH_DELIMITER);</span>
<span class="fc bfc" id="L921" title="All 2 branches covered.">			for (Iterator&lt;String&gt; iterator = this.pathSegments.iterator(); iterator.hasNext(); ) {</span>
<span class="fc" id="L922">				String pathSegment = iterator.next();</span>
<span class="fc" id="L923">				pathBuilder.append(pathSegment);</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">				if (iterator.hasNext()) {</span>
<span class="fc" id="L925">					pathBuilder.append(PATH_DELIMITER);</span>
				}
<span class="fc" id="L927">			}</span>
<span class="fc" id="L928">			return pathBuilder.toString();</span>
		}

		@Override
		public List&lt;String&gt; getPathSegments() {
<span class="fc" id="L933">			return this.pathSegments;</span>
		}

		@Override
		public PathComponent encode(BiFunction&lt;String, Type, String&gt; encoder) {
<span class="fc" id="L938">			List&lt;String&gt; pathSegments = getPathSegments();</span>
<span class="fc" id="L939">			List&lt;String&gt; encodedPathSegments = new ArrayList&lt;&gt;(pathSegments.size());</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">			for (String pathSegment : pathSegments) {</span>
<span class="fc" id="L941">				String encodedPathSegment = encoder.apply(pathSegment, Type.PATH_SEGMENT);</span>
<span class="fc" id="L942">				encodedPathSegments.add(encodedPathSegment);</span>
<span class="fc" id="L943">			}</span>
<span class="fc" id="L944">			return new PathSegmentComponent(encodedPathSegments);</span>
		}

		@Override
		public void verify() {
<span class="nc bnc" id="L949" title="All 2 branches missed.">			for (String pathSegment : getPathSegments()) {</span>
<span class="nc" id="L950">				verifyUriComponent(pathSegment, Type.PATH_SEGMENT);</span>
<span class="nc" id="L951">			}</span>
<span class="nc" id="L952">		}</span>

		@Override
		public PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator&lt;String&gt; encoder) {
<span class="fc" id="L956">			List&lt;String&gt; pathSegments = getPathSegments();</span>
<span class="fc" id="L957">			List&lt;String&gt; expandedPathSegments = new ArrayList&lt;&gt;(pathSegments.size());</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">			for (String pathSegment : pathSegments) {</span>
<span class="fc" id="L959">				String expandedPathSegment = expandUriComponent(pathSegment, uriVariables, encoder);</span>
<span class="fc" id="L960">				expandedPathSegments.add(expandedPathSegment);</span>
<span class="fc" id="L961">			}</span>
<span class="fc" id="L962">			return new PathSegmentComponent(expandedPathSegments);</span>
		}

		@Override
		public void copyToUriComponentsBuilder(UriComponentsBuilder builder) {
<span class="fc" id="L967">			builder.pathSegment(StringUtils.toStringArray(getPathSegments()));</span>
<span class="fc" id="L968">		}</span>

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L972" title="All 4 branches missed.">			return (this == other || (other instanceof PathSegmentComponent &amp;&amp;</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">					getPathSegments().equals(((PathSegmentComponent) other).getPathSegments())));</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L978">			return getPathSegments().hashCode();</span>
		}
	}


	/**
	 * Represents a collection of PathComponents.
	 */
	static final class PathComponentComposite implements PathComponent {

		private final List&lt;PathComponent&gt; pathComponents;

<span class="fc" id="L990">		public PathComponentComposite(List&lt;PathComponent&gt; pathComponents) {</span>
<span class="fc" id="L991">			Assert.notNull(pathComponents, &quot;PathComponent List must not be null&quot;);</span>
<span class="fc" id="L992">			this.pathComponents = pathComponents;</span>
<span class="fc" id="L993">		}</span>

		@Override
		public String getPath() {
<span class="fc" id="L997">			StringBuilder pathBuilder = new StringBuilder();</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">			for (PathComponent pathComponent : this.pathComponents) {</span>
<span class="fc" id="L999">				pathBuilder.append(pathComponent.getPath());</span>
<span class="fc" id="L1000">			}</span>
<span class="fc" id="L1001">			return pathBuilder.toString();</span>
		}

		@Override
		public List&lt;String&gt; getPathSegments() {
<span class="fc" id="L1006">			List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">			for (PathComponent pathComponent : this.pathComponents) {</span>
<span class="fc" id="L1008">				result.addAll(pathComponent.getPathSegments());</span>
<span class="fc" id="L1009">			}</span>
<span class="fc" id="L1010">			return result;</span>
		}

		@Override
		public PathComponent encode(BiFunction&lt;String, Type, String&gt; encoder) {
<span class="fc" id="L1015">			List&lt;PathComponent&gt; encodedComponents = new ArrayList&lt;&gt;(this.pathComponents.size());</span>
<span class="fc bfc" id="L1016" title="All 2 branches covered.">			for (PathComponent pathComponent : this.pathComponents) {</span>
<span class="fc" id="L1017">				encodedComponents.add(pathComponent.encode(encoder));</span>
<span class="fc" id="L1018">			}</span>
<span class="fc" id="L1019">			return new PathComponentComposite(encodedComponents);</span>
		}

		@Override
		public void verify() {
<span class="nc bnc" id="L1024" title="All 2 branches missed.">			for (PathComponent pathComponent : this.pathComponents) {</span>
<span class="nc" id="L1025">				pathComponent.verify();</span>
<span class="nc" id="L1026">			}</span>
<span class="nc" id="L1027">		}</span>

		@Override
		public PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator&lt;String&gt; encoder) {
<span class="fc" id="L1031">			List&lt;PathComponent&gt; expandedComponents = new ArrayList&lt;&gt;(this.pathComponents.size());</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">			for (PathComponent pathComponent : this.pathComponents) {</span>
<span class="fc" id="L1033">				expandedComponents.add(pathComponent.expand(uriVariables, encoder));</span>
<span class="fc" id="L1034">			}</span>
<span class="fc" id="L1035">			return new PathComponentComposite(expandedComponents);</span>
		}

		@Override
		public void copyToUriComponentsBuilder(UriComponentsBuilder builder) {
<span class="fc bfc" id="L1040" title="All 2 branches covered.">			for (PathComponent pathComponent : this.pathComponents) {</span>
<span class="fc" id="L1041">				pathComponent.copyToUriComponentsBuilder(builder);</span>
<span class="fc" id="L1042">			}</span>
<span class="fc" id="L1043">		}</span>
	}


	private static class QueryUriTemplateVariables implements UriTemplateVariables {

		private final UriTemplateVariables delegate;

<span class="fc" id="L1051">		public QueryUriTemplateVariables(UriTemplateVariables delegate) {</span>
<span class="fc" id="L1052">			this.delegate = delegate;</span>
<span class="fc" id="L1053">		}</span>

		@Override
		public Object getValue(@Nullable String name) {
<span class="fc" id="L1057">			Object value = this.delegate.getValue(name);</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">			if (ObjectUtils.isArray(value)) {</span>
<span class="fc" id="L1059">				value = StringUtils.arrayToCommaDelimitedString(ObjectUtils.toObjectArray(value));</span>
			}
<span class="fc" id="L1061">			return value;</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>