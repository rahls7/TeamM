<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HttpHeaders.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-web</a> &gt; <a href="index.source.html" class="el_package">org.springframework.http</a> &gt; <span class="el_source">HttpHeaders.java</span></div><h1>HttpHeaders.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.http;

import java.io.Serializable;
import java.net.InetSocketAddress;
import java.net.URI;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.StandardCharsets;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.StringJoiner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;
import org.springframework.util.LinkedCaseInsensitiveMap;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.StringUtils;

/**
 * A data structure representing HTTP request or response headers, mapping String header names
 * to a list of String values, also offering accessors for common application-level data types.
 *
 * &lt;p&gt;In addition to the regular methods defined by {@link Map}, this class offers many common
 * convenience methods, for example:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #getFirst(String)} returns the first value associated with a given header name&lt;/li&gt;
 * &lt;li&gt;{@link #add(String, String)} adds a header value to the list of values for a header name&lt;/li&gt;
 * &lt;li&gt;{@link #set(String, String)} sets the header value to a single string value&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Arjen Poutsma
 * @author Sebastien Deleuze
 * @author Brian Clozel
 * @author Juergen Hoeller
 * @author Josh Long
 * @since 3.0
 */
public class HttpHeaders implements MultiValueMap&lt;String, String&gt;, Serializable {

	private static final long serialVersionUID = -8578554704772377436L;


	/**
	 * The HTTP {@code Accept} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.3.2&quot;&gt;Section 5.3.2 of RFC 7231&lt;/a&gt;
	 */
	public static final String ACCEPT = &quot;Accept&quot;;
	/**
	 * The HTTP {@code Accept-Charset} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.3.3&quot;&gt;Section 5.3.3 of RFC 7231&lt;/a&gt;
	 */
	public static final String ACCEPT_CHARSET = &quot;Accept-Charset&quot;;
	/**
	 * The HTTP {@code Accept-Encoding} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.3.4&quot;&gt;Section 5.3.4 of RFC 7231&lt;/a&gt;
	 */
	public static final String ACCEPT_ENCODING = &quot;Accept-Encoding&quot;;
	/**
	 * The HTTP {@code Accept-Language} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.3.5&quot;&gt;Section 5.3.5 of RFC 7231&lt;/a&gt;
	 */
	public static final String ACCEPT_LANGUAGE = &quot;Accept-Language&quot;;
	/**
	 * The HTTP {@code Accept-Ranges} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;Section 5.3.5 of RFC 7233&lt;/a&gt;
	 */
	public static final String ACCEPT_RANGES = &quot;Accept-Ranges&quot;;
	/**
	 * The CORS {@code Access-Control-Allow-Credentials} response header field name.
	 * @see &lt;a href=&quot;http://www.w3.org/TR/cors/&quot;&gt;CORS W3C recommendation&lt;/a&gt;
	 */
	public static final String ACCESS_CONTROL_ALLOW_CREDENTIALS = &quot;Access-Control-Allow-Credentials&quot;;
	/**
	 * The CORS {@code Access-Control-Allow-Headers} response header field name.
	 * @see &lt;a href=&quot;http://www.w3.org/TR/cors/&quot;&gt;CORS W3C recommendation&lt;/a&gt;
	 */
	public static final String ACCESS_CONTROL_ALLOW_HEADERS = &quot;Access-Control-Allow-Headers&quot;;
	/**
	 * The CORS {@code Access-Control-Allow-Methods} response header field name.
	 * @see &lt;a href=&quot;http://www.w3.org/TR/cors/&quot;&gt;CORS W3C recommendation&lt;/a&gt;
	 */
	public static final String ACCESS_CONTROL_ALLOW_METHODS = &quot;Access-Control-Allow-Methods&quot;;
	/**
	 * The CORS {@code Access-Control-Allow-Origin} response header field name.
	 * @see &lt;a href=&quot;http://www.w3.org/TR/cors/&quot;&gt;CORS W3C recommendation&lt;/a&gt;
	 */
	public static final String ACCESS_CONTROL_ALLOW_ORIGIN = &quot;Access-Control-Allow-Origin&quot;;
	/**
	 * The CORS {@code Access-Control-Expose-Headers} response header field name.
	 * @see &lt;a href=&quot;http://www.w3.org/TR/cors/&quot;&gt;CORS W3C recommendation&lt;/a&gt;
	 */
	public static final String ACCESS_CONTROL_EXPOSE_HEADERS = &quot;Access-Control-Expose-Headers&quot;;
	/**
	 * The CORS {@code Access-Control-Max-Age} response header field name.
	 * @see &lt;a href=&quot;http://www.w3.org/TR/cors/&quot;&gt;CORS W3C recommendation&lt;/a&gt;
	 */
	public static final String ACCESS_CONTROL_MAX_AGE = &quot;Access-Control-Max-Age&quot;;
	/**
	 * The CORS {@code Access-Control-Request-Headers} request header field name.
	 * @see &lt;a href=&quot;http://www.w3.org/TR/cors/&quot;&gt;CORS W3C recommendation&lt;/a&gt;
	 */
	public static final String ACCESS_CONTROL_REQUEST_HEADERS = &quot;Access-Control-Request-Headers&quot;;
	/**
	 * The CORS {@code Access-Control-Request-Method} request header field name.
	 * @see &lt;a href=&quot;http://www.w3.org/TR/cors/&quot;&gt;CORS W3C recommendation&lt;/a&gt;
	 */
	public static final String ACCESS_CONTROL_REQUEST_METHOD = &quot;Access-Control-Request-Method&quot;;
	/**
	 * The HTTP {@code Age} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.1&quot;&gt;Section 5.1 of RFC 7234&lt;/a&gt;
	 */
	public static final String AGE = &quot;Age&quot;;
	/**
	 * The HTTP {@code Allow} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.4.1&quot;&gt;Section 7.4.1 of RFC 7231&lt;/a&gt;
	 */
	public static final String ALLOW = &quot;Allow&quot;;
	/**
	 * The HTTP {@code Authorization} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section 4.2 of RFC 7235&lt;/a&gt;
	 */
	public static final String AUTHORIZATION = &quot;Authorization&quot;;
	/**
	 * The HTTP {@code Cache-Control} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section 5.2 of RFC 7234&lt;/a&gt;
	 */
	public static final String CACHE_CONTROL = &quot;Cache-Control&quot;;
	/**
	 * The HTTP {@code Connection} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section 6.1 of RFC 7230&lt;/a&gt;
	 */
	public static final String CONNECTION = &quot;Connection&quot;;
	/**
	 * The HTTP {@code Content-Encoding} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.2&quot;&gt;Section 3.1.2.2 of RFC 7231&lt;/a&gt;
	 */
	public static final String CONTENT_ENCODING = &quot;Content-Encoding&quot;;
	/**
	 * The HTTP {@code Content-Disposition} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC 6266&lt;/a&gt;
	 */
	public static final String CONTENT_DISPOSITION = &quot;Content-Disposition&quot;;
	/**
	 * The HTTP {@code Content-Language} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.3.2&quot;&gt;Section 3.1.3.2 of RFC 7231&lt;/a&gt;
	 */
	public static final String CONTENT_LANGUAGE = &quot;Content-Language&quot;;
	/**
	 * The HTTP {@code Content-Length} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;Section 3.3.2 of RFC 7230&lt;/a&gt;
	 */
	public static final String CONTENT_LENGTH = &quot;Content-Length&quot;;
	/**
	 * The HTTP {@code Content-Location} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.4.2&quot;&gt;Section 3.1.4.2 of RFC 7231&lt;/a&gt;
	 */
	public static final String CONTENT_LOCATION = &quot;Content-Location&quot;;
	/**
	 * The HTTP {@code Content-Range} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Section 4.2 of RFC 7233&lt;/a&gt;
	 */
	public static final String CONTENT_RANGE = &quot;Content-Range&quot;;
	/**
	 * The HTTP {@code Content-Type} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.1.5&quot;&gt;Section 3.1.1.5 of RFC 7231&lt;/a&gt;
	 */
	public static final String CONTENT_TYPE = &quot;Content-Type&quot;;
	/**
	 * The HTTP {@code Cookie} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc2109#section-4.3.4&quot;&gt;Section 4.3.4 of RFC 2109&lt;/a&gt;
	 */
	public static final String COOKIE = &quot;Cookie&quot;;
	/**
	 * The HTTP {@code Date} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section 7.1.1.2 of RFC 7231&lt;/a&gt;
	 */
	public static final String DATE = &quot;Date&quot;;
	/**
	 * The HTTP {@code ETag} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;Section 2.3 of RFC 7232&lt;/a&gt;
	 */
	public static final String ETAG = &quot;ETag&quot;;
	/**
	 * The HTTP {@code Expect} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;Section 5.1.1 of RFC 7231&lt;/a&gt;
	 */
	public static final String EXPECT = &quot;Expect&quot;;
	/**
	 * The HTTP {@code Expires} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.3&quot;&gt;Section 5.3 of RFC 7234&lt;/a&gt;
	 */
	public static final String EXPIRES = &quot;Expires&quot;;
	/**
	 * The HTTP {@code From} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.5.1&quot;&gt;Section 5.5.1 of RFC 7231&lt;/a&gt;
	 */
	public static final String FROM = &quot;From&quot;;
	/**
	 * The HTTP {@code Host} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.4&quot;&gt;Section 5.4 of RFC 7230&lt;/a&gt;
	 */
	public static final String HOST = &quot;Host&quot;;
	/**
	 * The HTTP {@code If-Match} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;Section 3.1 of RFC 7232&lt;/a&gt;
	 */
	public static final String IF_MATCH = &quot;If-Match&quot;;
	/**
	 * The HTTP {@code If-Modified-Since} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section 3.3 of RFC 7232&lt;/a&gt;
	 */
	public static final String IF_MODIFIED_SINCE = &quot;If-Modified-Since&quot;;
	/**
	 * The HTTP {@code If-None-Match} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section 3.2 of RFC 7232&lt;/a&gt;
	 */
	public static final String IF_NONE_MATCH = &quot;If-None-Match&quot;;
	/**
	 * The HTTP {@code If-Range} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section 3.2 of RFC 7233&lt;/a&gt;
	 */
	public static final String IF_RANGE = &quot;If-Range&quot;;
	/**
	 * The HTTP {@code If-Unmodified-Since} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;Section 3.4 of RFC 7232&lt;/a&gt;
	 */
	public static final String IF_UNMODIFIED_SINCE = &quot;If-Unmodified-Since&quot;;
	/**
	 * The HTTP {@code Last-Modified} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;Section 2.2 of RFC 7232&lt;/a&gt;
	 */
	public static final String LAST_MODIFIED = &quot;Last-Modified&quot;;
	/**
	 * The HTTP {@code Link} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC 5988&lt;/a&gt;
	 */
	public static final String LINK = &quot;Link&quot;;
	/**
	 * The HTTP {@code Location} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.2&quot;&gt;Section 7.1.2 of RFC 7231&lt;/a&gt;
	 */
	public static final String LOCATION = &quot;Location&quot;;
	/**
	 * The HTTP {@code Max-Forwards} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.2&quot;&gt;Section 5.1.2 of RFC 7231&lt;/a&gt;
	 */
	public static final String MAX_FORWARDS = &quot;Max-Forwards&quot;;
	/**
	 * The HTTP {@code Origin} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc6454&quot;&gt;RFC 6454&lt;/a&gt;
	 */
	public static final String ORIGIN = &quot;Origin&quot;;
	/**
	 * The HTTP {@code Pragma} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.4&quot;&gt;Section 5.4 of RFC 7234&lt;/a&gt;
	 */
	public static final String PRAGMA = &quot;Pragma&quot;;
	/**
	 * The HTTP {@code Proxy-Authenticate} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.3&quot;&gt;Section 4.3 of RFC 7235&lt;/a&gt;
	 */
	public static final String PROXY_AUTHENTICATE = &quot;Proxy-Authenticate&quot;;
	/**
	 * The HTTP {@code Proxy-Authorization} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.4&quot;&gt;Section 4.4 of RFC 7235&lt;/a&gt;
	 */
	public static final String PROXY_AUTHORIZATION = &quot;Proxy-Authorization&quot;;
	/**
	 * The HTTP {@code Range} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.1&quot;&gt;Section 3.1 of RFC 7233&lt;/a&gt;
	 */
	public static final String RANGE = &quot;Range&quot;;
	/**
	 * The HTTP {@code Referer} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.5.2&quot;&gt;Section 5.5.2 of RFC 7231&lt;/a&gt;
	 */
	public static final String REFERER = &quot;Referer&quot;;
	/**
	 * The HTTP {@code Retry-After} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.3&quot;&gt;Section 7.1.3 of RFC 7231&lt;/a&gt;
	 */
	public static final String RETRY_AFTER = &quot;Retry-After&quot;;
	/**
	 * The HTTP {@code Server} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.4.2&quot;&gt;Section 7.4.2 of RFC 7231&lt;/a&gt;
	 */
	public static final String SERVER = &quot;Server&quot;;
	/**
	 * The HTTP {@code Set-Cookie} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc2109#section-4.2.2&quot;&gt;Section 4.2.2 of RFC 2109&lt;/a&gt;
	 */
	public static final String SET_COOKIE = &quot;Set-Cookie&quot;;
	/**
	 * The HTTP {@code Set-Cookie2} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc2965&quot;&gt;RFC 2965&lt;/a&gt;
	 */
	public static final String SET_COOKIE2 = &quot;Set-Cookie2&quot;;
	/**
	 * The HTTP {@code TE} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.3&quot;&gt;Section 4.3 of RFC 7230&lt;/a&gt;
	 */
	public static final String TE = &quot;TE&quot;;
	/**
	 * The HTTP {@code Trailer} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.4&quot;&gt;Section 4.4 of RFC 7230&lt;/a&gt;
	 */
	public static final String TRAILER = &quot;Trailer&quot;;
	/**
	 * The HTTP {@code Transfer-Encoding} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;Section 3.3.1 of RFC 7230&lt;/a&gt;
	 */
	public static final String TRANSFER_ENCODING = &quot;Transfer-Encoding&quot;;
	/**
	 * The HTTP {@code Upgrade} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section 6.7 of RFC 7230&lt;/a&gt;
	 */
	public static final String UPGRADE = &quot;Upgrade&quot;;
	/**
	 * The HTTP {@code User-Agent} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.5.3&quot;&gt;Section 5.5.3 of RFC 7231&lt;/a&gt;
	 */
	public static final String USER_AGENT = &quot;User-Agent&quot;;
	/**
	 * The HTTP {@code Vary} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.4&quot;&gt;Section 7.1.4 of RFC 7231&lt;/a&gt;
	 */
	public static final String VARY = &quot;Vary&quot;;
	/**
	 * The HTTP {@code Via} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section 5.7.1 of RFC 7230&lt;/a&gt;
	 */
	public static final String VIA = &quot;Via&quot;;
	/**
	 * The HTTP {@code Warning} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section 5.5 of RFC 7234&lt;/a&gt;
	 */
	public static final String WARNING = &quot;Warning&quot;;
	/**
	 * The HTTP {@code WWW-Authenticate} header field name.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.1&quot;&gt;Section 4.1 of RFC 7235&lt;/a&gt;
	 */
	public static final String WWW_AUTHENTICATE = &quot;WWW-Authenticate&quot;;


	/**
	 * An empty {@code HttpHeaders} instance (immutable).
	 * @since 5.0
	 */
<span class="fc" id="L384">	public static final HttpHeaders EMPTY = new ReadOnlyHttpHeaders(new HttpHeaders(new LinkedMultiValueMap&lt;&gt;(0)));</span>

	/**
	 * Pattern matching ETag multiple field values in headers such as &quot;If-Match&quot;, &quot;If-None-Match&quot;.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;Section 2.3 of RFC 7232&lt;/a&gt;
	 */
<span class="fc" id="L390">	private static final Pattern ETAG_HEADER_VALUE_PATTERN = Pattern.compile(&quot;\\*|\\s*((W\\/)?(\&quot;[^\&quot;]*\&quot;))\\s*,?&quot;);</span>

<span class="fc" id="L392">	private static final DecimalFormatSymbols DECIMAL_FORMAT_SYMBOLS = new DecimalFormatSymbols(Locale.ENGLISH);</span>

<span class="fc" id="L394">	private static final ZoneId GMT = ZoneId.of(&quot;GMT&quot;);</span>

	/**
	 * Date formats with time zone as specified in the HTTP RFC to use for formatting.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;Section 7.1.1.1 of RFC 7231&lt;/a&gt;
	 */
<span class="fc" id="L400">	private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(&quot;EEE, dd MMM yyyy HH:mm:ss zzz&quot;, Locale.US).withZone(GMT);</span>

	/**
	 * Date formats with time zone as specified in the HTTP RFC to use for parsing.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;Section 7.1.1.1 of RFC 7231&lt;/a&gt;
	 */
<span class="fc" id="L406">	private static final DateTimeFormatter[] DATE_PARSERS = new DateTimeFormatter[] {</span>
			DateTimeFormatter.RFC_1123_DATE_TIME,
<span class="fc" id="L408">			DateTimeFormatter.ofPattern(&quot;EEEE, dd-MMM-yy HH:mm:ss zzz&quot;, Locale.US),</span>
<span class="fc" id="L409">			DateTimeFormatter.ofPattern(&quot;EEE MMM dd HH:mm:ss yyyy&quot;, Locale.US).withZone(GMT)</span>
	};


	final MultiValueMap&lt;String, String&gt; headers;


	/**
	 * Construct a new, empty instance of the {@code HttpHeaders} object.
	 */
	public HttpHeaders() {
<span class="fc" id="L420">		this(CollectionUtils.toMultiValueMap(new LinkedCaseInsensitiveMap&lt;&gt;(8, Locale.ENGLISH)));</span>
<span class="fc" id="L421">	}</span>

	/**
	 * Construct a new {@code HttpHeaders} instance backed by an existing map.
	 * @since 5.1
	 */
<span class="fc" id="L427">	public HttpHeaders(MultiValueMap&lt;String, String&gt; headers) {</span>
<span class="fc" id="L428">		Assert.notNull(headers, &quot;MultiValueMap must not be null&quot;);</span>
<span class="fc" id="L429">		this.headers = headers;</span>
<span class="fc" id="L430">	}</span>


	/**
	 * Set the list of acceptable {@linkplain MediaType media types},
	 * as specified by the {@code Accept} header.
	 */
	public void setAccept(List&lt;MediaType&gt; acceptableMediaTypes) {
<span class="fc" id="L438">		set(ACCEPT, MediaType.toString(acceptableMediaTypes));</span>
<span class="fc" id="L439">	}</span>

	/**
	 * Return the list of acceptable {@linkplain MediaType media types},
	 * as specified by the {@code Accept} header.
	 * &lt;p&gt;Returns an empty list when the acceptable media types are unspecified.
	 */
	public List&lt;MediaType&gt; getAccept() {
<span class="fc" id="L447">		return MediaType.parseMediaTypes(get(ACCEPT));</span>
	}

	/**
	 * Set the acceptable language ranges, as specified by the
	 * {@literal Accept-Language} header.
	 * @since 5.0
	 */
	public void setAcceptLanguage(List&lt;Locale.LanguageRange&gt; languages) {
<span class="fc" id="L456">		Assert.notNull(languages, &quot;LanguageRange List must not be null&quot;);</span>
<span class="fc" id="L457">		DecimalFormat decimal = new DecimalFormat(&quot;0.0&quot;, DECIMAL_FORMAT_SYMBOLS);</span>
<span class="fc" id="L458">		List&lt;String&gt; values = languages.stream()</span>
<span class="fc" id="L459">				.map(range -&gt;</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">						range.getWeight() == Locale.LanguageRange.MAX_WEIGHT ?</span>
<span class="fc" id="L461">								range.getRange() :</span>
<span class="fc" id="L462">								range.getRange() + &quot;;q=&quot; + decimal.format(range.getWeight()))</span>
<span class="fc" id="L463">				.collect(Collectors.toList());</span>
<span class="fc" id="L464">		set(ACCEPT_LANGUAGE, toCommaDelimitedString(values));</span>
<span class="fc" id="L465">	}</span>

	/**
	 * Return the language ranges from the {@literal &quot;Accept-Language&quot;} header.
	 * &lt;p&gt;If you only need sorted, preferred locales only use
	 * {@link #getAcceptLanguageAsLocales()} or if you need to filter based on
	 * a list of supported locales you can pass the returned list to
	 * {@link Locale#filter(List, Collection)}.
	 * @throws IllegalArgumentException if the value cannot be converted to a language range
	 * @since 5.0
	 */
	public List&lt;Locale.LanguageRange&gt; getAcceptLanguage() {
<span class="fc" id="L477">		String value = getFirst(ACCEPT_LANGUAGE);</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">		return (StringUtils.hasText(value) ? Locale.LanguageRange.parse(value) : Collections.emptyList());</span>
	}

	/**
	 * Variant of {@link #setAcceptLanguage(List)} using {@link Locale}'s.
	 * @since 5.0
	 */
	public void setAcceptLanguageAsLocales(List&lt;Locale&gt; locales) {
<span class="fc" id="L486">		setAcceptLanguage(locales.stream()</span>
<span class="fc" id="L487">				.map(locale -&gt; new Locale.LanguageRange(locale.toLanguageTag()))</span>
<span class="fc" id="L488">				.collect(Collectors.toList()));</span>
<span class="fc" id="L489">	}</span>

	/**
	 * A variant of {@link #getAcceptLanguage()} that converts each
	 * {@link java.util.Locale.LanguageRange} to a {@link Locale}.
	 * @return the locales or an empty list
	 * @throws IllegalArgumentException if the value cannot be converted to a locale
	 * @since 5.0
	 */
	public List&lt;Locale&gt; getAcceptLanguageAsLocales() {
<span class="fc" id="L499">		List&lt;Locale.LanguageRange&gt; ranges = getAcceptLanguage();</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">		if (ranges.isEmpty()) {</span>
<span class="fc" id="L501">			return Collections.emptyList();</span>
		}
<span class="fc" id="L503">		return ranges.stream()</span>
<span class="fc" id="L504">				.map(range -&gt; Locale.forLanguageTag(range.getRange()))</span>
<span class="fc" id="L505">				.filter(locale -&gt; StringUtils.hasText(locale.getDisplayName()))</span>
<span class="fc" id="L506">				.collect(Collectors.toList());</span>
	}

	/**
	 * Set the (new) value of the {@code Access-Control-Allow-Credentials} response header.
	 */
	public void setAccessControlAllowCredentials(boolean allowCredentials) {
<span class="fc" id="L513">		set(ACCESS_CONTROL_ALLOW_CREDENTIALS, Boolean.toString(allowCredentials));</span>
<span class="fc" id="L514">	}</span>

	/**
	 * Return the value of the {@code Access-Control-Allow-Credentials} response header.
	 */
	public boolean getAccessControlAllowCredentials() {
<span class="fc" id="L520">		return Boolean.parseBoolean(getFirst(ACCESS_CONTROL_ALLOW_CREDENTIALS));</span>
	}

	/**
	 * Set the (new) value of the {@code Access-Control-Allow-Headers} response header.
	 */
	public void setAccessControlAllowHeaders(List&lt;String&gt; allowedHeaders) {
<span class="fc" id="L527">		set(ACCESS_CONTROL_ALLOW_HEADERS, toCommaDelimitedString(allowedHeaders));</span>
<span class="fc" id="L528">	}</span>

	/**
	 * Return the value of the {@code Access-Control-Allow-Headers} response header.
	 */
	public List&lt;String&gt; getAccessControlAllowHeaders() {
<span class="fc" id="L534">		return getValuesAsList(ACCESS_CONTROL_ALLOW_HEADERS);</span>
	}

	/**
	 * Set the (new) value of the {@code Access-Control-Allow-Methods} response header.
	 */
	public void setAccessControlAllowMethods(List&lt;HttpMethod&gt; allowedMethods) {
<span class="fc" id="L541">		set(ACCESS_CONTROL_ALLOW_METHODS, StringUtils.collectionToCommaDelimitedString(allowedMethods));</span>
<span class="fc" id="L542">	}</span>

	/**
	 * Return the value of the {@code Access-Control-Allow-Methods} response header.
	 */
	public List&lt;HttpMethod&gt; getAccessControlAllowMethods() {
<span class="fc" id="L548">		List&lt;HttpMethod&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L549">		String value = getFirst(ACCESS_CONTROL_ALLOW_METHODS);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">		if (value != null) {</span>
<span class="fc" id="L551">			String[] tokens = StringUtils.tokenizeToStringArray(value, &quot;,&quot;);</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">			for (String token : tokens) {</span>
<span class="fc" id="L553">				HttpMethod resolved = HttpMethod.resolve(token);</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">				if (resolved != null) {</span>
<span class="fc" id="L555">					result.add(resolved);</span>
				}
			}
		}
<span class="fc" id="L559">		return result;</span>
	}

	/**
	 * Set the (new) value of the {@code Access-Control-Allow-Origin} response header.
	 */
	public void setAccessControlAllowOrigin(@Nullable String allowedOrigin) {
<span class="fc" id="L566">		setOrRemove(ACCESS_CONTROL_ALLOW_ORIGIN, allowedOrigin);</span>
<span class="fc" id="L567">	}</span>

	/**
	 * Return the value of the {@code Access-Control-Allow-Origin} response header.
	 */
	@Nullable
	public String getAccessControlAllowOrigin() {
<span class="fc" id="L574">		return getFieldValues(ACCESS_CONTROL_ALLOW_ORIGIN);</span>
	}

	/**
	 * Set the (new) value of the {@code Access-Control-Expose-Headers} response header.
	 */
	public void setAccessControlExposeHeaders(List&lt;String&gt; exposedHeaders) {
<span class="fc" id="L581">		set(ACCESS_CONTROL_EXPOSE_HEADERS, toCommaDelimitedString(exposedHeaders));</span>
<span class="fc" id="L582">	}</span>

	/**
	 * Return the value of the {@code Access-Control-Expose-Headers} response header.
	 */
	public List&lt;String&gt; getAccessControlExposeHeaders() {
<span class="fc" id="L588">		return getValuesAsList(ACCESS_CONTROL_EXPOSE_HEADERS);</span>
	}

	/**
	 * Set the (new) value of the {@code Access-Control-Max-Age} response header.
	 */
	public void setAccessControlMaxAge(long maxAge) {
<span class="fc" id="L595">		set(ACCESS_CONTROL_MAX_AGE, Long.toString(maxAge));</span>
<span class="fc" id="L596">	}</span>

	/**
	 * Return the value of the {@code Access-Control-Max-Age} response header.
	 * &lt;p&gt;Returns -1 when the max age is unknown.
	 */
	public long getAccessControlMaxAge() {
<span class="fc" id="L603">		String value = getFirst(ACCESS_CONTROL_MAX_AGE);</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">		return (value != null ? Long.parseLong(value) : -1);</span>
	}

	/**
	 * Set the (new) value of the {@code Access-Control-Request-Headers} request header.
	 */
	public void setAccessControlRequestHeaders(List&lt;String&gt; requestHeaders) {
<span class="fc" id="L611">		set(ACCESS_CONTROL_REQUEST_HEADERS, toCommaDelimitedString(requestHeaders));</span>
<span class="fc" id="L612">	}</span>

	/**
	 * Return the value of the {@code Access-Control-Request-Headers} request header.
	 */
	public List&lt;String&gt; getAccessControlRequestHeaders() {
<span class="fc" id="L618">		return getValuesAsList(ACCESS_CONTROL_REQUEST_HEADERS);</span>
	}

	/**
	 * Set the (new) value of the {@code Access-Control-Request-Method} request header.
	 */
	public void setAccessControlRequestMethod(@Nullable HttpMethod requestMethod) {
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">		setOrRemove(ACCESS_CONTROL_REQUEST_METHOD, (requestMethod != null ? requestMethod.name() : null));</span>
<span class="fc" id="L626">	}</span>

	/**
	 * Return the value of the {@code Access-Control-Request-Method} request header.
	 */
	@Nullable
	public HttpMethod getAccessControlRequestMethod() {
<span class="fc" id="L633">		return HttpMethod.resolve(getFirst(ACCESS_CONTROL_REQUEST_METHOD));</span>
	}

	/**
	 * Set the list of acceptable {@linkplain Charset charsets},
	 * as specified by the {@code Accept-Charset} header.
	 */
	public void setAcceptCharset(List&lt;Charset&gt; acceptableCharsets) {
<span class="fc" id="L641">		StringJoiner joiner = new StringJoiner(&quot;, &quot;);</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">		for (Charset charset : acceptableCharsets) {</span>
<span class="fc" id="L643">			joiner.add(charset.name().toLowerCase(Locale.ENGLISH));</span>
<span class="fc" id="L644">		}</span>
<span class="fc" id="L645">		set(ACCEPT_CHARSET, joiner.toString());</span>
<span class="fc" id="L646">	}</span>

	/**
	 * Return the list of acceptable {@linkplain Charset charsets},
	 * as specified by the {@code Accept-Charset} header.
	 */
	public List&lt;Charset&gt; getAcceptCharset() {
<span class="fc" id="L653">		String value = getFirst(ACCEPT_CHARSET);</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">		if (value != null) {</span>
<span class="fc" id="L655">			String[] tokens = StringUtils.tokenizeToStringArray(value, &quot;,&quot;);</span>
<span class="fc" id="L656">			List&lt;Charset&gt; result = new ArrayList&lt;&gt;(tokens.length);</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">			for (String token : tokens) {</span>
<span class="fc" id="L658">				int paramIdx = token.indexOf(';');</span>
				String charsetName;
<span class="fc bfc" id="L660" title="All 2 branches covered.">				if (paramIdx == -1) {</span>
<span class="fc" id="L661">					charsetName = token;</span>
				}
				else {
<span class="fc" id="L664">					charsetName = token.substring(0, paramIdx);</span>
				}
<span class="fc bfc" id="L666" title="All 2 branches covered.">				if (!charsetName.equals(&quot;*&quot;)) {</span>
<span class="fc" id="L667">					result.add(Charset.forName(charsetName));</span>
				}
			}
<span class="fc" id="L670">			return result;</span>
		}
		else {
<span class="nc" id="L673">			return Collections.emptyList();</span>
		}
	}

	/**
	 * Set the set of allowed {@link HttpMethod HTTP methods},
	 * as specified by the {@code Allow} header.
	 */
	public void setAllow(Set&lt;HttpMethod&gt; allowedMethods) {
<span class="fc" id="L682">		set(ALLOW, StringUtils.collectionToCommaDelimitedString(allowedMethods));</span>
<span class="fc" id="L683">	}</span>

	/**
	 * Return the set of allowed {@link HttpMethod HTTP methods},
	 * as specified by the {@code Allow} header.
	 * &lt;p&gt;Returns an empty set when the allowed methods are unspecified.
	 */
	public Set&lt;HttpMethod&gt; getAllow() {
<span class="fc" id="L691">		String value = getFirst(ALLOW);</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">		if (!StringUtils.isEmpty(value)) {</span>
<span class="fc" id="L693">			String[] tokens = StringUtils.tokenizeToStringArray(value, &quot;,&quot;);</span>
<span class="fc" id="L694">			List&lt;HttpMethod&gt; result = new ArrayList&lt;&gt;(tokens.length);</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">			for (String token : tokens) {</span>
<span class="fc" id="L696">				HttpMethod resolved = HttpMethod.resolve(token);</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">				if (resolved != null) {</span>
<span class="fc" id="L698">					result.add(resolved);</span>
				}
			}
<span class="fc" id="L701">			return EnumSet.copyOf(result);</span>
		}
		else {
<span class="fc" id="L704">			return EnumSet.noneOf(HttpMethod.class);</span>
		}
	}

	/**
	 * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to
	 * Basic Authentication based on the given username and password.
	 * &lt;p&gt;Note that this method only supports characters in the
	 * {@link StandardCharsets#ISO_8859_1 ISO-8859-1} character set.
	 * @param username the username
	 * @param password the password
	 * @throws IllegalArgumentException if either {@code user} or
	 * {@code password} contain characters that cannot be encoded to ISO-8859-1
	 * @since 5.1
	 * @see #setBasicAuth(String, String, Charset)
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt;
	 */
	public void setBasicAuth(String username, String password) {
<span class="fc" id="L722">		setBasicAuth(username, password, null);</span>
<span class="fc" id="L723">	}</span>

	/**
	 * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to
	 * Basic Authentication based on the given username and password.
	 * @param username the username
	 * @param password the password
	 * @param charset the charset to use to convert the credentials into an octet
	 * sequence. Defaults to {@linkplain StandardCharsets#ISO_8859_1 ISO-8859-1}.
	 * @throws IllegalArgumentException if {@code username} or {@code password}
	 * contains characters that cannot be encoded to the given charset
	 * @since 5.1
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt;
	 */
	public void setBasicAuth(String username, String password, @Nullable Charset charset) {
<span class="fc" id="L738">		Assert.notNull(username, &quot;Username must not be null&quot;);</span>
<span class="fc" id="L739">		Assert.notNull(password, &quot;Password must not be null&quot;);</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">		if (charset == null) {</span>
<span class="fc" id="L741">			charset = StandardCharsets.ISO_8859_1;</span>
		}

<span class="fc" id="L744">		CharsetEncoder encoder = charset.newEncoder();</span>
<span class="pc bpc" id="L745" title="1 of 4 branches missed.">		if (!encoder.canEncode(username) || !encoder.canEncode(password)) {</span>
<span class="fc" id="L746">			throw new IllegalArgumentException(</span>
<span class="fc" id="L747">					&quot;Username or password contains characters that cannot be encoded to &quot; + charset.displayName());</span>
		}

<span class="fc" id="L750">		String credentialsString = username + &quot;:&quot; + password;</span>
<span class="fc" id="L751">		byte[] encodedBytes = Base64.getEncoder().encode(credentialsString.getBytes(charset));</span>
<span class="fc" id="L752">		String encodedCredentials = new String(encodedBytes, charset);</span>
<span class="fc" id="L753">		set(AUTHORIZATION, &quot;Basic &quot; + encodedCredentials);</span>
<span class="fc" id="L754">	}</span>

	/**
	 * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to
	 * the given Bearer token.
	 * @param token the Base64 encoded token
	 * @since 5.1
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc6750&quot;&gt;RFC 6750&lt;/a&gt;
	 */
	public void setBearerAuth(String token) {
<span class="fc" id="L764">		set(AUTHORIZATION, &quot;Bearer &quot; + token);</span>
<span class="fc" id="L765">	}</span>

	/**
	 * Set a configured {@link CacheControl} instance as the
	 * new value of the {@code Cache-Control} header.
	 * @since 5.0.5
	 */
	public void setCacheControl(CacheControl cacheControl) {
<span class="fc" id="L773">		setOrRemove(CACHE_CONTROL, cacheControl.getHeaderValue());</span>
<span class="fc" id="L774">	}</span>

	/**
	 * Set the (new) value of the {@code Cache-Control} header.
	 */
	public void setCacheControl(@Nullable String cacheControl) {
<span class="fc" id="L780">		setOrRemove(CACHE_CONTROL, cacheControl);</span>
<span class="fc" id="L781">	}</span>

	/**
	 * Return the value of the {@code Cache-Control} header.
	 */
	@Nullable
	public String getCacheControl() {
<span class="fc" id="L788">		return getFieldValues(CACHE_CONTROL);</span>
	}

	/**
	 * Set the (new) value of the {@code Connection} header.
	 */
	public void setConnection(String connection) {
<span class="nc" id="L795">		set(CONNECTION, connection);</span>
<span class="nc" id="L796">	}</span>

	/**
	 * Set the (new) value of the {@code Connection} header.
	 */
	public void setConnection(List&lt;String&gt; connection) {
<span class="nc" id="L802">		set(CONNECTION, toCommaDelimitedString(connection));</span>
<span class="nc" id="L803">	}</span>

	/**
	 * Return the value of the {@code Connection} header.
	 */
	public List&lt;String&gt; getConnection() {
<span class="nc" id="L809">		return getValuesAsList(CONNECTION);</span>
	}

	/**
	 * Set the {@code Content-Disposition} header when creating a
	 * {@code &quot;multipart/form-data&quot;} request.
	 * &lt;p&gt;Applications typically would not set this header directly but
	 * rather prepare a {@code MultiValueMap&lt;String, Object&gt;}, containing an
	 * Object or a {@link org.springframework.core.io.Resource} for each part,
	 * and then pass that to the {@code RestTemplate} or {@code WebClient}.
	 * @param name the control name
	 * @param filename the filename (may be {@code null})
	 * @see #getContentDisposition()
	 */
	public void setContentDispositionFormData(String name, @Nullable String filename) {
<span class="fc" id="L824">		Assert.notNull(name, &quot;Name must not be null&quot;);</span>
<span class="fc" id="L825">		ContentDisposition.Builder disposition = ContentDisposition.builder(&quot;form-data&quot;).name(name);</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">		if (filename != null) {</span>
<span class="fc" id="L827">			disposition.filename(filename);</span>
		}
<span class="fc" id="L829">		setContentDisposition(disposition.build());</span>
<span class="fc" id="L830">	}</span>

	/**
	 * Set the {@literal Content-Disposition} header.
	 * &lt;p&gt;This could be used on a response to indicate if the content is
	 * expected to be displayed inline in the browser or as an attachment to be
	 * saved locally.
	 * &lt;p&gt;It can also be used for a {@code &quot;multipart/form-data&quot;} request.
	 * For more details see notes on {@link #setContentDispositionFormData}.
	 * @since 5.0
	 * @see #getContentDisposition()
	 */
	public void setContentDisposition(ContentDisposition contentDisposition) {
<span class="fc" id="L843">		set(CONTENT_DISPOSITION, contentDisposition.toString());</span>
<span class="fc" id="L844">	}</span>

	/**
	 * Return a parsed representation of the {@literal Content-Disposition} header.
	 * @since 5.0
	 * @see #setContentDisposition(ContentDisposition)
	 */
	public ContentDisposition getContentDisposition() {
<span class="fc" id="L852">		String contentDisposition = getFirst(CONTENT_DISPOSITION);</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">		if (contentDisposition != null) {</span>
<span class="fc" id="L854">			return ContentDisposition.parse(contentDisposition);</span>
		}
<span class="fc" id="L856">		return ContentDisposition.empty();</span>
	}

	/**
	 * Set the {@link Locale} of the content language,
	 * as specified by the {@literal Content-Language} header.
	 * &lt;p&gt;Use {@code set(CONTENT_LANGUAGE, ...)} if you need
	 * to set multiple content languages.&lt;/p&gt;
	 * @since 5.0
	 */
	public void setContentLanguage(@Nullable Locale locale) {
<span class="pc bpc" id="L867" title="1 of 2 branches missed.">		setOrRemove(CONTENT_LANGUAGE, (locale != null ? locale.toLanguageTag() : null));</span>
<span class="fc" id="L868">	}</span>

	/**
	 * Return the first {@link Locale} of the content languages,
	 * as specified by the {@literal Content-Language} header.
	 * &lt;p&gt;Returns {@code null} when the content language is unknown.
	 * &lt;p&gt;Use {@code getValuesAsList(CONTENT_LANGUAGE)} if you need
	 * to get multiple content languages.&lt;/p&gt;
	 * @since 5.0
	 */
	@Nullable
	public Locale getContentLanguage() {
<span class="fc" id="L880">		return getValuesAsList(CONTENT_LANGUAGE)</span>
<span class="fc" id="L881">				.stream()</span>
<span class="fc" id="L882">				.findFirst()</span>
<span class="fc" id="L883">				.map(Locale::forLanguageTag)</span>
<span class="fc" id="L884">				.orElse(null);</span>
	}

	/**
	 * Set the length of the body in bytes, as specified by the
	 * {@code Content-Length} header.
	 */
	public void setContentLength(long contentLength) {
<span class="fc" id="L892">		set(CONTENT_LENGTH, Long.toString(contentLength));</span>
<span class="fc" id="L893">	}</span>

	/**
	 * Return the length of the body in bytes, as specified by the
	 * {@code Content-Length} header.
	 * &lt;p&gt;Returns -1 when the content-length is unknown.
	 */
	public long getContentLength() {
<span class="fc" id="L901">		String value = getFirst(CONTENT_LENGTH);</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">		return (value != null ? Long.parseLong(value) : -1);</span>
	}

	/**
	 * Set the {@linkplain MediaType media type} of the body,
	 * as specified by the {@code Content-Type} header.
	 */
	public void setContentType(@Nullable MediaType mediaType) {
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">		if (mediaType != null) {</span>
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">			Assert.isTrue(!mediaType.isWildcardType(), &quot;Content-Type cannot contain wildcard type '*'&quot;);</span>
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">			Assert.isTrue(!mediaType.isWildcardSubtype(), &quot;Content-Type cannot contain wildcard subtype '*'&quot;);</span>
<span class="fc" id="L913">			set(CONTENT_TYPE, mediaType.toString());</span>
		}
		else {
<span class="nc" id="L916">			remove(CONTENT_TYPE);</span>
		}
<span class="fc" id="L918">	}</span>

	/**
	 * Return the {@linkplain MediaType media type} of the body, as specified
	 * by the {@code Content-Type} header.
	 * &lt;p&gt;Returns {@code null} when the content-type is unknown.
	 */
	@Nullable
	public MediaType getContentType() {
<span class="fc" id="L927">		String value = getFirst(CONTENT_TYPE);</span>
<span class="fc bfc" id="L928" title="All 2 branches covered.">		return (StringUtils.hasLength(value) ? MediaType.parseMediaType(value) : null);</span>
	}

	/**
	 * Set the date and time at which the message was created, as specified
	 * by the {@code Date} header.
	 * &lt;p&gt;The date should be specified as the number of milliseconds since
	 * January 1, 1970 GMT.
	 */
	public void setDate(long date) {
<span class="fc" id="L938">		setDate(DATE, date);</span>
<span class="fc" id="L939">	}</span>

	/**
	 * Return the date and time at which the message was created, as specified
	 * by the {@code Date} header.
	 * &lt;p&gt;The date is returned as the number of milliseconds since
	 * January 1, 1970 GMT. Returns -1 when the date is unknown.
	 * @throws IllegalArgumentException if the value cannot be converted to a date
	 */
	public long getDate() {
<span class="fc" id="L949">		return getFirstDate(DATE);</span>
	}

	/**
	 * Set the (new) entity tag of the body, as specified by the {@code ETag} header.
	 */
	public void setETag(@Nullable String etag) {
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">		if (etag != null) {</span>
<span class="fc bfc" id="L957" title="All 4 branches covered.">			Assert.isTrue(etag.startsWith(&quot;\&quot;&quot;) || etag.startsWith(&quot;W/&quot;),</span>
					&quot;Invalid ETag: does not start with W/ or \&quot;&quot;);
<span class="fc" id="L959">			Assert.isTrue(etag.endsWith(&quot;\&quot;&quot;), &quot;Invalid ETag: does not end with \&quot;&quot;);</span>
<span class="fc" id="L960">			set(ETAG, etag);</span>
		}
		else {
<span class="nc" id="L963">			remove(ETAG);</span>
		}
<span class="fc" id="L965">	}</span>

	/**
	 * Return the entity tag of the body, as specified by the {@code ETag} header.
	 */
	@Nullable
	public String getETag() {
<span class="fc" id="L972">		return getFirst(ETAG);</span>
	}

	/**
	 * Set the duration after which the message is no longer valid,
	 * as specified by the {@code Expires} header.
	 * @since 5.0.5
	 */
	public void setExpires(ZonedDateTime expires) {
<span class="fc" id="L981">		setZonedDateTime(EXPIRES, expires);</span>
<span class="fc" id="L982">	}</span>

	/**
	 * Set the date and time at which the message is no longer valid,
	 * as specified by the {@code Expires} header.
	 * &lt;p&gt;The date should be specified as the number of milliseconds since
	 * January 1, 1970 GMT.
	 */
	public void setExpires(long expires) {
<span class="fc" id="L991">		setDate(EXPIRES, expires);</span>
<span class="fc" id="L992">	}</span>

	/**
	 * Return the date and time at which the message is no longer valid,
	 * as specified by the {@code Expires} header.
	 * &lt;p&gt;The date is returned as the number of milliseconds since
	 * January 1, 1970 GMT. Returns -1 when the date is unknown.
	 * @see #getFirstZonedDateTime(String)
	 */
	public long getExpires() {
<span class="fc" id="L1002">		return getFirstDate(EXPIRES, false);</span>
	}

	/**
	 * Set the (new) value of the {@code Host} header.
	 * &lt;p&gt;If the given {@linkplain InetSocketAddress#getPort() port} is {@code 0},
	 * the host header will only contain the
	 * {@linkplain InetSocketAddress#getHostString() host name}.
	 * @since 5.0
	 */
	public void setHost(@Nullable InetSocketAddress host) {
<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">		if (host != null) {</span>
<span class="fc" id="L1014">			String value = host.getHostString();</span>
<span class="fc" id="L1015">			int port = host.getPort();</span>
<span class="fc bfc" id="L1016" title="All 2 branches covered.">			if (port != 0) {</span>
<span class="fc" id="L1017">				value = value + &quot;:&quot; + port;</span>
			}
<span class="fc" id="L1019">			set(HOST, value);</span>
<span class="fc" id="L1020">		}</span>
		else {
<span class="nc" id="L1022">			remove(HOST, null);</span>
		}
<span class="fc" id="L1024">	}</span>

	/**
	 * Return the value of the {@code Host} header, if available.
	 * &lt;p&gt;If the header value does not contain a port, the
	 * {@linkplain InetSocketAddress#getPort() port} in the returned address will
	 * be {@code 0}.
	 * @since 5.0
	 */
	@Nullable
	public InetSocketAddress getHost() {
<span class="fc" id="L1035">		String value = getFirst(HOST);</span>
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">		if (value == null) {</span>
<span class="nc" id="L1037">			return null;</span>
		}

<span class="fc" id="L1040">		String host = null;</span>
<span class="fc" id="L1041">		int port = 0;</span>
<span class="fc bfc" id="L1042" title="All 2 branches covered.">		int separator = (value.startsWith(&quot;[&quot;) ? value.indexOf(':', value.indexOf(']')) : value.lastIndexOf(':'));</span>
<span class="fc bfc" id="L1043" title="All 2 branches covered.">		if (separator != -1) {</span>
<span class="fc" id="L1044">			host = value.substring(0, separator);</span>
<span class="fc" id="L1045">			String portString = value.substring(separator + 1);</span>
			try {
<span class="fc" id="L1047">				port = Integer.parseInt(portString);</span>
			}
<span class="nc" id="L1049">			catch (NumberFormatException ex) {</span>
				// ignore
<span class="fc" id="L1051">			}</span>
		}

<span class="fc bfc" id="L1054" title="All 2 branches covered.">		if (host == null) {</span>
<span class="fc" id="L1055">			host = value;</span>
		}
<span class="fc" id="L1057">		return InetSocketAddress.createUnresolved(host, port);</span>
	}

	/**
	 * Set the (new) value of the {@code If-Match} header.
	 * @since 4.3
	 */
	public void setIfMatch(String ifMatch) {
<span class="fc" id="L1065">		set(IF_MATCH, ifMatch);</span>
<span class="fc" id="L1066">	}</span>

	/**
	 * Set the (new) value of the {@code If-Match} header.
	 * @since 4.3
	 */
	public void setIfMatch(List&lt;String&gt; ifMatchList) {
<span class="nc" id="L1073">		set(IF_MATCH, toCommaDelimitedString(ifMatchList));</span>
<span class="nc" id="L1074">	}</span>

	/**
	 * Return the value of the {@code If-Match} header.
	 * @since 4.3
	 */
	public List&lt;String&gt; getIfMatch() {
<span class="fc" id="L1081">		return getETagValuesAsList(IF_MATCH);</span>
	}

	/**
	 * Set the time the resource was last changed, as specified by the
	 * {@code Last-Modified} header.
	 * @since 5.1.4
	 */
	public void setIfModifiedSince(ZonedDateTime ifModifiedSince) {
<span class="nc" id="L1090">		setZonedDateTime(IF_MODIFIED_SINCE, ifModifiedSince.withZoneSameInstant(GMT));</span>
<span class="nc" id="L1091">	}</span>

	/**
	 * Set the time the resource was last changed, as specified by the
	 * {@code Last-Modified} header.
	 * @since 5.1.4
	 */
	public void setIfModifiedSince(Instant ifModifiedSince) {
<span class="nc" id="L1099">		setInstant(IF_MODIFIED_SINCE, ifModifiedSince);</span>
<span class="nc" id="L1100">	}</span>

	/**
	 * Set the (new) value of the {@code If-Modified-Since} header.
	 * &lt;p&gt;The date should be specified as the number of milliseconds since
	 * January 1, 1970 GMT.
	 */
	public void setIfModifiedSince(long ifModifiedSince) {
<span class="fc" id="L1108">		setDate(IF_MODIFIED_SINCE, ifModifiedSince);</span>
<span class="fc" id="L1109">	}</span>

	/**
	 * Return the value of the {@code If-Modified-Since} header.
	 * &lt;p&gt;The date is returned as the number of milliseconds since
	 * January 1, 1970 GMT. Returns -1 when the date is unknown.
	 * @see #getFirstZonedDateTime(String)
	 */
	public long getIfModifiedSince() {
<span class="fc" id="L1118">		return getFirstDate(IF_MODIFIED_SINCE, false);</span>
	}

	/**
	 * Set the (new) value of the {@code If-None-Match} header.
	 */
	public void setIfNoneMatch(String ifNoneMatch) {
<span class="fc" id="L1125">		set(IF_NONE_MATCH, ifNoneMatch);</span>
<span class="fc" id="L1126">	}</span>

	/**
	 * Set the (new) values of the {@code If-None-Match} header.
	 */
	public void setIfNoneMatch(List&lt;String&gt; ifNoneMatchList) {
<span class="fc" id="L1132">		set(IF_NONE_MATCH, toCommaDelimitedString(ifNoneMatchList));</span>
<span class="fc" id="L1133">	}</span>

	/**
	 * Return the value of the {@code If-None-Match} header.
	 */
	public List&lt;String&gt; getIfNoneMatch() {
<span class="fc" id="L1139">		return getETagValuesAsList(IF_NONE_MATCH);</span>
	}

	/**
	 * Set the time the resource was last changed, as specified by the
	 * {@code Last-Modified} header.
	 * @since 5.1.4
	 */
	public void setIfUnmodifiedSince(ZonedDateTime ifUnmodifiedSince) {
<span class="nc" id="L1148">		setZonedDateTime(IF_UNMODIFIED_SINCE, ifUnmodifiedSince.withZoneSameInstant(GMT));</span>
<span class="nc" id="L1149">	}</span>

	/**
	 * Set the time the resource was last changed, as specified by the
	 * {@code Last-Modified} header.
	 * @since 5.1.4
	 */
	public void setIfUnmodifiedSince(Instant ifUnmodifiedSince) {
<span class="nc" id="L1157">		setInstant(IF_UNMODIFIED_SINCE, ifUnmodifiedSince);</span>
<span class="nc" id="L1158">	}</span>

	/**
	 * Set the (new) value of the {@code If-Unmodified-Since} header.
	 * &lt;p&gt;The date should be specified as the number of milliseconds since
	 * January 1, 1970 GMT.
	 * @since 4.3
	 */
	public void setIfUnmodifiedSince(long ifUnmodifiedSince) {
<span class="fc" id="L1167">		setDate(IF_UNMODIFIED_SINCE, ifUnmodifiedSince);</span>
<span class="fc" id="L1168">	}</span>

	/**
	 * Return the value of the {@code If-Unmodified-Since} header.
	 * &lt;p&gt;The date is returned as the number of milliseconds since
	 * January 1, 1970 GMT. Returns -1 when the date is unknown.
	 * @since 4.3
	 * @see #getFirstZonedDateTime(String)
	 */
	public long getIfUnmodifiedSince() {
<span class="fc" id="L1178">		return getFirstDate(IF_UNMODIFIED_SINCE, false);</span>
	}

	/**
	 * Set the time the resource was last changed, as specified by the
	 * {@code Last-Modified} header.
	 * @since 5.1.4
	 */
	public void setLastModified(ZonedDateTime lastModified) {
<span class="nc" id="L1187">		setZonedDateTime(LAST_MODIFIED, lastModified.withZoneSameInstant(GMT));</span>
<span class="nc" id="L1188">	}</span>

	/**
	 * Set the time the resource was last changed, as specified by the
	 * {@code Last-Modified} header.
	 * @since 5.1.4
	 */
	public void setLastModified(Instant lastModified) {
<span class="nc" id="L1196">		setInstant(LAST_MODIFIED, lastModified);</span>
<span class="nc" id="L1197">	}</span>

	/**
	 * Set the time the resource was last changed, as specified by the
	 * {@code Last-Modified} header.
	 * &lt;p&gt;The date should be specified as the number of milliseconds since
	 * January 1, 1970 GMT.
	 */
	public void setLastModified(long lastModified) {
<span class="fc" id="L1206">		setDate(LAST_MODIFIED, lastModified);</span>
<span class="fc" id="L1207">	}</span>

	/**
	 * Return the time the resource was last changed, as specified by the
	 * {@code Last-Modified} header.
	 * &lt;p&gt;The date is returned as the number of milliseconds since
	 * January 1, 1970 GMT. Returns -1 when the date is unknown.
	 * @see #getFirstZonedDateTime(String)
	 */
	public long getLastModified() {
<span class="fc" id="L1217">		return getFirstDate(LAST_MODIFIED, false);</span>
	}

	/**
	 * Set the (new) location of a resource,
	 * as specified by the {@code Location} header.
	 */
	public void setLocation(@Nullable URI location) {
<span class="pc bpc" id="L1225" title="1 of 2 branches missed.">		setOrRemove(LOCATION, (location != null ? location.toASCIIString() : null));</span>
<span class="fc" id="L1226">	}</span>

	/**
	 * Return the (new) location of a resource
	 * as specified by the {@code Location} header.
	 * &lt;p&gt;Returns {@code null} when the location is unknown.
	 */
	@Nullable
	public URI getLocation() {
<span class="fc" id="L1235">		String value = getFirst(LOCATION);</span>
<span class="fc bfc" id="L1236" title="All 2 branches covered.">		return (value != null ? URI.create(value) : null);</span>
	}

	/**
	 * Set the (new) value of the {@code Origin} header.
	 */
	public void setOrigin(@Nullable String origin) {
<span class="nc" id="L1243">		setOrRemove(ORIGIN, origin);</span>
<span class="nc" id="L1244">	}</span>

	/**
	 * Return the value of the {@code Origin} header.
	 */
	@Nullable
	public String getOrigin() {
<span class="fc" id="L1251">		return getFirst(ORIGIN);</span>
	}

	/**
	 * Set the (new) value of the {@code Pragma} header.
	 */
	public void setPragma(@Nullable String pragma) {
<span class="fc" id="L1258">		setOrRemove(PRAGMA, pragma);</span>
<span class="fc" id="L1259">	}</span>

	/**
	 * Return the value of the {@code Pragma} header.
	 */
	@Nullable
	public String getPragma() {
<span class="fc" id="L1266">		return getFirst(PRAGMA);</span>
	}

	/**
	 * Sets the (new) value of the {@code Range} header.
	 */
	public void setRange(List&lt;HttpRange&gt; ranges) {
<span class="fc" id="L1273">		String value = HttpRange.toString(ranges);</span>
<span class="fc" id="L1274">		set(RANGE, value);</span>
<span class="fc" id="L1275">	}</span>

	/**
	 * Return the value of the {@code Range} header.
	 * &lt;p&gt;Returns an empty list when the range is unknown.
	 */
	public List&lt;HttpRange&gt; getRange() {
<span class="fc" id="L1282">		String value = getFirst(RANGE);</span>
<span class="fc" id="L1283">		return HttpRange.parseRanges(value);</span>
	}

	/**
	 * Set the (new) value of the {@code Upgrade} header.
	 */
	public void setUpgrade(@Nullable String upgrade) {
<span class="nc" id="L1290">		setOrRemove(UPGRADE, upgrade);</span>
<span class="nc" id="L1291">	}</span>

	/**
	 * Return the value of the {@code Upgrade} header.
	 */
	@Nullable
	public String getUpgrade() {
<span class="nc" id="L1298">		return getFirst(UPGRADE);</span>
	}

	/**
	 * Set the request header names (e.g. &quot;Accept-Language&quot;) for which the
	 * response is subject to content negotiation and variances based on the
	 * value of those request headers.
	 * @param requestHeaders the request header names
	 * @since 4.3
	 */
	public void setVary(List&lt;String&gt; requestHeaders) {
<span class="nc" id="L1309">		set(VARY, toCommaDelimitedString(requestHeaders));</span>
<span class="nc" id="L1310">	}</span>

	/**
	 * Return the request header names subject to content negotiation.
	 * @since 4.3
	 */
	public List&lt;String&gt; getVary() {
<span class="nc" id="L1317">		return getValuesAsList(VARY);</span>
	}

	/**
	 * Set the given date under the given header name after formatting it as a string
	 * using the RFC-1123 date-time formatter. The equivalent of
	 * {@link #set(String, String)} but for date headers.
	 * @since 5.0
	 */
	public void setZonedDateTime(String headerName, ZonedDateTime date) {
<span class="fc" id="L1327">		set(headerName, DATE_FORMATTER.format(date));</span>
<span class="fc" id="L1328">	}</span>

	/**
	 * Set the given date under the given header name after formatting it as a string
	 * using the RFC-1123 date-time formatter. The equivalent of
	 * {@link #set(String, String)} but for date headers.
	 * @since 5.1.4
	 */
	public void setInstant(String headerName, Instant date) {
<span class="fc" id="L1337">		setZonedDateTime(headerName, ZonedDateTime.ofInstant(date, GMT));</span>
<span class="fc" id="L1338">	}</span>

	/**
	 * Set the given date under the given header name after formatting it as a string
	 * using the RFC-1123 date-time formatter. The equivalent of
	 * {@link #set(String, String)} but for date headers.
	 * @since 3.2.4
	 * @see #setZonedDateTime(String, ZonedDateTime)
	 */
	public void setDate(String headerName, long date) {
<span class="fc" id="L1348">		setInstant(headerName, Instant.ofEpochMilli(date));</span>
<span class="fc" id="L1349">	}</span>

	/**
	 * Parse the first header value for the given header name as a date,
	 * return -1 if there is no value, or raise {@link IllegalArgumentException}
	 * if the value cannot be parsed as a date.
	 * @param headerName the header name
	 * @return the parsed date header, or -1 if none
	 * @since 3.2.4
	 * @see #getFirstZonedDateTime(String)
	 */
	public long getFirstDate(String headerName) {
<span class="fc" id="L1361">		return getFirstDate(headerName, true);</span>
	}

	/**
	 * Parse the first header value for the given header name as a date,
	 * return -1 if there is no value or also in case of an invalid value
	 * (if {@code rejectInvalid=false}), or raise {@link IllegalArgumentException}
	 * if the value cannot be parsed as a date.
	 * @param headerName the header name
	 * @param rejectInvalid whether to reject invalid values with an
	 * {@link IllegalArgumentException} ({@code true}) or rather return -1
	 * in that case ({@code false})
	 * @return the parsed date header, or -1 if none (or invalid)
	 * @see #getFirstZonedDateTime(String, boolean)
	 */
	private long getFirstDate(String headerName, boolean rejectInvalid) {
<span class="fc" id="L1377">		ZonedDateTime zonedDateTime = getFirstZonedDateTime(headerName, rejectInvalid);</span>
<span class="fc bfc" id="L1378" title="All 2 branches covered.">		return (zonedDateTime != null ? zonedDateTime.toInstant().toEpochMilli() : -1);</span>
	}

	/**
	 * Parse the first header value for the given header name as a date,
	 * return {@code null} if there is no value, or raise {@link IllegalArgumentException}
	 * if the value cannot be parsed as a date.
	 * @param headerName the header name
	 * @return the parsed date header, or {@code null} if none
	 * @since 5.0
	 */
	@Nullable
	public ZonedDateTime getFirstZonedDateTime(String headerName) {
<span class="fc" id="L1391">		return getFirstZonedDateTime(headerName, true);</span>
	}

	/**
	 * Parse the first header value for the given header name as a date,
	 * return {@code null} if there is no value or also in case of an invalid value
	 * (if {@code rejectInvalid=false}), or raise {@link IllegalArgumentException}
	 * if the value cannot be parsed as a date.
	 * @param headerName the header name
	 * @param rejectInvalid whether to reject invalid values with an
	 * {@link IllegalArgumentException} ({@code true}) or rather return {@code null}
	 * in that case ({@code false})
	 * @return the parsed date header, or {@code null} if none (or invalid)
	 */
	@Nullable
	private ZonedDateTime getFirstZonedDateTime(String headerName, boolean rejectInvalid) {
<span class="fc" id="L1407">		String headerValue = getFirst(headerName);</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">		if (headerValue == null) {</span>
			// No header value sent at all
<span class="fc" id="L1410">			return null;</span>
		}
<span class="fc bfc" id="L1412" title="All 2 branches covered.">		if (headerValue.length() &gt;= 3) {</span>
			// Short &quot;0&quot; or &quot;-1&quot; like values are never valid HTTP date headers...
			// Let's only bother with DateTimeFormatter parsing for long enough values.

			// See https://stackoverflow.com/questions/12626699/if-modified-since-http-header-passed-by-ie9-includes-length
<span class="fc" id="L1417">			int parametersIndex = headerValue.indexOf(';');</span>
<span class="fc bfc" id="L1418" title="All 2 branches covered.">			if (parametersIndex != -1) {</span>
<span class="fc" id="L1419">				headerValue = headerValue.substring(0, parametersIndex);</span>
			}

<span class="fc bfc" id="L1422" title="All 2 branches covered.">			for (DateTimeFormatter dateFormatter : DATE_PARSERS) {</span>
				try {
<span class="fc" id="L1424">					return ZonedDateTime.parse(headerValue, dateFormatter);</span>
				}
<span class="fc" id="L1426">				catch (DateTimeParseException ex) {</span>
					// ignore
				}
			}

		}
<span class="fc bfc" id="L1432" title="All 2 branches covered.">		if (rejectInvalid) {</span>
<span class="fc" id="L1433">			throw new IllegalArgumentException(&quot;Cannot parse date value \&quot;&quot; + headerValue +</span>
					&quot;\&quot; for \&quot;&quot; + headerName + &quot;\&quot; header&quot;);
		}
<span class="fc" id="L1436">		return null;</span>
	}

	/**
	 * Return all values of a given header name,
	 * even if this header is set multiple times.
	 * @param headerName the header name
	 * @return all associated values
	 * @since 4.3
	 */
	public List&lt;String&gt; getValuesAsList(String headerName) {
<span class="fc" id="L1447">		List&lt;String&gt; values = get(headerName);</span>
<span class="fc bfc" id="L1448" title="All 2 branches covered.">		if (values != null) {</span>
<span class="fc" id="L1449">			List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1450" title="All 2 branches covered.">			for (String value : values) {</span>
<span class="pc bpc" id="L1451" title="1 of 2 branches missed.">				if (value != null) {</span>
<span class="fc" id="L1452">					Collections.addAll(result, StringUtils.tokenizeToStringArray(value, &quot;,&quot;));</span>
				}
<span class="fc" id="L1454">			}</span>
<span class="fc" id="L1455">			return result;</span>
		}
<span class="fc" id="L1457">		return Collections.emptyList();</span>
	}

	/**
	 * Retrieve a combined result from the field values of the ETag header.
	 * @param headerName the header name
	 * @return the combined result
	 * @since 4.3
	 */
	protected List&lt;String&gt; getETagValuesAsList(String headerName) {
<span class="fc" id="L1467">		List&lt;String&gt; values = get(headerName);</span>
<span class="pc bpc" id="L1468" title="1 of 2 branches missed.">		if (values != null) {</span>
<span class="fc" id="L1469">			List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1470" title="All 2 branches covered.">			for (String value : values) {</span>
<span class="pc bpc" id="L1471" title="1 of 2 branches missed.">				if (value != null) {</span>
<span class="fc" id="L1472">					Matcher matcher = ETAG_HEADER_VALUE_PATTERN.matcher(value);</span>
<span class="fc bfc" id="L1473" title="All 2 branches covered.">					while (matcher.find()) {</span>
<span class="fc bfc" id="L1474" title="All 2 branches covered.">						if (&quot;*&quot;.equals(matcher.group())) {</span>
<span class="fc" id="L1475">							result.add(matcher.group());</span>
						}
						else {
<span class="fc" id="L1478">							result.add(matcher.group(1));</span>
						}
					}
<span class="fc bfc" id="L1481" title="All 2 branches covered.">					if (result.isEmpty()) {</span>
<span class="fc" id="L1482">						throw new IllegalArgumentException(</span>
								&quot;Could not parse header '&quot; + headerName + &quot;' with value '&quot; + value + &quot;'&quot;);
					}
				}
<span class="fc" id="L1486">			}</span>
<span class="fc" id="L1487">			return result;</span>
		}
<span class="nc" id="L1489">		return Collections.emptyList();</span>
	}

	/**
	 * Retrieve a combined result from the field values of multi-valued headers.
	 * @param headerName the header name
	 * @return the combined result
	 * @since 4.3
	 */
	@Nullable
	protected String getFieldValues(String headerName) {
<span class="fc" id="L1500">		List&lt;String&gt; headerValues = get(headerName);</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">		return (headerValues != null ? toCommaDelimitedString(headerValues) : null);</span>
	}

	/**
	 * Turn the given list of header values into a comma-delimited result.
	 * @param headerValues the list of header values
	 * @return a combined result with comma delimitation
	 */
	protected String toCommaDelimitedString(List&lt;String&gt; headerValues) {
<span class="fc" id="L1510">		StringJoiner joiner = new StringJoiner(&quot;, &quot;);</span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">		for (String val : headerValues) {</span>
<span class="pc bpc" id="L1512" title="1 of 2 branches missed.">			if (val != null) {</span>
<span class="fc" id="L1513">				joiner.add(val);</span>
			}
<span class="fc" id="L1515">		}</span>
<span class="fc" id="L1516">		return joiner.toString();</span>
	}

	/**
	 * Set the given header value, or remove the header if {@code null}.
	 * @param headerName the header name
	 * @param headerValue the header value, or {@code null} for none
	 */
	private void setOrRemove(String headerName, @Nullable String headerValue) {
<span class="fc bfc" id="L1525" title="All 2 branches covered.">		if (headerValue != null) {</span>
<span class="fc" id="L1526">			set(headerName, headerValue);</span>
		}
		else {
<span class="fc" id="L1529">			remove(headerName);</span>
		}
<span class="fc" id="L1531">	}</span>


	// MultiValueMap implementation

	/**
	 * Return the first header value for the given header name, if any.
	 * @param headerName the header name
	 * @return the first header value, or {@code null} if none
	 */
	@Override
	@Nullable
	public String getFirst(String headerName) {
<span class="fc" id="L1544">		return this.headers.getFirst(headerName);</span>
	}

	/**
	 * Add the given, single header value under the given name.
	 * @param headerName the header name
	 * @param headerValue the header value
	 * @throws UnsupportedOperationException if adding headers is not supported
	 * @see #put(String, List)
	 * @see #set(String, String)
	 */
	@Override
	public void add(String headerName, @Nullable String headerValue) {
<span class="fc" id="L1557">		this.headers.add(headerName, headerValue);</span>
<span class="fc" id="L1558">	}</span>

	@Override
	public void addAll(String key, List&lt;? extends String&gt; values) {
<span class="fc" id="L1562">		this.headers.addAll(key, values);</span>
<span class="fc" id="L1563">	}</span>

	@Override
	public void addAll(MultiValueMap&lt;String, String&gt; values) {
<span class="fc" id="L1567">		this.headers.addAll(values);</span>
<span class="fc" id="L1568">	}</span>

	/**
	 * Set the given, single header value under the given name.
	 * @param headerName the header name
	 * @param headerValue the header value
	 * @throws UnsupportedOperationException if adding headers is not supported
	 * @see #put(String, List)
	 * @see #add(String, String)
	 */
	@Override
	public void set(String headerName, @Nullable String headerValue) {
<span class="fc" id="L1580">		this.headers.set(headerName, headerValue);</span>
<span class="fc" id="L1581">	}</span>

	@Override
	public void setAll(Map&lt;String, String&gt; values) {
<span class="nc" id="L1585">		this.headers.setAll(values);</span>
<span class="nc" id="L1586">	}</span>

	@Override
	public Map&lt;String, String&gt; toSingleValueMap() {
<span class="nc" id="L1590">		return this.headers.toSingleValueMap();</span>
	}


	// Map implementation

	@Override
	public int size() {
<span class="fc" id="L1598">		return this.headers.size();</span>
	}

	@Override
	public boolean isEmpty() {
<span class="fc" id="L1603">		return this.headers.isEmpty();</span>
	}

	@Override
	public boolean containsKey(Object key) {
<span class="fc" id="L1608">		return this.headers.containsKey(key);</span>
	}

	@Override
	public boolean containsValue(Object value) {
<span class="nc" id="L1613">		return this.headers.containsValue(value);</span>
	}

	@Override
	@Nullable
	public List&lt;String&gt; get(Object key) {
<span class="fc" id="L1619">		return this.headers.get(key);</span>
	}

	@Override
	public List&lt;String&gt; put(String key, List&lt;String&gt; value) {
<span class="fc" id="L1624">		return this.headers.put(key, value);</span>
	}

	@Override
	public List&lt;String&gt; remove(Object key) {
<span class="fc" id="L1629">		return this.headers.remove(key);</span>
	}

	@Override
	public void putAll(Map&lt;? extends String, ? extends List&lt;String&gt;&gt; map) {
<span class="fc" id="L1634">		this.headers.putAll(map);</span>
<span class="fc" id="L1635">	}</span>

	@Override
	public void clear() {
<span class="fc" id="L1639">		this.headers.clear();</span>
<span class="fc" id="L1640">	}</span>

	@Override
	public Set&lt;String&gt; keySet() {
<span class="fc" id="L1644">		return this.headers.keySet();</span>
	}

	@Override
	public Collection&lt;List&lt;String&gt;&gt; values() {
<span class="nc" id="L1649">		return this.headers.values();</span>
	}

	@Override
	public Set&lt;Entry&lt;String, List&lt;String&gt;&gt;&gt; entrySet() {
<span class="fc" id="L1654">		return this.headers.entrySet();</span>
	}


	@Override
	public boolean equals(Object other) {
<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">		if (this == other) {</span>
<span class="nc" id="L1661">			return true;</span>
		}
<span class="pc bpc" id="L1663" title="1 of 2 branches missed.">		if (!(other instanceof HttpHeaders)) {</span>
<span class="nc" id="L1664">			return false;</span>
		}
<span class="fc" id="L1666">		HttpHeaders otherHeaders = (HttpHeaders) other;</span>
<span class="fc" id="L1667">		return this.headers.equals(otherHeaders.headers);</span>
	}

	@Override
	public int hashCode() {
<span class="nc" id="L1672">		return this.headers.hashCode();</span>
	}

	@Override
	public String toString() {
<span class="fc" id="L1677">		return formatHeaders(this.headers);</span>
	}


	/**
	 * Return an {@code HttpHeaders} object that can only be read, not written to.
	 */
	public static HttpHeaders readOnlyHttpHeaders(HttpHeaders headers) {
<span class="fc" id="L1685">		Assert.notNull(headers, &quot;HttpHeaders must not be null&quot;);</span>
<span class="pc bpc" id="L1686" title="1 of 2 branches missed.">		if (headers instanceof ReadOnlyHttpHeaders) {</span>
<span class="nc" id="L1687">			return headers;</span>
		}
		else {
<span class="fc" id="L1690">			return new ReadOnlyHttpHeaders(headers);</span>
		}
	}

	/**
	 * Return an {@code HttpHeaders} object that can be read and written to.
	 * @since 5.1.1
	 */
	public static HttpHeaders writableHttpHeaders(HttpHeaders headers) {
<span class="fc" id="L1699">		Assert.notNull(headers, &quot;HttpHeaders must not be null&quot;);</span>
<span class="pc bpc" id="L1700" title="1 of 2 branches missed.">		if (headers == EMPTY) {</span>
<span class="nc" id="L1701">			return new HttpHeaders();</span>
		}
<span class="pc bpc" id="L1703" title="1 of 2 branches missed.">		else if (headers instanceof ReadOnlyHttpHeaders) {</span>
<span class="fc" id="L1704">			return new HttpHeaders(headers.headers);</span>
		}
		else {
<span class="nc" id="L1707">			return headers;</span>
		}
	}

	/**
	 * Helps to format HTTP header values, as HTTP header values themselves can
	 * contain comma-separated values, can become confusing with regular
	 * {@link Map} formatting that also uses commas between entries.
	 * @param headers the headers to format
	 * @return the headers to a String
	 * @since 5.1.4
	 */
	public static String formatHeaders(MultiValueMap&lt;String, String&gt; headers) {
<span class="fc" id="L1720">		return headers.entrySet().stream()</span>
<span class="fc" id="L1721">				.map(entry -&gt; {</span>
<span class="fc" id="L1722">					List&lt;String&gt; values = entry.getValue();</span>
<span class="pc bpc" id="L1723" title="1 of 2 branches missed.">					return entry.getKey() + &quot;:&quot; + (values.size() == 1 ?</span>
<span class="pc" id="L1724">							&quot;\&quot;&quot; + values.get(0) + &quot;\&quot;&quot; :</span>
<span class="pc" id="L1725">							values.stream().map(s -&gt; &quot;\&quot;&quot; + s + &quot;\&quot;&quot;).collect(Collectors.joining(&quot;, &quot;)));</span>
				})
<span class="fc" id="L1727">				.collect(Collectors.joining(&quot;, &quot;, &quot;[&quot;, &quot;]&quot;));</span>
	}

	// Package-private: used in ResponseCookie
	static String formatDate(long date) {
<span class="fc" id="L1732">		Instant instant = Instant.ofEpochMilli(date);</span>
<span class="fc" id="L1733">		ZonedDateTime time = ZonedDateTime.ofInstant(instant, GMT);</span>
<span class="fc" id="L1734">		return DATE_FORMATTER.format(time);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>