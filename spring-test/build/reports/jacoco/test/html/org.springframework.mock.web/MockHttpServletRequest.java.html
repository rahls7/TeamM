<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MockHttpServletRequest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-test</a> &gt; <a href="index.source.html" class="el_package">org.springframework.mock.web</a> &gt; <span class="el_source">MockHttpServletRequest.java</span></div><h1>MockHttpServletRequest.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.mock.web;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.security.Principal;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;
import javax.servlet.AsyncContext;
import javax.servlet.DispatcherType;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletInputStream;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpUpgradeHandler;
import javax.servlet.http.Part;

import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.LinkedCaseInsensitiveMap;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StreamUtils;
import org.springframework.util.StringUtils;

/**
 * Mock implementation of the {@link javax.servlet.http.HttpServletRequest} interface.
 *
 * &lt;p&gt;The default, preferred {@link Locale} for the &lt;em&gt;server&lt;/em&gt; mocked by this request
 * is {@link Locale#ENGLISH}. This value can be changed via {@link #addPreferredLocale}
 * or {@link #setPreferredLocales}.
 *
 * &lt;p&gt;As of Spring Framework 5.0, this set of mocks is designed on a Servlet 4.0 baseline.
 *
 * @author Juergen Hoeller
 * @author Rod Johnson
 * @author Rick Evans
 * @author Mark Fisher
 * @author Chris Beams
 * @author Sam Brannen
 * @author Brian Clozel
 * @since 1.0.2
 */
public class MockHttpServletRequest implements HttpServletRequest {

	private static final String HTTP = &quot;http&quot;;

	private static final String HTTPS = &quot;https&quot;;

	private static final String CHARSET_PREFIX = &quot;charset=&quot;;

<span class="fc" id="L96">	private static final TimeZone GMT = TimeZone.getTimeZone(&quot;GMT&quot;);</span>

<span class="fc" id="L98">	private static final ServletInputStream EMPTY_SERVLET_INPUT_STREAM =</span>
<span class="fc" id="L99">			new DelegatingServletInputStream(StreamUtils.emptyInput());</span>

<span class="fc" id="L101">	private static final BufferedReader EMPTY_BUFFERED_READER =</span>
			new BufferedReader(new StringReader(&quot;&quot;));

	/**
	 * Date formats as specified in the HTTP RFC.
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;Section 7.1.1.1 of RFC 7231&lt;/a&gt;
	 */
<span class="fc" id="L108">	private static final String[] DATE_FORMATS = new String[] {</span>
			&quot;EEE, dd MMM yyyy HH:mm:ss zzz&quot;,
			&quot;EEE, dd-MMM-yy HH:mm:ss zzz&quot;,
			&quot;EEE MMM dd HH:mm:ss yyyy&quot;
	};


	// ---------------------------------------------------------------------
	// Public constants
	// ---------------------------------------------------------------------

	/**
	 * The default protocol: 'HTTP/1.1'.
	 * @since 4.3.7
	 */
	public static final String DEFAULT_PROTOCOL = &quot;HTTP/1.1&quot;;

	/**
	 * The default scheme: 'http'.
	 * @since 4.3.7
	 */
	public static final String DEFAULT_SCHEME = HTTP;

	/**
	 * The default server address: '127.0.0.1'.
	 */
	public static final String DEFAULT_SERVER_ADDR = &quot;127.0.0.1&quot;;

	/**
	 * The default server name: 'localhost'.
	 */
	public static final String DEFAULT_SERVER_NAME = &quot;localhost&quot;;

	/**
	 * The default server port: '80'.
	 */
	public static final int DEFAULT_SERVER_PORT = 80;

	/**
	 * The default remote address: '127.0.0.1'.
	 */
	public static final String DEFAULT_REMOTE_ADDR = &quot;127.0.0.1&quot;;

	/**
	 * The default remote host: 'localhost'.
	 */
	public static final String DEFAULT_REMOTE_HOST = &quot;localhost&quot;;


	// ---------------------------------------------------------------------
	// Lifecycle properties
	// ---------------------------------------------------------------------

	private final ServletContext servletContext;

<span class="fc" id="L163">	private boolean active = true;</span>


	// ---------------------------------------------------------------------
	// ServletRequest properties
	// ---------------------------------------------------------------------

<span class="fc" id="L170">	private final Map&lt;String, Object&gt; attributes = new LinkedHashMap&lt;&gt;();</span>

	@Nullable
	private String characterEncoding;

	@Nullable
	private byte[] content;

	@Nullable
	private String contentType;

	@Nullable
	private ServletInputStream inputStream;

	@Nullable
	private BufferedReader reader;

<span class="fc" id="L187">	private final Map&lt;String, String[]&gt; parameters = new LinkedHashMap&lt;&gt;(16);</span>

<span class="fc" id="L189">	private String protocol = DEFAULT_PROTOCOL;</span>

<span class="fc" id="L191">	private String scheme = DEFAULT_SCHEME;</span>

<span class="fc" id="L193">	private String serverName = DEFAULT_SERVER_NAME;</span>

<span class="fc" id="L195">	private int serverPort = DEFAULT_SERVER_PORT;</span>

<span class="fc" id="L197">	private String remoteAddr = DEFAULT_REMOTE_ADDR;</span>

<span class="fc" id="L199">	private String remoteHost = DEFAULT_REMOTE_HOST;</span>

	/** List of locales in descending order. */
<span class="fc" id="L202">	private final List&lt;Locale&gt; locales = new LinkedList&lt;&gt;();</span>

<span class="fc" id="L204">	private boolean secure = false;</span>

<span class="fc" id="L206">	private int remotePort = DEFAULT_SERVER_PORT;</span>

<span class="fc" id="L208">	private String localName = DEFAULT_SERVER_NAME;</span>

<span class="fc" id="L210">	private String localAddr = DEFAULT_SERVER_ADDR;</span>

<span class="fc" id="L212">	private int localPort = DEFAULT_SERVER_PORT;</span>

<span class="fc" id="L214">	private boolean asyncStarted = false;</span>

<span class="fc" id="L216">	private boolean asyncSupported = false;</span>

	@Nullable
	private MockAsyncContext asyncContext;

<span class="fc" id="L221">	private DispatcherType dispatcherType = DispatcherType.REQUEST;</span>


	// ---------------------------------------------------------------------
	// HttpServletRequest properties
	// ---------------------------------------------------------------------

	@Nullable
	private String authType;

	@Nullable
	private Cookie[] cookies;

<span class="fc" id="L234">	private final Map&lt;String, HeaderValueHolder&gt; headers = new LinkedCaseInsensitiveMap&lt;&gt;();</span>

	@Nullable
	private String method;

	@Nullable
	private String pathInfo;

<span class="fc" id="L242">	private String contextPath = &quot;&quot;;</span>

	@Nullable
	private String queryString;

	@Nullable
	private String remoteUser;

<span class="fc" id="L250">	private final Set&lt;String&gt; userRoles = new HashSet&lt;&gt;();</span>

	@Nullable
	private Principal userPrincipal;

	@Nullable
	private String requestedSessionId;

	@Nullable
	private String requestURI;

<span class="fc" id="L261">	private String servletPath = &quot;&quot;;</span>

	@Nullable
	private HttpSession session;

<span class="fc" id="L266">	private boolean requestedSessionIdValid = true;</span>

<span class="fc" id="L268">	private boolean requestedSessionIdFromCookie = true;</span>

<span class="fc" id="L270">	private boolean requestedSessionIdFromURL = false;</span>

<span class="fc" id="L272">	private final MultiValueMap&lt;String, Part&gt; parts = new LinkedMultiValueMap&lt;&gt;();</span>


	// ---------------------------------------------------------------------
	// Constructors
	// ---------------------------------------------------------------------

	/**
	 * Create a new {@code MockHttpServletRequest} with a default
	 * {@link MockServletContext}.
	 * @see #MockHttpServletRequest(ServletContext, String, String)
	 */
	public MockHttpServletRequest() {
<span class="fc" id="L285">		this(null, &quot;&quot;, &quot;&quot;);</span>
<span class="fc" id="L286">	}</span>

	/**
	 * Create a new {@code MockHttpServletRequest} with a default
	 * {@link MockServletContext}.
	 * @param method the request method (may be {@code null})
	 * @param requestURI the request URI (may be {@code null})
	 * @see #setMethod
	 * @see #setRequestURI
	 * @see #MockHttpServletRequest(ServletContext, String, String)
	 */
	public MockHttpServletRequest(@Nullable String method, @Nullable String requestURI) {
<span class="fc" id="L298">		this(null, method, requestURI);</span>
<span class="fc" id="L299">	}</span>

	/**
	 * Create a new {@code MockHttpServletRequest} with the supplied {@link ServletContext}.
	 * @param servletContext the ServletContext that the request runs in
	 * (may be {@code null} to use a default {@link MockServletContext})
	 * @see #MockHttpServletRequest(ServletContext, String, String)
	 */
	public MockHttpServletRequest(@Nullable ServletContext servletContext) {
<span class="fc" id="L308">		this(servletContext, &quot;&quot;, &quot;&quot;);</span>
<span class="fc" id="L309">	}</span>

	/**
	 * Create a new {@code MockHttpServletRequest} with the supplied {@link ServletContext},
	 * {@code method}, and {@code requestURI}.
	 * &lt;p&gt;The preferred locale will be set to {@link Locale#ENGLISH}.
	 * @param servletContext the ServletContext that the request runs in (may be
	 * {@code null} to use a default {@link MockServletContext})
	 * @param method the request method (may be {@code null})
	 * @param requestURI the request URI (may be {@code null})
	 * @see #setMethod
	 * @see #setRequestURI
	 * @see #setPreferredLocales
	 * @see MockServletContext
	 */
<span class="fc" id="L324">	public MockHttpServletRequest(@Nullable ServletContext servletContext, @Nullable String method, @Nullable String requestURI) {</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">		this.servletContext = (servletContext != null ? servletContext : new MockServletContext());</span>
<span class="fc" id="L326">		this.method = method;</span>
<span class="fc" id="L327">		this.requestURI = requestURI;</span>
<span class="fc" id="L328">		this.locales.add(Locale.ENGLISH);</span>
<span class="fc" id="L329">	}</span>


	// ---------------------------------------------------------------------
	// Lifecycle methods
	// ---------------------------------------------------------------------

	/**
	 * Return the ServletContext that this request is associated with. (Not
	 * available in the standard HttpServletRequest interface for some reason.)
	 */
	@Override
	public ServletContext getServletContext() {
<span class="fc" id="L342">		return this.servletContext;</span>
	}

	/**
	 * Return whether this request is still active (that is, not completed yet).
	 */
	public boolean isActive() {
<span class="nc" id="L349">		return this.active;</span>
	}

	/**
	 * Mark this request as completed, keeping its state.
	 */
	public void close() {
<span class="nc" id="L356">		this.active = false;</span>
<span class="nc" id="L357">	}</span>

	/**
	 * Invalidate this request, clearing its state.
	 */
	public void invalidate() {
<span class="nc" id="L363">		close();</span>
<span class="nc" id="L364">		clearAttributes();</span>
<span class="nc" id="L365">	}</span>

	/**
	 * Check whether this request is still active (that is, not completed yet),
	 * throwing an IllegalStateException if not active anymore.
	 */
	protected void checkActive() throws IllegalStateException {
<span class="fc" id="L372">		Assert.state(this.active, &quot;Request is not active anymore&quot;);</span>
<span class="fc" id="L373">	}</span>


	// ---------------------------------------------------------------------
	// ServletRequest interface
	// ---------------------------------------------------------------------

	@Override
	public Object getAttribute(String name) {
<span class="fc" id="L382">		checkActive();</span>
<span class="fc" id="L383">		return this.attributes.get(name);</span>
	}

	@Override
	public Enumeration&lt;String&gt; getAttributeNames() {
<span class="fc" id="L388">		checkActive();</span>
<span class="fc" id="L389">		return Collections.enumeration(new LinkedHashSet&lt;&gt;(this.attributes.keySet()));</span>
	}

	@Override
	@Nullable
	public String getCharacterEncoding() {
<span class="fc" id="L395">		return this.characterEncoding;</span>
	}

	@Override
	public void setCharacterEncoding(@Nullable String characterEncoding) {
<span class="fc" id="L400">		this.characterEncoding = characterEncoding;</span>
<span class="fc" id="L401">		updateContentTypeHeader();</span>
<span class="fc" id="L402">	}</span>

	private void updateContentTypeHeader() {
<span class="fc bfc" id="L405" title="All 2 branches covered.">		if (StringUtils.hasLength(this.contentType)) {</span>
<span class="fc" id="L406">			String value = this.contentType;</span>
<span class="fc bfc" id="L407" title="All 4 branches covered.">			if (StringUtils.hasLength(this.characterEncoding) &amp;&amp; !this.contentType.toLowerCase().contains(CHARSET_PREFIX)) {</span>
<span class="fc" id="L408">				value += ';' + CHARSET_PREFIX + this.characterEncoding;</span>
			}
<span class="fc" id="L410">			doAddHeaderValue(HttpHeaders.CONTENT_TYPE, value, true);</span>
		}
<span class="fc" id="L412">	}</span>

	/**
	 * Set the content of the request body as a byte array.
	 * &lt;p&gt;If the supplied byte array represents text such as XML or JSON, the
	 * {@link #setCharacterEncoding character encoding} should typically be
	 * set as well.
	 * @see #setCharacterEncoding(String)
	 * @see #getContentAsByteArray()
	 * @see #getContentAsString()
	 */
	public void setContent(@Nullable byte[] content) {
<span class="fc" id="L424">		this.content = content;</span>
<span class="fc" id="L425">		this.inputStream = null;</span>
<span class="fc" id="L426">		this.reader = null;</span>
<span class="fc" id="L427">	}</span>

	/**
	 * Get the content of the request body as a byte array.
	 * @return the content as a byte array (potentially {@code null})
	 * @since 5.0
	 * @see #setContent(byte[])
	 * @see #getContentAsString()
	 */
	@Nullable
	public byte[] getContentAsByteArray() {
<span class="fc" id="L438">		return this.content;</span>
	}

	/**
	 * Get the content of the request body as a {@code String}, using the configured
	 * {@linkplain #getCharacterEncoding character encoding}.
	 * @return the content as a {@code String}, potentially {@code null}
	 * @throws IllegalStateException if the character encoding has not been set
	 * @throws UnsupportedEncodingException if the character encoding is not supported
	 * @since 5.0
	 * @see #setContent(byte[])
	 * @see #setCharacterEncoding(String)
	 * @see #getContentAsByteArray()
	 */
	@Nullable
	public String getContentAsString() throws IllegalStateException, UnsupportedEncodingException {
<span class="fc bfc" id="L454" title="All 2 branches covered.">		Assert.state(this.characterEncoding != null,</span>
				&quot;Cannot get content as a String for a null character encoding. &quot; +
				&quot;Consider setting the characterEncoding in the request.&quot;);

<span class="pc bpc" id="L458" title="1 of 2 branches missed.">		if (this.content == null) {</span>
<span class="nc" id="L459">			return null;</span>
		}
<span class="fc" id="L461">		return new String(this.content, this.characterEncoding);</span>
	}

	@Override
	public int getContentLength() {
<span class="fc bfc" id="L466" title="All 2 branches covered.">		return (this.content != null ? this.content.length : -1);</span>
	}

	@Override
	public long getContentLengthLong() {
<span class="nc" id="L471">		return getContentLength();</span>
	}

	public void setContentType(@Nullable String contentType) {
<span class="fc" id="L475">		this.contentType = contentType;</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">		if (contentType != null) {</span>
			try {
<span class="fc" id="L478">				MediaType mediaType = MediaType.parseMediaType(contentType);</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">				if (mediaType.getCharset() != null) {</span>
<span class="fc" id="L480">					this.characterEncoding = mediaType.getCharset().name();</span>
				}
			}
<span class="nc" id="L483">			catch (IllegalArgumentException ex) {</span>
				// Try to get charset value anyway
<span class="nc" id="L485">				int charsetIndex = contentType.toLowerCase().indexOf(CHARSET_PREFIX);</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">				if (charsetIndex != -1) {</span>
<span class="nc" id="L487">					this.characterEncoding = contentType.substring(charsetIndex + CHARSET_PREFIX.length());</span>
				}
<span class="fc" id="L489">			}</span>
<span class="fc" id="L490">			updateContentTypeHeader();</span>
		}
<span class="fc" id="L492">	}</span>

	@Override
	@Nullable
	public String getContentType() {
<span class="fc" id="L497">		return this.contentType;</span>
	}

	@Override
	public ServletInputStream getInputStream() {
<span class="fc bfc" id="L502" title="All 2 branches covered.">		if (this.inputStream != null) {</span>
<span class="fc" id="L503">			return this.inputStream;</span>
		}
<span class="fc bfc" id="L505" title="All 2 branches covered.">		else if (this.reader != null) {</span>
<span class="fc" id="L506">			throw new IllegalStateException(</span>
					&quot;Cannot call getInputStream() after getReader() has already been called for the current request&quot;)			;
		}

<span class="fc bfc" id="L510" title="All 2 branches covered.">		this.inputStream = (this.content != null ?</span>
				new DelegatingServletInputStream(new ByteArrayInputStream(this.content)) :
				EMPTY_SERVLET_INPUT_STREAM);
<span class="fc" id="L513">		return this.inputStream;</span>
	}

	/**
	 * Set a single value for the specified HTTP parameter.
	 * &lt;p&gt;If there are already one or more values registered for the given
	 * parameter name, they will be replaced.
	 */
	public void setParameter(String name, String value) {
<span class="fc" id="L522">		setParameter(name, new String[] {value});</span>
<span class="fc" id="L523">	}</span>

	/**
	 * Set an array of values for the specified HTTP parameter.
	 * &lt;p&gt;If there are already one or more values registered for the given
	 * parameter name, they will be replaced.
	 */
	public void setParameter(String name, String... values) {
<span class="fc" id="L531">		Assert.notNull(name, &quot;Parameter name must not be null&quot;);</span>
<span class="fc" id="L532">		this.parameters.put(name, values);</span>
<span class="fc" id="L533">	}</span>

	/**
	 * Set all provided parameters &lt;strong&gt;replacing&lt;/strong&gt; any existing
	 * values for the provided parameter names. To add without replacing
	 * existing values, use {@link #addParameters(java.util.Map)}.
	 */
	public void setParameters(Map&lt;String, ?&gt; params) {
<span class="fc" id="L541">		Assert.notNull(params, &quot;Parameter map must not be null&quot;);</span>
<span class="fc" id="L542">		params.forEach((key, value) -&gt; {</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">			if (value instanceof String) {</span>
<span class="fc" id="L544">				setParameter(key, (String) value);</span>
			}
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">			else if (value instanceof String[]) {</span>
<span class="fc" id="L547">				setParameter(key, (String[]) value);</span>
			}
			else {
<span class="nc" id="L550">				throw new IllegalArgumentException(</span>
<span class="nc" id="L551">						&quot;Parameter map value must be single value &quot; + &quot; or array of type [&quot; + String.class.getName() + &quot;]&quot;);</span>
			}
<span class="fc" id="L553">		});</span>
<span class="fc" id="L554">	}</span>

	/**
	 * Add a single value for the specified HTTP parameter.
	 * &lt;p&gt;If there are already one or more values registered for the given
	 * parameter name, the given value will be added to the end of the list.
	 */
	public void addParameter(String name, @Nullable String value) {
<span class="fc" id="L562">		addParameter(name, new String[] {value});</span>
<span class="fc" id="L563">	}</span>

	/**
	 * Add an array of values for the specified HTTP parameter.
	 * &lt;p&gt;If there are already one or more values registered for the given
	 * parameter name, the given values will be added to the end of the list.
	 */
	public void addParameter(String name, String... values) {
<span class="fc" id="L571">		Assert.notNull(name, &quot;Parameter name must not be null&quot;);</span>
<span class="fc" id="L572">		String[] oldArr = this.parameters.get(name);</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">		if (oldArr != null) {</span>
<span class="fc" id="L574">			String[] newArr = new String[oldArr.length + values.length];</span>
<span class="fc" id="L575">			System.arraycopy(oldArr, 0, newArr, 0, oldArr.length);</span>
<span class="fc" id="L576">			System.arraycopy(values, 0, newArr, oldArr.length, values.length);</span>
<span class="fc" id="L577">			this.parameters.put(name, newArr);</span>
<span class="fc" id="L578">		}</span>
		else {
<span class="fc" id="L580">			this.parameters.put(name, values);</span>
		}
<span class="fc" id="L582">	}</span>

	/**
	 * Add all provided parameters &lt;strong&gt;without&lt;/strong&gt; replacing any
	 * existing values. To replace existing values, use
	 * {@link #setParameters(java.util.Map)}.
	 */
	public void addParameters(Map&lt;String, ?&gt; params) {
<span class="fc" id="L590">		Assert.notNull(params, &quot;Parameter map must not be null&quot;);</span>
<span class="fc" id="L591">		params.forEach((key, value) -&gt; {</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">			if (value instanceof String) {</span>
<span class="fc" id="L593">				addParameter(key, (String) value);</span>
			}
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">			else if (value instanceof String[]) {</span>
<span class="fc" id="L596">				addParameter(key, (String[]) value);</span>
			}
			else {
<span class="nc" id="L599">				throw new IllegalArgumentException(&quot;Parameter map value must be single value &quot; +</span>
<span class="nc" id="L600">						&quot; or array of type [&quot; + String.class.getName() + &quot;]&quot;);</span>
			}
<span class="fc" id="L602">		});</span>
<span class="fc" id="L603">	}</span>

	/**
	 * Remove already registered values for the specified HTTP parameter, if any.
	 */
	public void removeParameter(String name) {
<span class="nc" id="L609">		Assert.notNull(name, &quot;Parameter name must not be null&quot;);</span>
<span class="nc" id="L610">		this.parameters.remove(name);</span>
<span class="nc" id="L611">	}</span>

	/**
	 * Remove all existing parameters.
	 */
	public void removeAllParameters() {
<span class="fc" id="L617">		this.parameters.clear();</span>
<span class="fc" id="L618">	}</span>

	@Override
	@Nullable
	public String getParameter(String name) {
<span class="fc" id="L623">		Assert.notNull(name, &quot;Parameter name must not be null&quot;);</span>
<span class="fc" id="L624">		String[] arr = this.parameters.get(name);</span>
<span class="pc bpc" id="L625" title="1 of 4 branches missed.">		return (arr != null &amp;&amp; arr.length &gt; 0 ? arr[0] : null);</span>
	}

	@Override
	public Enumeration&lt;String&gt; getParameterNames() {
<span class="fc" id="L630">		return Collections.enumeration(this.parameters.keySet());</span>
	}

	@Override
	public String[] getParameterValues(String name) {
<span class="fc" id="L635">		Assert.notNull(name, &quot;Parameter name must not be null&quot;);</span>
<span class="fc" id="L636">		return this.parameters.get(name);</span>
	}

	@Override
	public Map&lt;String, String[]&gt; getParameterMap() {
<span class="fc" id="L641">		return Collections.unmodifiableMap(this.parameters);</span>
	}

	public void setProtocol(String protocol) {
<span class="fc" id="L645">		this.protocol = protocol;</span>
<span class="fc" id="L646">	}</span>

	@Override
	public String getProtocol() {
<span class="fc" id="L650">		return this.protocol;</span>
	}

	public void setScheme(String scheme) {
<span class="fc" id="L654">		this.scheme = scheme;</span>
<span class="fc" id="L655">	}</span>

	@Override
	public String getScheme() {
<span class="fc" id="L659">		return this.scheme;</span>
	}

	public void setServerName(String serverName) {
<span class="fc" id="L663">		this.serverName = serverName;</span>
<span class="fc" id="L664">	}</span>

	@Override
	public String getServerName() {
<span class="fc" id="L668">		String host = getHeader(HttpHeaders.HOST);</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">		if (host != null) {</span>
<span class="fc" id="L670">			host = host.trim();</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">			if (host.startsWith(&quot;[&quot;)) {</span>
<span class="fc" id="L672">				host = host.substring(1, host.indexOf(']'));</span>
			}
<span class="fc bfc" id="L674" title="All 2 branches covered.">			else if (host.contains(&quot;:&quot;)) {</span>
<span class="fc" id="L675">				host = host.substring(0, host.indexOf(':'));</span>
			}
<span class="fc" id="L677">			return host;</span>
		}

		// else
<span class="fc" id="L681">		return this.serverName;</span>
	}

	public void setServerPort(int serverPort) {
<span class="fc" id="L685">		this.serverPort = serverPort;</span>
<span class="fc" id="L686">	}</span>

	@Override
	public int getServerPort() {
<span class="fc" id="L690">		String host = getHeader(HttpHeaders.HOST);</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">		if (host != null) {</span>
<span class="fc" id="L692">			host = host.trim();</span>
			int idx;
<span class="fc bfc" id="L694" title="All 2 branches covered.">			if (host.startsWith(&quot;[&quot;)) {</span>
<span class="fc" id="L695">				idx = host.indexOf(':', host.indexOf(']'));</span>
			}
			else {
<span class="fc" id="L698">				idx = host.indexOf(':');</span>
			}
<span class="fc bfc" id="L700" title="All 2 branches covered.">			if (idx != -1) {</span>
<span class="fc" id="L701">				return Integer.parseInt(host.substring(idx + 1));</span>
			}
		}

		// else
<span class="fc" id="L706">		return this.serverPort;</span>
	}

	@Override
	public BufferedReader getReader() throws UnsupportedEncodingException {
<span class="fc bfc" id="L711" title="All 2 branches covered.">		if (this.reader != null) {</span>
<span class="fc" id="L712">			return this.reader;</span>
		}
<span class="fc bfc" id="L714" title="All 2 branches covered.">		else if (this.inputStream != null) {</span>
<span class="fc" id="L715">			throw new IllegalStateException(</span>
					&quot;Cannot call getReader() after getInputStream() has already been called for the current request&quot;)			;
		}

<span class="fc bfc" id="L719" title="All 2 branches covered.">		if (this.content != null) {</span>
<span class="fc" id="L720">			InputStream sourceStream = new ByteArrayInputStream(this.content);</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">			Reader sourceReader = (this.characterEncoding != null) ?</span>
					new InputStreamReader(sourceStream, this.characterEncoding) :
					new InputStreamReader(sourceStream);
<span class="fc" id="L724">			this.reader = new BufferedReader(sourceReader);</span>
<span class="fc" id="L725">		}</span>
		else {
<span class="fc" id="L727">			this.reader = EMPTY_BUFFERED_READER;</span>
		}
<span class="fc" id="L729">		return this.reader;</span>
	}

	public void setRemoteAddr(String remoteAddr) {
<span class="nc" id="L733">		this.remoteAddr = remoteAddr;</span>
<span class="nc" id="L734">	}</span>

	@Override
	public String getRemoteAddr() {
<span class="fc" id="L738">		return this.remoteAddr;</span>
	}

	public void setRemoteHost(String remoteHost) {
<span class="nc" id="L742">		this.remoteHost = remoteHost;</span>
<span class="nc" id="L743">	}</span>

	@Override
	public String getRemoteHost() {
<span class="nc" id="L747">		return this.remoteHost;</span>
	}

	@Override
	public void setAttribute(String name, @Nullable Object value) {
<span class="fc" id="L752">		checkActive();</span>
<span class="fc" id="L753">		Assert.notNull(name, &quot;Attribute name must not be null&quot;);</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">		if (value != null) {</span>
<span class="fc" id="L755">			this.attributes.put(name, value);</span>
		}
		else {
<span class="fc" id="L758">			this.attributes.remove(name);</span>
		}
<span class="fc" id="L760">	}</span>

	@Override
	public void removeAttribute(String name) {
<span class="fc" id="L764">		checkActive();</span>
<span class="fc" id="L765">		Assert.notNull(name, &quot;Attribute name must not be null&quot;);</span>
<span class="fc" id="L766">		this.attributes.remove(name);</span>
<span class="fc" id="L767">	}</span>

	/**
	 * Clear all of this request's attributes.
	 */
	public void clearAttributes() {
<span class="nc" id="L773">		this.attributes.clear();</span>
<span class="nc" id="L774">	}</span>

	/**
	 * Add a new preferred locale, before any existing locales.
	 * @see #setPreferredLocales
	 */
	public void addPreferredLocale(Locale locale) {
<span class="fc" id="L781">		Assert.notNull(locale, &quot;Locale must not be null&quot;);</span>
<span class="fc" id="L782">		this.locales.add(0, locale);</span>
<span class="fc" id="L783">		updateAcceptLanguageHeader();</span>
<span class="fc" id="L784">	}</span>

	/**
	 * Set the list of preferred locales, in descending order, effectively replacing
	 * any existing locales.
	 * @since 3.2
	 * @see #addPreferredLocale
	 */
	public void setPreferredLocales(List&lt;Locale&gt; locales) {
<span class="fc" id="L793">		Assert.notEmpty(locales, &quot;Locale list must not be empty&quot;);</span>
<span class="fc" id="L794">		this.locales.clear();</span>
<span class="fc" id="L795">		this.locales.addAll(locales);</span>
<span class="fc" id="L796">		updateAcceptLanguageHeader();</span>
<span class="fc" id="L797">	}</span>

	private void updateAcceptLanguageHeader() {
<span class="fc" id="L800">		HttpHeaders headers = new HttpHeaders();</span>
<span class="fc" id="L801">		headers.setAcceptLanguageAsLocales(this.locales);</span>
<span class="fc" id="L802">		doAddHeaderValue(HttpHeaders.ACCEPT_LANGUAGE, headers.getFirst(HttpHeaders.ACCEPT_LANGUAGE), true);</span>
<span class="fc" id="L803">	}</span>

	/**
	 * Return the first preferred {@linkplain Locale locale} configured
	 * in this mock request.
	 * &lt;p&gt;If no locales have been explicitly configured, the default,
	 * preferred {@link Locale} for the &lt;em&gt;server&lt;/em&gt; mocked by this
	 * request is {@link Locale#ENGLISH}.
	 * &lt;p&gt;In contrast to the Servlet specification, this mock implementation
	 * does &lt;strong&gt;not&lt;/strong&gt; take into consideration any locales
	 * specified via the {@code Accept-Language} header.
	 * @see javax.servlet.ServletRequest#getLocale()
	 * @see #addPreferredLocale(Locale)
	 * @see #setPreferredLocales(List)
	 */
	@Override
	public Locale getLocale() {
<span class="fc" id="L820">		return this.locales.get(0);</span>
	}

	/**
	 * Return an {@linkplain Enumeration enumeration} of the preferred
	 * {@linkplain Locale locales} configured in this mock request.
	 * &lt;p&gt;If no locales have been explicitly configured, the default,
	 * preferred {@link Locale} for the &lt;em&gt;server&lt;/em&gt; mocked by this
	 * request is {@link Locale#ENGLISH}.
	 * &lt;p&gt;In contrast to the Servlet specification, this mock implementation
	 * does &lt;strong&gt;not&lt;/strong&gt; take into consideration any locales
	 * specified via the {@code Accept-Language} header.
	 * @see javax.servlet.ServletRequest#getLocales()
	 * @see #addPreferredLocale(Locale)
	 * @see #setPreferredLocales(List)
	 */
	@Override
	public Enumeration&lt;Locale&gt; getLocales() {
<span class="fc" id="L838">		return Collections.enumeration(this.locales);</span>
	}

	/**
	 * Set the boolean {@code secure} flag indicating whether the mock request
	 * was made using a secure channel, such as HTTPS.
	 * @see #isSecure()
	 * @see #getScheme()
	 * @see #setScheme(String)
	 */
	public void setSecure(boolean secure) {
<span class="fc" id="L849">		this.secure = secure;</span>
<span class="fc" id="L850">	}</span>

	/**
	 * Return {@code true} if the {@link #setSecure secure} flag has been set
	 * to {@code true} or if the {@link #getScheme scheme} is {@code https}.
	 * @see javax.servlet.ServletRequest#isSecure()
	 */
	@Override
	public boolean isSecure() {
<span class="fc bfc" id="L859" title="All 4 branches covered.">		return (this.secure || HTTPS.equalsIgnoreCase(this.scheme));</span>
	}

	@Override
	public RequestDispatcher getRequestDispatcher(String path) {
<span class="fc" id="L864">		return new MockRequestDispatcher(path);</span>
	}

	@Override
	@Deprecated
	public String getRealPath(String path) {
<span class="nc" id="L870">		return this.servletContext.getRealPath(path);</span>
	}

	public void setRemotePort(int remotePort) {
<span class="fc" id="L874">		this.remotePort = remotePort;</span>
<span class="fc" id="L875">	}</span>

	@Override
	public int getRemotePort() {
<span class="fc" id="L879">		return this.remotePort;</span>
	}

	public void setLocalName(String localName) {
<span class="nc" id="L883">		this.localName = localName;</span>
<span class="nc" id="L884">	}</span>

	@Override
	public String getLocalName() {
<span class="fc" id="L888">		return this.localName;</span>
	}

	public void setLocalAddr(String localAddr) {
<span class="nc" id="L892">		this.localAddr = localAddr;</span>
<span class="nc" id="L893">	}</span>

	@Override
	public String getLocalAddr() {
<span class="fc" id="L897">		return this.localAddr;</span>
	}

	public void setLocalPort(int localPort) {
<span class="fc" id="L901">		this.localPort = localPort;</span>
<span class="fc" id="L902">	}</span>

	@Override
	public int getLocalPort() {
<span class="fc" id="L906">		return this.localPort;</span>
	}

	@Override
	public AsyncContext startAsync() {
<span class="nc" id="L911">		return startAsync(this, null);</span>
	}

	@Override
	public AsyncContext startAsync(ServletRequest request, @Nullable ServletResponse response) {
<span class="fc" id="L916">		Assert.state(this.asyncSupported, &quot;Async not supported&quot;);</span>
<span class="fc" id="L917">		this.asyncStarted = true;</span>
<span class="fc" id="L918">		this.asyncContext = new MockAsyncContext(request, response);</span>
<span class="fc" id="L919">		return this.asyncContext;</span>
	}

	public void setAsyncStarted(boolean asyncStarted) {
<span class="fc" id="L923">		this.asyncStarted = asyncStarted;</span>
<span class="fc" id="L924">	}</span>

	@Override
	public boolean isAsyncStarted() {
<span class="fc" id="L928">		return this.asyncStarted;</span>
	}

	public void setAsyncSupported(boolean asyncSupported) {
<span class="fc" id="L932">		this.asyncSupported = asyncSupported;</span>
<span class="fc" id="L933">	}</span>

	@Override
	public boolean isAsyncSupported() {
<span class="fc" id="L937">		return this.asyncSupported;</span>
	}

	public void setAsyncContext(@Nullable MockAsyncContext asyncContext) {
<span class="nc" id="L941">		this.asyncContext = asyncContext;</span>
<span class="nc" id="L942">	}</span>

	@Override
	@Nullable
	public AsyncContext getAsyncContext() {
<span class="fc" id="L947">		return this.asyncContext;</span>
	}

	public void setDispatcherType(DispatcherType dispatcherType) {
<span class="fc" id="L951">		this.dispatcherType = dispatcherType;</span>
<span class="fc" id="L952">	}</span>

	@Override
	public DispatcherType getDispatcherType() {
<span class="fc" id="L956">		return this.dispatcherType;</span>
	}


	// ---------------------------------------------------------------------
	// HttpServletRequest interface
	// ---------------------------------------------------------------------

	public void setAuthType(@Nullable String authType) {
<span class="fc" id="L965">		this.authType = authType;</span>
<span class="fc" id="L966">	}</span>

	@Override
	@Nullable
	public String getAuthType() {
<span class="fc" id="L971">		return this.authType;</span>
	}

	public void setCookies(@Nullable Cookie... cookies) {
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">		this.cookies = (ObjectUtils.isEmpty(cookies) ? null : cookies);</span>
<span class="fc" id="L976">		this.headers.remove(HttpHeaders.COOKIE);</span>
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">		if (this.cookies != null) {</span>
<span class="fc" id="L978">			Arrays.stream(this.cookies)</span>
<span class="pc bpc" id="L979" title="1 of 2 branches missed.">					.map(c -&gt; c.getName() + '=' + (c.getValue() == null ? &quot;&quot; : c.getValue()))</span>
<span class="fc" id="L980">					.forEach(value -&gt; doAddHeaderValue(HttpHeaders.COOKIE, value, false));</span>
		}
<span class="fc" id="L982">	}</span>

	@Override
	@Nullable
	public Cookie[] getCookies() {
<span class="fc" id="L987">		return this.cookies;</span>
	}

	/**
	 * Add an HTTP header entry for the given name.
	 * &lt;p&gt;While this method can take any {@code Object} as a parameter,
	 * it is recommended to use the following types:
	 * &lt;ul&gt;
	 * &lt;li&gt;String or any Object to be converted using {@code toString()}; see {@link #getHeader}.&lt;/li&gt;
	 * &lt;li&gt;String, Number, or Date for date headers; see {@link #getDateHeader}.&lt;/li&gt;
	 * &lt;li&gt;String or Number for integer headers; see {@link #getIntHeader}.&lt;/li&gt;
	 * &lt;li&gt;{@code String[]} or {@code Collection&lt;String&gt;} for multiple values; see {@link #getHeaders}.&lt;/li&gt;
	 * &lt;/ul&gt;
	 * @see #getHeaderNames
	 * @see #getHeaders
	 * @see #getHeader
	 * @see #getDateHeader
	 */
	public void addHeader(String name, Object value) {
<span class="fc bfc" id="L1006" title="All 2 branches covered.">		if (HttpHeaders.CONTENT_TYPE.equalsIgnoreCase(name) &amp;&amp;</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">				!this.headers.containsKey(HttpHeaders.CONTENT_TYPE)) {</span>
<span class="fc" id="L1008">			setContentType(value.toString());</span>
		}
<span class="fc bfc" id="L1010" title="All 2 branches covered.">		else if (HttpHeaders.ACCEPT_LANGUAGE.equalsIgnoreCase(name) &amp;&amp;</span>
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">				!this.headers.containsKey(HttpHeaders.ACCEPT_LANGUAGE)) {</span>
			try {
<span class="fc" id="L1013">				HttpHeaders headers = new HttpHeaders();</span>
<span class="fc" id="L1014">				headers.add(HttpHeaders.ACCEPT_LANGUAGE, value.toString());</span>
<span class="fc" id="L1015">				List&lt;Locale&gt; locales = headers.getAcceptLanguageAsLocales();</span>
<span class="fc" id="L1016">				this.locales.clear();</span>
<span class="fc" id="L1017">				this.locales.addAll(locales);</span>
			}
<span class="fc" id="L1019">			catch (IllegalArgumentException ex) {</span>
				// Invalid Accept-Language format -&gt; just store plain header
<span class="fc" id="L1021">			}</span>
<span class="fc" id="L1022">			doAddHeaderValue(name, value, true);</span>
		}
		else {
<span class="fc" id="L1025">			doAddHeaderValue(name, value, false);</span>
		}
<span class="fc" id="L1027">	}</span>

	private void doAddHeaderValue(String name, @Nullable Object value, boolean replace) {
<span class="fc" id="L1030">		HeaderValueHolder header = HeaderValueHolder.getByName(this.headers, name);</span>
<span class="fc" id="L1031">		Assert.notNull(value, &quot;Header value must not be null&quot;);</span>
<span class="fc bfc" id="L1032" title="All 4 branches covered.">		if (header == null || replace) {</span>
<span class="fc" id="L1033">			header = new HeaderValueHolder();</span>
<span class="fc" id="L1034">			this.headers.put(name, header);</span>
		}
<span class="fc bfc" id="L1036" title="All 2 branches covered.">		if (value instanceof Collection) {</span>
<span class="fc" id="L1037">			header.addValues((Collection&lt;?&gt;) value);</span>
		}
<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">		else if (value.getClass().isArray()) {</span>
<span class="nc" id="L1040">			header.addValueArray(value);</span>
		}
		else {
<span class="fc" id="L1043">			header.addValue(value);</span>
		}
<span class="fc" id="L1045">	}</span>

	/**
	 * Remove already registered entries for the specified HTTP header, if any.
	 * @since 4.3.20
	 */
	public void removeHeader(String name) {
<span class="nc" id="L1052">		Assert.notNull(name, &quot;Header name must not be null&quot;);</span>
<span class="nc" id="L1053">		this.headers.remove(name);</span>
<span class="nc" id="L1054">	}</span>

	/**
	 * Return the long timestamp for the date header with the given {@code name}.
	 * &lt;p&gt;If the internal value representation is a String, this method will try
	 * to parse it as a date using the supported date formats:
	 * &lt;ul&gt;
	 * &lt;li&gt;&quot;EEE, dd MMM yyyy HH:mm:ss zzz&quot;&lt;/li&gt;
	 * &lt;li&gt;&quot;EEE, dd-MMM-yy HH:mm:ss zzz&quot;&lt;/li&gt;
	 * &lt;li&gt;&quot;EEE MMM dd HH:mm:ss yyyy&quot;&lt;/li&gt;
	 * &lt;/ul&gt;
	 * @param name the header name
	 * @see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;Section 7.1.1.1 of RFC 7231&lt;/a&gt;
	 */
	@Override
	public long getDateHeader(String name) {
<span class="fc" id="L1070">		HeaderValueHolder header = HeaderValueHolder.getByName(this.headers, name);</span>
<span class="fc bfc" id="L1071" title="All 2 branches covered.">		Object value = (header != null ? header.getValue() : null);</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">		if (value instanceof Date) {</span>
<span class="fc" id="L1073">			return ((Date) value).getTime();</span>
		}
<span class="fc bfc" id="L1075" title="All 2 branches covered.">		else if (value instanceof Number) {</span>
<span class="fc" id="L1076">			return ((Number) value).longValue();</span>
		}
<span class="fc bfc" id="L1078" title="All 2 branches covered.">		else if (value instanceof String) {</span>
<span class="fc" id="L1079">			return parseDateHeader(name, (String) value);</span>
		}
<span class="pc bpc" id="L1081" title="1 of 2 branches missed.">		else if (value != null) {</span>
<span class="nc" id="L1082">			throw new IllegalArgumentException(</span>
					&quot;Value for header '&quot; + name + &quot;' is not a Date, Number, or String: &quot; + value);
		}
		else {
<span class="fc" id="L1086">			return -1L;</span>
		}
	}

	private long parseDateHeader(String name, String value) {
<span class="fc bfc" id="L1091" title="All 2 branches covered.">		for (String dateFormat : DATE_FORMATS) {</span>
<span class="fc" id="L1092">			SimpleDateFormat simpleDateFormat = new SimpleDateFormat(dateFormat, Locale.US);</span>
<span class="fc" id="L1093">			simpleDateFormat.setTimeZone(GMT);</span>
			try {
<span class="fc" id="L1095">				return simpleDateFormat.parse(value).getTime();</span>
			}
<span class="fc" id="L1097">			catch (ParseException ex) {</span>
				// ignore
			}
		}
<span class="fc" id="L1101">		throw new IllegalArgumentException(&quot;Cannot parse date value '&quot; + value + &quot;' for '&quot; + name + &quot;' header&quot;);</span>
	}

	@Override
	@Nullable
	public String getHeader(String name) {
<span class="fc" id="L1107">		HeaderValueHolder header = HeaderValueHolder.getByName(this.headers, name);</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">		return (header != null ? header.getStringValue() : null);</span>
	}

	@Override
	public Enumeration&lt;String&gt; getHeaders(String name) {
<span class="fc" id="L1113">		HeaderValueHolder header = HeaderValueHolder.getByName(this.headers, name);</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">		return Collections.enumeration(header != null ? header.getStringValues() : new LinkedList&lt;&gt;());</span>
	}

	@Override
	public Enumeration&lt;String&gt; getHeaderNames() {
<span class="fc" id="L1119">		return Collections.enumeration(this.headers.keySet());</span>
	}

	@Override
	public int getIntHeader(String name) {
<span class="nc" id="L1124">		HeaderValueHolder header = HeaderValueHolder.getByName(this.headers, name);</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">		Object value = (header != null ? header.getValue() : null);</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">		if (value instanceof Number) {</span>
<span class="nc" id="L1127">			return ((Number) value).intValue();</span>
		}
<span class="nc bnc" id="L1129" title="All 2 branches missed.">		else if (value instanceof String) {</span>
<span class="nc" id="L1130">			return Integer.parseInt((String) value);</span>
		}
<span class="nc bnc" id="L1132" title="All 2 branches missed.">		else if (value != null) {</span>
<span class="nc" id="L1133">			throw new NumberFormatException(&quot;Value for header '&quot; + name + &quot;' is not a Number: &quot; + value);</span>
		}
		else {
<span class="nc" id="L1136">			return -1;</span>
		}
	}

	public void setMethod(@Nullable String method) {
<span class="fc" id="L1141">		this.method = method;</span>
<span class="fc" id="L1142">	}</span>

	@Override
	@Nullable
	public String getMethod() {
<span class="fc" id="L1147">		return this.method;</span>
	}

	public void setPathInfo(@Nullable String pathInfo) {
<span class="fc" id="L1151">		this.pathInfo = pathInfo;</span>
<span class="fc" id="L1152">	}</span>

	@Override
	@Nullable
	public String getPathInfo() {
<span class="fc" id="L1157">		return this.pathInfo;</span>
	}

	@Override
	@Nullable
	public String getPathTranslated() {
<span class="nc bnc" id="L1163" title="All 2 branches missed.">		return (this.pathInfo != null ? getRealPath(this.pathInfo) : null);</span>
	}

	public void setContextPath(String contextPath) {
<span class="fc" id="L1167">		this.contextPath = contextPath;</span>
<span class="fc" id="L1168">	}</span>

	@Override
	public String getContextPath() {
<span class="fc" id="L1172">		return this.contextPath;</span>
	}

	public void setQueryString(@Nullable String queryString) {
<span class="fc" id="L1176">		this.queryString = queryString;</span>
<span class="fc" id="L1177">	}</span>

	@Override
	@Nullable
	public String getQueryString() {
<span class="fc" id="L1182">		return this.queryString;</span>
	}

	public void setRemoteUser(@Nullable String remoteUser) {
<span class="nc" id="L1186">		this.remoteUser = remoteUser;</span>
<span class="nc" id="L1187">	}</span>

	@Override
	@Nullable
	public String getRemoteUser() {
<span class="nc" id="L1192">		return this.remoteUser;</span>
	}

	public void addUserRole(String role) {
<span class="nc" id="L1196">		this.userRoles.add(role);</span>
<span class="nc" id="L1197">	}</span>

	@Override
	public boolean isUserInRole(String role) {
<span class="nc bnc" id="L1201" title="All 4 branches missed.">		return (this.userRoles.contains(role) || (this.servletContext instanceof MockServletContext &amp;&amp;</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">				((MockServletContext) this.servletContext).getDeclaredRoles().contains(role)));</span>
	}

	public void setUserPrincipal(@Nullable Principal userPrincipal) {
<span class="fc" id="L1206">		this.userPrincipal = userPrincipal;</span>
<span class="fc" id="L1207">	}</span>

	@Override
	@Nullable
	public Principal getUserPrincipal() {
<span class="fc" id="L1212">		return this.userPrincipal;</span>
	}

	public void setRequestedSessionId(@Nullable String requestedSessionId) {
<span class="fc" id="L1216">		this.requestedSessionId = requestedSessionId;</span>
<span class="fc" id="L1217">	}</span>

	@Override
	@Nullable
	public String getRequestedSessionId() {
<span class="fc" id="L1222">		return this.requestedSessionId;</span>
	}

	public void setRequestURI(@Nullable String requestURI) {
<span class="fc" id="L1226">		this.requestURI = requestURI;</span>
<span class="fc" id="L1227">	}</span>

	@Override
	@Nullable
	public String getRequestURI() {
<span class="fc" id="L1232">		return this.requestURI;</span>
	}

	@Override
	public StringBuffer getRequestURL() {
<span class="fc" id="L1237">		String scheme = getScheme();</span>
<span class="fc" id="L1238">		String server = getServerName();</span>
<span class="fc" id="L1239">		int port = getServerPort();</span>
<span class="fc" id="L1240">		String uri = getRequestURI();</span>

<span class="fc" id="L1242">		StringBuffer url = new StringBuffer(scheme).append(&quot;://&quot;).append(server);</span>
<span class="fc bfc" id="L1243" title="All 6 branches covered.">		if (port &gt; 0 &amp;&amp; ((HTTP.equalsIgnoreCase(scheme) &amp;&amp; port != 80) ||</span>
<span class="fc bfc" id="L1244" title="All 4 branches covered.">				(HTTPS.equalsIgnoreCase(scheme) &amp;&amp; port != 443))) {</span>
<span class="fc" id="L1245">			url.append(':').append(port);</span>
		}
<span class="fc bfc" id="L1247" title="All 2 branches covered.">		if (StringUtils.hasText(uri)) {</span>
<span class="fc" id="L1248">			url.append(uri);</span>
		}
<span class="fc" id="L1250">		return url;</span>
	}

	public void setServletPath(String servletPath) {
<span class="fc" id="L1254">		this.servletPath = servletPath;</span>
<span class="fc" id="L1255">	}</span>

	@Override
	public String getServletPath() {
<span class="fc" id="L1259">		return this.servletPath;</span>
	}

	public void setSession(HttpSession session) {
<span class="fc" id="L1263">		this.session = session;</span>
<span class="fc bfc" id="L1264" title="All 2 branches covered.">		if (session instanceof MockHttpSession) {</span>
<span class="fc" id="L1265">			MockHttpSession mockSession = ((MockHttpSession) session);</span>
<span class="fc" id="L1266">			mockSession.access();</span>
		}
<span class="fc" id="L1268">	}</span>

	@Override
	@Nullable
	public HttpSession getSession(boolean create) {
<span class="fc" id="L1273">		checkActive();</span>
		// Reset session if invalidated.
<span class="pc bpc" id="L1275" title="1 of 4 branches missed.">		if (this.session instanceof MockHttpSession &amp;&amp; ((MockHttpSession) this.session).isInvalid()) {</span>
<span class="nc" id="L1276">			this.session = null;</span>
		}
		// Create new session if necessary.
<span class="fc bfc" id="L1279" title="All 4 branches covered.">		if (this.session == null &amp;&amp; create) {</span>
<span class="fc" id="L1280">			this.session = new MockHttpSession(this.servletContext);</span>
		}
<span class="fc" id="L1282">		return this.session;</span>
	}

	@Override
	@Nullable
	public HttpSession getSession() {
<span class="fc" id="L1288">		return getSession(true);</span>
	}

	/**
	 * The implementation of this (Servlet 3.1+) method calls
	 * {@link MockHttpSession#changeSessionId()} if the session is a mock session.
	 * Otherwise it simply returns the current session id.
	 * @since 4.0.3
	 */
	public String changeSessionId() {
<span class="nc bnc" id="L1298" title="All 2 branches missed.">		Assert.isTrue(this.session != null, &quot;The request does not have a session&quot;);</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">		if (this.session instanceof MockHttpSession) {</span>
<span class="nc" id="L1300">			return ((MockHttpSession) this.session).changeSessionId();</span>
		}
<span class="nc" id="L1302">		return this.session.getId();</span>
	}

	public void setRequestedSessionIdValid(boolean requestedSessionIdValid) {
<span class="nc" id="L1306">		this.requestedSessionIdValid = requestedSessionIdValid;</span>
<span class="nc" id="L1307">	}</span>

	@Override
	public boolean isRequestedSessionIdValid() {
<span class="nc" id="L1311">		return this.requestedSessionIdValid;</span>
	}

	public void setRequestedSessionIdFromCookie(boolean requestedSessionIdFromCookie) {
<span class="nc" id="L1315">		this.requestedSessionIdFromCookie = requestedSessionIdFromCookie;</span>
<span class="nc" id="L1316">	}</span>

	@Override
	public boolean isRequestedSessionIdFromCookie() {
<span class="nc" id="L1320">		return this.requestedSessionIdFromCookie;</span>
	}

	public void setRequestedSessionIdFromURL(boolean requestedSessionIdFromURL) {
<span class="nc" id="L1324">		this.requestedSessionIdFromURL = requestedSessionIdFromURL;</span>
<span class="nc" id="L1325">	}</span>

	@Override
	public boolean isRequestedSessionIdFromURL() {
<span class="nc" id="L1329">		return this.requestedSessionIdFromURL;</span>
	}

	@Override
	@Deprecated
	public boolean isRequestedSessionIdFromUrl() {
<span class="nc" id="L1335">		return isRequestedSessionIdFromURL();</span>
	}

	@Override
	public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {
<span class="nc" id="L1340">		throw new UnsupportedOperationException();</span>
	}

	@Override
	public void login(String username, String password) throws ServletException {
<span class="nc" id="L1345">		throw new UnsupportedOperationException();</span>
	}

	@Override
	public void logout() throws ServletException {
<span class="nc" id="L1350">		this.userPrincipal = null;</span>
<span class="nc" id="L1351">		this.remoteUser = null;</span>
<span class="nc" id="L1352">		this.authType = null;</span>
<span class="nc" id="L1353">	}</span>

	public void addPart(Part part) {
<span class="fc" id="L1356">		this.parts.add(part.getName(), part);</span>
<span class="fc" id="L1357">	}</span>

	@Override
	@Nullable
	public Part getPart(String name) throws IOException, ServletException {
<span class="fc" id="L1362">		return this.parts.getFirst(name);</span>
	}

	@Override
	public Collection&lt;Part&gt; getParts() throws IOException, ServletException {
<span class="fc" id="L1367">		List&lt;Part&gt; result = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L1368" title="All 2 branches covered.">		for (List&lt;Part&gt; list : this.parts.values()) {</span>
<span class="fc" id="L1369">			result.addAll(list);</span>
<span class="fc" id="L1370">		}</span>
<span class="fc" id="L1371">		return result;</span>
	}

	@Override
	public &lt;T extends HttpUpgradeHandler&gt; T upgrade(Class&lt;T&gt; handlerClass) throws IOException, ServletException {
<span class="nc" id="L1376">		throw new UnsupportedOperationException();</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>