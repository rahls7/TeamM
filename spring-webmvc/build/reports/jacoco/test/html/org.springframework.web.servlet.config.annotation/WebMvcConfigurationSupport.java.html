<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WebMvcConfigurationSupport.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-webmvc</a> &gt; <a href="index.source.html" class="el_package">org.springframework.web.servlet.config.annotation</a> &gt; <span class="el_source">WebMvcConfigurationSupport.java</span></div><h1>WebMvcConfigurationSupport.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.servlet.config.annotation;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.function.Predicate;
import javax.servlet.ServletContext;

import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.BeanFactoryUtils;
import org.springframework.beans.factory.BeanInitializationException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Lazy;
import org.springframework.core.convert.converter.Converter;
import org.springframework.format.Formatter;
import org.springframework.format.FormatterRegistry;
import org.springframework.format.support.DefaultFormattingConversionService;
import org.springframework.format.support.FormattingConversionService;
import org.springframework.http.MediaType;
import org.springframework.http.converter.ByteArrayHttpMessageConverter;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.ResourceHttpMessageConverter;
import org.springframework.http.converter.ResourceRegionHttpMessageConverter;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.http.converter.cbor.MappingJackson2CborHttpMessageConverter;
import org.springframework.http.converter.feed.AtomFeedHttpMessageConverter;
import org.springframework.http.converter.feed.RssChannelHttpMessageConverter;
import org.springframework.http.converter.json.GsonHttpMessageConverter;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.http.converter.json.JsonbHttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.http.converter.smile.MappingJackson2SmileHttpMessageConverter;
import org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter;
import org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter;
import org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;
import org.springframework.http.converter.xml.SourceHttpMessageConverter;
import org.springframework.lang.Nullable;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.PathMatcher;
import org.springframework.validation.Errors;
import org.springframework.validation.MessageCodesResolver;
import org.springframework.validation.Validator;
import org.springframework.web.HttpRequestHandler;
import org.springframework.web.accept.ContentNegotiationManager;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.support.ConfigurableWebBindingInitializer;
import org.springframework.web.context.ServletContextAware;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.method.support.CompositeUriComponentsContributor;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.HandlerMethodReturnValueHandler;
import org.springframework.web.servlet.HandlerAdapter;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.function.support.HandlerFunctionAdapter;
import org.springframework.web.servlet.function.support.RouterFunctionMapping;
import org.springframework.web.servlet.handler.AbstractHandlerMapping;
import org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping;
import org.springframework.web.servlet.handler.ConversionServiceExposingInterceptor;
import org.springframework.web.servlet.handler.HandlerExceptionResolverComposite;
import org.springframework.web.servlet.handler.HandlerMappingIntrospector;
import org.springframework.web.servlet.mvc.Controller;
import org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter;
import org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter;
import org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver;
import org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver;
import org.springframework.web.servlet.mvc.method.annotation.JsonViewRequestBodyAdvice;
import org.springframework.web.servlet.mvc.method.annotation.JsonViewResponseBodyAdvice;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
import org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver;
import org.springframework.web.servlet.resource.ResourceUrlProvider;
import org.springframework.web.servlet.resource.ResourceUrlProviderExposingInterceptor;
import org.springframework.web.servlet.view.InternalResourceViewResolver;
import org.springframework.web.servlet.view.ViewResolverComposite;
import org.springframework.web.util.UrlPathHelper;

/**
 * This is the main class providing the configuration behind the MVC Java config.
 * It is typically imported by adding {@link EnableWebMvc @EnableWebMvc} to an
 * application {@link Configuration @Configuration} class. An alternative more
 * advanced option is to extend directly from this class and override methods as
 * necessary, remembering to add {@link Configuration @Configuration} to the
 * subclass and {@link Bean @Bean} to overridden {@link Bean @Bean} methods.
 * For more details see the javadoc of {@link EnableWebMvc @EnableWebMvc}.
 *
 * &lt;p&gt;This class registers the following {@link HandlerMapping HandlerMappings}:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link RequestMappingHandlerMapping}
 * ordered at 0 for mapping requests to annotated controller methods.
 * &lt;li&gt;{@link HandlerMapping}
 * ordered at 1 to map URL paths directly to view names.
 * &lt;li&gt;{@link BeanNameUrlHandlerMapping}
 * ordered at 2 to map URL paths to controller bean names.
 * &lt;li&gt;{@link HandlerMapping}
 * ordered at {@code Integer.MAX_VALUE-1} to serve static resource requests.
 * &lt;li&gt;{@link HandlerMapping}
 * ordered at {@code Integer.MAX_VALUE} to forward requests to the default servlet.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Registers these {@link HandlerAdapter HandlerAdapters}:
 * &lt;ul&gt;
 * &lt;li&gt;{@link RequestMappingHandlerAdapter}
 * for processing requests with annotated controller methods.
 * &lt;li&gt;{@link HttpRequestHandlerAdapter}
 * for processing requests with {@link HttpRequestHandler HttpRequestHandlers}.
 * &lt;li&gt;{@link SimpleControllerHandlerAdapter}
 * for processing requests with interface-based {@link Controller Controllers}.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Registers a {@link HandlerExceptionResolverComposite} with this chain of
 * exception resolvers:
 * &lt;ul&gt;
 * &lt;li&gt;{@link ExceptionHandlerExceptionResolver} for handling exceptions through
 * {@link org.springframework.web.bind.annotation.ExceptionHandler} methods.
 * &lt;li&gt;{@link ResponseStatusExceptionResolver} for exceptions annotated with
 * {@link org.springframework.web.bind.annotation.ResponseStatus}.
 * &lt;li&gt;{@link DefaultHandlerExceptionResolver} for resolving known Spring
 * exception types
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Registers an {@link AntPathMatcher} and a {@link UrlPathHelper}
 * to be used by:
 * &lt;ul&gt;
 * &lt;li&gt;the {@link RequestMappingHandlerMapping},
 * &lt;li&gt;the {@link HandlerMapping} for ViewControllers
 * &lt;li&gt;and the {@link HandlerMapping} for serving resources
 * &lt;/ul&gt;
 * Note that those beans can be configured with a {@link PathMatchConfigurer}.
 *
 * &lt;p&gt;Both the {@link RequestMappingHandlerAdapter} and the
 * {@link ExceptionHandlerExceptionResolver} are configured with default
 * instances of the following by default:
 * &lt;ul&gt;
 * &lt;li&gt;a {@link ContentNegotiationManager}
 * &lt;li&gt;a {@link DefaultFormattingConversionService}
 * &lt;li&gt;an {@link org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean}
 * if a JSR-303 implementation is available on the classpath
 * &lt;li&gt;a range of {@link HttpMessageConverter HttpMessageConverters} depending on the third-party
 * libraries available on the classpath.
 * &lt;/ul&gt;
 *
 * @author Rossen Stoyanchev
 * @author Brian Clozel
 * @author Sebastien Deleuze
 * @since 3.1
 * @see EnableWebMvc
 * @see WebMvcConfigurer
 */
<span class="fc" id="L175">public class WebMvcConfigurationSupport implements ApplicationContextAware, ServletContextAware {</span>

	private static final boolean romePresent;

	private static final boolean jaxb2Present;

	private static final boolean jackson2Present;

	private static final boolean jackson2XmlPresent;

	private static final boolean jackson2SmilePresent;

	private static final boolean jackson2CborPresent;

	private static final boolean gsonPresent;

	private static final boolean jsonbPresent;

	static {
<span class="fc" id="L194">		ClassLoader classLoader = WebMvcConfigurationSupport.class.getClassLoader();</span>
<span class="fc" id="L195">		romePresent = ClassUtils.isPresent(&quot;com.rometools.rome.feed.WireFeed&quot;, classLoader);</span>
<span class="fc" id="L196">		jaxb2Present = ClassUtils.isPresent(&quot;javax.xml.bind.Binder&quot;, classLoader);</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">		jackson2Present = ClassUtils.isPresent(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;, classLoader) &amp;&amp;</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">						ClassUtils.isPresent(&quot;com.fasterxml.jackson.core.JsonGenerator&quot;, classLoader);</span>
<span class="fc" id="L199">		jackson2XmlPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader);</span>
<span class="fc" id="L200">		jackson2SmilePresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;, classLoader);</span>
<span class="fc" id="L201">		jackson2CborPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.cbor.CBORFactory&quot;, classLoader);</span>
<span class="fc" id="L202">		gsonPresent = ClassUtils.isPresent(&quot;com.google.gson.Gson&quot;, classLoader);</span>
<span class="fc" id="L203">		jsonbPresent = ClassUtils.isPresent(&quot;javax.json.bind.Jsonb&quot;, classLoader);</span>
<span class="fc" id="L204">	}</span>


	@Nullable
	private ApplicationContext applicationContext;

	@Nullable
	private ServletContext servletContext;

	@Nullable
	private List&lt;Object&gt; interceptors;

	@Nullable
	private PathMatchConfigurer pathMatchConfigurer;

	@Nullable
	private ContentNegotiationManager contentNegotiationManager;

	@Nullable
	private List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers;

	@Nullable
	private List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers;

	@Nullable
	private List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters;

	@Nullable
	private Map&lt;String, CorsConfiguration&gt; corsConfigurations;


	/**
	 * Set the Spring {@link ApplicationContext}, e.g. for resource loading.
	 */
	@Override
	public void setApplicationContext(@Nullable ApplicationContext applicationContext) {
<span class="fc" id="L240">		this.applicationContext = applicationContext;</span>
<span class="fc" id="L241">	}</span>

	/**
	 * Return the associated Spring {@link ApplicationContext}.
	 * @since 4.2
	 */
	@Nullable
	public final ApplicationContext getApplicationContext() {
<span class="nc" id="L249">		return this.applicationContext;</span>
	}

	/**
	 * Set the {@link javax.servlet.ServletContext}, e.g. for resource handling,
	 * looking up file extensions, etc.
	 */
	@Override
	public void setServletContext(@Nullable ServletContext servletContext) {
<span class="fc" id="L258">		this.servletContext = servletContext;</span>
<span class="fc" id="L259">	}</span>

	/**
	 * Return the associated {@link javax.servlet.ServletContext}.
	 * @since 4.2
	 */
	@Nullable
	public final ServletContext getServletContext() {
<span class="nc" id="L267">		return this.servletContext;</span>
	}


	/**
	 * Return a {@link RequestMappingHandlerMapping} ordered at 0 for mapping
	 * requests to annotated controllers.
	 */
	@Bean
	public RequestMappingHandlerMapping requestMappingHandlerMapping() {
<span class="fc" id="L277">		RequestMappingHandlerMapping mapping = createRequestMappingHandlerMapping();</span>
<span class="fc" id="L278">		mapping.setOrder(0);</span>
<span class="fc" id="L279">		mapping.setInterceptors(getInterceptors());</span>
<span class="fc" id="L280">		mapping.setContentNegotiationManager(mvcContentNegotiationManager());</span>
<span class="fc" id="L281">		mapping.setCorsConfigurations(getCorsConfigurations());</span>

<span class="fc" id="L283">		PathMatchConfigurer configurer = getPathMatchConfigurer();</span>

<span class="fc" id="L285">		Boolean useSuffixPatternMatch = configurer.isUseSuffixPatternMatch();</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">		if (useSuffixPatternMatch != null) {</span>
<span class="nc" id="L287">			mapping.setUseSuffixPatternMatch(useSuffixPatternMatch);</span>
		}
<span class="fc" id="L289">		Boolean useRegisteredSuffixPatternMatch = configurer.isUseRegisteredSuffixPatternMatch();</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">		if (useRegisteredSuffixPatternMatch != null) {</span>
<span class="fc" id="L291">			mapping.setUseRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch);</span>
		}
<span class="fc" id="L293">		Boolean useTrailingSlashMatch = configurer.isUseTrailingSlashMatch();</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">		if (useTrailingSlashMatch != null) {</span>
<span class="fc" id="L295">			mapping.setUseTrailingSlashMatch(useTrailingSlashMatch);</span>
		}

<span class="fc" id="L298">		UrlPathHelper pathHelper = configurer.getUrlPathHelper();</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">		if (pathHelper != null) {</span>
<span class="fc" id="L300">			mapping.setUrlPathHelper(pathHelper);</span>
		}
<span class="fc" id="L302">		PathMatcher pathMatcher = configurer.getPathMatcher();</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">		if (pathMatcher != null) {</span>
<span class="fc" id="L304">			mapping.setPathMatcher(pathMatcher);</span>
		}
<span class="fc" id="L306">		Map&lt;String, Predicate&lt;Class&lt;?&gt;&gt;&gt; pathPrefixes = configurer.getPathPrefixes();</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">		if (pathPrefixes != null) {</span>
<span class="fc" id="L308">			mapping.setPathPrefixes(pathPrefixes);</span>
		}

<span class="fc" id="L311">		return mapping;</span>
	}

	/**
	 * Protected method for plugging in a custom subclass of
	 * {@link RequestMappingHandlerMapping}.
	 * @since 4.0
	 */
	protected RequestMappingHandlerMapping createRequestMappingHandlerMapping() {
<span class="fc" id="L320">		return new RequestMappingHandlerMapping();</span>
	}

	/**
	 * Provide access to the shared handler interceptors used to configure
	 * {@link HandlerMapping} instances with.
	 * &lt;p&gt;This method cannot be overridden; use {@link #addInterceptors} instead.
	 */
	protected final Object[] getInterceptors() {
<span class="fc bfc" id="L329" title="All 2 branches covered.">		if (this.interceptors == null) {</span>
<span class="fc" id="L330">			InterceptorRegistry registry = new InterceptorRegistry();</span>
<span class="fc" id="L331">			addInterceptors(registry);</span>
<span class="fc" id="L332">			registry.addInterceptor(new ConversionServiceExposingInterceptor(mvcConversionService()));</span>
<span class="fc" id="L333">			registry.addInterceptor(new ResourceUrlProviderExposingInterceptor(mvcResourceUrlProvider()));</span>
<span class="fc" id="L334">			this.interceptors = registry.getInterceptors();</span>
		}
<span class="fc" id="L336">		return this.interceptors.toArray();</span>
	}

	/**
	 * Override this method to add Spring MVC interceptors for
	 * pre- and post-processing of controller invocation.
	 * @see InterceptorRegistry
	 */
	protected void addInterceptors(InterceptorRegistry registry) {
<span class="fc" id="L345">	}</span>

	/**
	 * Callback for building the {@link PathMatchConfigurer}.
	 * Delegates to {@link #configurePathMatch}.
	 * @since 4.1
	 */
	protected PathMatchConfigurer getPathMatchConfigurer() {
<span class="fc bfc" id="L353" title="All 2 branches covered.">		if (this.pathMatchConfigurer == null) {</span>
<span class="fc" id="L354">			this.pathMatchConfigurer = new PathMatchConfigurer();</span>
<span class="fc" id="L355">			configurePathMatch(this.pathMatchConfigurer);</span>
		}
<span class="fc" id="L357">		return this.pathMatchConfigurer;</span>
	}

	/**
	 * Override this method to configure path matching options.
	 * @since 4.0.3
	 * @see PathMatchConfigurer
	 */
	protected void configurePathMatch(PathMatchConfigurer configurer) {
<span class="fc" id="L366">	}</span>

	/**
	 * Return a global {@link PathMatcher} instance for path matching
	 * patterns in {@link HandlerMapping HandlerMappings}.
	 * This instance can be configured using the {@link PathMatchConfigurer}
	 * in {@link #configurePathMatch(PathMatchConfigurer)}.
	 * @since 4.1
	 */
	@Bean
	public PathMatcher mvcPathMatcher() {
<span class="fc" id="L377">		PathMatcher pathMatcher = getPathMatchConfigurer().getPathMatcher();</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">		return (pathMatcher != null ? pathMatcher : new AntPathMatcher());</span>
	}

	/**
	 * Return a global {@link UrlPathHelper} instance for path matching
	 * patterns in {@link HandlerMapping HandlerMappings}.
	 * This instance can be configured using the {@link PathMatchConfigurer}
	 * in {@link #configurePathMatch(PathMatchConfigurer)}.
	 * @since 4.1
	 */
	@Bean
	public UrlPathHelper mvcUrlPathHelper() {
<span class="fc" id="L390">		UrlPathHelper pathHelper = getPathMatchConfigurer().getUrlPathHelper();</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">		return (pathHelper != null ? pathHelper : new UrlPathHelper());</span>
	}

	/**
	 * Return a {@link ContentNegotiationManager} instance to use to determine
	 * requested {@linkplain MediaType media types} in a given request.
	 */
	@Bean
	public ContentNegotiationManager mvcContentNegotiationManager() {
<span class="fc bfc" id="L400" title="All 2 branches covered.">		if (this.contentNegotiationManager == null) {</span>
<span class="fc" id="L401">			ContentNegotiationConfigurer configurer = new ContentNegotiationConfigurer(this.servletContext);</span>
<span class="fc" id="L402">			configurer.mediaTypes(getDefaultMediaTypes());</span>
<span class="fc" id="L403">			configureContentNegotiation(configurer);</span>
<span class="fc" id="L404">			this.contentNegotiationManager = configurer.buildContentNegotiationManager();</span>
		}
<span class="fc" id="L406">		return this.contentNegotiationManager;</span>
	}

	protected Map&lt;String, MediaType&gt; getDefaultMediaTypes() {
<span class="fc" id="L410">		Map&lt;String, MediaType&gt; map = new HashMap&lt;&gt;(4);</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">		if (romePresent) {</span>
<span class="fc" id="L412">			map.put(&quot;atom&quot;, MediaType.APPLICATION_ATOM_XML);</span>
<span class="fc" id="L413">			map.put(&quot;rss&quot;, MediaType.APPLICATION_RSS_XML);</span>
		}
<span class="pc bpc" id="L415" title="3 of 4 branches missed.">		if (jaxb2Present || jackson2XmlPresent) {</span>
<span class="fc" id="L416">			map.put(&quot;xml&quot;, MediaType.APPLICATION_XML);</span>
		}
<span class="pc bpc" id="L418" title="5 of 6 branches missed.">		if (jackson2Present || gsonPresent || jsonbPresent) {</span>
<span class="fc" id="L419">			map.put(&quot;json&quot;, MediaType.APPLICATION_JSON);</span>
		}
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">		if (jackson2SmilePresent) {</span>
<span class="fc" id="L422">			map.put(&quot;smile&quot;, MediaType.valueOf(&quot;application/x-jackson-smile&quot;));</span>
		}
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">		if (jackson2CborPresent) {</span>
<span class="fc" id="L425">			map.put(&quot;cbor&quot;, MediaType.valueOf(&quot;application/cbor&quot;));</span>
		}
<span class="fc" id="L427">		return map;</span>
	}

	/**
	 * Override this method to configure content negotiation.
	 * @see DefaultServletHandlerConfigurer
	 */
	protected void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
<span class="fc" id="L435">	}</span>

	/**
	 * Return a handler mapping ordered at 1 to map URL paths directly to
	 * view names. To configure view controllers, override
	 * {@link #addViewControllers}.
	 */
	@Bean
	@Nullable
	public HandlerMapping viewControllerHandlerMapping() {
<span class="fc" id="L445">		ViewControllerRegistry registry = new ViewControllerRegistry(this.applicationContext);</span>
<span class="fc" id="L446">		addViewControllers(registry);</span>

<span class="fc" id="L448">		AbstractHandlerMapping handlerMapping = registry.buildHandlerMapping();</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">		if (handlerMapping == null) {</span>
<span class="fc" id="L450">			return null;</span>
		}
<span class="fc" id="L452">		handlerMapping.setPathMatcher(mvcPathMatcher());</span>
<span class="fc" id="L453">		handlerMapping.setUrlPathHelper(mvcUrlPathHelper());</span>
<span class="fc" id="L454">		handlerMapping.setInterceptors(getInterceptors());</span>
<span class="fc" id="L455">		handlerMapping.setCorsConfigurations(getCorsConfigurations());</span>
<span class="fc" id="L456">		return handlerMapping;</span>
	}

	/**
	 * Override this method to add view controllers.
	 * @see ViewControllerRegistry
	 */
	protected void addViewControllers(ViewControllerRegistry registry) {
<span class="fc" id="L464">	}</span>

	/**
	 * Return a {@link BeanNameUrlHandlerMapping} ordered at 2 to map URL
	 * paths to controller bean names.
	 */
	@Bean
	public BeanNameUrlHandlerMapping beanNameHandlerMapping() {
<span class="fc" id="L472">		BeanNameUrlHandlerMapping mapping = new BeanNameUrlHandlerMapping();</span>
<span class="fc" id="L473">		mapping.setOrder(2);</span>
<span class="fc" id="L474">		mapping.setInterceptors(getInterceptors());</span>
<span class="fc" id="L475">		mapping.setCorsConfigurations(getCorsConfigurations());</span>
<span class="fc" id="L476">		return mapping;</span>
	}

	/**
	 * Return a {@link RouterFunctionMapping} ordered at 3 to map
	 * {@linkplain org.springframework.web.servlet.function.RouterFunction router functions}.
	 * Consider overriding one of these other more fine-grained methods:
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link #addInterceptors} for adding handler interceptors.
	 * &lt;li&gt;{@link #addCorsMappings} to configure cross origin requests processing.
	 * &lt;li&gt;{@link #configureMessageConverters} for adding custom message converters.
	 * &lt;/ul&gt;
	 * @since 5.2
	 */
	@Bean
	public RouterFunctionMapping routerFunctionMapping() {
<span class="fc" id="L492">		RouterFunctionMapping mapping = new RouterFunctionMapping();</span>
<span class="fc" id="L493">		mapping.setOrder(3);</span>
<span class="fc" id="L494">		mapping.setInterceptors(getInterceptors());</span>
<span class="fc" id="L495">		mapping.setCorsConfigurations(getCorsConfigurations());</span>
<span class="fc" id="L496">		mapping.setMessageConverters(getMessageConverters());</span>
<span class="fc" id="L497">		return mapping;</span>
	}

	/**
	 * Return a handler mapping ordered at Integer.MAX_VALUE-1 with mapped
	 * resource handlers. To configure resource handling, override
	 * {@link #addResourceHandlers}.
	 */
	@Bean
	@Nullable
	public HandlerMapping resourceHandlerMapping() {
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">		Assert.state(this.applicationContext != null, &quot;No ApplicationContext set&quot;);</span>
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">		Assert.state(this.servletContext != null, &quot;No ServletContext set&quot;);</span>

<span class="fc" id="L511">		ResourceHandlerRegistry registry = new ResourceHandlerRegistry(this.applicationContext,</span>
<span class="fc" id="L512">				this.servletContext, mvcContentNegotiationManager(), mvcUrlPathHelper());</span>
<span class="fc" id="L513">		addResourceHandlers(registry);</span>

<span class="fc" id="L515">		AbstractHandlerMapping handlerMapping = registry.getHandlerMapping();</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">		if (handlerMapping == null) {</span>
<span class="fc" id="L517">			return null;</span>
		}
<span class="fc" id="L519">		handlerMapping.setPathMatcher(mvcPathMatcher());</span>
<span class="fc" id="L520">		handlerMapping.setUrlPathHelper(mvcUrlPathHelper());</span>
<span class="fc" id="L521">		handlerMapping.setInterceptors(getInterceptors());</span>
<span class="fc" id="L522">		handlerMapping.setCorsConfigurations(getCorsConfigurations());</span>
<span class="fc" id="L523">		return handlerMapping;</span>
	}

	/**
	 * Override this method to add resource handlers for serving static resources.
	 * @see ResourceHandlerRegistry
	 */
	protected void addResourceHandlers(ResourceHandlerRegistry registry) {
<span class="fc" id="L531">	}</span>

	/**
	 * A {@link ResourceUrlProvider} bean for use with the MVC dispatcher.
	 * @since 4.1
	 */
	@Bean
	public ResourceUrlProvider mvcResourceUrlProvider() {
<span class="fc" id="L539">		ResourceUrlProvider urlProvider = new ResourceUrlProvider();</span>
<span class="fc" id="L540">		UrlPathHelper pathHelper = getPathMatchConfigurer().getUrlPathHelper();</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">		if (pathHelper != null) {</span>
<span class="fc" id="L542">			urlProvider.setUrlPathHelper(pathHelper);</span>
		}
<span class="fc" id="L544">		PathMatcher pathMatcher = getPathMatchConfigurer().getPathMatcher();</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">		if (pathMatcher != null) {</span>
<span class="fc" id="L546">			urlProvider.setPathMatcher(pathMatcher);</span>
		}
<span class="fc" id="L548">		return urlProvider;</span>
	}

	/**
	 * Return a handler mapping ordered at Integer.MAX_VALUE with a mapped
	 * default servlet handler. To configure &quot;default&quot; Servlet handling,
	 * override {@link #configureDefaultServletHandling}.
	 */
	@Bean
	@Nullable
	public HandlerMapping defaultServletHandlerMapping() {
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">		Assert.state(this.servletContext != null, &quot;No ServletContext set&quot;);</span>
<span class="fc" id="L560">		DefaultServletHandlerConfigurer configurer = new DefaultServletHandlerConfigurer(this.servletContext);</span>
<span class="fc" id="L561">		configureDefaultServletHandling(configurer);</span>
<span class="fc" id="L562">		return configurer.buildHandlerMapping();</span>
	}

	/**
	 * Override this method to configure &quot;default&quot; Servlet handling.
	 * @see DefaultServletHandlerConfigurer
	 */
	protected void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
<span class="fc" id="L570">	}</span>

	/**
	 * Returns a {@link RequestMappingHandlerAdapter} for processing requests
	 * through annotated controller methods. Consider overriding one of these
	 * other more fine-grained methods:
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link #addArgumentResolvers} for adding custom argument resolvers.
	 * &lt;li&gt;{@link #addReturnValueHandlers} for adding custom return value handlers.
	 * &lt;li&gt;{@link #configureMessageConverters} for adding custom message converters.
	 * &lt;/ul&gt;
	 */
	@Bean
	public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {
<span class="fc" id="L584">		RequestMappingHandlerAdapter adapter = createRequestMappingHandlerAdapter();</span>
<span class="fc" id="L585">		adapter.setContentNegotiationManager(mvcContentNegotiationManager());</span>
<span class="fc" id="L586">		adapter.setMessageConverters(getMessageConverters());</span>
<span class="fc" id="L587">		adapter.setWebBindingInitializer(getConfigurableWebBindingInitializer());</span>
<span class="fc" id="L588">		adapter.setCustomArgumentResolvers(getArgumentResolvers());</span>
<span class="fc" id="L589">		adapter.setCustomReturnValueHandlers(getReturnValueHandlers());</span>

<span class="pc bpc" id="L591" title="1 of 2 branches missed.">		if (jackson2Present) {</span>
<span class="fc" id="L592">			adapter.setRequestBodyAdvice(Collections.singletonList(new JsonViewRequestBodyAdvice()));</span>
<span class="fc" id="L593">			adapter.setResponseBodyAdvice(Collections.singletonList(new JsonViewResponseBodyAdvice()));</span>
		}

<span class="fc" id="L596">		AsyncSupportConfigurer configurer = new AsyncSupportConfigurer();</span>
<span class="fc" id="L597">		configureAsyncSupport(configurer);</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">		if (configurer.getTaskExecutor() != null) {</span>
<span class="fc" id="L599">			adapter.setTaskExecutor(configurer.getTaskExecutor());</span>
		}
<span class="fc bfc" id="L601" title="All 2 branches covered.">		if (configurer.getTimeout() != null) {</span>
<span class="fc" id="L602">			adapter.setAsyncRequestTimeout(configurer.getTimeout());</span>
		}
<span class="fc" id="L604">		adapter.setCallableInterceptors(configurer.getCallableInterceptors());</span>
<span class="fc" id="L605">		adapter.setDeferredResultInterceptors(configurer.getDeferredResultInterceptors());</span>

<span class="fc" id="L607">		return adapter;</span>
	}

	/**
	 * Protected method for plugging in a custom subclass of
	 * {@link RequestMappingHandlerAdapter}.
	 * @since 4.3
	 */
	protected RequestMappingHandlerAdapter createRequestMappingHandlerAdapter() {
<span class="fc" id="L616">		return new RequestMappingHandlerAdapter();</span>
	}

	/**
	 * Returns a {@link HandlerFunctionAdapter} for processing requests through
	 * {@linkplain org.springframework.web.servlet.function.HandlerFunction handler functions}.
	 * @since 5.2
	 */
	@Bean
	public HandlerFunctionAdapter handlerFunctionAdapter() {
<span class="fc" id="L626">		return new HandlerFunctionAdapter();</span>
	}

	/**
	 * Return the {@link ConfigurableWebBindingInitializer} to use for
	 * initializing all {@link WebDataBinder} instances.
	 */
	protected ConfigurableWebBindingInitializer getConfigurableWebBindingInitializer() {
<span class="fc" id="L634">		ConfigurableWebBindingInitializer initializer = new ConfigurableWebBindingInitializer();</span>
<span class="fc" id="L635">		initializer.setConversionService(mvcConversionService());</span>
<span class="fc" id="L636">		initializer.setValidator(mvcValidator());</span>
<span class="fc" id="L637">		MessageCodesResolver messageCodesResolver = getMessageCodesResolver();</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">		if (messageCodesResolver != null) {</span>
<span class="fc" id="L639">			initializer.setMessageCodesResolver(messageCodesResolver);</span>
		}
<span class="fc" id="L641">		return initializer;</span>
	}

	/**
	 * Override this method to provide a custom {@link MessageCodesResolver}.
	 */
	@Nullable
	protected MessageCodesResolver getMessageCodesResolver() {
<span class="fc" id="L649">		return null;</span>
	}

	/**
	 * Override this method to configure asynchronous request processing options.
	 * @see AsyncSupportConfigurer
	 */
	protected void configureAsyncSupport(AsyncSupportConfigurer configurer) {
<span class="fc" id="L657">	}</span>

	/**
	 * Return a {@link FormattingConversionService} for use with annotated controllers.
	 * &lt;p&gt;See {@link #addFormatters} as an alternative to overriding this method.
	 */
	@Bean
	public FormattingConversionService mvcConversionService() {
<span class="fc" id="L665">		FormattingConversionService conversionService = new DefaultFormattingConversionService();</span>
<span class="fc" id="L666">		addFormatters(conversionService);</span>
<span class="fc" id="L667">		return conversionService;</span>
	}

	/**
	 * Override this method to add custom {@link Converter} and/or {@link Formatter}
	 * delegates to the common {@link FormattingConversionService}.
	 * @see #mvcConversionService()
	 */
	protected void addFormatters(FormatterRegistry registry) {
<span class="fc" id="L676">	}</span>

	/**
	 * Return a global {@link Validator} instance for example for validating
	 * {@code @ModelAttribute} and {@code @RequestBody} method arguments.
	 * Delegates to {@link #getValidator()} first and if that returns {@code null}
	 * checks the classpath for the presence of a JSR-303 implementations
	 * before creating a {@code OptionalValidatorFactoryBean}.If a JSR-303
	 * implementation is not available, a no-op {@link Validator} is returned.
	 */
	@Bean
	public Validator mvcValidator() {
<span class="fc" id="L688">		Validator validator = getValidator();</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">		if (validator == null) {</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">			if (ClassUtils.isPresent(&quot;javax.validation.Validator&quot;, getClass().getClassLoader())) {</span>
				Class&lt;?&gt; clazz;
				try {
<span class="fc" id="L693">					String className = &quot;org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean&quot;;</span>
<span class="fc" id="L694">					clazz = ClassUtils.forName(className, WebMvcConfigurationSupport.class.getClassLoader());</span>
				}
<span class="nc" id="L696">				catch (ClassNotFoundException | LinkageError ex) {</span>
<span class="nc" id="L697">					throw new BeanInitializationException(&quot;Failed to resolve default validator class&quot;, ex);</span>
<span class="fc" id="L698">				}</span>
<span class="fc" id="L699">				validator = (Validator) BeanUtils.instantiateClass(clazz);</span>
<span class="fc" id="L700">			}</span>
			else {
<span class="nc" id="L702">				validator = new NoOpValidator();</span>
			}
		}
<span class="fc" id="L705">		return validator;</span>
	}

	/**
	 * Override this method to provide a custom {@link Validator}.
	 */
	@Nullable
	protected Validator getValidator() {
<span class="fc" id="L713">		return null;</span>
	}

	/**
	 * Provide access to the shared custom argument resolvers used by the
	 * {@link RequestMappingHandlerAdapter} and the {@link ExceptionHandlerExceptionResolver}.
	 * &lt;p&gt;This method cannot be overridden; use {@link #addArgumentResolvers} instead.
	 * @since 4.3
	 */
	protected final List&lt;HandlerMethodArgumentResolver&gt; getArgumentResolvers() {
<span class="fc bfc" id="L723" title="All 2 branches covered.">		if (this.argumentResolvers == null) {</span>
<span class="fc" id="L724">			this.argumentResolvers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L725">			addArgumentResolvers(this.argumentResolvers);</span>
		}
<span class="fc" id="L727">		return this.argumentResolvers;</span>
	}

	/**
	 * Add custom {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}
	 * to use in addition to the ones registered by default.
	 * &lt;p&gt;Custom argument resolvers are invoked before built-in resolvers except for
	 * those that rely on the presence of annotations (e.g. {@code @RequestParameter},
	 * {@code @PathVariable}, etc). The latter can be customized by configuring the
	 * {@link RequestMappingHandlerAdapter} directly.
	 * @param argumentResolvers the list of custom converters (initially an empty list)
	 */
	protected void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {
<span class="fc" id="L740">	}</span>

	/**
	 * Provide access to the shared return value handlers used by the
	 * {@link RequestMappingHandlerAdapter} and the {@link ExceptionHandlerExceptionResolver}.
	 * &lt;p&gt;This method cannot be overridden; use {@link #addReturnValueHandlers} instead.
	 * @since 4.3
	 */
	protected final List&lt;HandlerMethodReturnValueHandler&gt; getReturnValueHandlers() {
<span class="fc bfc" id="L749" title="All 2 branches covered.">		if (this.returnValueHandlers == null) {</span>
<span class="fc" id="L750">			this.returnValueHandlers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L751">			addReturnValueHandlers(this.returnValueHandlers);</span>
		}
<span class="fc" id="L753">		return this.returnValueHandlers;</span>
	}

	/**
	 * Add custom {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}
	 * in addition to the ones registered by default.
	 * &lt;p&gt;Custom return value handlers are invoked before built-in ones except for
	 * those that rely on the presence of annotations (e.g. {@code @ResponseBody},
	 * {@code @ModelAttribute}, etc). The latter can be customized by configuring the
	 * {@link RequestMappingHandlerAdapter} directly.
	 * @param returnValueHandlers the list of custom handlers (initially an empty list)
	 */
	protected void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers) {
<span class="fc" id="L766">	}</span>

	/**
	 * Provides access to the shared {@link HttpMessageConverter HttpMessageConverters}
	 * used by the {@link RequestMappingHandlerAdapter} and the
	 * {@link ExceptionHandlerExceptionResolver}.
	 * &lt;p&gt;This method cannot be overridden; use {@link #configureMessageConverters} instead.
	 * Also see {@link #addDefaultHttpMessageConverters} for adding default message converters.
	 */
	protected final List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() {
<span class="fc bfc" id="L776" title="All 2 branches covered.">		if (this.messageConverters == null) {</span>
<span class="fc" id="L777">			this.messageConverters = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L778">			configureMessageConverters(this.messageConverters);</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">			if (this.messageConverters.isEmpty()) {</span>
<span class="fc" id="L780">				addDefaultHttpMessageConverters(this.messageConverters);</span>
			}
<span class="fc" id="L782">			extendMessageConverters(this.messageConverters);</span>
		}
<span class="fc" id="L784">		return this.messageConverters;</span>
	}

	/**
	 * Override this method to add custom {@link HttpMessageConverter HttpMessageConverters}
	 * to use with the {@link RequestMappingHandlerAdapter} and the
	 * {@link ExceptionHandlerExceptionResolver}.
	 * &lt;p&gt;Adding converters to the list turns off the default converters that would
	 * otherwise be registered by default. Also see {@link #addDefaultHttpMessageConverters}
	 * for adding default message converters.
	 * @param converters a list to add message converters to (initially an empty list)
	 */
	protected void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
<span class="fc" id="L797">	}</span>

	/**
	 * Override this method to extend or modify the list of converters after it has
	 * been configured. This may be useful for example to allow default converters
	 * to be registered and then insert a custom converter through this method.
	 * @param converters the list of configured converters to extend
	 * @since 4.1.3
	 */
	protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
<span class="fc" id="L807">	}</span>

	/**
	 * Adds a set of default HttpMessageConverter instances to the given list.
	 * Subclasses can call this method from {@link #configureMessageConverters}.
	 * @param messageConverters the list to add the default message converters to
	 */
	protected final void addDefaultHttpMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters) {
<span class="fc" id="L815">		StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();</span>
<span class="fc" id="L816">		stringHttpMessageConverter.setWriteAcceptCharset(false);  // see SPR-7316</span>

<span class="fc" id="L818">		messageConverters.add(new ByteArrayHttpMessageConverter());</span>
<span class="fc" id="L819">		messageConverters.add(stringHttpMessageConverter);</span>
<span class="fc" id="L820">		messageConverters.add(new ResourceHttpMessageConverter());</span>
<span class="fc" id="L821">		messageConverters.add(new ResourceRegionHttpMessageConverter());</span>
		try {
<span class="fc" id="L823">			messageConverters.add(new SourceHttpMessageConverter&lt;&gt;());</span>
		}
<span class="nc" id="L825">		catch (Throwable ex) {</span>
			// Ignore when no TransformerFactory implementation is available...
<span class="fc" id="L827">		}</span>
<span class="fc" id="L828">		messageConverters.add(new AllEncompassingFormHttpMessageConverter());</span>

<span class="pc bpc" id="L830" title="1 of 2 branches missed.">		if (romePresent) {</span>
<span class="fc" id="L831">			messageConverters.add(new AtomFeedHttpMessageConverter());</span>
<span class="fc" id="L832">			messageConverters.add(new RssChannelHttpMessageConverter());</span>
		}

<span class="pc bpc" id="L835" title="1 of 2 branches missed.">		if (jackson2XmlPresent) {</span>
<span class="fc" id="L836">			Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.xml();</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">			if (this.applicationContext != null) {</span>
<span class="fc" id="L838">				builder.applicationContext(this.applicationContext);</span>
			}
<span class="fc" id="L840">			messageConverters.add(new MappingJackson2XmlHttpMessageConverter(builder.build()));</span>
<span class="fc" id="L841">		}</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">		else if (jaxb2Present) {</span>
<span class="nc" id="L843">			messageConverters.add(new Jaxb2RootElementHttpMessageConverter());</span>
		}

<span class="pc bpc" id="L846" title="1 of 2 branches missed.">		if (jackson2Present) {</span>
<span class="fc" id="L847">			Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.json();</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">			if (this.applicationContext != null) {</span>
<span class="fc" id="L849">				builder.applicationContext(this.applicationContext);</span>
			}
<span class="fc" id="L851">			messageConverters.add(new MappingJackson2HttpMessageConverter(builder.build()));</span>
<span class="fc" id="L852">		}</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">		else if (gsonPresent) {</span>
<span class="nc" id="L854">			messageConverters.add(new GsonHttpMessageConverter());</span>
		}
<span class="nc bnc" id="L856" title="All 2 branches missed.">		else if (jsonbPresent) {</span>
<span class="nc" id="L857">			messageConverters.add(new JsonbHttpMessageConverter());</span>
		}

<span class="pc bpc" id="L860" title="1 of 2 branches missed.">		if (jackson2SmilePresent) {</span>
<span class="fc" id="L861">			Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.smile();</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">			if (this.applicationContext != null) {</span>
<span class="fc" id="L863">				builder.applicationContext(this.applicationContext);</span>
			}
<span class="fc" id="L865">			messageConverters.add(new MappingJackson2SmileHttpMessageConverter(builder.build()));</span>
		}
<span class="pc bpc" id="L867" title="1 of 2 branches missed.">		if (jackson2CborPresent) {</span>
<span class="fc" id="L868">			Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.cbor();</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">			if (this.applicationContext != null) {</span>
<span class="fc" id="L870">				builder.applicationContext(this.applicationContext);</span>
			}
<span class="fc" id="L872">			messageConverters.add(new MappingJackson2CborHttpMessageConverter(builder.build()));</span>
		}
<span class="fc" id="L874">	}</span>

	/**
	 * Return an instance of {@link CompositeUriComponentsContributor} for use with
	 * {@link org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder}.
	 * @since 4.0
	 */
	@Bean
	public CompositeUriComponentsContributor mvcUriComponentsContributor() {
<span class="fc" id="L883">		return new CompositeUriComponentsContributor(</span>
<span class="fc" id="L884">				requestMappingHandlerAdapter().getArgumentResolvers(), mvcConversionService());</span>
	}

	/**
	 * Returns a {@link HttpRequestHandlerAdapter} for processing requests
	 * with {@link HttpRequestHandler HttpRequestHandlers}.
	 */
	@Bean
	public HttpRequestHandlerAdapter httpRequestHandlerAdapter() {
<span class="fc" id="L893">		return new HttpRequestHandlerAdapter();</span>
	}

	/**
	 * Returns a {@link SimpleControllerHandlerAdapter} for processing requests
	 * with interface-based controllers.
	 */
	@Bean
	public SimpleControllerHandlerAdapter simpleControllerHandlerAdapter() {
<span class="fc" id="L902">		return new SimpleControllerHandlerAdapter();</span>
	}

	/**
	 * Returns a {@link HandlerExceptionResolverComposite} containing a list of exception
	 * resolvers obtained either through {@link #configureHandlerExceptionResolvers} or
	 * through {@link #addDefaultHandlerExceptionResolvers}.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method cannot be made final due to CGLIB constraints.
	 * Rather than overriding it, consider overriding {@link #configureHandlerExceptionResolvers}
	 * which allows for providing a list of resolvers.
	 */
	@Bean
	public HandlerExceptionResolver handlerExceptionResolver() {
<span class="fc" id="L915">		List&lt;HandlerExceptionResolver&gt; exceptionResolvers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L916">		configureHandlerExceptionResolvers(exceptionResolvers);</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">		if (exceptionResolvers.isEmpty()) {</span>
<span class="fc" id="L918">			addDefaultHandlerExceptionResolvers(exceptionResolvers);</span>
		}
<span class="fc" id="L920">		extendHandlerExceptionResolvers(exceptionResolvers);</span>
<span class="fc" id="L921">		HandlerExceptionResolverComposite composite = new HandlerExceptionResolverComposite();</span>
<span class="fc" id="L922">		composite.setOrder(0);</span>
<span class="fc" id="L923">		composite.setExceptionResolvers(exceptionResolvers);</span>
<span class="fc" id="L924">		return composite;</span>
	}

	/**
	 * Override this method to configure the list of
	 * {@link HandlerExceptionResolver HandlerExceptionResolvers} to use.
	 * &lt;p&gt;Adding resolvers to the list turns off the default resolvers that would otherwise
	 * be registered by default. Also see {@link #addDefaultHandlerExceptionResolvers}
	 * that can be used to add the default exception resolvers.
	 * @param exceptionResolvers a list to add exception resolvers to (initially an empty list)
	 */
	protected void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; exceptionResolvers) {
<span class="fc" id="L936">	}</span>

	/**
	 * Override this method to extend or modify the list of
	 * {@link HandlerExceptionResolver HandlerExceptionResolvers} after it has been configured.
	 * &lt;p&gt;This may be useful for example to allow default resolvers to be registered
	 * and then insert a custom one through this method.
	 * @param exceptionResolvers the list of configured resolvers to extend.
	 * @since 4.3
	 */
	protected void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; exceptionResolvers) {
<span class="fc" id="L947">	}</span>

	/**
	 * A method available to subclasses for adding default
	 * {@link HandlerExceptionResolver HandlerExceptionResolvers}.
	 * &lt;p&gt;Adds the following exception resolvers:
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link ExceptionHandlerExceptionResolver} for handling exceptions through
	 * {@link org.springframework.web.bind.annotation.ExceptionHandler} methods.
	 * &lt;li&gt;{@link ResponseStatusExceptionResolver} for exceptions annotated with
	 * {@link org.springframework.web.bind.annotation.ResponseStatus}.
	 * &lt;li&gt;{@link DefaultHandlerExceptionResolver} for resolving known Spring exception types
	 * &lt;/ul&gt;
	 */
	protected final void addDefaultHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; exceptionResolvers) {
<span class="fc" id="L962">		ExceptionHandlerExceptionResolver exceptionHandlerResolver = createExceptionHandlerExceptionResolver();</span>
<span class="fc" id="L963">		exceptionHandlerResolver.setContentNegotiationManager(mvcContentNegotiationManager());</span>
<span class="fc" id="L964">		exceptionHandlerResolver.setMessageConverters(getMessageConverters());</span>
<span class="fc" id="L965">		exceptionHandlerResolver.setCustomArgumentResolvers(getArgumentResolvers());</span>
<span class="fc" id="L966">		exceptionHandlerResolver.setCustomReturnValueHandlers(getReturnValueHandlers());</span>
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">		if (jackson2Present) {</span>
<span class="fc" id="L968">			exceptionHandlerResolver.setResponseBodyAdvice(</span>
<span class="fc" id="L969">					Collections.singletonList(new JsonViewResponseBodyAdvice()));</span>
		}
<span class="fc bfc" id="L971" title="All 2 branches covered.">		if (this.applicationContext != null) {</span>
<span class="fc" id="L972">			exceptionHandlerResolver.setApplicationContext(this.applicationContext);</span>
		}
<span class="fc" id="L974">		exceptionHandlerResolver.afterPropertiesSet();</span>
<span class="fc" id="L975">		exceptionResolvers.add(exceptionHandlerResolver);</span>

<span class="fc" id="L977">		ResponseStatusExceptionResolver responseStatusResolver = new ResponseStatusExceptionResolver();</span>
<span class="fc" id="L978">		responseStatusResolver.setMessageSource(this.applicationContext);</span>
<span class="fc" id="L979">		exceptionResolvers.add(responseStatusResolver);</span>

<span class="fc" id="L981">		exceptionResolvers.add(new DefaultHandlerExceptionResolver());</span>
<span class="fc" id="L982">	}</span>

	/**
	 * Protected method for plugging in a custom subclass of
	 * {@link ExceptionHandlerExceptionResolver}.
	 * @since 4.3
	 */
	protected ExceptionHandlerExceptionResolver createExceptionHandlerExceptionResolver() {
<span class="fc" id="L990">		return new ExceptionHandlerExceptionResolver();</span>
	}

	/**
	 * Register a {@link ViewResolverComposite} that contains a chain of view resolvers
	 * to use for view resolution.
	 * By default this resolver is ordered at 0 unless content negotiation view
	 * resolution is used in which case the order is raised to
	 * {@link org.springframework.core.Ordered#HIGHEST_PRECEDENCE
	 * Ordered.HIGHEST_PRECEDENCE}.
	 * &lt;p&gt;If no other resolvers are configured,
	 * {@link ViewResolverComposite#resolveViewName(String, Locale)} returns null in order
	 * to allow other potential {@link ViewResolver} beans to resolve views.
	 * @since 4.1
	 */
	@Bean
	public ViewResolver mvcViewResolver() {
<span class="fc" id="L1007">		ViewResolverRegistry registry = new ViewResolverRegistry(</span>
<span class="fc" id="L1008">				mvcContentNegotiationManager(), this.applicationContext);</span>
<span class="fc" id="L1009">		configureViewResolvers(registry);</span>

<span class="pc bpc" id="L1011" title="1 of 4 branches missed.">		if (registry.getViewResolvers().isEmpty() &amp;&amp; this.applicationContext != null) {</span>
<span class="fc" id="L1012">			String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span>
					this.applicationContext, ViewResolver.class, true, false);
<span class="fc bfc" id="L1014" title="All 2 branches covered.">			if (names.length == 1) {</span>
<span class="fc" id="L1015">				registry.getViewResolvers().add(new InternalResourceViewResolver());</span>
			}
		}

<span class="fc" id="L1019">		ViewResolverComposite composite = new ViewResolverComposite();</span>
<span class="fc" id="L1020">		composite.setOrder(registry.getOrder());</span>
<span class="fc" id="L1021">		composite.setViewResolvers(registry.getViewResolvers());</span>
<span class="pc bpc" id="L1022" title="1 of 2 branches missed.">		if (this.applicationContext != null) {</span>
<span class="fc" id="L1023">			composite.setApplicationContext(this.applicationContext);</span>
		}
<span class="pc bpc" id="L1025" title="1 of 2 branches missed.">		if (this.servletContext != null) {</span>
<span class="fc" id="L1026">			composite.setServletContext(this.servletContext);</span>
		}
<span class="fc" id="L1028">		return composite;</span>
	}

	/**
	 * Override this method to configure view resolution.
	 * @see ViewResolverRegistry
	 */
	protected void configureViewResolvers(ViewResolverRegistry registry) {
<span class="fc" id="L1036">	}</span>

	/**
	 * Return the registered {@link CorsConfiguration} objects,
	 * keyed by path pattern.
	 * @since 4.2
	 */
	protected final Map&lt;String, CorsConfiguration&gt; getCorsConfigurations() {
<span class="fc bfc" id="L1044" title="All 2 branches covered.">		if (this.corsConfigurations == null) {</span>
<span class="fc" id="L1045">			CorsRegistry registry = new CorsRegistry();</span>
<span class="fc" id="L1046">			addCorsMappings(registry);</span>
<span class="fc" id="L1047">			this.corsConfigurations = registry.getCorsConfigurations();</span>
		}
<span class="fc" id="L1049">		return this.corsConfigurations;</span>
	}

	/**
	 * Override this method to configure cross origin requests processing.
	 * @since 4.2
	 * @see CorsRegistry
	 */
	protected void addCorsMappings(CorsRegistry registry) {
<span class="fc" id="L1058">	}</span>

	@Bean
	@Lazy
	public HandlerMappingIntrospector mvcHandlerMappingIntrospector() {
<span class="nc" id="L1063">		return new HandlerMappingIntrospector();</span>
	}


	private static final class NoOpValidator implements Validator {

		@Override
		public boolean supports(Class&lt;?&gt; clazz) {
<span class="nc" id="L1071">			return false;</span>
		}

		@Override
		public void validate(@Nullable Object target, Errors errors) {
<span class="nc" id="L1076">		}</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>