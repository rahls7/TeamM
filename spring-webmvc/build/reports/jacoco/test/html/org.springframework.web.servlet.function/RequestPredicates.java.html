<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RequestPredicates.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-webmvc</a> &gt; <a href="index.source.html" class="el_package">org.springframework.web.servlet.function</a> &gt; <span class="el_source">RequestPredicates.java</span></div><h1>RequestPredicates.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.servlet.function;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.URI;
import java.security.Principal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.function.Predicate;
import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.PathContainer;
import org.springframework.lang.NonNull;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.MultiValueMap;
import org.springframework.web.util.UriBuilder;
import org.springframework.web.util.UriUtils;
import org.springframework.web.util.pattern.PathPattern;
import org.springframework.web.util.pattern.PathPatternParser;

/**
 * Implementations of {@link RequestPredicate} that implement various useful
 * request matching operations, such as matching based on path, HTTP method, etc.
 *
 * @author Arjen Poutsma
 * @since 5.2
 */
<span class="nc" id="L67">public abstract class RequestPredicates {</span>

<span class="fc" id="L69">	private static final Log logger = LogFactory.getLog(RequestPredicates.class);</span>

<span class="fc" id="L71">	private static final PathPatternParser DEFAULT_PATTERN_PARSER = new PathPatternParser();</span>


	/**
	 * Return a {@code RequestPredicate} that always matches.
	 * @return a predicate that always matches
	 */
	public static RequestPredicate all() {
<span class="fc" id="L79">		return request -&gt; true;</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if the request's
	 * HTTP method is equal to the given method.
	 * @param httpMethod the HTTP method to match against
	 * @return a predicate that tests against the given HTTP method
	 */
	public static RequestPredicate method(HttpMethod httpMethod) {
<span class="fc" id="L89">		return new HttpMethodPredicate(httpMethod);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if the request's
	 * HTTP method is equal to one the of the given methods.
	 * @param httpMethods the HTTP methods to match against
	 * @return a predicate that tests against the given HTTP methods
	 */
	public static RequestPredicate methods(HttpMethod... httpMethods) {
<span class="fc" id="L99">		return new HttpMethodPredicate(httpMethods);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that tests the request path
	 * against the given path pattern.
	 * @param pattern the pattern to match to
	 * @return a predicate that tests against the given path pattern
	 */
	public static RequestPredicate path(String pattern) {
<span class="fc" id="L109">		Assert.notNull(pattern, &quot;'pattern' must not be null&quot;);</span>
<span class="fc" id="L110">		return pathPredicates(DEFAULT_PATTERN_PARSER).apply(pattern);</span>
	}

	/**
	 * Return a function that creates new path-matching {@code RequestPredicates}
	 * from pattern Strings using the given {@link PathPatternParser}.
	 * &lt;p&gt;This method can be used to specify a non-default, customized
	 * {@code PathPatternParser} when resolving path patterns.
	 * @param patternParser the parser used to parse patterns given to the returned function
	 * @return a function that resolves a pattern String into a path-matching
	 * {@code RequestPredicates} instance
	 */
	public static Function&lt;String, RequestPredicate&gt; pathPredicates(PathPatternParser patternParser) {
<span class="fc" id="L123">		Assert.notNull(patternParser, &quot;PathPatternParser must not be null&quot;);</span>
<span class="fc" id="L124">		return pattern -&gt; new PathPatternPredicate(patternParser.parse(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that tests the request's headers
	 * against the given headers predicate.
	 * @param headersPredicate a predicate that tests against the request headers
	 * @return a predicate that tests against the given header predicate
	 */
	public static RequestPredicate headers(Predicate&lt;ServerRequest.Headers&gt; headersPredicate) {
<span class="fc" id="L134">		return new HeadersPredicate(headersPredicate);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that tests if the request's
	 * {@linkplain ServerRequest.Headers#contentType() content type} is
	 * {@linkplain MediaType#includes(MediaType) included} by any of the given media types.
	 * @param mediaTypes the media types to match the request's content type against
	 * @return a predicate that tests the request's content type against the given media types
	 */
	public static RequestPredicate contentType(MediaType... mediaTypes) {
<span class="fc" id="L145">		Assert.notEmpty(mediaTypes, &quot;'mediaTypes' must not be empty&quot;);</span>
<span class="fc" id="L146">		return new ContentTypePredicate(mediaTypes);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that tests if the request's
	 * {@linkplain ServerRequest.Headers#accept() accept} header is
	 * {@linkplain MediaType#isCompatibleWith(MediaType) compatible} with any of the given media types.
	 * @param mediaTypes the media types to match the request's accept header against
	 * @return a predicate that tests the request's accept header against the given media types
	 */
	public static RequestPredicate accept(MediaType... mediaTypes) {
<span class="fc" id="L157">		Assert.notEmpty(mediaTypes, &quot;'mediaTypes' must not be empty&quot;);</span>
<span class="fc" id="L158">		return new AcceptPredicate(mediaTypes);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code GET}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is GET and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate GET(String pattern) {
<span class="fc" id="L169">		return method(HttpMethod.GET).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code HEAD}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is HEAD and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate HEAD(String pattern) {
<span class="fc" id="L180">		return method(HttpMethod.HEAD).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code POST}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is POST and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate POST(String pattern) {
<span class="fc" id="L191">		return method(HttpMethod.POST).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PUT}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is PUT and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate PUT(String pattern) {
<span class="fc" id="L202">		return method(HttpMethod.PUT).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PATCH}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is PATCH and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate PATCH(String pattern) {
<span class="fc" id="L213">		return method(HttpMethod.PATCH).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code DELETE}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is DELETE and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate DELETE(String pattern) {
<span class="fc" id="L224">		return method(HttpMethod.DELETE).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code OPTIONS}
	 * and the given {@code pattern} matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is OPTIONS and if the given pattern
	 * matches against the request path
	 */
	public static RequestPredicate OPTIONS(String pattern) {
<span class="fc" id="L235">		return method(HttpMethod.OPTIONS).and(path(pattern));</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if the request's path has the given extension.
	 * @param extension the path extension to match against, ignoring case
	 * @return a predicate that matches if the request's path has the given file extension
	 */
	public static RequestPredicate pathExtension(String extension) {
<span class="fc" id="L244">		Assert.notNull(extension, &quot;'extension' must not be null&quot;);</span>
<span class="fc" id="L245">		return new PathExtensionPredicate(extension);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if the request's path matches the given
	 * predicate.
	 * @param extensionPredicate the predicate to test against the request path extension
	 * @return a predicate that matches if the given predicate matches against the request's path
	 * file extension
	 */
	public static RequestPredicate pathExtension(Predicate&lt;String&gt; extensionPredicate) {
<span class="nc" id="L256">		return new PathExtensionPredicate(extensionPredicate);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that matches if the request's parameter of the given name
	 * has the given value.
	 * @param name the name of the parameter to test against
	 * @param value the value of the parameter to test against
	 * @return a predicate that matches if the parameter has the given value
	 * @see ServerRequest#param(String)
	 */
	public static RequestPredicate param(String name, String value) {
<span class="fc" id="L268">		return new ParamPredicate(name, value);</span>
	}

	/**
	 * Return a {@code RequestPredicate} that tests the request's parameter of the given name
	 * against the given predicate.
	 * @param name the name of the parameter to test against
	 * @param predicate predicate to test against the parameter value
	 * @return a predicate that matches the given predicate against the parameter of the given name
	 * @see ServerRequest#param(String)
	 */
	public static RequestPredicate param(String name, Predicate&lt;String&gt; predicate) {
<span class="fc" id="L280">		return new ParamPredicate(name, predicate);</span>
	}


	private static void traceMatch(String prefix, Object desired, @Nullable Object actual, boolean match) {
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">		if (logger.isTraceEnabled()) {</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">			logger.trace(String.format(&quot;%s \&quot;%s\&quot; %s against value \&quot;%s\&quot;&quot;,</span>
					prefix, desired, match ? &quot;matches&quot; : &quot;does not match&quot;, actual));
		}
<span class="fc" id="L289">	}</span>

	private static void restoreAttributes(ServerRequest request, Map&lt;String, Object&gt; attributes) {
<span class="fc" id="L292">		request.attributes().clear();</span>
<span class="fc" id="L293">		request.attributes().putAll(attributes);</span>
<span class="fc" id="L294">	}</span>

	private static Map&lt;String, String&gt; mergePathVariables(Map&lt;String, String&gt; oldVariables,
			Map&lt;String, String&gt; newVariables) {

<span class="pc bpc" id="L299" title="1 of 2 branches missed.">		if (!newVariables.isEmpty()) {</span>
<span class="nc" id="L300">			Map&lt;String, String&gt; mergedVariables = new LinkedHashMap&lt;&gt;(oldVariables);</span>
<span class="nc" id="L301">			mergedVariables.putAll(newVariables);</span>
<span class="nc" id="L302">			return mergedVariables;</span>
		}
		else {
<span class="fc" id="L305">			return oldVariables;</span>
		}
	}

	private static PathPattern mergePatterns(@Nullable PathPattern oldPattern, PathPattern newPattern) {
<span class="fc bfc" id="L310" title="All 2 branches covered.">		if (oldPattern != null) {</span>
<span class="fc" id="L311">			return oldPattern.combine(newPattern);</span>
		}
		else {
<span class="fc" id="L314">			return newPattern;</span>
		}

	}


	/**
	 * Receives notifications from the logical structure of request predicates.
	 */
	public interface Visitor {

		/**
		 * Receive notification of an HTTP method predicate.
		 * @param methods the HTTP methods that make up the predicate
		 * @see RequestPredicates#method(HttpMethod)
		 */
		void method(Set&lt;HttpMethod&gt; methods);

		/**
		 * Receive notification of an path predicate.
		 * @param pattern the path pattern that makes up the predicate
		 * @see RequestPredicates#path(String)
		 */
		void path(String pattern);

		/**
		 * Receive notification of an path extension predicate.
		 * @param extension the path extension that makes up the predicate
		 * @see RequestPredicates#pathExtension(String)
		 */
		void pathExtension(String extension);

		/**
		 * Receive notification of a HTTP header predicate.
		 * @param name the name of the HTTP header to check
		 * @param value the desired value of the HTTP header
		 * @see RequestPredicates#headers(Predicate)
		 * @see RequestPredicates#contentType(MediaType...)
		 * @see RequestPredicates#accept(MediaType...)
		 */
		void header(String name, String value);

		/**
		 * Receive notification of a parameter predicate.
		 * @param name the name of the parameter
		 * @param value the desired value of the parameter
		 * @see RequestPredicates#param(String, String)
		 */
		void param(String name, String value);

		/**
		 * Receive first notification of a logical AND predicate.
		 * The first subsequent notification will contain the left-hand side of the AND-predicate;
		 * followed by {@link #and()}, followed by the right-hand side, followed by {@link #endAnd()}.
		 * @see RequestPredicate#and(RequestPredicate)
		 */
		void startAnd();

		/**
		 * Receive &quot;middle&quot; notification of a logical AND predicate.
		 * The following notification contains the right-hand side, followed by {@link #endAnd()}.
		 * @see RequestPredicate#and(RequestPredicate)
		 */
		void and();

		/**
		 * Receive last notification of a logical AND predicate.
		 * @see RequestPredicate#and(RequestPredicate)
		 */
		void endAnd();

		/**
		 * Receive first notification of a logical OR predicate.
		 * The first subsequent notification will contain the left-hand side of the OR-predicate;
		 * the second notification contains the right-hand side, followed by {@link #endOr()}.
		 * @see RequestPredicate#or(RequestPredicate)
		 */
		void startOr();

		/**
		 * Receive &quot;middle&quot; notification of a logical OR predicate.
		 * The following notification contains the right-hand side, followed by {@link #endOr()}.
		 * @see RequestPredicate#or(RequestPredicate)
		 */
		void or();

		/**
		 * Receive last notification of a logical OR predicate.
		 * @see RequestPredicate#or(RequestPredicate)
		 */
		void endOr();

		/**
		 * Receive first notification of a negated predicate.
		 * The first subsequent notification will contain the negated predicated, followed
		 * by {@link #endNegate()}.
		 * @see RequestPredicate#negate()
		 */
		void startNegate();

		/**
		 * Receive last notification of a negated predicate.
		 * @see RequestPredicate#negate()
		 */
		void endNegate();

		/**
		 * Receive first notification of an unknown predicate.
		 */
		void unknown(RequestPredicate predicate);
	}

	private static class HttpMethodPredicate implements RequestPredicate {

		private final Set&lt;HttpMethod&gt; httpMethods;


<span class="fc" id="L431">		public HttpMethodPredicate(HttpMethod httpMethod) {</span>
<span class="fc" id="L432">			Assert.notNull(httpMethod, &quot;HttpMethod must not be null&quot;);</span>
<span class="fc" id="L433">			this.httpMethods = EnumSet.of(httpMethod);</span>
<span class="fc" id="L434">		}</span>

<span class="fc" id="L436">		public HttpMethodPredicate(HttpMethod... httpMethods) {</span>
<span class="fc" id="L437">			Assert.notEmpty(httpMethods, &quot;HttpMethods must not be empty&quot;);</span>
<span class="fc" id="L438">			this.httpMethods = EnumSet.copyOf(Arrays.asList(httpMethods));</span>
<span class="fc" id="L439">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L443">			boolean match = this.httpMethods.contains(request.method());</span>
<span class="fc" id="L444">			traceMatch(&quot;Method&quot;, this.httpMethods, request.method(), match);</span>
<span class="fc" id="L445">			return match;</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L450">			visitor.method(Collections.unmodifiableSet(this.httpMethods));</span>
<span class="fc" id="L451">		}</span>

		@Override
		public String toString() {
<span class="nc bnc" id="L455" title="All 2 branches missed.">			if (this.httpMethods.size() == 1) {</span>
<span class="nc" id="L456">				return this.httpMethods.iterator().next().toString();</span>
			}
			else {
<span class="nc" id="L459">				return this.httpMethods.toString();</span>
			}
		}
	}


	private static class PathPatternPredicate implements RequestPredicate {

		private final PathPattern pattern;

<span class="fc" id="L469">		public PathPatternPredicate(PathPattern pattern) {</span>
<span class="fc" id="L470">			Assert.notNull(pattern, &quot;'pattern' must not be null&quot;);</span>
<span class="fc" id="L471">			this.pattern = pattern;</span>
<span class="fc" id="L472">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L476">			PathContainer pathContainer = request.pathContainer();</span>
<span class="fc" id="L477">			PathPattern.PathMatchInfo info = this.pattern.matchAndExtract(pathContainer);</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">			traceMatch(&quot;Pattern&quot;, this.pattern.getPatternString(), request.path(), info != null);</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">			if (info != null) {</span>
<span class="fc" id="L480">				mergeAttributes(request, info.getUriVariables(), this.pattern);</span>
<span class="fc" id="L481">				return true;</span>
			}
			else {
<span class="fc" id="L484">				return false;</span>
			}
		}

		private static void mergeAttributes(ServerRequest request, Map&lt;String, String&gt; variables,
				PathPattern pattern) {
<span class="fc" id="L490">			Map&lt;String, String&gt; pathVariables = mergePathVariables(request.pathVariables(), variables);</span>
<span class="fc" id="L491">			request.attributes().put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE,</span>
<span class="fc" id="L492">						Collections.unmodifiableMap(pathVariables));</span>

<span class="fc" id="L494">			pattern = mergePatterns(</span>
<span class="fc" id="L495">					(PathPattern) request.attributes().get(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE),</span>
					pattern);
<span class="fc" id="L497">			request.attributes().put(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE, pattern);</span>
<span class="fc" id="L498">		}</span>
		@Override
		public Optional&lt;ServerRequest&gt; nest(ServerRequest request) {
<span class="fc" id="L501">			return Optional.ofNullable(this.pattern.matchStartOfPath(request.pathContainer()))</span>
<span class="fc" id="L502">					.map(info -&gt; new SubPathServerRequestWrapper(request, info, this.pattern));</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L507">			visitor.path(this.pattern.getPatternString());</span>
<span class="fc" id="L508">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L512">			return this.pattern.getPatternString();</span>
		}
	}


	private static class HeadersPredicate implements RequestPredicate {

		private final Predicate&lt;ServerRequest.Headers&gt; headersPredicate;

<span class="fc" id="L521">		public HeadersPredicate(Predicate&lt;ServerRequest.Headers&gt; headersPredicate) {</span>
<span class="fc" id="L522">			Assert.notNull(headersPredicate, &quot;Predicate must not be null&quot;);</span>
<span class="fc" id="L523">			this.headersPredicate = headersPredicate;</span>
<span class="fc" id="L524">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L528">			return this.headersPredicate.test(request.headers());</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L533">			return this.headersPredicate.toString();</span>
		}
	}

	private static class ContentTypePredicate extends HeadersPredicate {

		private final Set&lt;MediaType&gt; mediaTypes;

		public ContentTypePredicate(MediaType... mediaTypes) {
<span class="fc" id="L542">			this(new HashSet&lt;&gt;(Arrays.asList(mediaTypes)));</span>
<span class="fc" id="L543">		}</span>

		private ContentTypePredicate(Set&lt;MediaType&gt; mediaTypes) {
<span class="fc" id="L546">			super(headers -&gt; {</span>
<span class="fc" id="L547">				MediaType contentType =</span>
<span class="fc" id="L548">						headers.contentType().orElse(MediaType.APPLICATION_OCTET_STREAM);</span>
<span class="fc" id="L549">				boolean match = mediaTypes.stream()</span>
<span class="fc" id="L550">						.anyMatch(mediaType -&gt; mediaType.includes(contentType));</span>
<span class="fc" id="L551">				traceMatch(&quot;Content-Type&quot;, mediaTypes, contentType, match);</span>
<span class="fc" id="L552">				return match;</span>
			});
<span class="fc" id="L554">			this.mediaTypes = mediaTypes;</span>
<span class="fc" id="L555">		}</span>

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L559">			visitor.header(HttpHeaders.CONTENT_TYPE,</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">					(this.mediaTypes.size() == 1) ?</span>
<span class="fc" id="L561">							this.mediaTypes.iterator().next().toString() :</span>
<span class="fc" id="L562">							this.mediaTypes.toString());</span>
<span class="fc" id="L563">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L567">			return String.format(&quot;Content-Type: %s&quot;,</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">					(this.mediaTypes.size() == 1) ?</span>
<span class="nc" id="L569">							this.mediaTypes.iterator().next().toString() :</span>
<span class="nc" id="L570">							this.mediaTypes.toString());</span>
		}
	}

	private static class AcceptPredicate extends HeadersPredicate {

		private final Set&lt;MediaType&gt; mediaTypes;

		public AcceptPredicate(MediaType... mediaTypes) {
<span class="fc" id="L579">			this(new HashSet&lt;&gt;(Arrays.asList(mediaTypes)));</span>
<span class="fc" id="L580">		}</span>

		private AcceptPredicate(Set&lt;MediaType&gt; mediaTypes) {
<span class="fc" id="L583">			super(headers -&gt; {</span>
<span class="fc" id="L584">				List&lt;MediaType&gt; acceptedMediaTypes = acceptedMediaTypes(headers);</span>
<span class="fc" id="L585">				boolean match = acceptedMediaTypes.stream()</span>
<span class="fc" id="L586">						.anyMatch(acceptedMediaType -&gt; mediaTypes.stream()</span>
<span class="fc" id="L587">								.anyMatch(acceptedMediaType::isCompatibleWith));</span>
<span class="fc" id="L588">				traceMatch(&quot;Accept&quot;, mediaTypes, acceptedMediaTypes, match);</span>
<span class="fc" id="L589">				return match;</span>
			});
<span class="fc" id="L591">			this.mediaTypes = mediaTypes;</span>
<span class="fc" id="L592">		}</span>

		@NonNull
		private static List&lt;MediaType&gt; acceptedMediaTypes(ServerRequest.Headers headers) {
<span class="fc" id="L596">			List&lt;MediaType&gt; acceptedMediaTypes = headers.accept();</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">			if (acceptedMediaTypes.isEmpty()) {</span>
<span class="nc" id="L598">				acceptedMediaTypes = Collections.singletonList(MediaType.ALL);</span>
			}
			else {
<span class="fc" id="L601">				MediaType.sortBySpecificityAndQuality(acceptedMediaTypes);</span>
			}
<span class="fc" id="L603">			return acceptedMediaTypes;</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L608">			visitor.header(HttpHeaders.ACCEPT,</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">					(this.mediaTypes.size() == 1) ?</span>
<span class="pc" id="L610">							this.mediaTypes.iterator().next().toString() :</span>
<span class="nc" id="L611">							this.mediaTypes.toString());</span>
<span class="fc" id="L612">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L616">			return String.format(&quot;Accept: %s&quot;,</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">					(this.mediaTypes.size() == 1) ?</span>
<span class="nc" id="L618">							this.mediaTypes.iterator().next().toString() :</span>
<span class="nc" id="L619">							this.mediaTypes.toString());</span>
		}
	}

	private static class PathExtensionPredicate implements RequestPredicate {

		private final Predicate&lt;String&gt; extensionPredicate;

		@Nullable
		private final String extension;
<span class="nc" id="L629">		public PathExtensionPredicate(Predicate&lt;String&gt; extensionPredicate) {</span>
<span class="nc" id="L630">			Assert.notNull(extensionPredicate, &quot;Predicate must not be null&quot;);</span>
<span class="nc" id="L631">			this.extensionPredicate = extensionPredicate;</span>
<span class="nc" id="L632">			this.extension = null;</span>
<span class="nc" id="L633">		}</span>

<span class="fc" id="L635">		public PathExtensionPredicate(String extension) {</span>
<span class="fc" id="L636">			Assert.notNull(extension, &quot;Extension must not be null&quot;);</span>

<span class="fc" id="L638">			this.extensionPredicate = s -&gt; {</span>
<span class="fc" id="L639">				boolean match = extension.equalsIgnoreCase(s);</span>
<span class="fc" id="L640">				traceMatch(&quot;Extension&quot;, extension, s, match);</span>
<span class="fc" id="L641">				return match;</span>
			};
<span class="fc" id="L643">			this.extension = extension;</span>
<span class="fc" id="L644">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L648">			String pathExtension = UriUtils.extractFileExtension(request.path());</span>
<span class="fc" id="L649">			return this.extensionPredicate.test(pathExtension);</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">			visitor.pathExtension(</span>
					(this.extension != null) ?
							this.extension :
<span class="nc" id="L657">							this.extensionPredicate.toString());</span>
<span class="fc" id="L658">		}</span>

		@Override
		public String toString() {
<span class="nc bnc" id="L662" title="All 2 branches missed.">			return String.format(&quot;*.%s&quot;,</span>
					(this.extension != null) ?
							this.extension :
							this.extensionPredicate);
		}

	}


	private static class ParamPredicate implements RequestPredicate {

		private final String name;

		private final Predicate&lt;String&gt; valuePredicate;

		@Nullable
		private final String value;

<span class="fc" id="L680">		public ParamPredicate(String name, Predicate&lt;String&gt; valuePredicate) {</span>
<span class="fc" id="L681">			Assert.notNull(name, &quot;Name must not be null&quot;);</span>
<span class="fc" id="L682">			Assert.notNull(valuePredicate, &quot;Predicate must not be null&quot;);</span>
<span class="fc" id="L683">			this.name = name;</span>
<span class="fc" id="L684">			this.valuePredicate = valuePredicate;</span>
<span class="fc" id="L685">			this.value = null;</span>
<span class="fc" id="L686">		}</span>

<span class="fc" id="L688">		public ParamPredicate(String name, String value) {</span>
<span class="fc" id="L689">			Assert.notNull(name, &quot;Name must not be null&quot;);</span>
<span class="fc" id="L690">			Assert.notNull(value, &quot;Value must not be null&quot;);</span>
<span class="fc" id="L691">			this.name = name;</span>
<span class="fc" id="L692">			this.valuePredicate = value::equals;</span>
<span class="fc" id="L693">			this.value = value;</span>
<span class="fc" id="L694">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L698">			Optional&lt;String&gt; s = request.param(this.name);</span>
<span class="fc" id="L699">			return s.filter(this.valuePredicate).isPresent();</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">			visitor.param(this.name,</span>
					(this.value != null) ?
							this.value :
<span class="nc" id="L707">							this.valuePredicate.toString());</span>
<span class="fc" id="L708">		}</span>

		@Override
		public String toString() {
<span class="nc bnc" id="L712" title="All 2 branches missed.">			return String.format(&quot;?%s %s&quot;, this.name,</span>
					(this.value != null) ?
							this.value :
							this.valuePredicate);
		}
	}


	/**
	 * {@link RequestPredicate} for where both {@code left} and {@code right} predicates
	 * must match.
	 */
	static class AndRequestPredicate implements RequestPredicate {

		private final RequestPredicate left;

		private final RequestPredicate right;

<span class="fc" id="L730">		public AndRequestPredicate(RequestPredicate left, RequestPredicate right) {</span>
<span class="fc" id="L731">			Assert.notNull(left, &quot;Left RequestPredicate must not be null&quot;);</span>
<span class="fc" id="L732">			Assert.notNull(right, &quot;Right RequestPredicate must not be null&quot;);</span>
<span class="fc" id="L733">			this.left = left;</span>
<span class="fc" id="L734">			this.right = right;</span>
<span class="fc" id="L735">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L739">			Map&lt;String, Object&gt; oldAttributes = new HashMap&lt;&gt;(request.attributes());</span>

<span class="fc bfc" id="L741" title="All 4 branches covered.">			if (this.left.test(request) &amp;&amp; this.right.test(request)) {</span>
<span class="fc" id="L742">				return true;</span>
			}
<span class="fc" id="L744">			restoreAttributes(request, oldAttributes);</span>
<span class="fc" id="L745">			return false;</span>
		}

		@Override
		public Optional&lt;ServerRequest&gt; nest(ServerRequest request) {
<span class="nc" id="L750">			return this.left.nest(request).flatMap(this.right::nest);</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L755">			visitor.startAnd();</span>
<span class="fc" id="L756">			this.left.accept(visitor);</span>
<span class="fc" id="L757">			visitor.and();</span>
<span class="fc" id="L758">			this.right.accept(visitor);</span>
<span class="fc" id="L759">			visitor.endAnd();</span>
<span class="fc" id="L760">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L764">			return String.format(&quot;(%s &amp;&amp; %s)&quot;, this.left, this.right);</span>
		}
	}

	/**
	 * {@link RequestPredicate} that negates a delegate predicate.
	 */
	static class NegateRequestPredicate implements RequestPredicate {
		private final RequestPredicate delegate;

<span class="fc" id="L774">		public NegateRequestPredicate(RequestPredicate delegate) {</span>
<span class="fc" id="L775">			Assert.notNull(delegate, &quot;Delegate must not be null&quot;);</span>
<span class="fc" id="L776">			this.delegate = delegate;</span>
<span class="fc" id="L777">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L781">			Map&lt;String, Object&gt; oldAttributes = new HashMap&lt;&gt;(request.attributes());</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">			boolean result = !this.delegate.test(request);</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">			if (!result) {</span>
<span class="fc" id="L784">				restoreAttributes(request, oldAttributes);</span>
			}
<span class="fc" id="L786">			return result;</span>
		}

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L791">			visitor.startNegate();</span>
<span class="fc" id="L792">			this.delegate.accept(visitor);</span>
<span class="fc" id="L793">			visitor.endNegate();</span>
<span class="fc" id="L794">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L798">			return &quot;!&quot; + this.delegate.toString();</span>
		}
	}

	/**
	 * {@link RequestPredicate} where either {@code left} or {@code right} predicates
	 * may match.
	 */
	static class OrRequestPredicate implements RequestPredicate {

		private final RequestPredicate left;

		private final RequestPredicate right;

<span class="fc" id="L812">		public OrRequestPredicate(RequestPredicate left, RequestPredicate right) {</span>
<span class="fc" id="L813">			Assert.notNull(left, &quot;Left RequestPredicate must not be null&quot;);</span>
<span class="fc" id="L814">			Assert.notNull(right, &quot;Right RequestPredicate must not be null&quot;);</span>
<span class="fc" id="L815">			this.left = left;</span>
<span class="fc" id="L816">			this.right = right;</span>
<span class="fc" id="L817">		}</span>

		@Override
		public boolean test(ServerRequest request) {
<span class="fc" id="L821">			Map&lt;String, Object&gt; oldAttributes = new HashMap&lt;&gt;(request.attributes());</span>

<span class="fc bfc" id="L823" title="All 2 branches covered.">			if (this.left.test(request)) {</span>
<span class="fc" id="L824">				return true;</span>
			}
			else {
<span class="fc" id="L827">				restoreAttributes(request, oldAttributes);</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">				if (this.right.test(request)) {</span>
<span class="fc" id="L829">					return true;</span>
				}
			}
<span class="fc" id="L832">			restoreAttributes(request, oldAttributes);</span>
<span class="fc" id="L833">			return false;</span>
		}

		@Override
		public Optional&lt;ServerRequest&gt; nest(ServerRequest request) {
<span class="nc" id="L838">			Optional&lt;ServerRequest&gt; leftResult = this.left.nest(request);</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">			if (leftResult.isPresent()) {</span>
<span class="nc" id="L840">				return leftResult;</span>
			}
			else {
<span class="nc" id="L843">				return this.right.nest(request);</span>
			}
		}

		@Override
		public void accept(Visitor visitor) {
<span class="fc" id="L849">			visitor.startOr();</span>
<span class="fc" id="L850">			this.left.accept(visitor);</span>
<span class="fc" id="L851">			visitor.or();</span>
<span class="fc" id="L852">			this.right.accept(visitor);</span>
<span class="fc" id="L853">			visitor.endOr();</span>
<span class="fc" id="L854">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L858">			return String.format(&quot;(%s || %s)&quot;, this.left, this.right);</span>
		}
	}


	private static class SubPathServerRequestWrapper implements ServerRequest {

		private final ServerRequest request;

		private final PathContainer pathContainer;

		private final Map&lt;String, Object&gt; attributes;

		public SubPathServerRequestWrapper(ServerRequest request,
<span class="fc" id="L872">				PathPattern.PathRemainingMatchInfo info, PathPattern pattern) {</span>
<span class="fc" id="L873">			this.request = request;</span>
<span class="fc" id="L874">			this.pathContainer = new SubPathContainer(info.getPathRemaining());</span>
<span class="fc" id="L875">			this.attributes = mergeAttributes(request, info.getUriVariables(), pattern);</span>
<span class="fc" id="L876">		}</span>

		private static Map&lt;String, Object&gt; mergeAttributes(ServerRequest request,
		Map&lt;String, String&gt; pathVariables, PathPattern pattern) {
<span class="fc" id="L880">			Map&lt;String, Object&gt; result = new ConcurrentHashMap&lt;&gt;(request.attributes());</span>

<span class="fc" id="L882">			result.put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE,</span>
<span class="fc" id="L883">					mergePathVariables(request.pathVariables(), pathVariables));</span>

<span class="fc" id="L885">			pattern = mergePatterns(</span>
<span class="fc" id="L886">					(PathPattern) request.attributes().get(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE),</span>
					pattern);
<span class="fc" id="L888">			result.put(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE, pattern);</span>
<span class="fc" id="L889">			return result;</span>
		}

		@Override
		public HttpMethod method() {
<span class="fc" id="L894">			return this.request.method();</span>
		}

		@Override
		public String methodName() {
<span class="nc" id="L899">			return this.request.methodName();</span>
		}

		@Override
		public URI uri() {
<span class="nc" id="L904">			return this.request.uri();</span>
		}

		@Override
		public UriBuilder uriBuilder() {
<span class="nc" id="L909">			return this.request.uriBuilder();</span>
		}

		@Override
		public String path() {
<span class="fc" id="L914">			return this.pathContainer.value();</span>
		}

		@Override
		public PathContainer pathContainer() {
<span class="fc" id="L919">			return this.pathContainer;</span>
		}

		@Override
		public Headers headers() {
<span class="nc" id="L924">			return this.request.headers();</span>
		}

		@Override
		public MultiValueMap&lt;String, Cookie&gt; cookies() {
<span class="nc" id="L929">			return this.request.cookies();</span>
		}

		@Override
		public Optional&lt;InetSocketAddress&gt; remoteAddress() {
<span class="nc" id="L934">			return this.request.remoteAddress();</span>
		}

		@Override
		public List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters() {
<span class="nc" id="L939">			return this.request.messageConverters();</span>
		}

		@Override
		public &lt;T&gt; T body(Class&lt;T&gt; bodyType) throws ServletException, IOException {
<span class="nc" id="L944">			return this.request.body(bodyType);</span>
		}

		@Override
		public &lt;T&gt; T body(ParameterizedTypeReference&lt;T&gt; bodyType)
				throws ServletException, IOException {
<span class="nc" id="L950">			return this.request.body(bodyType);</span>
		}

		@Override
		public Optional&lt;Object&gt; attribute(String name) {
<span class="nc" id="L955">			return this.request.attribute(name);</span>
		}

		@Override
		public Map&lt;String, Object&gt; attributes() {
<span class="fc" id="L960">			return this.attributes;</span>
		}

		@Override
		public Optional&lt;String&gt; param(String name) {
<span class="nc" id="L965">			return this.request.param(name);</span>
		}

		@Override
		public MultiValueMap&lt;String, String&gt; params() {
<span class="nc" id="L970">			return this.request.params();</span>
		}

		@Override
		@SuppressWarnings(&quot;unchecked&quot;)
		public Map&lt;String, String&gt; pathVariables() {
<span class="fc" id="L976">			return (Map&lt;String, String&gt;) this.attributes.getOrDefault(</span>
<span class="fc" id="L977">					RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap());</span>
		}

		@Override
		public HttpSession session() {
<span class="nc" id="L982">			return this.request.session();</span>
		}



		@Override
		public Optional&lt;Principal&gt; principal() {
<span class="nc" id="L989">			return this.request.principal();</span>
		}

		@Override
		public HttpServletRequest servletRequest() {
<span class="nc" id="L994">			return this.request.servletRequest();</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L999">			return method() + &quot; &quot; +  path();</span>
		}

		private static class SubPathContainer implements PathContainer {

<span class="pc" id="L1004">			private static final PathContainer.Separator SEPARATOR = () -&gt; &quot;/&quot;;</span>


			private final String value;

			private final List&lt;Element&gt; elements;

<span class="fc" id="L1011">			public SubPathContainer(PathContainer original) {</span>
<span class="fc" id="L1012">				this.value = prefixWithSlash(original.value());</span>
<span class="fc" id="L1013">				this.elements = prependWithSeparator(original.elements());</span>
<span class="fc" id="L1014">			}</span>

			private static String prefixWithSlash(String path) {
<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">				if (!path.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L1018">					path = &quot;/&quot; + path;</span>
				}
<span class="fc" id="L1020">				return path;</span>
			}

			private static List&lt;Element&gt; prependWithSeparator(List&lt;Element&gt; elements) {
<span class="fc" id="L1024">				List&lt;Element&gt; result = new ArrayList&lt;&gt;(elements);</span>
<span class="pc bpc" id="L1025" title="2 of 4 branches missed.">				if (result.isEmpty() || !(result.get(0) instanceof Separator)) {</span>
<span class="nc" id="L1026">					result.add(0, SEPARATOR);</span>
				}
<span class="fc" id="L1028">				return Collections.unmodifiableList(result);</span>
			}


			@Override
			public String value() {
<span class="fc" id="L1034">				return this.value;</span>
			}

			@Override
			public List&lt;Element&gt; elements() {
<span class="fc" id="L1039">				return this.elements;</span>
			}
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>