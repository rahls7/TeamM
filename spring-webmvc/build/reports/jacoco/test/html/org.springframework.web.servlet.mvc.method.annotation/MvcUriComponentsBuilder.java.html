<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MvcUriComponentsBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-webmvc</a> &gt; <a href="index.source.html" class="el_package">org.springframework.web.servlet.mvc.method.annotation</a> &gt; <span class="el_source">MvcUriComponentsBuilder.java</span></div><h1>MvcUriComponentsBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.servlet.mvc.method.annotation;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.servlet.http.HttpServletRequest;

import org.aopalliance.intercept.MethodInterceptor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.aop.framework.ProxyFactory;
import org.springframework.aop.target.EmptyTargetSource;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.cglib.core.SpringNamingPolicy;
import org.springframework.cglib.proxy.Callback;
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.Factory;
import org.springframework.cglib.proxy.MethodProxy;
import org.springframework.core.DefaultParameterNameDiscoverer;
import org.springframework.core.MethodIntrospector;
import org.springframework.core.MethodParameter;
import org.springframework.core.ParameterNameDiscoverer;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.core.annotation.SynthesizingMethodParameter;
import org.springframework.lang.Nullable;
import org.springframework.objenesis.ObjenesisException;
import org.springframework.objenesis.SpringObjenesis;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.Assert;
import org.springframework.util.ObjectUtils;
import org.springframework.util.PathMatcher;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.ReflectionUtils.MethodFilter;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.method.annotation.RequestParamMethodArgumentResolver;
import org.springframework.web.method.support.CompositeUriComponentsContributor;
import org.springframework.web.servlet.DispatcherServlet;
import org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;
import org.springframework.web.util.UriComponentsBuilder;

/**
 * Creates instances of {@link org.springframework.web.util.UriComponentsBuilder}
 * by pointing to {@code @RequestMapping} methods on Spring MVC controllers.
 *
 * &lt;p&gt;There are several groups of methods:
 * &lt;ul&gt;
 * &lt;li&gt;Static {@code fromXxx(...)} methods to prepare links using information
 * from the current request as determined by a call to
 * {@link org.springframework.web.servlet.support.ServletUriComponentsBuilder#fromCurrentServletMapping()}.
 * &lt;li&gt;Static {@code fromXxx(UriComponentsBuilder,...)} methods can be given
 * a baseUrl when operating outside the context of a request.
 * &lt;li&gt;Instance-based {@code withXxx(...)} methods where an instance of
 * MvcUriComponentsBuilder is created with a baseUrl via
 * {@link #relativeTo(org.springframework.web.util.UriComponentsBuilder)}.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This class uses values from &quot;Forwarded&quot;
 * (&lt;a href=&quot;https://tools.ietf.org/html/rfc7239&quot;&gt;RFC 7239&lt;/a&gt;),
 * &quot;X-Forwarded-Host&quot;, &quot;X-Forwarded-Port&quot;, and &quot;X-Forwarded-Proto&quot; headers,
 * if present, in order to reflect the client-originated protocol and address.
 * Consider using the {@code ForwardedHeaderFilter} in order to choose from a
 * central place whether to extract and use, or to discard such headers.
 * See the Spring Framework reference for more on this filter.
 *
 * @author Oliver Gierke
 * @author Rossen Stoyanchev
 * @author Sam Brannen
 * @since 4.0
 */
public class MvcUriComponentsBuilder {

	/**
	 * Well-known name for the {@link CompositeUriComponentsContributor} object in the bean factory.
	 */
	public static final String MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME = &quot;mvcUriComponentsContributor&quot;;


<span class="fc" id="L105">	private static final Log logger = LogFactory.getLog(MvcUriComponentsBuilder.class);</span>

<span class="fc" id="L107">	private static final SpringObjenesis objenesis = new SpringObjenesis();</span>

<span class="fc" id="L109">	private static final PathMatcher pathMatcher = new AntPathMatcher();</span>

<span class="fc" id="L111">	private static final ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();</span>

	private static final CompositeUriComponentsContributor defaultUriComponentsContributor;

	static {
<span class="fc" id="L116">		defaultUriComponentsContributor = new CompositeUriComponentsContributor(</span>
				new PathVariableMethodArgumentResolver(), new RequestParamMethodArgumentResolver(false));
<span class="fc" id="L118">	}</span>

	private final UriComponentsBuilder baseUrl;


	/**
	 * Default constructor. Protected to prevent direct instantiation.
	 * @see #fromController(Class)
	 * @see #fromMethodName(Class, String, Object...)
	 * @see #fromMethodCall(Object)
	 * @see #fromMappingName(String)
	 * @see #fromMethod(Class, Method, Object...)
	 */
<span class="fc" id="L131">	protected MvcUriComponentsBuilder(UriComponentsBuilder baseUrl) {</span>
<span class="fc" id="L132">		Assert.notNull(baseUrl, &quot;'baseUrl' is required&quot;);</span>
<span class="fc" id="L133">		this.baseUrl = baseUrl;</span>
<span class="fc" id="L134">	}</span>


	/**
	 * Create an instance of this class with a base URL. After that calls to one
	 * of the instance based {@code withXxx(...}} methods will create URLs relative
	 * to the given base URL.
	 */
	public static MvcUriComponentsBuilder relativeTo(UriComponentsBuilder baseUrl) {
<span class="fc" id="L143">		return new MvcUriComponentsBuilder(baseUrl);</span>
	}


	/**
	 * Create a {@link UriComponentsBuilder} from the mapping of a controller class
	 * and current request information including Servlet mapping. If the controller
	 * contains multiple mappings, only the first one is used.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @param controllerType the controller to build a URI for
	 * @return a UriComponentsBuilder instance (never {@code null})
	 */
	public static UriComponentsBuilder fromController(Class&lt;?&gt; controllerType) {
<span class="fc" id="L157">		return fromController(null, controllerType);</span>
	}

	/**
	 * An alternative to {@link #fromController(Class)} that accepts a
	 * {@code UriComponentsBuilder} representing the base URL. This is useful
	 * when using MvcUriComponentsBuilder outside the context of processing a
	 * request or to apply a custom baseUrl not matching the current request.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @param builder the builder for the base URL; the builder will be cloned
	 * and therefore not modified and may be re-used for further calls.
	 * @param controllerType the controller to build a URI for
	 * @return a UriComponentsBuilder instance (never {@code null})
	 */
	public static UriComponentsBuilder fromController(@Nullable UriComponentsBuilder builder,
			Class&lt;?&gt; controllerType) {

<span class="fc" id="L175">		builder = getBaseUrlToUse(builder);</span>

		// Externally configured prefix via PathConfigurer..
<span class="fc" id="L178">		String prefix = getPathPrefix(controllerType);</span>
<span class="fc" id="L179">		builder.path(prefix);</span>

<span class="fc" id="L181">		String mapping = getClassMapping(controllerType);</span>
<span class="fc" id="L182">		builder.path(mapping);</span>

<span class="fc" id="L184">		return builder;</span>
	}

	/**
	 * Create a {@link UriComponentsBuilder} from the mapping of a controller
	 * method and an array of method argument values. This method delegates
	 * to {@link #fromMethod(Class, Method, Object...)}.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @param controllerType the controller
	 * @param methodName the method name
	 * @param args the argument values
	 * @return a UriComponentsBuilder instance, never {@code null}
	 * @throws IllegalArgumentException if there is no matching or
	 * if there is more than one matching method
	 */
	public static UriComponentsBuilder fromMethodName(Class&lt;?&gt; controllerType,
			String methodName, Object... args) {

<span class="fc" id="L203">		Method method = getMethod(controllerType, methodName, args);</span>
<span class="fc" id="L204">		return fromMethodInternal(null, controllerType, method, args);</span>
	}

	/**
	 * An alternative to {@link #fromMethodName(Class, String, Object...)} that
	 * accepts a {@code UriComponentsBuilder} representing the base URL. This is
	 * useful when using MvcUriComponentsBuilder outside the context of processing
	 * a request or to apply a custom baseUrl not matching the current request.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @param builder the builder for the base URL; the builder will be cloned
	 * and therefore not modified and may be re-used for further calls.
	 * @param controllerType the controller
	 * @param methodName the method name
	 * @param args the argument values
	 * @return a UriComponentsBuilder instance, never {@code null}
	 * @throws IllegalArgumentException if there is no matching or
	 * if there is more than one matching method
	 */
	public static UriComponentsBuilder fromMethodName(UriComponentsBuilder builder,
			Class&lt;?&gt; controllerType, String methodName, Object... args) {

<span class="fc" id="L226">		Method method = getMethod(controllerType, methodName, args);</span>
<span class="fc" id="L227">		return fromMethodInternal(builder, controllerType, method, args);</span>
	}

	/**
	 * Create a {@link UriComponentsBuilder} from the mapping of a controller method
	 * and an array of method argument values. The array of values  must match the
	 * signature of the controller method. Values for {@code @RequestParam} and
	 * {@code @PathVariable} are used for building the URI (via implementations of
	 * {@link org.springframework.web.method.support.UriComponentsContributor
	 * UriComponentsContributor}) while remaining argument values are ignored and
	 * can be {@code null}.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @param controllerType the controller type
	 * @param method the controller method
	 * @param args argument values for the controller method
	 * @return a UriComponentsBuilder instance, never {@code null}
	 * @since 4.2
	 */
	public static UriComponentsBuilder fromMethod(Class&lt;?&gt; controllerType, Method method, Object... args) {
<span class="nc" id="L247">		return fromMethodInternal(null, controllerType, method, args);</span>
	}

	/**
	 * An alternative to {@link #fromMethod(Class, Method, Object...)}
	 * that accepts a {@code UriComponentsBuilder} representing the base URL.
	 * This is useful when using MvcUriComponentsBuilder outside the context of
	 * processing a request or to apply a custom baseUrl not matching the
	 * current request.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @param baseUrl the builder for the base URL; the builder will be cloned
	 * and therefore not modified and may be re-used for further calls.
	 * @param controllerType the controller type
	 * @param method the controller method
	 * @param args argument values for the controller method
	 * @return a UriComponentsBuilder instance (never {@code null})
	 * @since 4.2
	 */
	public static UriComponentsBuilder fromMethod(UriComponentsBuilder baseUrl,
			@Nullable Class&lt;?&gt; controllerType, Method method, Object... args) {

<span class="nc bnc" id="L269" title="All 2 branches missed.">		return fromMethodInternal(baseUrl,</span>
<span class="nc" id="L270">				(controllerType != null ? controllerType : method.getDeclaringClass()), method, args);</span>
	}

	/**
	 * Create a {@link UriComponentsBuilder} by invoking a &quot;mock&quot; controller method.
	 * The controller method and the supplied argument values are then used to
	 * delegate to {@link #fromMethod(Class, Method, Object...)}.
	 * &lt;p&gt;For example, given this controller:
	 * &lt;pre class=&quot;code&quot;&gt;
	 * &amp;#064;RequestMapping(&quot;/people/{id}/addresses&quot;)
	 * class AddressController {
	 *
	 *   &amp;#064;RequestMapping(&quot;/{country}&quot;)
	 *   public HttpEntity&amp;lt;Void&amp;gt; getAddressesForCountry(&amp;#064;PathVariable String country) { ... }
	 *
	 *   &amp;#064;RequestMapping(value=&quot;/&quot;, method=RequestMethod.POST)
	 *   public void addAddress(Address address) { ... }
	 * }
	 * &lt;/pre&gt;
	 * A UriComponentsBuilder can be created:
	 * &lt;pre class=&quot;code&quot;&gt;
	 * // Inline style with static import of &quot;MvcUriComponentsBuilder.on&quot;
	 *
	 * MvcUriComponentsBuilder.fromMethodCall(
	 * 		on(AddressController.class).getAddressesForCountry(&quot;US&quot;)).buildAndExpand(1);
	 *
	 * // Longer form useful for repeated invocation (and void controller methods)
	 *
	 * AddressController controller = MvcUriComponentsBuilder.on(AddressController.class);
	 * controller.addAddress(null);
	 * builder = MvcUriComponentsBuilder.fromMethodCall(controller);
	 * controller.getAddressesForCountry(&quot;US&quot;)
	 * builder = MvcUriComponentsBuilder.fromMethodCall(controller);
	 * &lt;/pre&gt;
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @param info either the value returned from a &quot;mock&quot; controller
	 * invocation or the &quot;mock&quot; controller itself after an invocation
	 * @return a UriComponents instance
	 * @see #on(Class)
	 * @see #controller(Class)
	 */
	public static UriComponentsBuilder fromMethodCall(Object info) {
<span class="fc" id="L313">		Assert.isInstanceOf(MethodInvocationInfo.class, info, &quot;MethodInvocationInfo required&quot;);</span>
<span class="fc" id="L314">		MethodInvocationInfo invocationInfo = (MethodInvocationInfo) info;</span>
<span class="fc" id="L315">		Class&lt;?&gt; controllerType = invocationInfo.getControllerType();</span>
<span class="fc" id="L316">		Method method = invocationInfo.getControllerMethod();</span>
<span class="fc" id="L317">		Object[] arguments = invocationInfo.getArgumentValues();</span>
<span class="fc" id="L318">		return fromMethodInternal(null, controllerType, method, arguments);</span>
	}

	/**
	 * An alternative to {@link #fromMethodCall(Object)} that accepts a
	 * {@code UriComponentsBuilder} representing the base URL. This is useful
	 * when using MvcUriComponentsBuilder outside the context of processing a
	 * request or to apply a custom baseUrl not matching the current request.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @param builder the builder for the base URL; the builder will be cloned
	 * and therefore not modified and may be re-used for further calls.
	 * @param info either the value returned from a &quot;mock&quot; controller
	 * invocation or the &quot;mock&quot; controller itself after an invocation
	 * @return a UriComponents instance
	 */
	public static UriComponentsBuilder fromMethodCall(UriComponentsBuilder builder, Object info) {
<span class="fc" id="L335">		Assert.isInstanceOf(MethodInvocationInfo.class, info, &quot;MethodInvocationInfo required&quot;);</span>
<span class="fc" id="L336">		MethodInvocationInfo invocationInfo = (MethodInvocationInfo) info;</span>
<span class="fc" id="L337">		Class&lt;?&gt; controllerType = invocationInfo.getControllerType();</span>
<span class="fc" id="L338">		Method method = invocationInfo.getControllerMethod();</span>
<span class="fc" id="L339">		Object[] arguments = invocationInfo.getArgumentValues();</span>
<span class="fc" id="L340">		return fromMethodInternal(builder, controllerType, method, arguments);</span>
	}

	/**
	 * Return a &quot;mock&quot; controller instance. When an {@code @RequestMapping} method
	 * on the controller is invoked, the supplied argument values are remembered
	 * and the result can then be used to create a {@code UriComponentsBuilder}
	 * via {@link #fromMethodCall(Object)}.
	 * &lt;p&gt;Note that this is a shorthand version of {@link #controller(Class)} intended
	 * for inline use (with a static import), for example:
	 * &lt;pre class=&quot;code&quot;&gt;
	 * MvcUriComponentsBuilder.fromMethodCall(on(FooController.class).getFoo(1)).build();
	 * &lt;/pre&gt;
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 *
	 * @param controllerType the target controller
	 */
	public static &lt;T&gt; T on(Class&lt;T&gt; controllerType) {
<span class="fc" id="L359">		return controller(controllerType);</span>
	}

	/**
	 * Return a &quot;mock&quot; controller instance. When an {@code @RequestMapping} method
	 * on the controller is invoked, the supplied argument values are remembered
	 * and the result can then be used to create {@code UriComponentsBuilder} via
	 * {@link #fromMethodCall(Object)}.
	 * &lt;p&gt;This is a longer version of {@link #on(Class)}. It is needed with controller
	 * methods returning void as well for repeated invocations.
	 * &lt;pre class=&quot;code&quot;&gt;
	 * FooController fooController = controller(FooController.class);
	 *
	 * fooController.saveFoo(1, null);
	 * builder = MvcUriComponentsBuilder.fromMethodCall(fooController);
	 *
	 * fooController.saveFoo(2, null);
	 * builder = MvcUriComponentsBuilder.fromMethodCall(fooController);
	 * &lt;/pre&gt;
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @param controllerType the target controller
	 */
	public static &lt;T&gt; T controller(Class&lt;T&gt; controllerType) {
<span class="fc" id="L383">		Assert.notNull(controllerType, &quot;'controllerType' must not be null&quot;);</span>
<span class="fc" id="L384">		return ControllerMethodInvocationInterceptor.initProxy(controllerType, null);</span>
	}

	/**
	 * Create a URL from the name of a Spring MVC controller method's request mapping.
	 * &lt;p&gt;The configured
	 * {@link org.springframework.web.servlet.handler.HandlerMethodMappingNamingStrategy
	 * HandlerMethodMappingNamingStrategy} determines the names of controller
	 * method request mappings at startup. By default all mappings are assigned
	 * a name based on the capital letters of the class name, followed by &quot;#&quot; as
	 * separator, and then the method name. For example &quot;PC#getPerson&quot;
	 * for a class named PersonController with method getPerson. In case the
	 * naming convention does not produce unique results, an explicit name may
	 * be assigned through the name attribute of the {@code @RequestMapping}
	 * annotation.
	 * &lt;p&gt;This is aimed primarily for use in view rendering technologies and EL
	 * expressions. The Spring URL tag library registers this method as a function
	 * called &quot;mvcUrl&quot;.
	 * &lt;p&gt;For example, given this controller:
	 * &lt;pre class=&quot;code&quot;&gt;
	 * &amp;#064;RequestMapping(&quot;/people&quot;)
	 * class PersonController {
	 *
	 *   &amp;#064;RequestMapping(&quot;/{id}&quot;)
	 *   public HttpEntity&amp;lt;Void&amp;gt; getPerson(&amp;#064;PathVariable String id) { ... }
	 *
	 * }
	 * &lt;/pre&gt;
	 *
	 * A JSP can prepare a URL to the controller method as follows:
	 *
	 * &lt;pre class=&quot;code&quot;&gt;
	 * &lt;%@ taglib uri=&quot;http://www.springframework.org/tags&quot; prefix=&quot;s&quot; %&gt;
	 *
	 * &amp;lt;a href=&quot;${s:mvcUrl('PC#getPerson').arg(0,&quot;123&quot;).build()}&quot;&amp;gt;Get Person&amp;lt;/a&amp;gt;
	 * &lt;/pre&gt;
	 * &lt;p&gt;Note that it's not necessary to specify all arguments. Only the ones
	 * required to prepare the URL, mainly {@code @RequestParam} and {@code @PathVariable}).
	 *
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 *
	 * @param mappingName the mapping name
	 * @return a builder to prepare the URI String
	 * @throws IllegalArgumentException if the mapping name is not found or
	 * if there is no unique match
	 * @since 4.1
	 */
	public static MethodArgumentBuilder fromMappingName(String mappingName) {
<span class="fc" id="L433">		return fromMappingName(null, mappingName);</span>
	}

	/**
	 * An alternative to {@link #fromMappingName(String)} that accepts a
	 * {@code UriComponentsBuilder} representing the base URL. This is useful
	 * when using MvcUriComponentsBuilder outside the context of processing a
	 * request or to apply a custom baseUrl not matching the current request.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @param builder the builder for the base URL; the builder will be cloned
	 * and therefore not modified and may be re-used for further calls.
	 * @param name the mapping name
	 * @return a builder to prepare the URI String
	 * @throws IllegalArgumentException if the mapping name is not found or
	 * if there is no unique match
	 * @since 4.2
	 */
	public static MethodArgumentBuilder fromMappingName(@Nullable UriComponentsBuilder builder, String name) {
<span class="fc" id="L452">		WebApplicationContext wac = getWebApplicationContext();</span>
<span class="fc" id="L453">		Assert.notNull(wac, &quot;No WebApplicationContext. &quot;);</span>
<span class="fc" id="L454">		Map&lt;String, RequestMappingInfoHandlerMapping&gt; map = wac.getBeansOfType(RequestMappingInfoHandlerMapping.class);</span>
<span class="fc" id="L455">		List&lt;HandlerMethod&gt; handlerMethods = null;</span>
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">		for (RequestMappingInfoHandlerMapping mapping : map.values()) {</span>
<span class="fc" id="L457">			handlerMethods = mapping.getHandlerMethodsForMappingName(name);</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">			if (handlerMethods != null) {</span>
<span class="fc" id="L459">				break;</span>
			}
<span class="nc" id="L461">		}</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">		if (handlerMethods == null) {</span>
<span class="nc" id="L463">			throw new IllegalArgumentException(&quot;Mapping not found: &quot; + name);</span>
		}
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">		else if (handlerMethods.size() != 1) {</span>
<span class="nc" id="L466">			throw new IllegalArgumentException(&quot;No unique match for mapping &quot; + name + &quot;: &quot; + handlerMethods);</span>
		}
		else {
<span class="fc" id="L469">			HandlerMethod handlerMethod = handlerMethods.get(0);</span>
<span class="fc" id="L470">			Class&lt;?&gt; controllerType = handlerMethod.getBeanType();</span>
<span class="fc" id="L471">			Method method = handlerMethod.getMethod();</span>
<span class="fc" id="L472">			return new MethodArgumentBuilder(builder, controllerType, method);</span>
		}
	}


	// Instance methods, relative to a base UriComponentsBuilder...

	/**
	 * An alternative to {@link #fromController(Class)} for use with an instance
	 * of this class created via a call to {@link #relativeTo}.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @since 4.2
	 */
	public UriComponentsBuilder withController(Class&lt;?&gt; controllerType) {
<span class="fc" id="L487">		return fromController(this.baseUrl, controllerType);</span>
	}

	/**
	 * An alternative to {@link #fromMethodName(Class, String, Object...)}} for
	 * use with an instance of this class created via {@link #relativeTo}.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @since 4.2
	 */
	public UriComponentsBuilder withMethodName(Class&lt;?&gt; controllerType, String methodName, Object... args) {
<span class="fc" id="L498">		return fromMethodName(this.baseUrl, controllerType, methodName, args);</span>
	}

	/**
	 * An alternative to {@link #fromMethodCall(Object)} for use with an instance
	 * of this class created via {@link #relativeTo}.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @since 4.2
	 */
	public UriComponentsBuilder withMethodCall(Object invocationInfo) {
<span class="fc" id="L509">		return fromMethodCall(this.baseUrl, invocationInfo);</span>
	}

	/**
	 * An alternative to {@link #fromMappingName(String)} for use with an instance
	 * of this class created via {@link #relativeTo}.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @since 4.2
	 */
	public MethodArgumentBuilder withMappingName(String mappingName) {
<span class="fc" id="L520">		return fromMappingName(this.baseUrl, mappingName);</span>
	}

	/**
	 * An alternative to {@link #fromMethod(Class, Method, Object...)}
	 * for use with an instance of this class created via {@link #relativeTo}.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method extracts values from &quot;Forwarded&quot;
	 * and &quot;X-Forwarded-*&quot; headers if found. See class-level docs.
	 * @since 4.2
	 */
	public UriComponentsBuilder withMethod(Class&lt;?&gt; controllerType, Method method, Object... args) {
<span class="nc" id="L531">		return fromMethod(this.baseUrl, controllerType, method, args);</span>
	}


	private static UriComponentsBuilder fromMethodInternal(@Nullable UriComponentsBuilder builder,
			Class&lt;?&gt; controllerType, Method method, Object... args) {

<span class="fc" id="L538">		builder = getBaseUrlToUse(builder);</span>

		// Externally configured prefix via PathConfigurer..
<span class="fc" id="L541">		String prefix = getPathPrefix(controllerType);</span>
<span class="fc" id="L542">		builder.path(prefix);</span>

<span class="fc" id="L544">		String typePath = getClassMapping(controllerType);</span>
<span class="fc" id="L545">		String methodPath = getMethodMapping(method);</span>
<span class="fc" id="L546">		String path = pathMatcher.combine(typePath, methodPath);</span>
<span class="fc" id="L547">		builder.path(path);</span>

<span class="fc" id="L549">		return applyContributors(builder, method, args);</span>
	}

	private static UriComponentsBuilder getBaseUrlToUse(@Nullable UriComponentsBuilder baseUrl) {
<span class="fc bfc" id="L553" title="All 2 branches covered.">		return baseUrl == null ?</span>
<span class="fc" id="L554">				ServletUriComponentsBuilder.fromCurrentServletMapping() :</span>
<span class="fc" id="L555">				baseUrl.cloneBuilder();</span>
	}

	private static String getPathPrefix(Class&lt;?&gt; controllerType) {
<span class="fc" id="L559">		WebApplicationContext wac = getWebApplicationContext();</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">		if (wac != null) {</span>
<span class="fc" id="L561">			Map&lt;String, RequestMappingHandlerMapping&gt; map = wac.getBeansOfType(RequestMappingHandlerMapping.class);</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">			for (RequestMappingHandlerMapping mapping : map.values()) {</span>
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">				if (mapping.isHandler(controllerType)) {</span>
<span class="fc" id="L564">					String prefix = mapping.getPathPrefix(controllerType);</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">					if (prefix != null) {</span>
<span class="fc" id="L566">						return prefix;</span>
					}
				}
<span class="fc" id="L569">			}</span>
		}
<span class="fc" id="L571">		return &quot;&quot;;</span>
	}

	private static String getClassMapping(Class&lt;?&gt; controllerType) {
<span class="fc" id="L575">		Assert.notNull(controllerType, &quot;'controllerType' must not be null&quot;);</span>
<span class="fc" id="L576">		RequestMapping mapping = AnnotatedElementUtils.findMergedAnnotation(controllerType, RequestMapping.class);</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">		if (mapping == null) {</span>
<span class="fc" id="L578">			return &quot;/&quot;;</span>
		}
<span class="fc" id="L580">		String[] paths = mapping.path();</span>
<span class="pc bpc" id="L581" title="2 of 4 branches missed.">		if (ObjectUtils.isEmpty(paths) || StringUtils.isEmpty(paths[0])) {</span>
<span class="nc" id="L582">			return &quot;/&quot;;</span>
		}
<span class="pc bpc" id="L584" title="1 of 4 branches missed.">		if (paths.length &gt; 1 &amp;&amp; logger.isTraceEnabled()) {</span>
<span class="nc" id="L585">			logger.trace(&quot;Using first of multiple paths on &quot; + controllerType.getName());</span>
		}
<span class="fc" id="L587">		return paths[0];</span>
	}

	private static String getMethodMapping(Method method) {
<span class="fc" id="L591">		Assert.notNull(method, &quot;'method' must not be null&quot;);</span>
<span class="fc" id="L592">		RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(method, RequestMapping.class);</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">		if (requestMapping == null) {</span>
<span class="nc" id="L594">			throw new IllegalArgumentException(&quot;No @RequestMapping on: &quot; + method.toGenericString());</span>
		}
<span class="fc" id="L596">		String[] paths = requestMapping.path();</span>
<span class="pc bpc" id="L597" title="1 of 4 branches missed.">		if (ObjectUtils.isEmpty(paths) || StringUtils.isEmpty(paths[0])) {</span>
<span class="fc" id="L598">			return &quot;/&quot;;</span>
		}
<span class="pc bpc" id="L600" title="3 of 4 branches missed.">		if (paths.length &gt; 1 &amp;&amp; logger.isTraceEnabled()) {</span>
<span class="nc" id="L601">			logger.trace(&quot;Using first of multiple paths on &quot; + method.toGenericString());</span>
		}
<span class="fc" id="L603">		return paths[0];</span>
	}

	private static Method getMethod(Class&lt;?&gt; controllerType, final String methodName, final Object... args) {
<span class="fc" id="L607">		MethodFilter selector = method -&gt; {</span>
<span class="fc" id="L608">			String name = method.getName();</span>
<span class="fc" id="L609">			int argLength = method.getParameterCount();</span>
<span class="pc bpc" id="L610" title="1 of 4 branches missed.">			return (name.equals(methodName) &amp;&amp; argLength == args.length);</span>
		};
<span class="fc" id="L612">		Set&lt;Method&gt; methods = MethodIntrospector.selectMethods(controllerType, selector);</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">		if (methods.size() == 1) {</span>
<span class="fc" id="L614">			return methods.iterator().next();</span>
		}
<span class="nc bnc" id="L616" title="All 2 branches missed.">		else if (methods.size() &gt; 1) {</span>
<span class="nc" id="L617">			throw new IllegalArgumentException(String.format(</span>
					&quot;Found two methods named '%s' accepting arguments %s in controller %s: [%s]&quot;,
<span class="nc" id="L619">					methodName, Arrays.asList(args), controllerType.getName(), methods));</span>
		}
		else {
<span class="nc" id="L622">			throw new IllegalArgumentException(&quot;No method named '&quot; + methodName + &quot;' with &quot; + args.length +</span>
<span class="nc" id="L623">					&quot; arguments found in controller &quot; + controllerType.getName());</span>
		}
	}

	private static UriComponentsBuilder applyContributors(UriComponentsBuilder builder, Method method, Object... args) {
<span class="fc" id="L628">		CompositeUriComponentsContributor contributor = getUriComponentsContributor();</span>

<span class="fc" id="L630">		int paramCount = method.getParameterCount();</span>
<span class="fc" id="L631">		int argCount = args.length;</span>
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">		if (paramCount != argCount) {</span>
<span class="nc" id="L633">			throw new IllegalArgumentException(&quot;Number of method parameters &quot; + paramCount +</span>
					&quot; does not match number of argument values &quot; + argCount);
		}

<span class="fc" id="L637">		final Map&lt;String, Object&gt; uriVars = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">		for (int i = 0; i &lt; paramCount; i++) {</span>
<span class="fc" id="L639">			MethodParameter param = new SynthesizingMethodParameter(method, i);</span>
<span class="fc" id="L640">			param.initParameterNameDiscovery(parameterNameDiscoverer);</span>
<span class="fc" id="L641">			contributor.contributeMethodArgument(param, args[i], builder, uriVars);</span>
		}

		// This may not be all the URI variables, supply what we have so far..
<span class="fc" id="L645">		return builder.uriVariables(uriVars);</span>
	}

	private static CompositeUriComponentsContributor getUriComponentsContributor() {
<span class="fc" id="L649">		WebApplicationContext wac = getWebApplicationContext();</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">		if (wac != null) {</span>
			try {
<span class="fc" id="L652">				return wac.getBean(MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME, CompositeUriComponentsContributor.class);</span>
			}
<span class="nc" id="L654">			catch (NoSuchBeanDefinitionException ex) {</span>
				// Ignore
			}
		}
<span class="fc" id="L658">		return defaultUriComponentsContributor;</span>
	}

	@Nullable
	private static WebApplicationContext getWebApplicationContext() {
<span class="fc" id="L663">		RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">		if (requestAttributes == null) {</span>
<span class="nc" id="L665">			return null;</span>
		}
<span class="fc" id="L667">		HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();</span>
<span class="fc" id="L668">		String attributeName = DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE;</span>
<span class="fc" id="L669">		WebApplicationContext wac = (WebApplicationContext) request.getAttribute(attributeName);</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">		if (wac == null) {</span>
<span class="fc" id="L671">			return null;</span>
		}
<span class="fc" id="L673">		return wac;</span>
	}



	/**
	 * Method invocation information.
	 */
	public interface MethodInvocationInfo {

		/**
		 * Return the controller types.
		 */
		Class&lt;?&gt; getControllerType();

		/**
		 * Return the controller method.
		 */
		Method getControllerMethod();

		/**
		 * Return the argument values.
		 */
		Object[] getArgumentValues();
	}


	private static class ControllerMethodInvocationInterceptor
			implements org.springframework.cglib.proxy.MethodInterceptor, MethodInterceptor, MethodInvocationInfo {

		private final Class&lt;?&gt; controllerType;

		@Nullable
		private Method controllerMethod;

		@Nullable
		private Object[] argumentValues;

<span class="fc" id="L711">		ControllerMethodInvocationInterceptor(Class&lt;?&gt; controllerType) {</span>
<span class="fc" id="L712">			this.controllerType = controllerType;</span>
<span class="fc" id="L713">		}</span>

		@Override
		@Nullable
		public Object intercept(Object obj, Method method, Object[] args, @Nullable MethodProxy proxy) {
<span class="fc bfc" id="L718" title="All 2 branches covered.">			if (method.getName().equals(&quot;getControllerType&quot;)) {</span>
<span class="fc" id="L719">				return this.controllerType;</span>
			}
<span class="fc bfc" id="L721" title="All 2 branches covered.">			else if (method.getName().equals(&quot;getControllerMethod&quot;)) {</span>
<span class="fc" id="L722">				return this.controllerMethod;</span>
			}
<span class="fc bfc" id="L724" title="All 2 branches covered.">			else if (method.getName().equals(&quot;getArgumentValues&quot;)) {</span>
<span class="fc" id="L725">				return this.argumentValues;</span>
			}
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">			else if (ReflectionUtils.isObjectMethod(method)) {</span>
<span class="nc" id="L728">				return ReflectionUtils.invokeMethod(method, obj, args);</span>
			}
			else {
<span class="fc" id="L731">				this.controllerMethod = method;</span>
<span class="fc" id="L732">				this.argumentValues = args;</span>
<span class="fc" id="L733">				Class&lt;?&gt; returnType = method.getReturnType();</span>
				try {
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">					return (returnType == void.class ? null : returnType.cast(initProxy(returnType, this)));</span>
				}
<span class="fc" id="L737">				catch (Throwable ex) {</span>
<span class="fc" id="L738">					throw new IllegalStateException(</span>
							&quot;Failed to create proxy for controller method return type: &quot; + method, ex);
				}
			}
		}

		@Override
		@Nullable
		public Object invoke(org.aopalliance.intercept.MethodInvocation inv) throws Throwable {
<span class="nc" id="L747">			return intercept(inv.getThis(), inv.getMethod(), inv.getArguments(), null);</span>
		}

		@Override
		public Class&lt;?&gt; getControllerType() {
<span class="fc" id="L752">			return this.controllerType;</span>
		}

		@Override
		public Method getControllerMethod() {
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">			Assert.state(this.controllerMethod != null, &quot;Not initialized yet&quot;);</span>
<span class="fc" id="L758">			return this.controllerMethod;</span>
		}

		@Override
		public Object[] getArgumentValues() {
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">			Assert.state(this.argumentValues != null, &quot;Not initialized yet&quot;);</span>
<span class="fc" id="L764">			return this.argumentValues;</span>
		}


		@SuppressWarnings(&quot;unchecked&quot;)
		private static &lt;T&gt; T initProxy(
				Class&lt;?&gt; controllerType, @Nullable ControllerMethodInvocationInterceptor interceptor) {

<span class="fc bfc" id="L772" title="All 2 branches covered.">			interceptor = interceptor != null ?</span>
					interceptor : new ControllerMethodInvocationInterceptor(controllerType);

<span class="fc bfc" id="L775" title="All 2 branches covered.">			if (controllerType == Object.class) {</span>
<span class="fc" id="L776">				return (T) interceptor;</span>
			}

<span class="pc bpc" id="L779" title="1 of 2 branches missed.">			else if (controllerType.isInterface()) {</span>
<span class="nc" id="L780">				ProxyFactory factory = new ProxyFactory(EmptyTargetSource.INSTANCE);</span>
<span class="nc" id="L781">				factory.addInterface(controllerType);</span>
<span class="nc" id="L782">				factory.addInterface(MethodInvocationInfo.class);</span>
<span class="nc" id="L783">				factory.addAdvice(interceptor);</span>
<span class="nc" id="L784">				return (T) factory.getProxy();</span>
			}

			else {
<span class="fc" id="L788">				Enhancer enhancer = new Enhancer();</span>
<span class="fc" id="L789">				enhancer.setSuperclass(controllerType);</span>
<span class="fc" id="L790">				enhancer.setInterfaces(new Class&lt;?&gt;[] {MethodInvocationInfo.class});</span>
<span class="fc" id="L791">				enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span>
<span class="fc" id="L792">				enhancer.setCallbackType(org.springframework.cglib.proxy.MethodInterceptor.class);</span>

<span class="fc" id="L794">				Class&lt;?&gt; proxyClass = enhancer.createClass();</span>
<span class="fc" id="L795">				Object proxy = null;</span>

<span class="pc bpc" id="L797" title="1 of 2 branches missed.">				if (objenesis.isWorthTrying()) {</span>
					try {
<span class="fc" id="L799">						proxy = objenesis.newInstance(proxyClass, enhancer.getUseCache());</span>
					}
<span class="nc" id="L801">					catch (ObjenesisException ex) {</span>
<span class="nc" id="L802">						logger.debug(&quot;Failed to create controller proxy, falling back on default constructor&quot;, ex);</span>
<span class="fc" id="L803">					}</span>
				}

<span class="pc bpc" id="L806" title="1 of 2 branches missed.">				if (proxy == null) {</span>
					try {
<span class="nc" id="L808">						proxy = ReflectionUtils.accessibleConstructor(proxyClass).newInstance();</span>
					}
<span class="nc" id="L810">					catch (Throwable ex) {</span>
<span class="nc" id="L811">						throw new IllegalStateException(</span>
								&quot;Failed to create controller proxy or use default constructor&quot;, ex);
<span class="nc" id="L813">					}</span>
				}

<span class="fc" id="L816">				((Factory) proxy).setCallbacks(new Callback[] {interceptor});</span>
<span class="fc" id="L817">				return (T) proxy;</span>
			}
		}
	}


	/**
	 * Builder class to create URLs for method arguments.
	 */
	public static class MethodArgumentBuilder {

		private final Class&lt;?&gt; controllerType;

		private final Method method;

		private final Object[] argumentValues;

		private final UriComponentsBuilder baseUrl;

		/**
		 * Create a new {@link MethodArgumentBuilder} instance.
		 * @since 4.2
		 */
		public MethodArgumentBuilder(Class&lt;?&gt; controllerType, Method method) {
<span class="nc" id="L841">			this(null, controllerType, method);</span>
<span class="nc" id="L842">		}</span>

		/**
		 * Create a new {@link MethodArgumentBuilder} instance.
		 * @since 4.2
		 */
<span class="fc" id="L848">		public MethodArgumentBuilder(@Nullable UriComponentsBuilder baseUrl, Class&lt;?&gt; controllerType, Method method) {</span>
<span class="fc" id="L849">			Assert.notNull(controllerType, &quot;'controllerType' is required&quot;);</span>
<span class="fc" id="L850">			Assert.notNull(method, &quot;'method' is required&quot;);</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">			this.baseUrl = baseUrl != null ? baseUrl : UriComponentsBuilder.fromPath(getPath());</span>
<span class="fc" id="L852">			this.controllerType = controllerType;</span>
<span class="fc" id="L853">			this.method = method;</span>
<span class="fc" id="L854">			this.argumentValues = new Object[method.getParameterCount()];</span>
<span class="fc" id="L855">		}</span>

		private static String getPath() {
<span class="fc" id="L858">			UriComponentsBuilder builder = ServletUriComponentsBuilder.fromCurrentServletMapping();</span>
<span class="fc" id="L859">			String path = builder.build().getPath();</span>
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">			return path != null ? path : &quot;&quot;;</span>
		}

		public MethodArgumentBuilder arg(int index, Object value) {
<span class="fc" id="L864">			this.argumentValues[index] = value;</span>
<span class="fc" id="L865">			return this;</span>
		}

		/**
		 * Use this method only if you need to apply strong encoding to expanded
		 * URI variables by quoting all characters with reserved meaning.
		 * @since 5.0.8
		 */
		public MethodArgumentBuilder encode() {
<span class="fc" id="L874">			this.baseUrl.encode();</span>
<span class="fc" id="L875">			return this;</span>
		}

		public String build() {
<span class="nc" id="L879">			return fromMethodInternal(this.baseUrl, this.controllerType, this.method, this.argumentValues)</span>
<span class="nc" id="L880">					.build().encode().toUriString();</span>
		}

		public String buildAndExpand(Object... uriVars) {
<span class="fc" id="L884">			return fromMethodInternal(this.baseUrl, this.controllerType, this.method, this.argumentValues)</span>
<span class="fc" id="L885">					.buildAndExpand(uriVars).encode().toString();</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>