<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RequestMappingHandlerAdapter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-webmvc</a> &gt; <a href="index.source.html" class="el_package">org.springframework.web.servlet.mvc.method.annotation</a> &gt; <span class="el_source">RequestMappingHandlerAdapter.java</span></div><h1>RequestMappingHandlerAdapter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.servlet.mvc.method.annotation;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.core.DefaultParameterNameDiscoverer;
import org.springframework.core.MethodIntrospector;
import org.springframework.core.ParameterNameDiscoverer;
import org.springframework.core.ReactiveAdapterRegistry;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.core.annotation.AnnotationAwareOrderComparator;
import org.springframework.core.log.LogFormatUtils;
import org.springframework.core.task.AsyncTaskExecutor;
import org.springframework.core.task.SimpleAsyncTaskExecutor;
import org.springframework.http.converter.ByteArrayHttpMessageConverter;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter;
import org.springframework.http.converter.xml.SourceHttpMessageConverter;
import org.springframework.lang.Nullable;
import org.springframework.ui.ModelMap;
import org.springframework.util.CollectionUtils;
import org.springframework.util.ReflectionUtils.MethodFilter;
import org.springframework.web.accept.ContentNegotiationManager;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.support.DefaultDataBinderFactory;
import org.springframework.web.bind.support.DefaultSessionAttributeStore;
import org.springframework.web.bind.support.SessionAttributeStore;
import org.springframework.web.bind.support.WebBindingInitializer;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.context.request.ServletWebRequest;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.context.request.async.AsyncWebRequest;
import org.springframework.web.context.request.async.CallableProcessingInterceptor;
import org.springframework.web.context.request.async.DeferredResultProcessingInterceptor;
import org.springframework.web.context.request.async.WebAsyncManager;
import org.springframework.web.context.request.async.WebAsyncTask;
import org.springframework.web.context.request.async.WebAsyncUtils;
import org.springframework.web.method.ControllerAdviceBean;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.method.annotation.ErrorsMethodArgumentResolver;
import org.springframework.web.method.annotation.ExpressionValueMethodArgumentResolver;
import org.springframework.web.method.annotation.InitBinderDataBinderFactory;
import org.springframework.web.method.annotation.MapMethodProcessor;
import org.springframework.web.method.annotation.ModelAttributeMethodProcessor;
import org.springframework.web.method.annotation.ModelFactory;
import org.springframework.web.method.annotation.ModelMethodProcessor;
import org.springframework.web.method.annotation.RequestHeaderMapMethodArgumentResolver;
import org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolver;
import org.springframework.web.method.annotation.RequestParamMapMethodArgumentResolver;
import org.springframework.web.method.annotation.RequestParamMethodArgumentResolver;
import org.springframework.web.method.annotation.SessionAttributesHandler;
import org.springframework.web.method.annotation.SessionStatusMethodArgumentResolver;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.HandlerMethodArgumentResolverComposite;
import org.springframework.web.method.support.HandlerMethodReturnValueHandler;
import org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite;
import org.springframework.web.method.support.InvocableHandlerMethod;
import org.springframework.web.method.support.ModelAndViewContainer;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.View;
import org.springframework.web.servlet.mvc.annotation.ModelAndViewResolver;
import org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;
import org.springframework.web.servlet.support.RequestContextUtils;
import org.springframework.web.util.WebUtils;

/**
 * Extension of {@link AbstractHandlerMethodAdapter} that supports
 * {@link RequestMapping @RequestMapping} annotated {@link HandlerMethod HandlerMethods}.
 *
 * &lt;p&gt;Support for custom argument and return value types can be added via
 * {@link #setCustomArgumentResolvers} and {@link #setCustomReturnValueHandlers},
 * or alternatively, to re-configure all argument and return value types,
 * use {@link #setArgumentResolvers} and {@link #setReturnValueHandlers}.
 *
 * @author Rossen Stoyanchev
 * @author Juergen Hoeller
 * @since 3.1
 * @see HandlerMethodArgumentResolver
 * @see HandlerMethodReturnValueHandler
 */
public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean {

	/**
	 * MethodFilter that matches {@link InitBinder @InitBinder} methods.
	 */
<span class="fc" id="L121">	public static final MethodFilter INIT_BINDER_METHODS = method -&gt;</span>
<span class="fc" id="L122">			AnnotatedElementUtils.hasAnnotation(method, InitBinder.class);</span>

	/**
	 * MethodFilter that matches {@link ModelAttribute @ModelAttribute} methods.
	 */
<span class="fc" id="L127">	public static final MethodFilter MODEL_ATTRIBUTE_METHODS = method -&gt;</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">			(!AnnotatedElementUtils.hasAnnotation(method, RequestMapping.class) &amp;&amp;</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">					AnnotatedElementUtils.hasAnnotation(method, ModelAttribute.class));</span>


	@Nullable
	private List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers;

	@Nullable
	private HandlerMethodArgumentResolverComposite argumentResolvers;

	@Nullable
	private HandlerMethodArgumentResolverComposite initBinderArgumentResolvers;

	@Nullable
	private List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers;

	@Nullable
	private HandlerMethodReturnValueHandlerComposite returnValueHandlers;

	@Nullable
	private List&lt;ModelAndViewResolver&gt; modelAndViewResolvers;

<span class="fc" id="L150">	private ContentNegotiationManager contentNegotiationManager = new ContentNegotiationManager();</span>

	private List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters;

<span class="fc" id="L154">	private List&lt;Object&gt; requestResponseBodyAdvice = new ArrayList&lt;&gt;();</span>

	@Nullable
	private WebBindingInitializer webBindingInitializer;

<span class="fc" id="L159">	private AsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor(&quot;MvcAsync&quot;);</span>

	@Nullable
	private Long asyncRequestTimeout;

<span class="fc" id="L164">	private CallableProcessingInterceptor[] callableInterceptors = new CallableProcessingInterceptor[0];</span>

<span class="fc" id="L166">	private DeferredResultProcessingInterceptor[] deferredResultInterceptors = new DeferredResultProcessingInterceptor[0];</span>

<span class="fc" id="L168">	private ReactiveAdapterRegistry reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance();</span>

<span class="fc" id="L170">	private boolean ignoreDefaultModelOnRedirect = false;</span>

<span class="fc" id="L172">	private int cacheSecondsForSessionAttributeHandlers = 0;</span>

<span class="fc" id="L174">	private boolean synchronizeOnSession = false;</span>

<span class="fc" id="L176">	private SessionAttributeStore sessionAttributeStore = new DefaultSessionAttributeStore();</span>

<span class="fc" id="L178">	private ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();</span>

	@Nullable
	private ConfigurableBeanFactory beanFactory;


<span class="fc" id="L184">	private final Map&lt;Class&lt;?&gt;, SessionAttributesHandler&gt; sessionAttributesHandlerCache = new ConcurrentHashMap&lt;&gt;(64);</span>

<span class="fc" id="L186">	private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; initBinderCache = new ConcurrentHashMap&lt;&gt;(64);</span>

<span class="fc" id="L188">	private final Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; initBinderAdviceCache = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L190">	private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; modelAttributeCache = new ConcurrentHashMap&lt;&gt;(64);</span>

<span class="fc" id="L192">	private final Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; modelAttributeAdviceCache = new LinkedHashMap&lt;&gt;();</span>


<span class="fc" id="L195">	public RequestMappingHandlerAdapter() {</span>
<span class="fc" id="L196">		StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();</span>
<span class="fc" id="L197">		stringHttpMessageConverter.setWriteAcceptCharset(false);  // see SPR-7316</span>

<span class="fc" id="L199">		this.messageConverters = new ArrayList&lt;&gt;(4);</span>
<span class="fc" id="L200">		this.messageConverters.add(new ByteArrayHttpMessageConverter());</span>
<span class="fc" id="L201">		this.messageConverters.add(stringHttpMessageConverter);</span>
		try {
<span class="fc" id="L203">			this.messageConverters.add(new SourceHttpMessageConverter&lt;&gt;());</span>
		}
<span class="nc" id="L205">		catch (Error err) {</span>
			// Ignore when no TransformerFactory implementation is available
<span class="fc" id="L207">		}</span>
<span class="fc" id="L208">		this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());</span>
<span class="fc" id="L209">	}</span>


	/**
	 * Provide resolvers for custom argument types. Custom resolvers are ordered
	 * after built-in ones. To override the built-in support for argument
	 * resolution use {@link #setArgumentResolvers} instead.
	 */
	public void setCustomArgumentResolvers(@Nullable List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {
<span class="fc" id="L218">		this.customArgumentResolvers = argumentResolvers;</span>
<span class="fc" id="L219">	}</span>

	/**
	 * Return the custom argument resolvers, or {@code null}.
	 */
	@Nullable
	public List&lt;HandlerMethodArgumentResolver&gt; getCustomArgumentResolvers() {
<span class="fc" id="L226">		return this.customArgumentResolvers;</span>
	}

	/**
	 * Configure the complete list of supported argument types thus overriding
	 * the resolvers that would otherwise be configured by default.
	 */
	public void setArgumentResolvers(@Nullable List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">		if (argumentResolvers == null) {</span>
<span class="nc" id="L235">			this.argumentResolvers = null;</span>
		}
		else {
<span class="fc" id="L238">			this.argumentResolvers = new HandlerMethodArgumentResolverComposite();</span>
<span class="fc" id="L239">			this.argumentResolvers.addResolvers(argumentResolvers);</span>
		}
<span class="fc" id="L241">	}</span>

	/**
	 * Return the configured argument resolvers, or possibly {@code null} if
	 * not initialized yet via {@link #afterPropertiesSet()}.
	 */
	@Nullable
	public List&lt;HandlerMethodArgumentResolver&gt; getArgumentResolvers() {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">		return (this.argumentResolvers != null ? this.argumentResolvers.getResolvers() : null);</span>
	}

	/**
	 * Configure the supported argument types in {@code @InitBinder} methods.
	 */
	public void setInitBinderArgumentResolvers(@Nullable List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">		if (argumentResolvers == null) {</span>
<span class="nc" id="L257">			this.initBinderArgumentResolvers = null;</span>
		}
		else {
<span class="fc" id="L260">			this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite();</span>
<span class="fc" id="L261">			this.initBinderArgumentResolvers.addResolvers(argumentResolvers);</span>
		}
<span class="fc" id="L263">	}</span>

	/**
	 * Return the argument resolvers for {@code @InitBinder} methods, or possibly
	 * {@code null} if not initialized yet via {@link #afterPropertiesSet()}.
	 */
	@Nullable
	public List&lt;HandlerMethodArgumentResolver&gt; getInitBinderArgumentResolvers() {
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">		return (this.initBinderArgumentResolvers != null ? this.initBinderArgumentResolvers.getResolvers() : null);</span>
	}

	/**
	 * Provide handlers for custom return value types. Custom handlers are
	 * ordered after built-in ones. To override the built-in support for
	 * return value handling use {@link #setReturnValueHandlers}.
	 */
	public void setCustomReturnValueHandlers(@Nullable List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers) {
<span class="fc" id="L280">		this.customReturnValueHandlers = returnValueHandlers;</span>
<span class="fc" id="L281">	}</span>

	/**
	 * Return the custom return value handlers, or {@code null}.
	 */
	@Nullable
	public List&lt;HandlerMethodReturnValueHandler&gt; getCustomReturnValueHandlers() {
<span class="fc" id="L288">		return this.customReturnValueHandlers;</span>
	}

	/**
	 * Configure the complete list of supported return value types thus
	 * overriding handlers that would otherwise be configured by default.
	 */
	public void setReturnValueHandlers(@Nullable List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers) {
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">		if (returnValueHandlers == null) {</span>
<span class="nc" id="L297">			this.returnValueHandlers = null;</span>
		}
		else {
<span class="fc" id="L300">			this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite();</span>
<span class="fc" id="L301">			this.returnValueHandlers.addHandlers(returnValueHandlers);</span>
		}
<span class="fc" id="L303">	}</span>

	/**
	 * Return the configured handlers, or possibly {@code null} if not
	 * initialized yet via {@link #afterPropertiesSet()}.
	 */
	@Nullable
	public List&lt;HandlerMethodReturnValueHandler&gt; getReturnValueHandlers() {
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">		return (this.returnValueHandlers != null ? this.returnValueHandlers.getHandlers() : null);</span>
	}

	/**
	 * Provide custom {@link ModelAndViewResolver ModelAndViewResolvers}.
	 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method is available for backwards
	 * compatibility only. However, it is recommended to re-write a
	 * {@code ModelAndViewResolver} as {@link HandlerMethodReturnValueHandler}.
	 * An adapter between the two interfaces is not possible since the
	 * {@link HandlerMethodReturnValueHandler#supportsReturnType} method
	 * cannot be implemented. Hence {@code ModelAndViewResolver}s are limited
	 * to always being invoked at the end after all other return value
	 * handlers have been given a chance.
	 * &lt;p&gt;A {@code HandlerMethodReturnValueHandler} provides better access to
	 * the return type and controller method information and can be ordered
	 * freely relative to other return value handlers.
	 */
	public void setModelAndViewResolvers(@Nullable List&lt;ModelAndViewResolver&gt; modelAndViewResolvers) {
<span class="fc" id="L329">		this.modelAndViewResolvers = modelAndViewResolvers;</span>
<span class="fc" id="L330">	}</span>

	/**
	 * Return the configured {@link ModelAndViewResolver ModelAndViewResolvers}, or {@code null}.
	 */
	@Nullable
	public List&lt;ModelAndViewResolver&gt; getModelAndViewResolvers() {
<span class="fc" id="L337">		return this.modelAndViewResolvers;</span>
	}

	/**
	 * Set the {@link ContentNegotiationManager} to use to determine requested media types.
	 * If not set, the default constructor is used.
	 */
	public void setContentNegotiationManager(ContentNegotiationManager contentNegotiationManager) {
<span class="fc" id="L345">		this.contentNegotiationManager = contentNegotiationManager;</span>
<span class="fc" id="L346">	}</span>

	/**
	 * Provide the converters to use in argument resolvers and return value
	 * handlers that support reading and/or writing to the body of the
	 * request and response.
	 */
	public void setMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters) {
<span class="fc" id="L354">		this.messageConverters = messageConverters;</span>
<span class="fc" id="L355">	}</span>

	/**
	 * Return the configured message body converters.
	 */
	public List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() {
<span class="fc" id="L361">		return this.messageConverters;</span>
	}

	/**
	 * Add one or more {@code RequestBodyAdvice} instances to intercept the
	 * request before it is read and converted for {@code @RequestBody} and
	 * {@code HttpEntity} method arguments.
	 */
	public void setRequestBodyAdvice(@Nullable List&lt;RequestBodyAdvice&gt; requestBodyAdvice) {
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">		if (requestBodyAdvice != null) {</span>
<span class="fc" id="L371">			this.requestResponseBodyAdvice.addAll(requestBodyAdvice);</span>
		}
<span class="fc" id="L373">	}</span>

	/**
	 * Add one or more {@code ResponseBodyAdvice} instances to intercept the
	 * response before {@code @ResponseBody} or {@code ResponseEntity} return
	 * values are written to the response body.
	 */
	public void setResponseBodyAdvice(@Nullable List&lt;ResponseBodyAdvice&lt;?&gt;&gt; responseBodyAdvice) {
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">		if (responseBodyAdvice != null) {</span>
<span class="fc" id="L382">			this.requestResponseBodyAdvice.addAll(responseBodyAdvice);</span>
		}
<span class="fc" id="L384">	}</span>

	/**
	 * Provide a WebBindingInitializer with &quot;global&quot; initialization to apply
	 * to every DataBinder instance.
	 */
	public void setWebBindingInitializer(@Nullable WebBindingInitializer webBindingInitializer) {
<span class="fc" id="L391">		this.webBindingInitializer = webBindingInitializer;</span>
<span class="fc" id="L392">	}</span>

	/**
	 * Return the configured WebBindingInitializer, or {@code null} if none.
	 */
	@Nullable
	public WebBindingInitializer getWebBindingInitializer() {
<span class="fc" id="L399">		return this.webBindingInitializer;</span>
	}

	/**
	 * Set the default {@link AsyncTaskExecutor} to use when a controller method
	 * return a {@link Callable}. Controller methods can override this default on
	 * a per-request basis by returning an {@link WebAsyncTask}.
	 * &lt;p&gt;By default a {@link SimpleAsyncTaskExecutor} instance is used.
	 * It's recommended to change that default in production as the simple executor
	 * does not re-use threads.
	 */
	public void setTaskExecutor(AsyncTaskExecutor taskExecutor) {
<span class="fc" id="L411">		this.taskExecutor = taskExecutor;</span>
<span class="fc" id="L412">	}</span>

	/**
	 * Specify the amount of time, in milliseconds, before concurrent handling
	 * should time out. In Servlet 3, the timeout begins after the main request
	 * processing thread has exited and ends when the request is dispatched again
	 * for further processing of the concurrently produced result.
	 * &lt;p&gt;If this value is not set, the default timeout of the underlying
	 * implementation is used, e.g. 10 seconds on Tomcat with Servlet 3.
	 * @param timeout the timeout value in milliseconds
	 */
	public void setAsyncRequestTimeout(long timeout) {
<span class="fc" id="L424">		this.asyncRequestTimeout = timeout;</span>
<span class="fc" id="L425">	}</span>

	/**
	 * Configure {@code CallableProcessingInterceptor}'s to register on async requests.
	 * @param interceptors the interceptors to register
	 */
	public void setCallableInterceptors(List&lt;CallableProcessingInterceptor&gt; interceptors) {
<span class="fc" id="L432">		this.callableInterceptors = interceptors.toArray(new CallableProcessingInterceptor[0]);</span>
<span class="fc" id="L433">	}</span>

	/**
	 * Configure {@code DeferredResultProcessingInterceptor}'s to register on async requests.
	 * @param interceptors the interceptors to register
	 */
	public void setDeferredResultInterceptors(List&lt;DeferredResultProcessingInterceptor&gt; interceptors) {
<span class="fc" id="L440">		this.deferredResultInterceptors = interceptors.toArray(new DeferredResultProcessingInterceptor[0]);</span>
<span class="fc" id="L441">	}</span>

	/**
	 * Configure the registry for reactive library types to be supported as
	 * return values from controller methods.
	 * @since 5.0.5
	 */
	public void setReactiveAdapterRegistry(ReactiveAdapterRegistry reactiveAdapterRegistry) {
<span class="nc" id="L449">		this.reactiveAdapterRegistry = reactiveAdapterRegistry;</span>
<span class="nc" id="L450">	}</span>

	/**
	 * Return the configured reactive type registry of adapters.
	 * @since 5.0
	 */
	public ReactiveAdapterRegistry getReactiveAdapterRegistry() {
<span class="nc" id="L457">		return this.reactiveAdapterRegistry;</span>
	}

	/**
	 * By default the content of the &quot;default&quot; model is used both during
	 * rendering and redirect scenarios. Alternatively a controller method
	 * can declare a {@link RedirectAttributes} argument and use it to provide
	 * attributes for a redirect.
	 * &lt;p&gt;Setting this flag to {@code true} guarantees the &quot;default&quot; model is
	 * never used in a redirect scenario even if a RedirectAttributes argument
	 * is not declared. Setting it to {@code false} means the &quot;default&quot; model
	 * may be used in a redirect if the controller method doesn't declare a
	 * RedirectAttributes argument.
	 * &lt;p&gt;The default setting is {@code false} but new applications should
	 * consider setting it to {@code true}.
	 * @see RedirectAttributes
	 */
	public void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect) {
<span class="fc" id="L475">		this.ignoreDefaultModelOnRedirect = ignoreDefaultModelOnRedirect;</span>
<span class="fc" id="L476">	}</span>

	/**
	 * Specify the strategy to store session attributes with. The default is
	 * {@link org.springframework.web.bind.support.DefaultSessionAttributeStore},
	 * storing session attributes in the HttpSession with the same attribute
	 * name as in the model.
	 */
	public void setSessionAttributeStore(SessionAttributeStore sessionAttributeStore) {
<span class="nc" id="L485">		this.sessionAttributeStore = sessionAttributeStore;</span>
<span class="nc" id="L486">	}</span>

	/**
	 * Cache content produced by {@code @SessionAttributes} annotated handlers
	 * for the given number of seconds.
	 * &lt;p&gt;Possible values are:
	 * &lt;ul&gt;
	 * &lt;li&gt;-1: no generation of cache-related headers&lt;/li&gt;
	 * &lt;li&gt;0 (default value): &quot;Cache-Control: no-store&quot; will prevent caching&lt;/li&gt;
	 * &lt;li&gt;1 or higher: &quot;Cache-Control: max-age=seconds&quot; will ask to cache content;
	 * not advised when dealing with session attributes&lt;/li&gt;
	 * &lt;/ul&gt;
	 * &lt;p&gt;In contrast to the &quot;cacheSeconds&quot; property which will apply to all general
	 * handlers (but not to {@code @SessionAttributes} annotated handlers),
	 * this setting will apply to {@code @SessionAttributes} handlers only.
	 * @see #setCacheSeconds
	 * @see org.springframework.web.bind.annotation.SessionAttributes
	 */
	public void setCacheSecondsForSessionAttributeHandlers(int cacheSecondsForSessionAttributeHandlers) {
<span class="nc" id="L505">		this.cacheSecondsForSessionAttributeHandlers = cacheSecondsForSessionAttributeHandlers;</span>
<span class="nc" id="L506">	}</span>

	/**
	 * Set if controller execution should be synchronized on the session,
	 * to serialize parallel invocations from the same client.
	 * &lt;p&gt;More specifically, the execution of the {@code handleRequestInternal}
	 * method will get synchronized if this flag is &quot;true&quot;. The best available
	 * session mutex will be used for the synchronization; ideally, this will
	 * be a mutex exposed by HttpSessionMutexListener.
	 * &lt;p&gt;The session mutex is guaranteed to be the same object during
	 * the entire lifetime of the session, available under the key defined
	 * by the {@code SESSION_MUTEX_ATTRIBUTE} constant. It serves as a
	 * safe reference to synchronize on for locking on the current session.
	 * &lt;p&gt;In many cases, the HttpSession reference itself is a safe mutex
	 * as well, since it will always be the same object reference for the
	 * same active logical session. However, this is not guaranteed across
	 * different servlet containers; the only 100% safe way is a session mutex.
	 * @see org.springframework.web.util.HttpSessionMutexListener
	 * @see org.springframework.web.util.WebUtils#getSessionMutex(javax.servlet.http.HttpSession)
	 */
	public void setSynchronizeOnSession(boolean synchronizeOnSession) {
<span class="nc" id="L527">		this.synchronizeOnSession = synchronizeOnSession;</span>
<span class="nc" id="L528">	}</span>

	/**
	 * Set the ParameterNameDiscoverer to use for resolving method parameter names if needed
	 * (e.g. for default attribute names).
	 * &lt;p&gt;Default is a {@link org.springframework.core.DefaultParameterNameDiscoverer}.
	 */
	public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {
<span class="nc" id="L536">		this.parameterNameDiscoverer = parameterNameDiscoverer;</span>
<span class="nc" id="L537">	}</span>

	/**
	 * A {@link ConfigurableBeanFactory} is expected for resolving expressions
	 * in method argument default values.
	 */
	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">		if (beanFactory instanceof ConfigurableBeanFactory) {</span>
<span class="fc" id="L546">			this.beanFactory = (ConfigurableBeanFactory) beanFactory;</span>
		}
<span class="fc" id="L548">	}</span>

	/**
	 * Return the owning factory of this bean instance, or {@code null} if none.
	 */
	@Nullable
	protected ConfigurableBeanFactory getBeanFactory() {
<span class="fc" id="L555">		return this.beanFactory;</span>
	}


	@Override
	public void afterPropertiesSet() {
		// Do this first, it may add ResponseBody advice beans
<span class="fc" id="L562">		initControllerAdviceCache();</span>

<span class="fc bfc" id="L564" title="All 2 branches covered.">		if (this.argumentResolvers == null) {</span>
<span class="fc" id="L565">			List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span>
<span class="fc" id="L566">			this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span>
		}
<span class="fc bfc" id="L568" title="All 2 branches covered.">		if (this.initBinderArgumentResolvers == null) {</span>
<span class="fc" id="L569">			List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span>
<span class="fc" id="L570">			this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span>
		}
<span class="fc bfc" id="L572" title="All 2 branches covered.">		if (this.returnValueHandlers == null) {</span>
<span class="fc" id="L573">			List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span>
<span class="fc" id="L574">			this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span>
		}
<span class="fc" id="L576">	}</span>

	private void initControllerAdviceCache() {
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">		if (getApplicationContext() == null) {</span>
<span class="nc" id="L580">			return;</span>
		}

<span class="fc" id="L583">		List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());</span>
<span class="fc" id="L584">		AnnotationAwareOrderComparator.sort(adviceBeans);</span>

<span class="fc" id="L586">		List&lt;Object&gt; requestResponseBodyAdviceBeans = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L588" title="All 2 branches covered.">		for (ControllerAdviceBean adviceBean : adviceBeans) {</span>
<span class="fc" id="L589">			Class&lt;?&gt; beanType = adviceBean.getBeanType();</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">			if (beanType == null) {</span>
<span class="nc" id="L591">				throw new IllegalStateException(&quot;Unresolvable type for ControllerAdviceBean: &quot; + adviceBean);</span>
			}
<span class="fc" id="L593">			Set&lt;Method&gt; attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">			if (!attrMethods.isEmpty()) {</span>
<span class="fc" id="L595">				this.modelAttributeAdviceCache.put(adviceBean, attrMethods);</span>
			}
<span class="fc" id="L597">			Set&lt;Method&gt; binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">			if (!binderMethods.isEmpty()) {</span>
<span class="nc" id="L599">				this.initBinderAdviceCache.put(adviceBean, binderMethods);</span>
			}
<span class="pc bpc" id="L601" title="1 of 4 branches missed.">			if (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) {</span>
<span class="fc" id="L602">				requestResponseBodyAdviceBeans.add(adviceBean);</span>
			}
<span class="fc" id="L604">		}</span>

<span class="fc bfc" id="L606" title="All 2 branches covered.">		if (!requestResponseBodyAdviceBeans.isEmpty()) {</span>
<span class="fc" id="L607">			this.requestResponseBodyAdvice.addAll(0, requestResponseBodyAdviceBeans);</span>
		}

<span class="pc bpc" id="L610" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L611">			int modelSize = this.modelAttributeAdviceCache.size();</span>
<span class="nc" id="L612">			int binderSize = this.initBinderAdviceCache.size();</span>
<span class="nc" id="L613">			int reqCount = getBodyAdviceCount(RequestBodyAdvice.class);</span>
<span class="nc" id="L614">			int resCount = getBodyAdviceCount(ResponseBodyAdvice.class);</span>
<span class="nc bnc" id="L615" title="All 8 branches missed.">			if (modelSize == 0 &amp;&amp; binderSize == 0 &amp;&amp; reqCount == 0 &amp;&amp; resCount == 0) {</span>
<span class="nc" id="L616">				logger.debug(&quot;ControllerAdvice beans: none&quot;);</span>
			}
			else {
<span class="nc" id="L619">				logger.debug(&quot;ControllerAdvice beans: &quot; + modelSize + &quot; @ModelAttribute, &quot; + binderSize +</span>
						&quot; @InitBinder, &quot; + reqCount + &quot; RequestBodyAdvice, &quot; + resCount + &quot; ResponseBodyAdvice&quot;);
			}
		}
<span class="fc" id="L623">	}</span>

	// Count all advice, including explicit registrations..

	private int getBodyAdviceCount(Class&lt;?&gt; adviceType) {
<span class="nc" id="L628">		List&lt;Object&gt; advice = this.requestResponseBodyAdvice;</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">		return RequestBodyAdvice.class.isAssignableFrom(adviceType) ?</span>
<span class="nc" id="L630">				RequestResponseBodyAdviceChain.getAdviceByType(advice, RequestBodyAdvice.class).size() :</span>
<span class="nc" id="L631">				RequestResponseBodyAdviceChain.getAdviceByType(advice, ResponseBodyAdvice.class).size();</span>
	}

	/**
	 * Return the list of argument resolvers to use including built-in resolvers
	 * and custom resolvers provided via {@link #setCustomArgumentResolvers}.
	 */
	private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() {
<span class="fc" id="L639">		List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList&lt;&gt;();</span>

		// Annotation-based argument resolution
<span class="fc" id="L642">		resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false));</span>
<span class="fc" id="L643">		resolvers.add(new RequestParamMapMethodArgumentResolver());</span>
<span class="fc" id="L644">		resolvers.add(new PathVariableMethodArgumentResolver());</span>
<span class="fc" id="L645">		resolvers.add(new PathVariableMapMethodArgumentResolver());</span>
<span class="fc" id="L646">		resolvers.add(new MatrixVariableMethodArgumentResolver());</span>
<span class="fc" id="L647">		resolvers.add(new MatrixVariableMapMethodArgumentResolver());</span>
<span class="fc" id="L648">		resolvers.add(new ServletModelAttributeMethodProcessor(false));</span>
<span class="fc" id="L649">		resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));</span>
<span class="fc" id="L650">		resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice));</span>
<span class="fc" id="L651">		resolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory()));</span>
<span class="fc" id="L652">		resolvers.add(new RequestHeaderMapMethodArgumentResolver());</span>
<span class="fc" id="L653">		resolvers.add(new ServletCookieValueMethodArgumentResolver(getBeanFactory()));</span>
<span class="fc" id="L654">		resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory()));</span>
<span class="fc" id="L655">		resolvers.add(new SessionAttributeMethodArgumentResolver());</span>
<span class="fc" id="L656">		resolvers.add(new RequestAttributeMethodArgumentResolver());</span>

		// Type-based argument resolution
<span class="fc" id="L659">		resolvers.add(new ServletRequestMethodArgumentResolver());</span>
<span class="fc" id="L660">		resolvers.add(new ServletResponseMethodArgumentResolver());</span>
<span class="fc" id="L661">		resolvers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));</span>
<span class="fc" id="L662">		resolvers.add(new RedirectAttributesMethodArgumentResolver());</span>
<span class="fc" id="L663">		resolvers.add(new ModelMethodProcessor());</span>
<span class="fc" id="L664">		resolvers.add(new MapMethodProcessor());</span>
<span class="fc" id="L665">		resolvers.add(new ErrorsMethodArgumentResolver());</span>
<span class="fc" id="L666">		resolvers.add(new SessionStatusMethodArgumentResolver());</span>
<span class="fc" id="L667">		resolvers.add(new UriComponentsBuilderMethodArgumentResolver());</span>

		// Custom arguments
<span class="fc bfc" id="L670" title="All 2 branches covered.">		if (getCustomArgumentResolvers() != null) {</span>
<span class="fc" id="L671">			resolvers.addAll(getCustomArgumentResolvers());</span>
		}

		// Catch-all
<span class="fc" id="L675">		resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true));</span>
<span class="fc" id="L676">		resolvers.add(new ServletModelAttributeMethodProcessor(true));</span>

<span class="fc" id="L678">		return resolvers;</span>
	}

	/**
	 * Return the list of argument resolvers to use for {@code @InitBinder}
	 * methods including built-in and custom resolvers.
	 */
	private List&lt;HandlerMethodArgumentResolver&gt; getDefaultInitBinderArgumentResolvers() {
<span class="fc" id="L686">		List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList&lt;&gt;();</span>

		// Annotation-based argument resolution
<span class="fc" id="L689">		resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false));</span>
<span class="fc" id="L690">		resolvers.add(new RequestParamMapMethodArgumentResolver());</span>
<span class="fc" id="L691">		resolvers.add(new PathVariableMethodArgumentResolver());</span>
<span class="fc" id="L692">		resolvers.add(new PathVariableMapMethodArgumentResolver());</span>
<span class="fc" id="L693">		resolvers.add(new MatrixVariableMethodArgumentResolver());</span>
<span class="fc" id="L694">		resolvers.add(new MatrixVariableMapMethodArgumentResolver());</span>
<span class="fc" id="L695">		resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory()));</span>
<span class="fc" id="L696">		resolvers.add(new SessionAttributeMethodArgumentResolver());</span>
<span class="fc" id="L697">		resolvers.add(new RequestAttributeMethodArgumentResolver());</span>

		// Type-based argument resolution
<span class="fc" id="L700">		resolvers.add(new ServletRequestMethodArgumentResolver());</span>
<span class="fc" id="L701">		resolvers.add(new ServletResponseMethodArgumentResolver());</span>

		// Custom arguments
<span class="fc bfc" id="L704" title="All 2 branches covered.">		if (getCustomArgumentResolvers() != null) {</span>
<span class="fc" id="L705">			resolvers.addAll(getCustomArgumentResolvers());</span>
		}

		// Catch-all
<span class="fc" id="L709">		resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true));</span>

<span class="fc" id="L711">		return resolvers;</span>
	}

	/**
	 * Return the list of return value handlers to use including built-in and
	 * custom handlers provided via {@link #setReturnValueHandlers}.
	 */
	private List&lt;HandlerMethodReturnValueHandler&gt; getDefaultReturnValueHandlers() {
<span class="fc" id="L719">		List&lt;HandlerMethodReturnValueHandler&gt; handlers = new ArrayList&lt;&gt;();</span>

		// Single-purpose return value types
<span class="fc" id="L722">		handlers.add(new ModelAndViewMethodReturnValueHandler());</span>
<span class="fc" id="L723">		handlers.add(new ModelMethodProcessor());</span>
<span class="fc" id="L724">		handlers.add(new ViewMethodReturnValueHandler());</span>
<span class="fc" id="L725">		handlers.add(new ResponseBodyEmitterReturnValueHandler(getMessageConverters(),</span>
				this.reactiveAdapterRegistry, this.taskExecutor, this.contentNegotiationManager));
<span class="fc" id="L727">		handlers.add(new StreamingResponseBodyReturnValueHandler());</span>
<span class="fc" id="L728">		handlers.add(new HttpEntityMethodProcessor(getMessageConverters(),</span>
				this.contentNegotiationManager, this.requestResponseBodyAdvice));
<span class="fc" id="L730">		handlers.add(new HttpHeadersReturnValueHandler());</span>
<span class="fc" id="L731">		handlers.add(new CallableMethodReturnValueHandler());</span>
<span class="fc" id="L732">		handlers.add(new DeferredResultMethodReturnValueHandler());</span>
<span class="fc" id="L733">		handlers.add(new AsyncTaskMethodReturnValueHandler(this.beanFactory));</span>

		// Annotation-based return value types
<span class="fc" id="L736">		handlers.add(new ModelAttributeMethodProcessor(false));</span>
<span class="fc" id="L737">		handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(),</span>
				this.contentNegotiationManager, this.requestResponseBodyAdvice));

		// Multi-purpose return value types
<span class="fc" id="L741">		handlers.add(new ViewNameMethodReturnValueHandler());</span>
<span class="fc" id="L742">		handlers.add(new MapMethodProcessor());</span>

		// Custom return value types
<span class="fc bfc" id="L745" title="All 2 branches covered.">		if (getCustomReturnValueHandlers() != null) {</span>
<span class="fc" id="L746">			handlers.addAll(getCustomReturnValueHandlers());</span>
		}

		// Catch-all
<span class="fc bfc" id="L750" title="All 2 branches covered.">		if (!CollectionUtils.isEmpty(getModelAndViewResolvers())) {</span>
<span class="fc" id="L751">			handlers.add(new ModelAndViewResolverMethodReturnValueHandler(getModelAndViewResolvers()));</span>
		}
		else {
<span class="fc" id="L754">			handlers.add(new ModelAttributeMethodProcessor(true));</span>
		}

<span class="fc" id="L757">		return handlers;</span>
	}


	/**
	 * Always return {@code true} since any method argument and return value
	 * type will be processed in some way. A method argument not recognized
	 * by any HandlerMethodArgumentResolver is interpreted as a request parameter
	 * if it is a simple type, or as a model attribute otherwise. A return value
	 * not recognized by any HandlerMethodReturnValueHandler will be interpreted
	 * as a model attribute.
	 */
	@Override
	protected boolean supportsInternal(HandlerMethod handlerMethod) {
<span class="fc" id="L771">		return true;</span>
	}

	@Override
	protected ModelAndView handleInternal(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

		ModelAndView mav;
<span class="fc" id="L779">		checkRequest(request);</span>

		// Execute invokeHandlerMethod in synchronized block if required.
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">		if (this.synchronizeOnSession) {</span>
<span class="nc" id="L783">			HttpSession session = request.getSession(false);</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">			if (session != null) {</span>
<span class="nc" id="L785">				Object mutex = WebUtils.getSessionMutex(session);</span>
<span class="nc" id="L786">				synchronized (mutex) {</span>
<span class="nc" id="L787">					mav = invokeHandlerMethod(request, response, handlerMethod);</span>
<span class="nc" id="L788">				}</span>
<span class="nc" id="L789">			}</span>
			else {
				// No HttpSession available -&gt; no mutex necessary
<span class="nc" id="L792">				mav = invokeHandlerMethod(request, response, handlerMethod);</span>
			}
<span class="nc" id="L794">		}</span>
		else {
			// No synchronization on session demanded at all...
<span class="fc" id="L797">			mav = invokeHandlerMethod(request, response, handlerMethod);</span>
		}

<span class="fc bfc" id="L800" title="All 2 branches covered.">		if (!response.containsHeader(HEADER_CACHE_CONTROL)) {</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">			if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {</span>
<span class="fc" id="L802">				applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);</span>
			}
			else {
<span class="fc" id="L805">				prepareResponse(response);</span>
			}
		}

<span class="fc" id="L809">		return mav;</span>
	}

	/**
	 * This implementation always returns -1. An {@code @RequestMapping} method can
	 * calculate the lastModified value, call {@link WebRequest#checkNotModified(long)},
	 * and return {@code null} if the result of that call is {@code true}.
	 */
	@Override
	protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod) {
<span class="fc" id="L819">		return -1;</span>
	}


	/**
	 * Return the {@link SessionAttributesHandler} instance for the given handler type
	 * (never {@code null}).
	 */
	private SessionAttributesHandler getSessionAttributesHandler(HandlerMethod handlerMethod) {
<span class="fc" id="L828">		Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span>
<span class="fc" id="L829">		SessionAttributesHandler sessionAttrHandler = this.sessionAttributesHandlerCache.get(handlerType);</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">		if (sessionAttrHandler == null) {</span>
<span class="fc" id="L831">			synchronized (this.sessionAttributesHandlerCache) {</span>
<span class="fc" id="L832">				sessionAttrHandler = this.sessionAttributesHandlerCache.get(handlerType);</span>
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">				if (sessionAttrHandler == null) {</span>
<span class="fc" id="L834">					sessionAttrHandler = new SessionAttributesHandler(handlerType, this.sessionAttributeStore);</span>
<span class="fc" id="L835">					this.sessionAttributesHandlerCache.put(handlerType, sessionAttrHandler);</span>
				}
<span class="fc" id="L837">			}</span>
		}
<span class="fc" id="L839">		return sessionAttrHandler;</span>
	}

	/**
	 * Invoke the {@link RequestMapping} handler method preparing a {@link ModelAndView}
	 * if view resolution is required.
	 * @since 4.2
	 * @see #createInvocableHandlerMethod(HandlerMethod)
	 */
	@Nullable
	protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

<span class="fc" id="L852">		ServletWebRequest webRequest = new ServletWebRequest(request, response);</span>
		try {
<span class="fc" id="L854">			WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span>
<span class="fc" id="L855">			ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span>

<span class="fc" id="L857">			ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span>
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">			if (this.argumentResolvers != null) {</span>
<span class="fc" id="L859">				invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);</span>
			}
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">			if (this.returnValueHandlers != null) {</span>
<span class="fc" id="L862">				invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);</span>
			}
<span class="fc" id="L864">			invocableMethod.setDataBinderFactory(binderFactory);</span>
<span class="fc" id="L865">			invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);</span>

<span class="fc" id="L867">			ModelAndViewContainer mavContainer = new ModelAndViewContainer();</span>
<span class="fc" id="L868">			mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span>
<span class="fc" id="L869">			modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span>
<span class="fc" id="L870">			mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</span>

<span class="fc" id="L872">			AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span>
<span class="fc" id="L873">			asyncWebRequest.setTimeout(this.asyncRequestTimeout);</span>

<span class="fc" id="L875">			WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span>
<span class="fc" id="L876">			asyncManager.setTaskExecutor(this.taskExecutor);</span>
<span class="fc" id="L877">			asyncManager.setAsyncWebRequest(asyncWebRequest);</span>
<span class="fc" id="L878">			asyncManager.registerCallableInterceptors(this.callableInterceptors);</span>
<span class="fc" id="L879">			asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</span>

<span class="pc bpc" id="L881" title="1 of 2 branches missed.">			if (asyncManager.hasConcurrentResult()) {</span>
<span class="nc" id="L882">				Object result = asyncManager.getConcurrentResult();</span>
<span class="nc" id="L883">				mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];</span>
<span class="nc" id="L884">				asyncManager.clearConcurrentResult();</span>
<span class="nc" id="L885">				LogFormatUtils.traceDebug(logger, traceOn -&gt; {</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">					String formatted = LogFormatUtils.formatValue(result, !traceOn);</span>
<span class="nc" id="L887">					return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;;</span>
				});
<span class="nc" id="L889">				invocableMethod = invocableMethod.wrapConcurrentResult(result);</span>
			}

<span class="fc" id="L892">			invocableMethod.invokeAndHandle(webRequest, mavContainer);</span>
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">			if (asyncManager.isConcurrentHandlingStarted()) {</span>
<span class="nc" id="L894">				return null;</span>
			}

<span class="fc" id="L897">			return getModelAndView(mavContainer, modelFactory, webRequest);</span>
		}
		finally {
<span class="fc" id="L900">			webRequest.requestCompleted();</span>
		}
	}

	/**
	 * Create a {@link ServletInvocableHandlerMethod} from the given {@link HandlerMethod} definition.
	 * @param handlerMethod the {@link HandlerMethod} definition
	 * @return the corresponding {@link ServletInvocableHandlerMethod} (or custom subclass thereof)
	 * @since 4.2
	 */
	protected ServletInvocableHandlerMethod createInvocableHandlerMethod(HandlerMethod handlerMethod) {
<span class="fc" id="L911">		return new ServletInvocableHandlerMethod(handlerMethod);</span>
	}

	private ModelFactory getModelFactory(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) {
<span class="fc" id="L915">		SessionAttributesHandler sessionAttrHandler = getSessionAttributesHandler(handlerMethod);</span>
<span class="fc" id="L916">		Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span>
<span class="fc" id="L917">		Set&lt;Method&gt; methods = this.modelAttributeCache.get(handlerType);</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">		if (methods == null) {</span>
<span class="fc" id="L919">			methods = MethodIntrospector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);</span>
<span class="fc" id="L920">			this.modelAttributeCache.put(handlerType, methods);</span>
		}
<span class="fc" id="L922">		List&lt;InvocableHandlerMethod&gt; attrMethods = new ArrayList&lt;&gt;();</span>
		// Global methods first
<span class="fc" id="L924">		this.modelAttributeAdviceCache.forEach((clazz, methodSet) -&gt; {</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">			if (clazz.isApplicableToBeanType(handlerType)) {</span>
<span class="fc" id="L926">				Object bean = clazz.resolveBean();</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">				for (Method method : methodSet) {</span>
<span class="fc" id="L928">					attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</span>
<span class="fc" id="L929">				}</span>
			}
<span class="fc" id="L931">		});</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">		for (Method method : methods) {</span>
<span class="fc" id="L933">			Object bean = handlerMethod.getBean();</span>
<span class="fc" id="L934">			attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</span>
<span class="fc" id="L935">		}</span>
<span class="fc" id="L936">		return new ModelFactory(attrMethods, binderFactory, sessionAttrHandler);</span>
	}

	private InvocableHandlerMethod createModelAttributeMethod(WebDataBinderFactory factory, Object bean, Method method) {
<span class="fc" id="L940">		InvocableHandlerMethod attrMethod = new InvocableHandlerMethod(bean, method);</span>
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">		if (this.argumentResolvers != null) {</span>
<span class="fc" id="L942">			attrMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);</span>
		}
<span class="fc" id="L944">		attrMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);</span>
<span class="fc" id="L945">		attrMethod.setDataBinderFactory(factory);</span>
<span class="fc" id="L946">		return attrMethod;</span>
	}

	private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) throws Exception {
<span class="fc" id="L950">		Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span>
<span class="fc" id="L951">		Set&lt;Method&gt; methods = this.initBinderCache.get(handlerType);</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">		if (methods == null) {</span>
<span class="fc" id="L953">			methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS);</span>
<span class="fc" id="L954">			this.initBinderCache.put(handlerType, methods);</span>
		}
<span class="fc" id="L956">		List&lt;InvocableHandlerMethod&gt; initBinderMethods = new ArrayList&lt;&gt;();</span>
		// Global methods first
<span class="fc" id="L958">		this.initBinderAdviceCache.forEach((clazz, methodSet) -&gt; {</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">			if (clazz.isApplicableToBeanType(handlerType)) {</span>
<span class="nc" id="L960">				Object bean = clazz.resolveBean();</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">				for (Method method : methodSet) {</span>
<span class="nc" id="L962">					initBinderMethods.add(createInitBinderMethod(bean, method));</span>
<span class="nc" id="L963">				}</span>
			}
<span class="nc" id="L965">		});</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">		for (Method method : methods) {</span>
<span class="fc" id="L967">			Object bean = handlerMethod.getBean();</span>
<span class="fc" id="L968">			initBinderMethods.add(createInitBinderMethod(bean, method));</span>
<span class="fc" id="L969">		}</span>
<span class="fc" id="L970">		return createDataBinderFactory(initBinderMethods);</span>
	}

	private InvocableHandlerMethod createInitBinderMethod(Object bean, Method method) {
<span class="fc" id="L974">		InvocableHandlerMethod binderMethod = new InvocableHandlerMethod(bean, method);</span>
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">		if (this.initBinderArgumentResolvers != null) {</span>
<span class="fc" id="L976">			binderMethod.setHandlerMethodArgumentResolvers(this.initBinderArgumentResolvers);</span>
		}
<span class="fc" id="L978">		binderMethod.setDataBinderFactory(new DefaultDataBinderFactory(this.webBindingInitializer));</span>
<span class="fc" id="L979">		binderMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);</span>
<span class="fc" id="L980">		return binderMethod;</span>
	}

	/**
	 * Template method to create a new InitBinderDataBinderFactory instance.
	 * &lt;p&gt;The default implementation creates a ServletRequestDataBinderFactory.
	 * This can be overridden for custom ServletRequestDataBinder subclasses.
	 * @param binderMethods {@code @InitBinder} methods
	 * @return the InitBinderDataBinderFactory instance to use
	 * @throws Exception in case of invalid state or arguments
	 */
	protected InitBinderDataBinderFactory createDataBinderFactory(List&lt;InvocableHandlerMethod&gt; binderMethods)
			throws Exception {

<span class="fc" id="L994">		return new ServletRequestDataBinderFactory(binderMethods, getWebBindingInitializer());</span>
	}

	@Nullable
	private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,
			ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception {

<span class="fc" id="L1001">		modelFactory.updateModel(webRequest, mavContainer);</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">		if (mavContainer.isRequestHandled()) {</span>
<span class="fc" id="L1003">			return null;</span>
		}
<span class="fc" id="L1005">		ModelMap model = mavContainer.getModel();</span>
<span class="fc" id="L1006">		ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">		if (!mavContainer.isViewReference()) {</span>
<span class="fc" id="L1008">			mav.setView((View) mavContainer.getView());</span>
		}
<span class="fc bfc" id="L1010" title="All 2 branches covered.">		if (model instanceof RedirectAttributes) {</span>
<span class="fc" id="L1011">			Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span>
<span class="fc" id="L1012">			HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span>
<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">			if (request != null) {</span>
<span class="fc" id="L1014">				RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span>
			}
		}
<span class="fc" id="L1017">		return mav;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>