<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MessageBrokerBeanDefinitionParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-websocket</a> &gt; <a href="index.source.html" class="el_package">org.springframework.web.socket.config</a> &gt; <span class="el_source">MessageBrokerBeanDefinitionParser.java</span></div><h1>MessageBrokerBeanDefinitionParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.socket.config;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import org.w3c.dom.Element;

import org.springframework.beans.MutablePropertyValues;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.ConstructorArgumentValues;
import org.springframework.beans.factory.config.CustomScopeConfigurer;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.parsing.BeanComponentDefinition;
import org.springframework.beans.factory.parsing.CompositeComponentDefinition;
import org.springframework.beans.factory.support.GenericBeanDefinition;
import org.springframework.beans.factory.support.ManagedList;
import org.springframework.beans.factory.support.ManagedMap;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.beans.factory.xml.BeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean;
import org.springframework.lang.Nullable;
import org.springframework.messaging.converter.ByteArrayMessageConverter;
import org.springframework.messaging.converter.CompositeMessageConverter;
import org.springframework.messaging.converter.DefaultContentTypeResolver;
import org.springframework.messaging.converter.MappingJackson2MessageConverter;
import org.springframework.messaging.converter.StringMessageConverter;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.messaging.simp.SimpSessionScope;
import org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler;
import org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler;
import org.springframework.messaging.simp.user.DefaultUserDestinationResolver;
import org.springframework.messaging.simp.user.MultiServerUserRegistry;
import org.springframework.messaging.simp.user.UserDestinationMessageHandler;
import org.springframework.messaging.simp.user.UserRegistryMessageHandler;
import org.springframework.messaging.support.ExecutorSubscribableChannel;
import org.springframework.messaging.support.ImmutableMessageChannelInterceptor;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.MimeTypeUtils;
import org.springframework.util.StringUtils;
import org.springframework.util.xml.DomUtils;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.handler.WebSocketHandlerDecoratorFactory;
import org.springframework.web.socket.messaging.DefaultSimpUserRegistry;
import org.springframework.web.socket.messaging.StompSubProtocolHandler;
import org.springframework.web.socket.messaging.SubProtocolWebSocketHandler;
import org.springframework.web.socket.messaging.WebSocketAnnotationMethodMessageHandler;
import org.springframework.web.socket.server.support.OriginHandshakeInterceptor;
import org.springframework.web.socket.server.support.WebSocketHandlerMapping;
import org.springframework.web.socket.server.support.WebSocketHttpRequestHandler;
import org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler;

/**
 * A {@link org.springframework.beans.factory.xml.BeanDefinitionParser} that provides
 * the configuration for the {@code &lt;websocket:message-broker/&gt;} XML namespace element.
 *
 * &lt;p&gt;Registers a Spring MVC {@link org.springframework.web.servlet.HandlerMapping}
 * with order 1 to map HTTP WebSocket handshake requests from STOMP/WebSocket clients.
 *
 * &lt;p&gt;Registers the following {@link org.springframework.messaging.MessageChannel MessageChannels}:
 * &lt;ul&gt;
 * &lt;li&gt;&quot;clientInboundChannel&quot; for receiving messages from clients (e.g. WebSocket clients)
 * &lt;li&gt;&quot;clientOutboundChannel&quot; for sending messages to clients (e.g. WebSocket clients)
 * &lt;li&gt;&quot;brokerChannel&quot; for sending messages from within the application to the message broker
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Registers one of the following based on the selected message broker options:
 * &lt;ul&gt;
 * &lt;li&gt;a {@link SimpleBrokerMessageHandler} if the &lt;simple-broker/&gt; is used
 * &lt;li&gt;a {@link StompBrokerRelayMessageHandler} if the &lt;stomp-broker-relay/&gt; is used
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Registers a {@link UserDestinationMessageHandler} for handling user destinations.
 *
 * @author Brian Clozel
 * @author Rossen Stoyanchev
 * @since 4.0
 */
<span class="fc" id="L100">class MessageBrokerBeanDefinitionParser implements BeanDefinitionParser {</span>

	public static final String WEB_SOCKET_HANDLER_BEAN_NAME = &quot;subProtocolWebSocketHandler&quot;;

	public static final String SCHEDULER_BEAN_NAME = &quot;messageBrokerScheduler&quot;;

	public static final String SOCKJS_SCHEDULER_BEAN_NAME = &quot;messageBrokerSockJsScheduler&quot;;

	public static final String MESSAGING_TEMPLATE_BEAN_NAME = &quot;brokerMessagingTemplate&quot;;

	public static final String MESSAGE_CONVERTER_BEAN_NAME = &quot;brokerMessageConverter&quot;;

	private static final int DEFAULT_MAPPING_ORDER = 1;

	private static final boolean jackson2Present;

	private static final boolean javaxValidationPresent;

	static {
<span class="fc" id="L119">		ClassLoader classLoader = MessageBrokerBeanDefinitionParser.class.getClassLoader();</span>
<span class="fc" id="L120">		jackson2Present = ClassUtils.isPresent(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;, classLoader);</span>
<span class="fc" id="L121">		javaxValidationPresent = ClassUtils.isPresent(&quot;javax.validation.Validator&quot;, classLoader);</span>
<span class="fc" id="L122">	}</span>


	@Override
	public BeanDefinition parse(Element element, ParserContext context) {
<span class="fc" id="L127">		Object source = context.extractSource(element);</span>
<span class="fc" id="L128">		CompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), source);</span>
<span class="fc" id="L129">		context.pushContainingComponent(compDefinition);</span>

<span class="fc" id="L131">		Element channelElem = DomUtils.getChildElementByTagName(element, &quot;client-inbound-channel&quot;);</span>
<span class="fc" id="L132">		RuntimeBeanReference inChannel = getMessageChannel(&quot;clientInboundChannel&quot;, channelElem, context, source);</span>

<span class="fc" id="L134">		channelElem = DomUtils.getChildElementByTagName(element, &quot;client-outbound-channel&quot;);</span>
<span class="fc" id="L135">		RuntimeBeanReference outChannel = getMessageChannel(&quot;clientOutboundChannel&quot;, channelElem, context, source);</span>

<span class="fc" id="L137">		channelElem = DomUtils.getChildElementByTagName(element, &quot;broker-channel&quot;);</span>
<span class="fc" id="L138">		RuntimeBeanReference brokerChannel = getMessageChannel(&quot;brokerChannel&quot;, channelElem, context, source);</span>

<span class="fc" id="L140">		RuntimeBeanReference userRegistry = registerUserRegistry(element, context, source);</span>
<span class="fc" id="L141">		Object userDestHandler = registerUserDestHandler(element, userRegistry, inChannel, brokerChannel, context, source);</span>

<span class="fc" id="L143">		RuntimeBeanReference converter = registerMessageConverter(element, context, source);</span>
<span class="fc" id="L144">		RuntimeBeanReference template = registerMessagingTemplate(element, brokerChannel, converter, context, source);</span>
<span class="fc" id="L145">		registerAnnotationMethodMessageHandler(element, inChannel, outChannel,converter, template, context, source);</span>

<span class="fc" id="L147">		RootBeanDefinition broker = registerMessageBroker(element, inChannel, outChannel, brokerChannel,</span>
				userDestHandler, template, userRegistry, context, source);

		// WebSocket and sub-protocol handling

<span class="fc" id="L152">		ManagedMap&lt;String, Object&gt; urlMap = registerHandlerMapping(element, context, source);</span>
<span class="fc" id="L153">		RuntimeBeanReference stompHandler = registerStompHandler(element, inChannel, outChannel, context, source);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">		for (Element endpointElem : DomUtils.getChildElementsByTagName(element, &quot;stomp-endpoint&quot;)) {</span>
<span class="fc" id="L155">			RuntimeBeanReference requestHandler = registerRequestHandler(endpointElem, stompHandler, context, source);</span>
<span class="fc" id="L156">			String pathAttribute = endpointElem.getAttribute(&quot;path&quot;);</span>
<span class="fc" id="L157">			Assert.hasText(pathAttribute, &quot;Invalid &lt;stomp-endpoint&gt; (no path mapping)&quot;);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">			for (String path : StringUtils.tokenizeToStringArray(pathAttribute, &quot;,&quot;)) {</span>
<span class="fc" id="L159">				path = path.trim();</span>
<span class="pc" id="L160">				Assert.hasText(path, () -&gt; &quot;Invalid &lt;stomp-endpoint&gt; path attribute: &quot; + pathAttribute);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">				if (DomUtils.getChildElementByTagName(endpointElem, &quot;sockjs&quot;) != null) {</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">					path = (path.endsWith(&quot;/&quot;) ? path + &quot;**&quot; : path + &quot;/**&quot;);</span>
				}
<span class="fc" id="L164">				urlMap.put(path, requestHandler);</span>
			}
<span class="fc" id="L166">		}</span>

<span class="fc" id="L168">		Map&lt;String, Object&gt; scopeMap = Collections.singletonMap(&quot;websocket&quot;, new SimpSessionScope());</span>
<span class="fc" id="L169">		RootBeanDefinition scopeConfigurer = new RootBeanDefinition(CustomScopeConfigurer.class);</span>
<span class="fc" id="L170">		scopeConfigurer.getPropertyValues().add(&quot;scopes&quot;, scopeMap);</span>
<span class="fc" id="L171">		registerBeanDefByName(&quot;webSocketScopeConfigurer&quot;, scopeConfigurer, context, source);</span>

<span class="fc" id="L173">		registerWebSocketMessageBrokerStats(broker, inChannel, outChannel, context, source);</span>

<span class="fc" id="L175">		context.popAndRegisterContainingComponent();</span>
<span class="fc" id="L176">		return null;</span>
	}

	private RuntimeBeanReference registerUserRegistry(Element element, ParserContext context, @Nullable Object source) {
<span class="fc" id="L180">		Element relayElement = DomUtils.getChildElementByTagName(element, &quot;stomp-broker-relay&quot;);</span>
<span class="pc bpc" id="L181" title="1 of 4 branches missed.">		boolean multiServer = (relayElement != null &amp;&amp; relayElement.hasAttribute(&quot;user-registry-broadcast&quot;));</span>

<span class="fc bfc" id="L183" title="All 2 branches covered.">		if (multiServer) {</span>
<span class="fc" id="L184">			RootBeanDefinition localRegistryBeanDef = new RootBeanDefinition(DefaultSimpUserRegistry.class);</span>
<span class="fc" id="L185">			RootBeanDefinition beanDef = new RootBeanDefinition(MultiServerUserRegistry.class);</span>
<span class="fc" id="L186">			beanDef.getConstructorArgumentValues().addIndexedArgumentValue(0, localRegistryBeanDef);</span>
<span class="fc" id="L187">			String beanName = registerBeanDef(beanDef, context, source);</span>
<span class="fc" id="L188">			return new RuntimeBeanReference(beanName);</span>
		}
		else {
<span class="fc" id="L191">			RootBeanDefinition beanDef = new RootBeanDefinition(DefaultSimpUserRegistry.class);</span>
<span class="fc" id="L192">			String beanName = registerBeanDef(beanDef, context, source);</span>
<span class="fc" id="L193">			return new RuntimeBeanReference(beanName);</span>
		}
	}

	private ManagedMap&lt;String, Object&gt; registerHandlerMapping(
			Element element, ParserContext context, @Nullable Object source) {

<span class="fc" id="L200">		RootBeanDefinition handlerMappingDef = new RootBeanDefinition(WebSocketHandlerMapping.class);</span>

<span class="fc" id="L202">		String orderAttribute = element.getAttribute(&quot;order&quot;);</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">		int order = orderAttribute.isEmpty() ? DEFAULT_MAPPING_ORDER : Integer.valueOf(orderAttribute);</span>
<span class="fc" id="L204">		handlerMappingDef.getPropertyValues().add(&quot;order&quot;, order);</span>

<span class="fc" id="L206">		String pathHelper = element.getAttribute(&quot;path-helper&quot;);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">		if (StringUtils.hasText(pathHelper)) {</span>
<span class="fc" id="L208">			handlerMappingDef.getPropertyValues().add(&quot;urlPathHelper&quot;, new RuntimeBeanReference(pathHelper));</span>
		}

<span class="fc" id="L211">		ManagedMap&lt;String, Object&gt; urlMap = new ManagedMap&lt;&gt;();</span>
<span class="fc" id="L212">		urlMap.setSource(source);</span>
<span class="fc" id="L213">		handlerMappingDef.getPropertyValues().add(&quot;urlMap&quot;, urlMap);</span>

<span class="fc" id="L215">		registerBeanDef(handlerMappingDef, context, source);</span>
<span class="fc" id="L216">		return urlMap;</span>
	}

	private RuntimeBeanReference getMessageChannel(
			String name, @Nullable Element element, ParserContext context, @Nullable Object source) {

		RootBeanDefinition executor;
<span class="fc bfc" id="L223" title="All 2 branches covered.">		if (element == null) {</span>
<span class="fc" id="L224">			executor = getDefaultExecutorBeanDefinition(name);</span>
		}
		else {
<span class="fc" id="L227">			Element executorElem = DomUtils.getChildElementByTagName(element, &quot;executor&quot;);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">			if (executorElem == null) {</span>
<span class="fc" id="L229">				executor = getDefaultExecutorBeanDefinition(name);</span>
			}
			else {
<span class="fc" id="L232">				executor = new RootBeanDefinition(ThreadPoolTaskExecutor.class);</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">				if (executorElem.hasAttribute(&quot;core-pool-size&quot;)) {</span>
<span class="fc" id="L234">					executor.getPropertyValues().add(&quot;corePoolSize&quot;, executorElem.getAttribute(&quot;core-pool-size&quot;));</span>
				}
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">				if (executorElem.hasAttribute(&quot;max-pool-size&quot;)) {</span>
<span class="fc" id="L237">					executor.getPropertyValues().add(&quot;maxPoolSize&quot;, executorElem.getAttribute(&quot;max-pool-size&quot;));</span>
				}
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">				if (executorElem.hasAttribute(&quot;keep-alive-seconds&quot;)) {</span>
<span class="fc" id="L240">					executor.getPropertyValues().add(&quot;keepAliveSeconds&quot;, executorElem.getAttribute(&quot;keep-alive-seconds&quot;));</span>
				}
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">				if (executorElem.hasAttribute(&quot;queue-capacity&quot;)) {</span>
<span class="nc" id="L243">					executor.getPropertyValues().add(&quot;queueCapacity&quot;, executorElem.getAttribute(&quot;queue-capacity&quot;));</span>
				}
			}
		}

<span class="fc" id="L248">		ConstructorArgumentValues cargs = new ConstructorArgumentValues();</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">		if (executor != null) {</span>
<span class="fc" id="L250">			executor.getPropertyValues().add(&quot;threadNamePrefix&quot;, name + &quot;-&quot;);</span>
<span class="fc" id="L251">			String executorName = name + &quot;Executor&quot;;</span>
<span class="fc" id="L252">			registerBeanDefByName(executorName, executor, context, source);</span>
<span class="fc" id="L253">			cargs.addIndexedArgumentValue(0, new RuntimeBeanReference(executorName));</span>
		}

<span class="fc" id="L256">		RootBeanDefinition channelDef = new RootBeanDefinition(ExecutorSubscribableChannel.class, cargs, null);</span>
<span class="fc" id="L257">		ManagedList&lt;Object&gt; interceptors = new ManagedList&lt;&gt;();</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">		if (element != null) {</span>
<span class="fc" id="L259">			Element interceptorsElement = DomUtils.getChildElementByTagName(element, &quot;interceptors&quot;);</span>
<span class="fc" id="L260">			interceptors.addAll(WebSocketNamespaceUtils.parseBeanSubElements(interceptorsElement, context));</span>
		}
<span class="fc" id="L262">		interceptors.add(new ImmutableMessageChannelInterceptor());</span>
<span class="fc" id="L263">		channelDef.getPropertyValues().add(&quot;interceptors&quot;, interceptors);</span>

<span class="fc" id="L265">		registerBeanDefByName(name, channelDef, context, source);</span>
<span class="fc" id="L266">		return new RuntimeBeanReference(name);</span>
	}

	@Nullable
	private RootBeanDefinition getDefaultExecutorBeanDefinition(String channelName) {
<span class="fc bfc" id="L271" title="All 2 branches covered.">		if (channelName.equals(&quot;brokerChannel&quot;)) {</span>
<span class="fc" id="L272">			return null;</span>
		}
<span class="fc" id="L274">		RootBeanDefinition executorDef = new RootBeanDefinition(ThreadPoolTaskExecutor.class);</span>
<span class="fc" id="L275">		executorDef.getPropertyValues().add(&quot;corePoolSize&quot;, Runtime.getRuntime().availableProcessors() * 2);</span>
<span class="fc" id="L276">		executorDef.getPropertyValues().add(&quot;maxPoolSize&quot;, Integer.MAX_VALUE);</span>
<span class="fc" id="L277">		executorDef.getPropertyValues().add(&quot;queueCapacity&quot;, Integer.MAX_VALUE);</span>
<span class="fc" id="L278">		executorDef.getPropertyValues().add(&quot;allowCoreThreadTimeOut&quot;, true);</span>
<span class="fc" id="L279">		return executorDef;</span>
	}

	private RuntimeBeanReference registerStompHandler(Element element, RuntimeBeanReference inChannel,
			RuntimeBeanReference outChannel, ParserContext context, @Nullable Object source) {

<span class="fc" id="L285">		RootBeanDefinition stompHandlerDef = new RootBeanDefinition(StompSubProtocolHandler.class);</span>
<span class="fc" id="L286">		registerBeanDef(stompHandlerDef, context, source);</span>

<span class="fc" id="L288">		Element errorHandlerElem = DomUtils.getChildElementByTagName(element, &quot;stomp-error-handler&quot;);</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">		if (errorHandlerElem != null) {</span>
<span class="fc" id="L290">			RuntimeBeanReference errorHandlerRef = new RuntimeBeanReference(errorHandlerElem.getAttribute(&quot;ref&quot;));</span>
<span class="fc" id="L291">			stompHandlerDef.getPropertyValues().add(&quot;errorHandler&quot;, errorHandlerRef);</span>
		}

<span class="fc" id="L294">		ConstructorArgumentValues cargs = new ConstructorArgumentValues();</span>
<span class="fc" id="L295">		cargs.addIndexedArgumentValue(0, inChannel);</span>
<span class="fc" id="L296">		cargs.addIndexedArgumentValue(1, outChannel);</span>

<span class="fc" id="L298">		RootBeanDefinition handlerDef = new RootBeanDefinition(SubProtocolWebSocketHandler.class, cargs, null);</span>
<span class="fc" id="L299">		handlerDef.getPropertyValues().addPropertyValue(&quot;protocolHandlers&quot;, stompHandlerDef);</span>
<span class="fc" id="L300">		registerBeanDefByName(WEB_SOCKET_HANDLER_BEAN_NAME, handlerDef, context, source);</span>
<span class="fc" id="L301">		RuntimeBeanReference result = new RuntimeBeanReference(WEB_SOCKET_HANDLER_BEAN_NAME);</span>

<span class="fc" id="L303">		Element transportElem = DomUtils.getChildElementByTagName(element, &quot;transport&quot;);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">		if (transportElem != null) {</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">			if (transportElem.hasAttribute(&quot;message-size&quot;)) {</span>
<span class="fc" id="L306">				stompHandlerDef.getPropertyValues().add(&quot;messageSizeLimit&quot;, transportElem.getAttribute(&quot;message-size&quot;));</span>
			}
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">			if (transportElem.hasAttribute(&quot;send-timeout&quot;)) {</span>
<span class="fc" id="L309">				handlerDef.getPropertyValues().add(&quot;sendTimeLimit&quot;, transportElem.getAttribute(&quot;send-timeout&quot;));</span>
			}
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">			if (transportElem.hasAttribute(&quot;send-buffer-size&quot;)) {</span>
<span class="fc" id="L312">				handlerDef.getPropertyValues().add(&quot;sendBufferSizeLimit&quot;, transportElem.getAttribute(&quot;send-buffer-size&quot;));</span>
			}
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">			if (transportElem.hasAttribute(&quot;time-to-first-message&quot;)) {</span>
<span class="fc" id="L315">				handlerDef.getPropertyValues().add(&quot;timeToFirstMessage&quot;, transportElem.getAttribute(&quot;time-to-first-message&quot;));</span>
			}
<span class="fc" id="L317">			Element factoriesElement = DomUtils.getChildElementByTagName(transportElem, &quot;decorator-factories&quot;);</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">			if (factoriesElement != null) {</span>
<span class="fc" id="L319">				ManagedList&lt;Object&gt; factories = extractBeanSubElements(factoriesElement, context);</span>
<span class="fc" id="L320">				RootBeanDefinition factoryBean = new RootBeanDefinition(DecoratingFactoryBean.class);</span>
<span class="fc" id="L321">				factoryBean.getConstructorArgumentValues().addIndexedArgumentValue(0, result);</span>
<span class="fc" id="L322">				factoryBean.getConstructorArgumentValues().addIndexedArgumentValue(1, factories);</span>
<span class="fc" id="L323">				result = new RuntimeBeanReference(registerBeanDef(factoryBean, context, source));</span>
			}
		}
<span class="fc" id="L326">		return result;</span>
	}

	private RuntimeBeanReference registerRequestHandler(
			Element element, RuntimeBeanReference subProtoHandler, ParserContext ctx, @Nullable Object source) {

		RootBeanDefinition beanDef;

<span class="fc" id="L334">		RuntimeBeanReference sockJsService = WebSocketNamespaceUtils.registerSockJsService(</span>
				element, SCHEDULER_BEAN_NAME, ctx, source);

<span class="fc bfc" id="L337" title="All 2 branches covered.">		if (sockJsService != null) {</span>
<span class="fc" id="L338">			ConstructorArgumentValues cargs = new ConstructorArgumentValues();</span>
<span class="fc" id="L339">			cargs.addIndexedArgumentValue(0, sockJsService);</span>
<span class="fc" id="L340">			cargs.addIndexedArgumentValue(1, subProtoHandler);</span>
<span class="fc" id="L341">			beanDef = new RootBeanDefinition(SockJsHttpRequestHandler.class, cargs, null);</span>

			// Register alias for backwards compatibility with 4.1
<span class="fc" id="L344">			ctx.getRegistry().registerAlias(SCHEDULER_BEAN_NAME, SOCKJS_SCHEDULER_BEAN_NAME);</span>
<span class="fc" id="L345">		}</span>
		else {
<span class="fc" id="L347">			RuntimeBeanReference handler = WebSocketNamespaceUtils.registerHandshakeHandler(element, ctx, source);</span>
<span class="fc" id="L348">			Element interceptElem = DomUtils.getChildElementByTagName(element, &quot;handshake-interceptors&quot;);</span>
<span class="fc" id="L349">			ManagedList&lt;Object&gt; interceptors = WebSocketNamespaceUtils.parseBeanSubElements(interceptElem, ctx);</span>
<span class="fc" id="L350">			String allowedOrigins = element.getAttribute(&quot;allowed-origins&quot;);</span>
<span class="fc" id="L351">			List&lt;String&gt; origins = Arrays.asList(StringUtils.tokenizeToStringArray(allowedOrigins, &quot;,&quot;));</span>
<span class="fc" id="L352">			interceptors.add(new OriginHandshakeInterceptor(origins));</span>
<span class="fc" id="L353">			ConstructorArgumentValues cargs = new ConstructorArgumentValues();</span>
<span class="fc" id="L354">			cargs.addIndexedArgumentValue(0, subProtoHandler);</span>
<span class="fc" id="L355">			cargs.addIndexedArgumentValue(1, handler);</span>
<span class="fc" id="L356">			beanDef = new RootBeanDefinition(WebSocketHttpRequestHandler.class, cargs, null);</span>
<span class="fc" id="L357">			beanDef.getPropertyValues().add(&quot;handshakeInterceptors&quot;, interceptors);</span>
		}
<span class="fc" id="L359">		return new RuntimeBeanReference(registerBeanDef(beanDef, ctx, source));</span>
	}

	private RootBeanDefinition registerMessageBroker(Element brokerElement,
			RuntimeBeanReference inChannel, RuntimeBeanReference outChannel, RuntimeBeanReference brokerChannel,
			Object userDestHandler, RuntimeBeanReference brokerTemplate, RuntimeBeanReference userRegistry,
			ParserContext context, @Nullable Object source) {

<span class="fc" id="L367">		Element simpleBrokerElem = DomUtils.getChildElementByTagName(brokerElement, &quot;simple-broker&quot;);</span>
<span class="fc" id="L368">		Element brokerRelayElem = DomUtils.getChildElementByTagName(brokerElement, &quot;stomp-broker-relay&quot;);</span>

<span class="fc" id="L370">		ConstructorArgumentValues cargs = new ConstructorArgumentValues();</span>
<span class="fc" id="L371">		cargs.addIndexedArgumentValue(0, inChannel);</span>
<span class="fc" id="L372">		cargs.addIndexedArgumentValue(1, outChannel);</span>
<span class="fc" id="L373">		cargs.addIndexedArgumentValue(2, brokerChannel);</span>

		RootBeanDefinition brokerDef;
<span class="fc bfc" id="L376" title="All 2 branches covered.">		if (simpleBrokerElem != null) {</span>
<span class="fc" id="L377">			String prefix = simpleBrokerElem.getAttribute(&quot;prefix&quot;);</span>
<span class="fc" id="L378">			cargs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, &quot;,&quot;)));</span>
<span class="fc" id="L379">			brokerDef = new RootBeanDefinition(SimpleBrokerMessageHandler.class, cargs, null);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">			if (brokerElement.hasAttribute(&quot;path-matcher&quot;)) {</span>
<span class="fc" id="L381">				String pathMatcherRef = brokerElement.getAttribute(&quot;path-matcher&quot;);</span>
<span class="fc" id="L382">				brokerDef.getPropertyValues().add(&quot;pathMatcher&quot;, new RuntimeBeanReference(pathMatcherRef));</span>
			}
<span class="fc bfc" id="L384" title="All 2 branches covered.">			if (simpleBrokerElem.hasAttribute(&quot;scheduler&quot;)) {</span>
<span class="fc" id="L385">				String scheduler = simpleBrokerElem.getAttribute(&quot;scheduler&quot;);</span>
<span class="fc" id="L386">				brokerDef.getPropertyValues().add(&quot;taskScheduler&quot;, new RuntimeBeanReference(scheduler));</span>
			}
<span class="fc bfc" id="L388" title="All 2 branches covered.">			if (simpleBrokerElem.hasAttribute(&quot;heartbeat&quot;)) {</span>
<span class="fc" id="L389">				String heartbeatValue = simpleBrokerElem.getAttribute(&quot;heartbeat&quot;);</span>
<span class="fc" id="L390">				brokerDef.getPropertyValues().add(&quot;heartbeatValue&quot;, heartbeatValue);</span>
			}
<span class="fc bfc" id="L392" title="All 2 branches covered.">			if (simpleBrokerElem.hasAttribute(&quot;selector-header&quot;)) {</span>
<span class="fc" id="L393">				String headerName = simpleBrokerElem.getAttribute(&quot;selector-header&quot;);</span>
<span class="fc" id="L394">				brokerDef.getPropertyValues().add(&quot;selectorHeaderName&quot;, headerName);</span>
			}
<span class="fc" id="L396">		}</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">		else if (brokerRelayElem != null) {</span>
<span class="fc" id="L398">			String prefix = brokerRelayElem.getAttribute(&quot;prefix&quot;);</span>
<span class="fc" id="L399">			cargs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, &quot;,&quot;)));</span>

<span class="fc" id="L401">			MutablePropertyValues values = new MutablePropertyValues();</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">			if (brokerRelayElem.hasAttribute(&quot;relay-host&quot;)) {</span>
<span class="fc" id="L403">				values.add(&quot;relayHost&quot;, brokerRelayElem.getAttribute(&quot;relay-host&quot;));</span>
			}
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">			if (brokerRelayElem.hasAttribute(&quot;relay-port&quot;)) {</span>
<span class="fc" id="L406">				values.add(&quot;relayPort&quot;, brokerRelayElem.getAttribute(&quot;relay-port&quot;));</span>
			}
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">			if (brokerRelayElem.hasAttribute(&quot;client-login&quot;)) {</span>
<span class="fc" id="L409">				values.add(&quot;clientLogin&quot;, brokerRelayElem.getAttribute(&quot;client-login&quot;));</span>
			}
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">			if (brokerRelayElem.hasAttribute(&quot;client-passcode&quot;)) {</span>
<span class="fc" id="L412">				values.add(&quot;clientPasscode&quot;, brokerRelayElem.getAttribute(&quot;client-passcode&quot;));</span>
			}
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">			if (brokerRelayElem.hasAttribute(&quot;system-login&quot;)) {</span>
<span class="fc" id="L415">				values.add(&quot;systemLogin&quot;, brokerRelayElem.getAttribute(&quot;system-login&quot;));</span>
			}
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">			if (brokerRelayElem.hasAttribute(&quot;system-passcode&quot;)) {</span>
<span class="fc" id="L418">				values.add(&quot;systemPasscode&quot;, brokerRelayElem.getAttribute(&quot;system-passcode&quot;));</span>
			}
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">			if (brokerRelayElem.hasAttribute(&quot;heartbeat-send-interval&quot;)) {</span>
<span class="fc" id="L421">				values.add(&quot;systemHeartbeatSendInterval&quot;, brokerRelayElem.getAttribute(&quot;heartbeat-send-interval&quot;));</span>
			}
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">			if (brokerRelayElem.hasAttribute(&quot;heartbeat-receive-interval&quot;)) {</span>
<span class="fc" id="L424">				values.add(&quot;systemHeartbeatReceiveInterval&quot;, brokerRelayElem.getAttribute(&quot;heartbeat-receive-interval&quot;));</span>
			}
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">			if (brokerRelayElem.hasAttribute(&quot;virtual-host&quot;)) {</span>
<span class="fc" id="L427">				values.add(&quot;virtualHost&quot;, brokerRelayElem.getAttribute(&quot;virtual-host&quot;));</span>
			}
<span class="fc" id="L429">			ManagedMap&lt;String, Object&gt; map = new ManagedMap&lt;&gt;();</span>
<span class="fc" id="L430">			map.setSource(source);</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">			if (brokerRelayElem.hasAttribute(&quot;user-destination-broadcast&quot;)) {</span>
<span class="fc" id="L432">				String destination = brokerRelayElem.getAttribute(&quot;user-destination-broadcast&quot;);</span>
<span class="fc" id="L433">				map.put(destination, userDestHandler);</span>
			}
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">			if (brokerRelayElem.hasAttribute(&quot;user-registry-broadcast&quot;)) {</span>
<span class="fc" id="L436">				String destination = brokerRelayElem.getAttribute(&quot;user-registry-broadcast&quot;);</span>
<span class="fc" id="L437">				map.put(destination, registerUserRegistryMessageHandler(userRegistry,</span>
						brokerTemplate, destination, context, source));
			}
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">			if (!map.isEmpty()) {</span>
<span class="fc" id="L441">				values.add(&quot;systemSubscriptions&quot;, map);</span>
			}
<span class="fc" id="L443">			Class&lt;?&gt; handlerType = StompBrokerRelayMessageHandler.class;</span>
<span class="fc" id="L444">			brokerDef = new RootBeanDefinition(handlerType, cargs, values);</span>
<span class="fc" id="L445">		}</span>
		else {
			// Should not happen
<span class="nc" id="L448">			throw new IllegalStateException(&quot;Neither &lt;simple-broker&gt; nor &lt;stomp-broker-relay&gt; elements found.&quot;);</span>
		}

<span class="fc bfc" id="L451" title="All 2 branches covered.">		if (brokerElement.hasAttribute(&quot;preserve-publish-order&quot;)) {</span>
<span class="fc" id="L452">			String preservePublishOrder = brokerElement.getAttribute(&quot;preserve-publish-order&quot;);</span>
<span class="fc" id="L453">			brokerDef.getPropertyValues().add(&quot;preservePublishOrder&quot;, preservePublishOrder);</span>
		}

<span class="fc" id="L456">		registerBeanDef(brokerDef, context, source);</span>
<span class="fc" id="L457">		return brokerDef;</span>
	}

	private RuntimeBeanReference registerUserRegistryMessageHandler(
			RuntimeBeanReference userRegistry, RuntimeBeanReference brokerTemplate,
			String destination, ParserContext context, @Nullable Object source) {

<span class="fc" id="L464">		Object scheduler = WebSocketNamespaceUtils.registerScheduler(SCHEDULER_BEAN_NAME, context, source);</span>

<span class="fc" id="L466">		RootBeanDefinition beanDef = new RootBeanDefinition(UserRegistryMessageHandler.class);</span>
<span class="fc" id="L467">		beanDef.getConstructorArgumentValues().addIndexedArgumentValue(0, userRegistry);</span>
<span class="fc" id="L468">		beanDef.getConstructorArgumentValues().addIndexedArgumentValue(1, brokerTemplate);</span>
<span class="fc" id="L469">		beanDef.getConstructorArgumentValues().addIndexedArgumentValue(2, destination);</span>
<span class="fc" id="L470">		beanDef.getConstructorArgumentValues().addIndexedArgumentValue(3, scheduler);</span>

<span class="fc" id="L472">		String beanName = registerBeanDef(beanDef, context, source);</span>
<span class="fc" id="L473">		return new RuntimeBeanReference(beanName);</span>
	}

	private RuntimeBeanReference registerMessageConverter(
			Element element, ParserContext context, @Nullable Object source) {

<span class="fc" id="L479">		Element convertersElement = DomUtils.getChildElementByTagName(element, &quot;message-converters&quot;);</span>
<span class="fc" id="L480">		ManagedList&lt;Object&gt; converters = new ManagedList&lt;&gt;();</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">		if (convertersElement != null) {</span>
<span class="fc" id="L482">			converters.setSource(source);</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">			for (Element beanElement : DomUtils.getChildElementsByTagName(convertersElement, &quot;bean&quot;, &quot;ref&quot;)) {</span>
<span class="fc" id="L484">				Object object = context.getDelegate().parsePropertySubElement(beanElement, null);</span>
<span class="fc" id="L485">				converters.add(object);</span>
<span class="fc" id="L486">			}</span>
		}
<span class="fc bfc" id="L488" title="All 4 branches covered.">		if (convertersElement == null || Boolean.valueOf(convertersElement.getAttribute(&quot;register-defaults&quot;))) {</span>
<span class="fc" id="L489">			converters.setSource(source);</span>
<span class="fc" id="L490">			converters.add(new RootBeanDefinition(StringMessageConverter.class));</span>
<span class="fc" id="L491">			converters.add(new RootBeanDefinition(ByteArrayMessageConverter.class));</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">			if (jackson2Present) {</span>
<span class="fc" id="L493">				RootBeanDefinition jacksonConverterDef = new RootBeanDefinition(MappingJackson2MessageConverter.class);</span>
<span class="fc" id="L494">				RootBeanDefinition resolverDef = new RootBeanDefinition(DefaultContentTypeResolver.class);</span>
<span class="fc" id="L495">				resolverDef.getPropertyValues().add(&quot;defaultMimeType&quot;, MimeTypeUtils.APPLICATION_JSON);</span>
<span class="fc" id="L496">				jacksonConverterDef.getPropertyValues().add(&quot;contentTypeResolver&quot;, resolverDef);</span>
				// Use Jackson factory in order to have JSR-310 and Joda-Time modules registered automatically
<span class="fc" id="L498">				GenericBeanDefinition jacksonFactoryDef = new GenericBeanDefinition();</span>
<span class="fc" id="L499">				jacksonFactoryDef.setBeanClass(Jackson2ObjectMapperFactoryBean.class);</span>
<span class="fc" id="L500">				jacksonFactoryDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span>
<span class="fc" id="L501">				jacksonFactoryDef.setSource(source);</span>
<span class="fc" id="L502">				jacksonConverterDef.getPropertyValues().add(&quot;objectMapper&quot;, jacksonFactoryDef);</span>
<span class="fc" id="L503">				converters.add(jacksonConverterDef);</span>
			}
		}
<span class="fc" id="L506">		ConstructorArgumentValues cargs = new ConstructorArgumentValues();</span>
<span class="fc" id="L507">		cargs.addIndexedArgumentValue(0, converters);</span>
<span class="fc" id="L508">		RootBeanDefinition messageConverterDef = new RootBeanDefinition(CompositeMessageConverter.class, cargs, null);</span>
<span class="fc" id="L509">		String name = MESSAGE_CONVERTER_BEAN_NAME;</span>
<span class="fc" id="L510">		registerBeanDefByName(name, messageConverterDef, context, source);</span>
<span class="fc" id="L511">		return new RuntimeBeanReference(name);</span>
	}

	private RuntimeBeanReference registerMessagingTemplate(Element element, RuntimeBeanReference brokerChannel,
			RuntimeBeanReference messageConverter, ParserContext context, @Nullable Object source) {

<span class="fc" id="L517">		ConstructorArgumentValues cargs = new ConstructorArgumentValues();</span>
<span class="fc" id="L518">		cargs.addIndexedArgumentValue(0, brokerChannel);</span>
<span class="fc" id="L519">		RootBeanDefinition beanDef = new RootBeanDefinition(SimpMessagingTemplate.class, cargs, null);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">		if (element.hasAttribute(&quot;user-destination-prefix&quot;)) {</span>
<span class="fc" id="L521">			beanDef.getPropertyValues().add(&quot;userDestinationPrefix&quot;, element.getAttribute(&quot;user-destination-prefix&quot;));</span>
		}
<span class="fc" id="L523">		beanDef.getPropertyValues().add(&quot;messageConverter&quot;, messageConverter);</span>
<span class="fc" id="L524">		String name = MESSAGING_TEMPLATE_BEAN_NAME;</span>
<span class="fc" id="L525">		registerBeanDefByName(name, beanDef, context, source);</span>
<span class="fc" id="L526">		return new RuntimeBeanReference(name);</span>
	}

	private void registerAnnotationMethodMessageHandler(Element messageBrokerElement,
			RuntimeBeanReference inChannel, RuntimeBeanReference outChannel,
			RuntimeBeanReference converter, RuntimeBeanReference messagingTemplate,
			ParserContext context, @Nullable Object source) {

<span class="fc" id="L534">		ConstructorArgumentValues cargs = new ConstructorArgumentValues();</span>
<span class="fc" id="L535">		cargs.addIndexedArgumentValue(0, inChannel);</span>
<span class="fc" id="L536">		cargs.addIndexedArgumentValue(1, outChannel);</span>
<span class="fc" id="L537">		cargs.addIndexedArgumentValue(2, messagingTemplate);</span>

<span class="fc" id="L539">		MutablePropertyValues values = new MutablePropertyValues();</span>
<span class="fc" id="L540">		String prefixAttribute = messageBrokerElement.getAttribute(&quot;application-destination-prefix&quot;);</span>
<span class="fc" id="L541">		values.add(&quot;destinationPrefixes&quot;, Arrays.asList(StringUtils.tokenizeToStringArray(prefixAttribute, &quot;,&quot;)));</span>
<span class="fc" id="L542">		values.add(&quot;messageConverter&quot;, converter);</span>

<span class="fc" id="L544">		RootBeanDefinition beanDef = new RootBeanDefinition(WebSocketAnnotationMethodMessageHandler.class, cargs, values);</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">		if (messageBrokerElement.hasAttribute(&quot;path-matcher&quot;)) {</span>
<span class="fc" id="L546">			String pathMatcherRef = messageBrokerElement.getAttribute(&quot;path-matcher&quot;);</span>
<span class="fc" id="L547">			beanDef.getPropertyValues().add(&quot;pathMatcher&quot;, new RuntimeBeanReference(pathMatcherRef));</span>
		}

<span class="fc" id="L550">		RuntimeBeanReference validatorRef = getValidator(messageBrokerElement, source, context);</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">		if (validatorRef != null) {</span>
<span class="fc" id="L552">			beanDef.getPropertyValues().add(&quot;validator&quot;, validatorRef);</span>
		}

<span class="fc" id="L555">		Element resolversElement = DomUtils.getChildElementByTagName(messageBrokerElement, &quot;argument-resolvers&quot;);</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">		if (resolversElement != null) {</span>
<span class="fc" id="L557">			values.add(&quot;customArgumentResolvers&quot;, extractBeanSubElements(resolversElement, context));</span>
		}

<span class="fc" id="L560">		Element handlersElement = DomUtils.getChildElementByTagName(messageBrokerElement, &quot;return-value-handlers&quot;);</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">		if (handlersElement != null) {</span>
<span class="fc" id="L562">			values.add(&quot;customReturnValueHandlers&quot;, extractBeanSubElements(handlersElement, context));</span>
		}

<span class="fc" id="L565">		registerBeanDef(beanDef, context, source);</span>
<span class="fc" id="L566">	}</span>

	@Nullable
	private RuntimeBeanReference getValidator(
			Element messageBrokerElement, @Nullable Object source, ParserContext context) {

<span class="fc bfc" id="L572" title="All 2 branches covered.">		if (messageBrokerElement.hasAttribute(&quot;validator&quot;)) {</span>
<span class="fc" id="L573">			return new RuntimeBeanReference(messageBrokerElement.getAttribute(&quot;validator&quot;));</span>
		}
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">		else if (javaxValidationPresent) {</span>
<span class="nc" id="L576">			RootBeanDefinition validatorDef = new RootBeanDefinition(</span>
					&quot;org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean&quot;);
<span class="nc" id="L578">			validatorDef.setSource(source);</span>
<span class="nc" id="L579">			validatorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span>
<span class="nc" id="L580">			String validatorName = context.getReaderContext().registerWithGeneratedName(validatorDef);</span>
<span class="nc" id="L581">			context.registerComponent(new BeanComponentDefinition(validatorDef, validatorName));</span>
<span class="nc" id="L582">			return new RuntimeBeanReference(validatorName);</span>
		}
		else {
<span class="fc" id="L585">			return null;</span>
		}
	}

	private ManagedList&lt;Object&gt; extractBeanSubElements(Element parentElement, ParserContext context) {
<span class="fc" id="L590">		ManagedList&lt;Object&gt; list = new ManagedList&lt;&gt;();</span>
<span class="fc" id="L591">		list.setSource(context.extractSource(parentElement));</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">		for (Element beanElement : DomUtils.getChildElementsByTagName(parentElement, &quot;bean&quot;, &quot;ref&quot;)) {</span>
<span class="fc" id="L593">			Object object = context.getDelegate().parsePropertySubElement(beanElement, null);</span>
<span class="fc" id="L594">			list.add(object);</span>
<span class="fc" id="L595">		}</span>
<span class="fc" id="L596">		return list;</span>
	}

	private RuntimeBeanReference registerUserDestResolver(Element brokerElem,
			RuntimeBeanReference userRegistry, ParserContext context, @Nullable Object source) {

<span class="fc" id="L602">		RootBeanDefinition beanDef = new RootBeanDefinition(DefaultUserDestinationResolver.class);</span>
<span class="fc" id="L603">		beanDef.getConstructorArgumentValues().addIndexedArgumentValue(0, userRegistry);</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">		if (brokerElem.hasAttribute(&quot;user-destination-prefix&quot;)) {</span>
<span class="fc" id="L605">			beanDef.getPropertyValues().add(&quot;userDestinationPrefix&quot;, brokerElem.getAttribute(&quot;user-destination-prefix&quot;));</span>
		}
<span class="fc bfc" id="L607" title="All 2 branches covered.">		if (brokerElem.hasAttribute(&quot;path-matcher&quot;)) {</span>
<span class="fc" id="L608">			String pathMatcherRef = brokerElem.getAttribute(&quot;path-matcher&quot;);</span>
<span class="fc" id="L609">			beanDef.getPropertyValues().add(&quot;pathMatcher&quot;, new RuntimeBeanReference(pathMatcherRef));</span>
		}
<span class="fc" id="L611">		return new RuntimeBeanReference(registerBeanDef(beanDef, context, source));</span>
	}

	private RuntimeBeanReference registerUserDestHandler(Element brokerElem,
			RuntimeBeanReference userRegistry, RuntimeBeanReference inChannel,
			RuntimeBeanReference brokerChannel, ParserContext context, @Nullable Object source) {

<span class="fc" id="L618">		Object userDestResolver = registerUserDestResolver(brokerElem, userRegistry, context, source);</span>

<span class="fc" id="L620">		RootBeanDefinition beanDef = new RootBeanDefinition(UserDestinationMessageHandler.class);</span>
<span class="fc" id="L621">		beanDef.getConstructorArgumentValues().addIndexedArgumentValue(0, inChannel);</span>
<span class="fc" id="L622">		beanDef.getConstructorArgumentValues().addIndexedArgumentValue(1, brokerChannel);</span>
<span class="fc" id="L623">		beanDef.getConstructorArgumentValues().addIndexedArgumentValue(2, userDestResolver);</span>

<span class="fc" id="L625">		Element relayElement = DomUtils.getChildElementByTagName(brokerElem, &quot;stomp-broker-relay&quot;);</span>
<span class="pc bpc" id="L626" title="1 of 4 branches missed.">		if (relayElement != null &amp;&amp; relayElement.hasAttribute(&quot;user-destination-broadcast&quot;)) {</span>
<span class="fc" id="L627">			String destination = relayElement.getAttribute(&quot;user-destination-broadcast&quot;);</span>
<span class="fc" id="L628">			beanDef.getPropertyValues().add(&quot;broadcastDestination&quot;, destination);</span>
		}

<span class="fc" id="L631">		String beanName = registerBeanDef(beanDef, context, source);</span>
<span class="fc" id="L632">		return new RuntimeBeanReference(beanName);</span>
	}

	private void registerWebSocketMessageBrokerStats(RootBeanDefinition broker, RuntimeBeanReference inChannel,
			RuntimeBeanReference outChannel, ParserContext context, @Nullable Object source) {

<span class="fc" id="L638">		RootBeanDefinition beanDef = new RootBeanDefinition(WebSocketMessageBrokerStats.class);</span>

<span class="fc" id="L640">		RuntimeBeanReference webSocketHandler = new RuntimeBeanReference(WEB_SOCKET_HANDLER_BEAN_NAME);</span>
<span class="fc" id="L641">		beanDef.getPropertyValues().add(&quot;subProtocolWebSocketHandler&quot;, webSocketHandler);</span>

<span class="fc bfc" id="L643" title="All 2 branches covered.">		if (StompBrokerRelayMessageHandler.class == broker.getBeanClass()) {</span>
<span class="fc" id="L644">			beanDef.getPropertyValues().add(&quot;stompBrokerRelay&quot;, broker);</span>
		}
<span class="fc" id="L646">		String name = inChannel.getBeanName() + &quot;Executor&quot;;</span>
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">		if (context.getRegistry().containsBeanDefinition(name)) {</span>
<span class="fc" id="L648">			beanDef.getPropertyValues().add(&quot;inboundChannelExecutor&quot;, context.getRegistry().getBeanDefinition(name));</span>
		}
<span class="fc" id="L650">		name = outChannel.getBeanName() + &quot;Executor&quot;;</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">		if (context.getRegistry().containsBeanDefinition(name)) {</span>
<span class="fc" id="L652">			beanDef.getPropertyValues().add(&quot;outboundChannelExecutor&quot;, context.getRegistry().getBeanDefinition(name));</span>
		}
<span class="fc" id="L654">		Object scheduler = WebSocketNamespaceUtils.registerScheduler(SCHEDULER_BEAN_NAME, context, source);</span>
<span class="fc" id="L655">		beanDef.getPropertyValues().add(&quot;sockJsTaskScheduler&quot;, scheduler);</span>

<span class="fc" id="L657">		registerBeanDefByName(&quot;webSocketMessageBrokerStats&quot;, beanDef, context, source);</span>
<span class="fc" id="L658">	}</span>

	private static String registerBeanDef(RootBeanDefinition beanDef, ParserContext context, @Nullable Object source) {
<span class="fc" id="L661">		String name = context.getReaderContext().generateBeanName(beanDef);</span>
<span class="fc" id="L662">		registerBeanDefByName(name, beanDef, context, source);</span>
<span class="fc" id="L663">		return name;</span>
	}

	private static void registerBeanDefByName(
			String name, RootBeanDefinition beanDef, ParserContext context, @Nullable Object source) {

<span class="fc" id="L669">		beanDef.setSource(source);</span>
<span class="fc" id="L670">		beanDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span>
<span class="fc" id="L671">		context.getRegistry().registerBeanDefinition(name, beanDef);</span>
<span class="fc" id="L672">		context.registerComponent(new BeanComponentDefinition(beanDef, name));</span>
<span class="fc" id="L673">	}</span>


	private static final class DecoratingFactoryBean implements FactoryBean&lt;WebSocketHandler&gt; {

		private final WebSocketHandler handler;

		private final List&lt;WebSocketHandlerDecoratorFactory&gt; factories;

		@SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L683">		public DecoratingFactoryBean(WebSocketHandler handler, List&lt;WebSocketHandlerDecoratorFactory&gt; factories) {</span>
<span class="fc" id="L684">			this.handler = handler;</span>
<span class="fc" id="L685">			this.factories = factories;</span>
<span class="fc" id="L686">		}</span>

		@Override
		public WebSocketHandler getObject() {
<span class="fc" id="L690">			WebSocketHandler result = this.handler;</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">			for (WebSocketHandlerDecoratorFactory factory : this.factories) {</span>
<span class="fc" id="L692">				result = factory.decorate(result);</span>
<span class="fc" id="L693">			}</span>
<span class="fc" id="L694">			return result;</span>
		}

		@Override
		public Class&lt;?&gt; getObjectType() {
<span class="fc" id="L699">			return WebSocketHandler.class;</span>
		}

		@Override
		public boolean isSingleton() {
<span class="fc" id="L704">			return true;</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>