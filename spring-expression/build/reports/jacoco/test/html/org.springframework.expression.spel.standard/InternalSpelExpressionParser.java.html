<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InternalSpelExpressionParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-expression</a> &gt; <a href="index.source.html" class="el_package">org.springframework.expression.spel.standard</a> &gt; <span class="el_source">InternalSpelExpressionParser.java</span></div><h1>InternalSpelExpressionParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.expression.spel.standard;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.List;
import java.util.regex.Pattern;

import org.springframework.expression.ParseException;
import org.springframework.expression.ParserContext;
import org.springframework.expression.common.TemplateAwareExpressionParser;
import org.springframework.expression.spel.InternalParseException;
import org.springframework.expression.spel.SpelMessage;
import org.springframework.expression.spel.SpelParseException;
import org.springframework.expression.spel.SpelParserConfiguration;
import org.springframework.expression.spel.ast.Assign;
import org.springframework.expression.spel.ast.BeanReference;
import org.springframework.expression.spel.ast.BooleanLiteral;
import org.springframework.expression.spel.ast.CompoundExpression;
import org.springframework.expression.spel.ast.ConstructorReference;
import org.springframework.expression.spel.ast.Elvis;
import org.springframework.expression.spel.ast.FunctionReference;
import org.springframework.expression.spel.ast.Identifier;
import org.springframework.expression.spel.ast.Indexer;
import org.springframework.expression.spel.ast.InlineList;
import org.springframework.expression.spel.ast.InlineMap;
import org.springframework.expression.spel.ast.Literal;
import org.springframework.expression.spel.ast.MethodReference;
import org.springframework.expression.spel.ast.NullLiteral;
import org.springframework.expression.spel.ast.OpAnd;
import org.springframework.expression.spel.ast.OpDec;
import org.springframework.expression.spel.ast.OpDivide;
import org.springframework.expression.spel.ast.OpEQ;
import org.springframework.expression.spel.ast.OpGE;
import org.springframework.expression.spel.ast.OpGT;
import org.springframework.expression.spel.ast.OpInc;
import org.springframework.expression.spel.ast.OpLE;
import org.springframework.expression.spel.ast.OpLT;
import org.springframework.expression.spel.ast.OpMinus;
import org.springframework.expression.spel.ast.OpModulus;
import org.springframework.expression.spel.ast.OpMultiply;
import org.springframework.expression.spel.ast.OpNE;
import org.springframework.expression.spel.ast.OpOr;
import org.springframework.expression.spel.ast.OpPlus;
import org.springframework.expression.spel.ast.OperatorBetween;
import org.springframework.expression.spel.ast.OperatorInstanceof;
import org.springframework.expression.spel.ast.OperatorMatches;
import org.springframework.expression.spel.ast.OperatorNot;
import org.springframework.expression.spel.ast.OperatorPower;
import org.springframework.expression.spel.ast.Projection;
import org.springframework.expression.spel.ast.PropertyOrFieldReference;
import org.springframework.expression.spel.ast.QualifiedIdentifier;
import org.springframework.expression.spel.ast.Selection;
import org.springframework.expression.spel.ast.SpelNodeImpl;
import org.springframework.expression.spel.ast.StringLiteral;
import org.springframework.expression.spel.ast.Ternary;
import org.springframework.expression.spel.ast.TypeReference;
import org.springframework.expression.spel.ast.VariableReference;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

/**
 * Hand-written SpEL parser. Instances are reusable but are not thread-safe.
 *
 * @author Andy Clement
 * @author Juergen Hoeller
 * @author Phillip Webb
 * @since 3.0
 */
class InternalSpelExpressionParser extends TemplateAwareExpressionParser {

<span class="fc" id="L90">	private static final Pattern VALID_QUALIFIED_ID_PATTERN = Pattern.compile(&quot;[\\p{L}\\p{N}_$]+&quot;);</span>


	private final SpelParserConfiguration configuration;

	// For rules that build nodes, they are stacked here for return
<span class="fc" id="L96">	private final Deque&lt;SpelNodeImpl&gt; constructedNodes = new ArrayDeque&lt;&gt;();</span>

	// The expression being parsed
<span class="fc" id="L99">	private String expressionString = &quot;&quot;;</span>

	// The token stream constructed from that expression string
<span class="fc" id="L102">	private List&lt;Token&gt; tokenStream = Collections.emptyList();</span>

	// length of a populated token stream
	private int tokenStreamLength;

	// Current location in the token stream when processing tokens
	private int tokenStreamPointer;


	/**
	 * Create a parser with some configured behavior.
	 * @param configuration custom configuration options
	 */
<span class="fc" id="L115">	public InternalSpelExpressionParser(SpelParserConfiguration configuration) {</span>
<span class="fc" id="L116">		this.configuration = configuration;</span>
<span class="fc" id="L117">	}</span>


	@Override
	protected SpelExpression doParseExpression(String expressionString, @Nullable ParserContext context)
			throws ParseException {

		try {
<span class="fc" id="L125">			this.expressionString = expressionString;</span>
<span class="fc" id="L126">			Tokenizer tokenizer = new Tokenizer(expressionString);</span>
<span class="fc" id="L127">			this.tokenStream = tokenizer.process();</span>
<span class="fc" id="L128">			this.tokenStreamLength = this.tokenStream.size();</span>
<span class="fc" id="L129">			this.tokenStreamPointer = 0;</span>
<span class="fc" id="L130">			this.constructedNodes.clear();</span>
<span class="fc" id="L131">			SpelNodeImpl ast = eatExpression();</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">			Assert.state(ast != null, &quot;No node&quot;);</span>
<span class="fc" id="L133">			Token t = peekToken();</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">			if (t != null) {</span>
<span class="fc" id="L135">				throw new SpelParseException(t.startPos, SpelMessage.MORE_INPUT, toString(nextToken()));</span>
			}
<span class="fc" id="L137">			Assert.isTrue(this.constructedNodes.isEmpty(), &quot;At least one node expected&quot;);</span>
<span class="fc" id="L138">			return new SpelExpression(expressionString, ast, this.configuration);</span>
		}
<span class="fc" id="L140">		catch (InternalParseException ex) {</span>
<span class="fc" id="L141">			throw ex.getCause();</span>
		}
	}

	//	expression
	//    : logicalOrExpression
	//      ( (ASSIGN^ logicalOrExpression)
	//	    | (DEFAULT^ logicalOrExpression)
	//	    | (QMARK^ expression COLON! expression)
	//      | (ELVIS^ expression))?;
	@Nullable
	private SpelNodeImpl eatExpression() {
<span class="fc" id="L153">		SpelNodeImpl expr = eatLogicalOrExpression();</span>
<span class="fc" id="L154">		Token t = peekToken();</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">		if (t != null) {</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">			if (t.kind == TokenKind.ASSIGN) {  // a=b</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">				if (expr == null) {</span>
<span class="fc" id="L158">					expr = new NullLiteral(t.startPos - 1, t.endPos - 1);</span>
				}
<span class="fc" id="L160">				nextToken();</span>
<span class="fc" id="L161">				SpelNodeImpl assignedValue = eatLogicalOrExpression();</span>
<span class="fc" id="L162">				return new Assign(t.startPos, t.endPos, expr, assignedValue);</span>
			}
<span class="fc bfc" id="L164" title="All 2 branches covered.">			if (t.kind == TokenKind.ELVIS) {  // a?:b (a if it isn't null, otherwise b)</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">				if (expr == null) {</span>
<span class="fc" id="L166">					expr = new NullLiteral(t.startPos - 1, t.endPos - 2);</span>
				}
<span class="fc" id="L168">				nextToken();  // elvis has left the building</span>
<span class="fc" id="L169">				SpelNodeImpl valueIfNull = eatExpression();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">				if (valueIfNull == null) {</span>
<span class="fc" id="L171">					valueIfNull = new NullLiteral(t.startPos + 1, t.endPos + 1);</span>
				}
<span class="fc" id="L173">				return new Elvis(t.startPos, t.endPos, expr, valueIfNull);</span>
			}
<span class="fc bfc" id="L175" title="All 2 branches covered.">			if (t.kind == TokenKind.QMARK) {  // a?b:c</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">				if (expr == null) {</span>
<span class="fc" id="L177">					expr = new NullLiteral(t.startPos - 1, t.endPos - 1);</span>
				}
<span class="fc" id="L179">				nextToken();</span>
<span class="fc" id="L180">				SpelNodeImpl ifTrueExprValue = eatExpression();</span>
<span class="fc" id="L181">				eatToken(TokenKind.COLON);</span>
<span class="fc" id="L182">				SpelNodeImpl ifFalseExprValue = eatExpression();</span>
<span class="fc" id="L183">				return new Ternary(t.startPos, t.endPos, expr, ifTrueExprValue, ifFalseExprValue);</span>
			}
		}
<span class="fc" id="L186">		return expr;</span>
	}

	//logicalOrExpression : logicalAndExpression (OR^ logicalAndExpression)*;
	@Nullable
	private SpelNodeImpl eatLogicalOrExpression() {
<span class="fc" id="L192">		SpelNodeImpl expr = eatLogicalAndExpression();</span>
<span class="fc bfc" id="L193" title="All 4 branches covered.">		while (peekIdentifierToken(&quot;or&quot;) || peekToken(TokenKind.SYMBOLIC_OR)) {</span>
<span class="fc" id="L194">			Token t = takeToken();  //consume OR</span>
<span class="fc" id="L195">			SpelNodeImpl rhExpr = eatLogicalAndExpression();</span>
<span class="fc" id="L196">			checkOperands(t, expr, rhExpr);</span>
<span class="fc" id="L197">			expr = new OpOr(t.startPos, t.endPos, expr, rhExpr);</span>
<span class="fc" id="L198">		}</span>
<span class="fc" id="L199">		return expr;</span>
	}

	// logicalAndExpression : relationalExpression (AND^ relationalExpression)*;
	@Nullable
	private SpelNodeImpl eatLogicalAndExpression() {
<span class="fc" id="L205">		SpelNodeImpl expr = eatRelationalExpression();</span>
<span class="fc bfc" id="L206" title="All 4 branches covered.">		while (peekIdentifierToken(&quot;and&quot;) || peekToken(TokenKind.SYMBOLIC_AND)) {</span>
<span class="fc" id="L207">			Token t = takeToken();  // consume 'AND'</span>
<span class="fc" id="L208">			SpelNodeImpl rhExpr = eatRelationalExpression();</span>
<span class="fc" id="L209">			checkOperands(t, expr, rhExpr);</span>
<span class="fc" id="L210">			expr = new OpAnd(t.startPos, t.endPos, expr, rhExpr);</span>
<span class="fc" id="L211">		}</span>
<span class="fc" id="L212">		return expr;</span>
	}

	// relationalExpression : sumExpression (relationalOperator^ sumExpression)?;
	@Nullable
	private SpelNodeImpl eatRelationalExpression() {
<span class="fc" id="L218">		SpelNodeImpl expr = eatSumExpression();</span>
<span class="fc" id="L219">		Token relationalOperatorToken = maybeEatRelationalOperator();</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">		if (relationalOperatorToken != null) {</span>
<span class="fc" id="L221">			Token t = takeToken();  // consume relational operator token</span>
<span class="fc" id="L222">			SpelNodeImpl rhExpr = eatSumExpression();</span>
<span class="fc" id="L223">			checkOperands(t, expr, rhExpr);</span>
<span class="fc" id="L224">			TokenKind tk = relationalOperatorToken.kind;</span>

<span class="fc bfc" id="L226" title="All 2 branches covered.">			if (relationalOperatorToken.isNumericRelationalOperator()) {</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">				if (tk == TokenKind.GT) {</span>
<span class="fc" id="L228">					return new OpGT(t.startPos, t.endPos, expr, rhExpr);</span>
				}
<span class="fc bfc" id="L230" title="All 2 branches covered.">				if (tk == TokenKind.LT) {</span>
<span class="fc" id="L231">					return new OpLT(t.startPos, t.endPos, expr, rhExpr);</span>
				}
<span class="fc bfc" id="L233" title="All 2 branches covered.">				if (tk == TokenKind.LE) {</span>
<span class="fc" id="L234">					return new OpLE(t.startPos, t.endPos, expr, rhExpr);</span>
				}
<span class="fc bfc" id="L236" title="All 2 branches covered.">				if (tk == TokenKind.GE) {</span>
<span class="fc" id="L237">					return new OpGE(t.startPos, t.endPos, expr, rhExpr);</span>
				}
<span class="fc bfc" id="L239" title="All 2 branches covered.">				if (tk == TokenKind.EQ) {</span>
<span class="fc" id="L240">					return new OpEQ(t.startPos, t.endPos, expr, rhExpr);</span>
				}
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">				Assert.isTrue(tk == TokenKind.NE, &quot;Not-equals token expected&quot;);</span>
<span class="fc" id="L243">				return new OpNE(t.startPos, t.endPos, expr, rhExpr);</span>
			}

<span class="fc bfc" id="L246" title="All 2 branches covered.">			if (tk == TokenKind.INSTANCEOF) {</span>
<span class="fc" id="L247">				return new OperatorInstanceof(t.startPos, t.endPos, expr, rhExpr);</span>
			}

<span class="fc bfc" id="L250" title="All 2 branches covered.">			if (tk == TokenKind.MATCHES) {</span>
<span class="fc" id="L251">				return new OperatorMatches(t.startPos, t.endPos, expr, rhExpr);</span>
			}

<span class="pc bpc" id="L254" title="1 of 2 branches missed.">			Assert.isTrue(tk == TokenKind.BETWEEN, &quot;Between token expected&quot;);</span>
<span class="fc" id="L255">			return new OperatorBetween(t.startPos, t.endPos, expr, rhExpr);</span>
		}
<span class="fc" id="L257">		return expr;</span>
	}

	//sumExpression: productExpression ( (PLUS^ | MINUS^) productExpression)*;
	@Nullable
	private SpelNodeImpl eatSumExpression() {
<span class="fc" id="L263">		SpelNodeImpl expr = eatProductExpression();</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">		while (peekToken(TokenKind.PLUS, TokenKind.MINUS, TokenKind.INC)) {</span>
<span class="fc" id="L265">			Token t = takeToken();  //consume PLUS or MINUS or INC</span>
<span class="fc" id="L266">			SpelNodeImpl rhExpr = eatProductExpression();</span>
<span class="fc" id="L267">			checkRightOperand(t, rhExpr);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">			if (t.kind == TokenKind.PLUS) {</span>
<span class="fc" id="L269">				expr = new OpPlus(t.startPos, t.endPos, expr, rhExpr);</span>
			}
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">			else if (t.kind == TokenKind.MINUS) {</span>
<span class="fc" id="L272">				expr = new OpMinus(t.startPos, t.endPos, expr, rhExpr);</span>
			}
<span class="fc" id="L274">		}</span>
<span class="fc" id="L275">		return expr;</span>
	}

	// productExpression: powerExpr ((STAR^ | DIV^| MOD^) powerExpr)* ;
	@Nullable
	private SpelNodeImpl eatProductExpression() {
<span class="fc" id="L281">		SpelNodeImpl expr = eatPowerIncDecExpression();</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">		while (peekToken(TokenKind.STAR, TokenKind.DIV, TokenKind.MOD)) {</span>
<span class="fc" id="L283">			Token t = takeToken();  // consume STAR/DIV/MOD</span>
<span class="fc" id="L284">			SpelNodeImpl rhExpr = eatPowerIncDecExpression();</span>
<span class="fc" id="L285">			checkOperands(t, expr, rhExpr);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">			if (t.kind == TokenKind.STAR) {</span>
<span class="fc" id="L287">				expr = new OpMultiply(t.startPos, t.endPos, expr, rhExpr);</span>
			}
<span class="fc bfc" id="L289" title="All 2 branches covered.">			else if (t.kind == TokenKind.DIV) {</span>
<span class="fc" id="L290">				expr = new OpDivide(t.startPos, t.endPos, expr, rhExpr);</span>
			}
			else {
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">				Assert.isTrue(t.kind == TokenKind.MOD, &quot;Mod token expected&quot;);</span>
<span class="fc" id="L294">				expr = new OpModulus(t.startPos, t.endPos, expr, rhExpr);</span>
			}
<span class="fc" id="L296">		}</span>
<span class="fc" id="L297">		return expr;</span>
	}

	// powerExpr  : unaryExpression (POWER^ unaryExpression)? (INC || DEC) ;
	@Nullable
	private SpelNodeImpl eatPowerIncDecExpression() {
<span class="fc" id="L303">		SpelNodeImpl expr = eatUnaryExpression();</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">		if (peekToken(TokenKind.POWER)) {</span>
<span class="fc" id="L305">			Token t = takeToken();  //consume POWER</span>
<span class="fc" id="L306">			SpelNodeImpl rhExpr = eatUnaryExpression();</span>
<span class="fc" id="L307">			checkRightOperand(t, rhExpr);</span>
<span class="fc" id="L308">			return new OperatorPower(t.startPos, t.endPos, expr, rhExpr);</span>
		}
<span class="fc bfc" id="L310" title="All 4 branches covered.">		if (expr != null &amp;&amp; peekToken(TokenKind.INC, TokenKind.DEC)) {</span>
<span class="fc" id="L311">			Token t = takeToken();  //consume INC/DEC</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">			if (t.getKind() == TokenKind.INC) {</span>
<span class="fc" id="L313">				return new OpInc(t.startPos, t.endPos, true, expr);</span>
			}
<span class="fc" id="L315">			return new OpDec(t.startPos, t.endPos, true, expr);</span>
		}
<span class="fc" id="L317">		return expr;</span>
	}

	// unaryExpression: (PLUS^ | MINUS^ | BANG^ | INC^ | DEC^) unaryExpression | primaryExpression ;
	@Nullable
	private SpelNodeImpl eatUnaryExpression() {
<span class="fc bfc" id="L323" title="All 2 branches covered.">		if (peekToken(TokenKind.PLUS, TokenKind.MINUS, TokenKind.NOT)) {</span>
<span class="fc" id="L324">			Token t = takeToken();</span>
<span class="fc" id="L325">			SpelNodeImpl expr = eatUnaryExpression();</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">			Assert.state(expr != null, &quot;No node&quot;);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">			if (t.kind == TokenKind.NOT) {</span>
<span class="fc" id="L328">				return new OperatorNot(t.startPos, t.endPos, expr);</span>
			}
<span class="fc bfc" id="L330" title="All 2 branches covered.">			if (t.kind == TokenKind.PLUS) {</span>
<span class="fc" id="L331">				return new OpPlus(t.startPos, t.endPos, expr);</span>
			}
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">			Assert.isTrue(t.kind == TokenKind.MINUS, &quot;Minus token expected&quot;);</span>
<span class="fc" id="L334">			return new OpMinus(t.startPos, t.endPos, expr);</span>
		}
<span class="fc bfc" id="L336" title="All 2 branches covered.">		if (peekToken(TokenKind.INC, TokenKind.DEC)) {</span>
<span class="fc" id="L337">			Token t = takeToken();</span>
<span class="fc" id="L338">			SpelNodeImpl expr = eatUnaryExpression();</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">			if (t.getKind() == TokenKind.INC) {</span>
<span class="fc" id="L340">				return new OpInc(t.startPos, t.endPos, false, expr);</span>
			}
<span class="fc" id="L342">			return new OpDec(t.startPos, t.endPos, false, expr);</span>
		}
<span class="fc" id="L344">		return eatPrimaryExpression();</span>
	}

	// primaryExpression : startNode (node)? -&gt; ^(EXPRESSION startNode (node)?);
	@Nullable
	private SpelNodeImpl eatPrimaryExpression() {
<span class="fc" id="L350">		SpelNodeImpl start = eatStartNode();  // always a start node</span>
<span class="fc" id="L351">		List&lt;SpelNodeImpl&gt; nodes = null;</span>
<span class="fc" id="L352">		SpelNodeImpl node = eatNode();</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">		while (node != null) {</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">			if (nodes == null) {</span>
<span class="fc" id="L355">				nodes = new ArrayList&lt;&gt;(4);</span>
<span class="fc" id="L356">				nodes.add(start);</span>
			}
<span class="fc" id="L358">			nodes.add(node);</span>
<span class="fc" id="L359">			node = eatNode();</span>
		}
<span class="fc bfc" id="L361" title="All 4 branches covered.">		if (start == null || nodes == null) {</span>
<span class="fc" id="L362">			return start;</span>
		}
<span class="fc" id="L364">		return new CompoundExpression(start.getStartPosition(), nodes.get(nodes.size() - 1).getEndPosition(),</span>
<span class="fc" id="L365">				nodes.toArray(new SpelNodeImpl[0]));</span>
	}

	// node : ((DOT dottedNode) | (SAFE_NAVI dottedNode) | nonDottedNode)+;
	@Nullable
	private SpelNodeImpl eatNode() {
<span class="fc bfc" id="L371" title="All 2 branches covered.">		return (peekToken(TokenKind.DOT, TokenKind.SAFE_NAVI) ? eatDottedNode() : eatNonDottedNode());</span>
	}

	// nonDottedNode: indexer;
	@Nullable
	private SpelNodeImpl eatNonDottedNode() {
<span class="fc bfc" id="L377" title="All 2 branches covered.">		if (peekToken(TokenKind.LSQUARE)) {</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">			if (maybeEatIndexer()) {</span>
<span class="fc" id="L379">				return pop();</span>
			}
		}
<span class="fc" id="L382">		return null;</span>
	}

	//dottedNode
	// : ((methodOrProperty
	//	  | functionOrVar
	//    | projection
	//    | selection
	//    | firstSelection
	//    | lastSelection
	//    ))
	//	;
	private SpelNodeImpl eatDottedNode() {
<span class="fc" id="L395">		Token t = takeToken();  // it was a '.' or a '?.'</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">		boolean nullSafeNavigation = (t.kind == TokenKind.SAFE_NAVI);</span>
<span class="pc bpc" id="L397" title="1 of 4 branches missed.">		if (maybeEatMethodOrProperty(nullSafeNavigation) || maybeEatFunctionOrVar() ||</span>
<span class="fc bfc" id="L398" title="All 4 branches covered.">				maybeEatProjection(nullSafeNavigation) || maybeEatSelection(nullSafeNavigation)) {</span>
<span class="fc" id="L399">			return pop();</span>
		}
<span class="fc bfc" id="L401" title="All 2 branches covered.">		if (peekToken() == null) {</span>
			// unexpectedly ran out of data
<span class="fc" id="L403">			throw internalException(t.startPos, SpelMessage.OOD);</span>
		}
		else {
<span class="fc" id="L406">			throw internalException(t.startPos, SpelMessage.UNEXPECTED_DATA_AFTER_DOT, toString(peekToken()));</span>
		}
	}

	// functionOrVar
	// : (POUND ID LPAREN) =&gt; function
	// | var
	//
	// function : POUND id=ID methodArgs -&gt; ^(FUNCTIONREF[$id] methodArgs);
	// var : POUND id=ID -&gt; ^(VARIABLEREF[$id]);
	private boolean maybeEatFunctionOrVar() {
<span class="fc bfc" id="L417" title="All 2 branches covered.">		if (!peekToken(TokenKind.HASH)) {</span>
<span class="fc" id="L418">			return false;</span>
		}
<span class="fc" id="L420">		Token t = takeToken();</span>
<span class="fc" id="L421">		Token functionOrVariableName = eatToken(TokenKind.IDENTIFIER);</span>
<span class="fc" id="L422">		SpelNodeImpl[] args = maybeEatMethodArgs();</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">		if (args == null) {</span>
<span class="fc" id="L424">			push(new VariableReference(functionOrVariableName.stringValue(),</span>
					t.startPos, functionOrVariableName.endPos));
<span class="fc" id="L426">			return true;</span>
		}

<span class="fc" id="L429">		push(new FunctionReference(functionOrVariableName.stringValue(),</span>
				t.startPos, functionOrVariableName.endPos, args));
<span class="fc" id="L431">		return true;</span>
	}

	// methodArgs : LPAREN! (argument (COMMA! argument)* (COMMA!)?)? RPAREN!;
	@Nullable
	private SpelNodeImpl[] maybeEatMethodArgs() {
<span class="fc bfc" id="L437" title="All 2 branches covered.">		if (!peekToken(TokenKind.LPAREN)) {</span>
<span class="fc" id="L438">			return null;</span>
		}
<span class="fc" id="L440">		List&lt;SpelNodeImpl&gt; args = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L441">		consumeArguments(args);</span>
<span class="fc" id="L442">		eatToken(TokenKind.RPAREN);</span>
<span class="fc" id="L443">		return args.toArray(new SpelNodeImpl[0]);</span>
	}

	private void eatConstructorArgs(List&lt;SpelNodeImpl&gt; accumulatedArguments) {
<span class="fc bfc" id="L447" title="All 2 branches covered.">		if (!peekToken(TokenKind.LPAREN)) {</span>
<span class="fc" id="L448">			throw new InternalParseException(new SpelParseException(this.expressionString,</span>
<span class="fc" id="L449">					positionOf(peekToken()), SpelMessage.MISSING_CONSTRUCTOR_ARGS));</span>
		}
<span class="fc" id="L451">		consumeArguments(accumulatedArguments);</span>
<span class="fc" id="L452">		eatToken(TokenKind.RPAREN);</span>
<span class="fc" id="L453">	}</span>

	/**
	 * Used for consuming arguments for either a method or a constructor call.
	 */
	private void consumeArguments(List&lt;SpelNodeImpl&gt; accumulatedArguments) {
<span class="fc" id="L459">		Token t = peekToken();</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">		Assert.state(t != null, &quot;Expected token&quot;);</span>
<span class="fc" id="L461">		int pos = t.startPos;</span>
		Token next;
		do {
<span class="fc" id="L464">			nextToken();  // consume (first time through) or comma (subsequent times)</span>
<span class="fc" id="L465">			t = peekToken();</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">			if (t == null) {</span>
<span class="fc" id="L467">				throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS);</span>
			}
<span class="fc bfc" id="L469" title="All 2 branches covered.">			if (t.kind != TokenKind.RPAREN) {</span>
<span class="fc" id="L470">				accumulatedArguments.add(eatExpression());</span>
			}
<span class="fc" id="L472">			next = peekToken();</span>
		}
<span class="fc bfc" id="L474" title="All 4 branches covered.">		while (next != null &amp;&amp; next.kind == TokenKind.COMMA);</span>

<span class="fc bfc" id="L476" title="All 2 branches covered.">		if (next == null) {</span>
<span class="fc" id="L477">			throw internalException(pos, SpelMessage.RUN_OUT_OF_ARGUMENTS);</span>
		}
<span class="fc" id="L479">	}</span>

	private int positionOf(@Nullable Token t) {
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">		if (t == null) {</span>
			// if null assume the problem is because the right token was
			// not found at the end of the expression
<span class="fc" id="L485">			return this.expressionString.length();</span>
		}
<span class="nc" id="L487">		return t.startPos;</span>
	}

	//startNode
	// : parenExpr | literal
	//	    | type
	//	    | methodOrProperty
	//	    | functionOrVar
	//	    | projection
	//	    | selection
	//	    | firstSelection
	//	    | lastSelection
	//	    | indexer
	//	    | constructor
	@Nullable
	private SpelNodeImpl eatStartNode() {
<span class="fc bfc" id="L503" title="All 2 branches covered.">		if (maybeEatLiteral()) {</span>
<span class="fc" id="L504">			return pop();</span>
		}
<span class="fc bfc" id="L506" title="All 2 branches covered.">		else if (maybeEatParenExpression()) {</span>
<span class="fc" id="L507">			return pop();</span>
		}
<span class="fc bfc" id="L509" title="All 6 branches covered.">		else if (maybeEatTypeReference() || maybeEatNullReference() || maybeEatConstructorReference() ||</span>
<span class="fc bfc" id="L510" title="All 4 branches covered.">				maybeEatMethodOrProperty(false) || maybeEatFunctionOrVar()) {</span>
<span class="fc" id="L511">			return pop();</span>
		}
<span class="fc bfc" id="L513" title="All 2 branches covered.">		else if (maybeEatBeanReference()) {</span>
<span class="fc" id="L514">			return pop();</span>
		}
<span class="pc bpc" id="L516" title="2 of 6 branches missed.">		else if (maybeEatProjection(false) || maybeEatSelection(false) || maybeEatIndexer()) {</span>
<span class="fc" id="L517">			return pop();</span>
		}
<span class="fc bfc" id="L519" title="All 2 branches covered.">		else if (maybeEatInlineListOrMap()) {</span>
<span class="fc" id="L520">			return pop();</span>
		}
		else {
<span class="fc" id="L523">			return null;</span>
		}
	}

	// parse: @beanname @'bean.name'
	// quoted if dotted
	private boolean maybeEatBeanReference() {
<span class="fc bfc" id="L530" title="All 4 branches covered.">		if (peekToken(TokenKind.BEAN_REF) || peekToken(TokenKind.FACTORY_BEAN_REF)) {</span>
<span class="fc" id="L531">			Token beanRefToken = takeToken();</span>
<span class="fc" id="L532">			Token beanNameToken = null;</span>
<span class="fc" id="L533">			String beanName = null;</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">			if (peekToken(TokenKind.IDENTIFIER)) {</span>
<span class="fc" id="L535">				beanNameToken = eatToken(TokenKind.IDENTIFIER);</span>
<span class="fc" id="L536">				beanName = beanNameToken.stringValue();</span>
			}
<span class="fc bfc" id="L538" title="All 2 branches covered.">			else if (peekToken(TokenKind.LITERAL_STRING)) {</span>
<span class="fc" id="L539">				beanNameToken = eatToken(TokenKind.LITERAL_STRING);</span>
<span class="fc" id="L540">				beanName = beanNameToken.stringValue();</span>
<span class="fc" id="L541">				beanName = beanName.substring(1, beanName.length() - 1);</span>
			}
			else {
<span class="fc" id="L544">				throw internalException(beanRefToken.startPos, SpelMessage.INVALID_BEAN_REFERENCE);</span>
			}
			BeanReference beanReference;
<span class="fc bfc" id="L547" title="All 2 branches covered.">			if (beanRefToken.getKind() == TokenKind.FACTORY_BEAN_REF) {</span>
<span class="fc" id="L548">				String beanNameString = String.valueOf(TokenKind.FACTORY_BEAN_REF.tokenChars) + beanName;</span>
<span class="fc" id="L549">				beanReference = new BeanReference(beanRefToken.startPos, beanNameToken.endPos, beanNameString);</span>
<span class="fc" id="L550">			}</span>
			else {
<span class="fc" id="L552">				beanReference = new BeanReference(beanNameToken.startPos, beanNameToken.endPos, beanName);</span>
			}
<span class="fc" id="L554">			this.constructedNodes.push(beanReference);</span>
<span class="fc" id="L555">			return true;</span>
		}
<span class="fc" id="L557">		return false;</span>
	}

	private boolean maybeEatTypeReference() {
<span class="fc bfc" id="L561" title="All 2 branches covered.">		if (peekToken(TokenKind.IDENTIFIER)) {</span>
<span class="fc" id="L562">			Token typeName = peekToken();</span>
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">			Assert.state(typeName != null, &quot;Expected token&quot;);</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">			if (!&quot;T&quot;.equals(typeName.stringValue())) {</span>
<span class="fc" id="L565">				return false;</span>
			}
			// It looks like a type reference but is T being used as a map key?
<span class="fc" id="L568">			Token t = takeToken();</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">			if (peekToken(TokenKind.RSQUARE)) {</span>
				// looks like 'T]' (T is map key)
<span class="fc" id="L571">				push(new PropertyOrFieldReference(false, t.stringValue(), t.startPos, t.endPos));</span>
<span class="fc" id="L572">				return true;</span>
			}
<span class="fc" id="L574">			eatToken(TokenKind.LPAREN);</span>
<span class="fc" id="L575">			SpelNodeImpl node = eatPossiblyQualifiedId();</span>
			// dotted qualified id
			// Are there array dimensions?
<span class="fc" id="L578">			int dims = 0;</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">			while (peekToken(TokenKind.LSQUARE, true)) {</span>
<span class="fc" id="L580">				eatToken(TokenKind.RSQUARE);</span>
<span class="fc" id="L581">				dims++;</span>
			}
<span class="fc" id="L583">			eatToken(TokenKind.RPAREN);</span>
<span class="fc" id="L584">			this.constructedNodes.push(new TypeReference(typeName.startPos, typeName.endPos, node, dims));</span>
<span class="fc" id="L585">			return true;</span>
		}
<span class="fc" id="L587">		return false;</span>
	}

	private boolean maybeEatNullReference() {
<span class="fc bfc" id="L591" title="All 2 branches covered.">		if (peekToken(TokenKind.IDENTIFIER)) {</span>
<span class="fc" id="L592">			Token nullToken = peekToken();</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">			Assert.state(nullToken != null, &quot;Expected token&quot;);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">			if (!&quot;null&quot;.equalsIgnoreCase(nullToken.stringValue())) {</span>
<span class="fc" id="L595">				return false;</span>
			}
<span class="fc" id="L597">			nextToken();</span>
<span class="fc" id="L598">			this.constructedNodes.push(new NullLiteral(nullToken.startPos, nullToken.endPos));</span>
<span class="fc" id="L599">			return true;</span>
		}
<span class="fc" id="L601">		return false;</span>
	}

	//projection: PROJECT^ expression RCURLY!;
	private boolean maybeEatProjection(boolean nullSafeNavigation) {
<span class="fc" id="L606">		Token t = peekToken();</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">		if (!peekToken(TokenKind.PROJECT, true)) {</span>
<span class="fc" id="L608">			return false;</span>
		}
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">		Assert.state(t != null, &quot;No token&quot;);</span>
<span class="fc" id="L611">		SpelNodeImpl expr = eatExpression();</span>
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">		Assert.state(expr != null, &quot;No node&quot;);</span>
<span class="fc" id="L613">		eatToken(TokenKind.RSQUARE);</span>
<span class="fc" id="L614">		this.constructedNodes.push(new Projection(nullSafeNavigation, t.startPos, t.endPos, expr));</span>
<span class="fc" id="L615">		return true;</span>
	}

	// list = LCURLY (element (COMMA element)*) RCURLY
	// map  = LCURLY (key ':' value (COMMA key ':' value)*) RCURLY
	private boolean maybeEatInlineListOrMap() {
<span class="fc" id="L621">		Token t = peekToken();</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">		if (!peekToken(TokenKind.LCURLY, true)) {</span>
<span class="fc" id="L623">			return false;</span>
		}
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">		Assert.state(t != null, &quot;No token&quot;);</span>
<span class="fc" id="L626">		SpelNodeImpl expr = null;</span>
<span class="fc" id="L627">		Token closingCurly = peekToken();</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">		if (peekToken(TokenKind.RCURLY, true)) {</span>
			// empty list '{}'
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">			Assert.state(closingCurly != null, &quot;No token&quot;);</span>
<span class="fc" id="L631">			expr = new InlineList(t.startPos, closingCurly.endPos);</span>
		}
<span class="fc bfc" id="L633" title="All 2 branches covered.">		else if (peekToken(TokenKind.COLON, true)) {</span>
<span class="fc" id="L634">			closingCurly = eatToken(TokenKind.RCURLY);</span>
			// empty map '{:}'
<span class="fc" id="L636">			expr = new InlineMap(t.startPos, closingCurly.endPos);</span>
		}
		else {
<span class="fc" id="L639">			SpelNodeImpl firstExpression = eatExpression();</span>
			// Next is either:
			// '}' - end of list
			// ',' - more expressions in this list
			// ':' - this is a map!
<span class="fc bfc" id="L644" title="All 2 branches covered.">			if (peekToken(TokenKind.RCURLY)) {  // list with one item in it</span>
<span class="fc" id="L645">				List&lt;SpelNodeImpl&gt; elements = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L646">				elements.add(firstExpression);</span>
<span class="fc" id="L647">				closingCurly = eatToken(TokenKind.RCURLY);</span>
<span class="fc" id="L648">				expr = new InlineList(t.startPos, closingCurly.endPos, elements.toArray(new SpelNodeImpl[0]));</span>
<span class="fc" id="L649">			}</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">			else if (peekToken(TokenKind.COMMA, true)) {  // multi-item list</span>
<span class="fc" id="L651">				List&lt;SpelNodeImpl&gt; elements = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L652">				elements.add(firstExpression);</span>
				do {
<span class="fc" id="L654">					elements.add(eatExpression());</span>
				}
<span class="fc bfc" id="L656" title="All 2 branches covered.">				while (peekToken(TokenKind.COMMA, true));</span>
<span class="fc" id="L657">				closingCurly = eatToken(TokenKind.RCURLY);</span>
<span class="fc" id="L658">				expr = new InlineList(t.startPos, closingCurly.endPos, elements.toArray(new SpelNodeImpl[0]));</span>

<span class="fc" id="L660">			}</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">			else if (peekToken(TokenKind.COLON, true)) {  // map!</span>
<span class="fc" id="L662">				List&lt;SpelNodeImpl&gt; elements = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L663">				elements.add(firstExpression);</span>
<span class="fc" id="L664">				elements.add(eatExpression());</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">				while (peekToken(TokenKind.COMMA, true)) {</span>
<span class="fc" id="L666">					elements.add(eatExpression());</span>
<span class="fc" id="L667">					eatToken(TokenKind.COLON);</span>
<span class="fc" id="L668">					elements.add(eatExpression());</span>
				}
<span class="fc" id="L670">				closingCurly = eatToken(TokenKind.RCURLY);</span>
<span class="fc" id="L671">				expr = new InlineMap(t.startPos, closingCurly.endPos, elements.toArray(new SpelNodeImpl[0]));</span>
<span class="fc" id="L672">			}</span>
			else {
<span class="fc" id="L674">				throw internalException(t.startPos, SpelMessage.OOD);</span>
			}
		}
<span class="fc" id="L677">		this.constructedNodes.push(expr);</span>
<span class="fc" id="L678">		return true;</span>
	}

	private boolean maybeEatIndexer() {
<span class="fc" id="L682">		Token t = peekToken();</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">		if (!peekToken(TokenKind.LSQUARE, true)) {</span>
<span class="fc" id="L684">			return false;</span>
		}
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">		Assert.state(t != null, &quot;No token&quot;);</span>
<span class="fc" id="L687">		SpelNodeImpl expr = eatExpression();</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">		Assert.state(expr != null, &quot;No node&quot;);</span>
<span class="fc" id="L689">		eatToken(TokenKind.RSQUARE);</span>
<span class="fc" id="L690">		this.constructedNodes.push(new Indexer(t.startPos, t.endPos, expr));</span>
<span class="fc" id="L691">		return true;</span>
	}

	private boolean maybeEatSelection(boolean nullSafeNavigation) {
<span class="fc" id="L695">		Token t = peekToken();</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">		if (!peekSelectToken()) {</span>
<span class="fc" id="L697">			return false;</span>
		}
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">		Assert.state(t != null, &quot;No token&quot;);</span>
<span class="fc" id="L700">		nextToken();</span>
<span class="fc" id="L701">		SpelNodeImpl expr = eatExpression();</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">		if (expr == null) {</span>
<span class="fc" id="L703">			throw internalException(t.startPos, SpelMessage.MISSING_SELECTION_EXPRESSION);</span>
		}
<span class="fc" id="L705">		eatToken(TokenKind.RSQUARE);</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">		if (t.kind == TokenKind.SELECT_FIRST) {</span>
<span class="fc" id="L707">			this.constructedNodes.push(new Selection(nullSafeNavigation, Selection.FIRST, t.startPos, t.endPos, expr));</span>
		}
<span class="fc bfc" id="L709" title="All 2 branches covered.">		else if (t.kind == TokenKind.SELECT_LAST) {</span>
<span class="fc" id="L710">			this.constructedNodes.push(new Selection(nullSafeNavigation, Selection.LAST, t.startPos, t.endPos, expr));</span>
		}
		else {
<span class="fc" id="L713">			this.constructedNodes.push(new Selection(nullSafeNavigation, Selection.ALL, t.startPos, t.endPos, expr));</span>
		}
<span class="fc" id="L715">		return true;</span>
	}

	/**
	 * Eat an identifier, possibly qualified (meaning that it is dotted).
	 * TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c)
	 */
	private SpelNodeImpl eatPossiblyQualifiedId() {
<span class="fc" id="L723">		Deque&lt;SpelNodeImpl&gt; qualifiedIdPieces = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L724">		Token node = peekToken();</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">		while (isValidQualifiedId(node)) {</span>
<span class="fc" id="L726">			nextToken();</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">			if (node.kind != TokenKind.DOT) {</span>
<span class="fc" id="L728">				qualifiedIdPieces.add(new Identifier(node.stringValue(), node.startPos, node.endPos));</span>
			}
<span class="fc" id="L730">			node = peekToken();</span>
		}
<span class="fc bfc" id="L732" title="All 2 branches covered.">		if (qualifiedIdPieces.isEmpty()) {</span>
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">			if (node == null) {</span>
<span class="nc" id="L734">				throw internalException( this.expressionString.length(), SpelMessage.OOD);</span>
			}
<span class="fc" id="L736">			throw internalException(node.startPos, SpelMessage.NOT_EXPECTED_TOKEN,</span>
<span class="fc" id="L737">					&quot;qualified ID&quot;, node.getKind().toString().toLowerCase());</span>
		}
<span class="fc" id="L739">		return new QualifiedIdentifier(qualifiedIdPieces.getFirst().getStartPosition(),</span>
<span class="fc" id="L740">				qualifiedIdPieces.getLast().getEndPosition(), qualifiedIdPieces.toArray(new SpelNodeImpl[0]));</span>
	}

	private boolean isValidQualifiedId(@Nullable Token node) {
<span class="fc bfc" id="L744" title="All 4 branches covered.">		if (node == null || node.kind == TokenKind.LITERAL_STRING) {</span>
<span class="fc" id="L745">			return false;</span>
		}
<span class="fc bfc" id="L747" title="All 4 branches covered.">		if (node.kind == TokenKind.DOT || node.kind == TokenKind.IDENTIFIER) {</span>
<span class="fc" id="L748">			return true;</span>
		}
<span class="fc" id="L750">		String value = node.stringValue();</span>
<span class="pc bpc" id="L751" title="1 of 4 branches missed.">		return (StringUtils.hasLength(value) &amp;&amp; VALID_QUALIFIED_ID_PATTERN.matcher(value).matches());</span>
	}

	// This is complicated due to the support for dollars in identifiers.
	// Dollars are normally separate tokens but there we want to combine
	// a series of identifiers and dollars into a single identifier.
	private boolean maybeEatMethodOrProperty(boolean nullSafeNavigation) {
<span class="fc bfc" id="L758" title="All 2 branches covered.">		if (peekToken(TokenKind.IDENTIFIER)) {</span>
<span class="fc" id="L759">			Token methodOrPropertyName = takeToken();</span>
<span class="fc" id="L760">			SpelNodeImpl[] args = maybeEatMethodArgs();</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">			if (args == null) {</span>
				// property
<span class="fc" id="L763">				push(new PropertyOrFieldReference(nullSafeNavigation, methodOrPropertyName.stringValue(),</span>
						methodOrPropertyName.startPos, methodOrPropertyName.endPos));
<span class="fc" id="L765">				return true;</span>
			}
			// method reference
<span class="fc" id="L768">			push(new MethodReference(nullSafeNavigation, methodOrPropertyName.stringValue(),</span>
					methodOrPropertyName.startPos, methodOrPropertyName.endPos, args));
			// TODO what is the end position for a method reference? the name or the last arg?
<span class="fc" id="L771">			return true;</span>
		}
<span class="fc" id="L773">		return false;</span>
	}

	//constructor
    //:	('new' qualifiedId LPAREN) =&gt; 'new' qualifiedId ctorArgs -&gt; ^(CONSTRUCTOR qualifiedId ctorArgs)
	private boolean maybeEatConstructorReference() {
<span class="fc bfc" id="L779" title="All 2 branches covered.">		if (peekIdentifierToken(&quot;new&quot;)) {</span>
<span class="fc" id="L780">			Token newToken = takeToken();</span>
			// It looks like a constructor reference but is NEW being used as a map key?
<span class="fc bfc" id="L782" title="All 2 branches covered.">			if (peekToken(TokenKind.RSQUARE)) {</span>
				// looks like 'NEW]' (so NEW used as map key)
<span class="fc" id="L784">				push(new PropertyOrFieldReference(false, newToken.stringValue(), newToken.startPos, newToken.endPos));</span>
<span class="fc" id="L785">				return true;</span>
			}
<span class="fc" id="L787">			SpelNodeImpl possiblyQualifiedConstructorName = eatPossiblyQualifiedId();</span>
<span class="fc" id="L788">			List&lt;SpelNodeImpl&gt; nodes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L789">			nodes.add(possiblyQualifiedConstructorName);</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">			if (peekToken(TokenKind.LSQUARE)) {</span>
				// array initializer
<span class="fc" id="L792">				List&lt;SpelNodeImpl&gt; dimensions = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">				while (peekToken(TokenKind.LSQUARE, true)) {</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">					if (!peekToken(TokenKind.RSQUARE)) {</span>
<span class="fc" id="L795">						dimensions.add(eatExpression());</span>
					}
					else {
<span class="fc" id="L798">						dimensions.add(null);</span>
					}
<span class="fc" id="L800">					eatToken(TokenKind.RSQUARE);</span>
				}
<span class="fc bfc" id="L802" title="All 2 branches covered.">				if (maybeEatInlineListOrMap()) {</span>
<span class="fc" id="L803">					nodes.add(pop());</span>
				}
<span class="fc" id="L805">				push(new ConstructorReference(newToken.startPos, newToken.endPos,</span>
<span class="fc" id="L806">						dimensions.toArray(new SpelNodeImpl[0]), nodes.toArray(new SpelNodeImpl[0])));</span>
<span class="fc" id="L807">			}</span>
			else {
				// regular constructor invocation
<span class="fc" id="L810">				eatConstructorArgs(nodes);</span>
				// TODO correct end position?
<span class="fc" id="L812">				push(new ConstructorReference(newToken.startPos, newToken.endPos, nodes.toArray(new SpelNodeImpl[0])));</span>
			}
<span class="fc" id="L814">			return true;</span>
		}
<span class="fc" id="L816">		return false;</span>
	}

	private void push(SpelNodeImpl newNode) {
<span class="fc" id="L820">		this.constructedNodes.push(newNode);</span>
<span class="fc" id="L821">	}</span>

	private SpelNodeImpl pop() {
<span class="fc" id="L824">		return this.constructedNodes.pop();</span>
	}

	//	literal
	//  : INTEGER_LITERAL
	//	| boolLiteral
	//	| STRING_LITERAL
	//  | HEXADECIMAL_INTEGER_LITERAL
	//  | REAL_LITERAL
	//	| DQ_STRING_LITERAL
	//	| NULL_LITERAL
	private boolean maybeEatLiteral() {
<span class="fc" id="L836">		Token t = peekToken();</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">		if (t == null) {</span>
<span class="fc" id="L838">			return false;</span>
		}
<span class="fc bfc" id="L840" title="All 2 branches covered.">		if (t.kind == TokenKind.LITERAL_INT) {</span>
<span class="fc" id="L841">			push(Literal.getIntLiteral(t.stringValue(), t.startPos, t.endPos, 10));</span>
		}
<span class="fc bfc" id="L843" title="All 2 branches covered.">		else if (t.kind == TokenKind.LITERAL_LONG) {</span>
<span class="fc" id="L844">			push(Literal.getLongLiteral(t.stringValue(), t.startPos, t.endPos, 10));</span>
		}
<span class="fc bfc" id="L846" title="All 2 branches covered.">		else if (t.kind == TokenKind.LITERAL_HEXINT) {</span>
<span class="fc" id="L847">			push(Literal.getIntLiteral(t.stringValue(), t.startPos, t.endPos, 16));</span>
		}
<span class="fc bfc" id="L849" title="All 2 branches covered.">		else if (t.kind == TokenKind.LITERAL_HEXLONG) {</span>
<span class="fc" id="L850">			push(Literal.getLongLiteral(t.stringValue(), t.startPos, t.endPos, 16));</span>
		}
<span class="fc bfc" id="L852" title="All 2 branches covered.">		else if (t.kind == TokenKind.LITERAL_REAL) {</span>
<span class="fc" id="L853">			push(Literal.getRealLiteral(t.stringValue(), t.startPos, t.endPos, false));</span>
		}
<span class="fc bfc" id="L855" title="All 2 branches covered.">		else if (t.kind == TokenKind.LITERAL_REAL_FLOAT) {</span>
<span class="fc" id="L856">			push(Literal.getRealLiteral(t.stringValue(), t.startPos, t.endPos, true));</span>
		}
<span class="fc bfc" id="L858" title="All 2 branches covered.">		else if (peekIdentifierToken(&quot;true&quot;)) {</span>
<span class="fc" id="L859">			push(new BooleanLiteral(t.stringValue(), t.startPos, t.endPos, true));</span>
		}
<span class="fc bfc" id="L861" title="All 2 branches covered.">		else if (peekIdentifierToken(&quot;false&quot;)) {</span>
<span class="fc" id="L862">			push(new BooleanLiteral(t.stringValue(), t.startPos, t.endPos, false));</span>
		}
<span class="fc bfc" id="L864" title="All 2 branches covered.">		else if (t.kind == TokenKind.LITERAL_STRING) {</span>
<span class="fc" id="L865">			push(new StringLiteral(t.stringValue(), t.startPos, t.endPos, t.stringValue()));</span>
		}
		else {
<span class="fc" id="L868">			return false;</span>
		}
<span class="fc" id="L870">		nextToken();</span>
<span class="fc" id="L871">		return true;</span>
	}

	//parenExpr : LPAREN! expression RPAREN!;
	private boolean maybeEatParenExpression() {
<span class="fc bfc" id="L876" title="All 2 branches covered.">		if (peekToken(TokenKind.LPAREN)) {</span>
<span class="fc" id="L877">			nextToken();</span>
<span class="fc" id="L878">			SpelNodeImpl expr = eatExpression();</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">			Assert.state(expr != null, &quot;No node&quot;);</span>
<span class="fc" id="L880">			eatToken(TokenKind.RPAREN);</span>
<span class="fc" id="L881">			push(expr);</span>
<span class="fc" id="L882">			return true;</span>
		}
		else {
<span class="fc" id="L885">			return false;</span>
		}
	}

	// relationalOperator
	// : EQUAL | NOT_EQUAL | LESS_THAN | LESS_THAN_OR_EQUAL | GREATER_THAN
	// | GREATER_THAN_OR_EQUAL | INSTANCEOF | BETWEEN | MATCHES
	@Nullable
	private Token maybeEatRelationalOperator() {
<span class="fc" id="L894">		Token t = peekToken();</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">		if (t == null) {</span>
<span class="fc" id="L896">			return null;</span>
		}
<span class="fc bfc" id="L898" title="All 2 branches covered.">		if (t.isNumericRelationalOperator()) {</span>
<span class="fc" id="L899">			return t;</span>
		}
<span class="fc bfc" id="L901" title="All 2 branches covered.">		if (t.isIdentifier()) {</span>
<span class="fc" id="L902">			String idString = t.stringValue();</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">			if (idString.equalsIgnoreCase(&quot;instanceof&quot;)) {</span>
<span class="fc" id="L904">				return t.asInstanceOfToken();</span>
			}
<span class="fc bfc" id="L906" title="All 2 branches covered.">			if (idString.equalsIgnoreCase(&quot;matches&quot;)) {</span>
<span class="fc" id="L907">				return t.asMatchesToken();</span>
			}
<span class="fc bfc" id="L909" title="All 2 branches covered.">			if (idString.equalsIgnoreCase(&quot;between&quot;)) {</span>
<span class="fc" id="L910">				return t.asBetweenToken();</span>
			}
		}
<span class="fc" id="L913">		return null;</span>
	}

	private Token eatToken(TokenKind expectedKind) {
<span class="fc" id="L917">		Token t = nextToken();</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">		if (t == null) {</span>
<span class="fc" id="L919">			int pos = this.expressionString.length();</span>
<span class="fc" id="L920">			throw internalException(pos, SpelMessage.OOD);</span>
		}
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">		if (t.kind != expectedKind) {</span>
<span class="nc" id="L923">			throw internalException(t.startPos, SpelMessage.NOT_EXPECTED_TOKEN,</span>
<span class="nc" id="L924">					expectedKind.toString().toLowerCase(), t.getKind().toString().toLowerCase());</span>
		}
<span class="fc" id="L926">		return t;</span>
	}

	private boolean peekToken(TokenKind desiredTokenKind) {
<span class="fc" id="L930">		return peekToken(desiredTokenKind, false);</span>
	}

	private boolean peekToken(TokenKind desiredTokenKind, boolean consumeIfMatched) {
<span class="fc" id="L934">		Token t = peekToken();</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">		if (t == null) {</span>
<span class="fc" id="L936">			return false;</span>
		}
<span class="fc bfc" id="L938" title="All 2 branches covered.">		if (t.kind == desiredTokenKind) {</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">			if (consumeIfMatched) {</span>
<span class="fc" id="L940">				this.tokenStreamPointer++;</span>
			}
<span class="fc" id="L942">			return true;</span>
		}

<span class="fc bfc" id="L945" title="All 2 branches covered.">		if (desiredTokenKind == TokenKind.IDENTIFIER) {</span>
			// Might be one of the textual forms of the operators (e.g. NE for != ) -
			// in which case we can treat it as an identifier. The list is represented here:
			// Tokenizer.alternativeOperatorNames and those ones are in order in the TokenKind enum.
<span class="fc bfc" id="L949" title="All 6 branches covered.">			if (t.kind.ordinal() &gt;= TokenKind.DIV.ordinal() &amp;&amp; t.kind.ordinal() &lt;= TokenKind.NOT.ordinal() &amp;&amp;</span>
					t.data != null) {
				// if t.data were null, we'd know it wasn't the textual form, it was the symbol form
<span class="fc" id="L952">				return true;</span>
			}
		}
<span class="fc" id="L955">		return false;</span>
	}

	private boolean peekToken(TokenKind possible1, TokenKind possible2) {
<span class="fc" id="L959">		Token t = peekToken();</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">		if (t == null) {</span>
<span class="fc" id="L961">			return false;</span>
		}
<span class="fc bfc" id="L963" title="All 4 branches covered.">		return (t.kind == possible1 || t.kind == possible2);</span>
	}

	private boolean peekToken(TokenKind possible1, TokenKind possible2, TokenKind possible3) {
<span class="fc" id="L967">		Token t = peekToken();</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">		if (t == null) {</span>
<span class="fc" id="L969">			return false;</span>
		}
<span class="fc bfc" id="L971" title="All 6 branches covered.">		return (t.kind == possible1 || t.kind == possible2 || t.kind == possible3);</span>
	}

	private boolean peekIdentifierToken(String identifierString) {
<span class="fc" id="L975">		Token t = peekToken();</span>
<span class="fc bfc" id="L976" title="All 2 branches covered.">		if (t == null) {</span>
<span class="fc" id="L977">			return false;</span>
		}
<span class="fc bfc" id="L979" title="All 4 branches covered.">		return (t.kind == TokenKind.IDENTIFIER &amp;&amp; identifierString.equalsIgnoreCase(t.stringValue()));</span>
	}

	private boolean peekSelectToken() {
<span class="fc" id="L983">		Token t = peekToken();</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">		if (t == null) {</span>
<span class="fc" id="L985">			return false;</span>
		}
<span class="fc bfc" id="L987" title="All 6 branches covered.">		return (t.kind == TokenKind.SELECT || t.kind == TokenKind.SELECT_FIRST || t.kind == TokenKind.SELECT_LAST);</span>
	}

	private Token takeToken() {
<span class="pc bpc" id="L991" title="1 of 2 branches missed.">		if (this.tokenStreamPointer &gt;= this.tokenStreamLength) {</span>
<span class="nc" id="L992">			throw new IllegalStateException(&quot;No token&quot;);</span>
		}
<span class="fc" id="L994">		return this.tokenStream.get(this.tokenStreamPointer++);</span>
	}

	@Nullable
	private Token nextToken() {
<span class="fc bfc" id="L999" title="All 2 branches covered.">		if (this.tokenStreamPointer &gt;= this.tokenStreamLength) {</span>
<span class="fc" id="L1000">			return null;</span>
		}
<span class="fc" id="L1002">		return this.tokenStream.get(this.tokenStreamPointer++);</span>
	}

	@Nullable
	private Token peekToken() {
<span class="fc bfc" id="L1007" title="All 2 branches covered.">		if (this.tokenStreamPointer &gt;= this.tokenStreamLength) {</span>
<span class="fc" id="L1008">			return null;</span>
		}
<span class="fc" id="L1010">		return this.tokenStream.get(this.tokenStreamPointer);</span>
	}

	public String toString(@Nullable Token t) {
<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">		if (t == null) {</span>
<span class="nc" id="L1015">			return &quot;&quot;;</span>
		}
<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">		if (t.getKind().hasPayload()) {</span>
<span class="fc" id="L1018">			return t.stringValue();</span>
		}
<span class="nc" id="L1020">		return t.kind.toString().toLowerCase();</span>
	}

	private void checkOperands(Token token, @Nullable SpelNodeImpl left, @Nullable SpelNodeImpl right) {
<span class="fc" id="L1024">		checkLeftOperand(token, left);</span>
<span class="fc" id="L1025">		checkRightOperand(token, right);</span>
<span class="fc" id="L1026">	}</span>

	private void checkLeftOperand(Token token, @Nullable SpelNodeImpl operandExpression) {
<span class="fc bfc" id="L1029" title="All 2 branches covered.">		if (operandExpression == null) {</span>
<span class="fc" id="L1030">			throw internalException(token.startPos, SpelMessage.LEFT_OPERAND_PROBLEM);</span>
		}
<span class="fc" id="L1032">	}</span>

	private void checkRightOperand(Token token, @Nullable SpelNodeImpl operandExpression) {
<span class="fc bfc" id="L1035" title="All 2 branches covered.">		if (operandExpression == null) {</span>
<span class="fc" id="L1036">			throw internalException(token.startPos, SpelMessage.RIGHT_OPERAND_PROBLEM);</span>
		}
<span class="fc" id="L1038">	}</span>

	private InternalParseException internalException(int startPos, SpelMessage message, Object... inserts) {
<span class="fc" id="L1041">		return new InternalParseException(new SpelParseException(this.expressionString, startPos, message, inserts));</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>